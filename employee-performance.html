<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Performance Dashboard | QMS</title>
<meta name="description" content="Quality Management System Performance Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="auth-check.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="load-sidebar.js"></script>
    <script src="search.js"></script>
    <script src="form-validation.js"></script>
    <script src="timezone-utils.js"></script>
    <script src="date-filter-utils.js"></script>

    <style>
        /* Ensure main content stays within bounds */
        .main-content {
            overflow-x: hidden;
            max-width: calc(100vw - var(--sidebar-collapsed)) !important;
            box-sizing: border-box;
            width: 100%;
        }
        
        .sidebar:not(.collapsed) ~ .main-content {
            max-width: calc(100vw - var(--sidebar-width)) !important;
        }
        
        .main-content > * {
            max-width: 100%;
            box-sizing: border-box;
        }

        .header-actions {
            display: flex;
            gap: 0.5625rem;
            flex-wrap: wrap;
            align-items: center;
            width: 100%;
            max-width: 100%;
        }

        .action-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.4688rem 0.75rem;
            background-color: var(--background-white);
            color: var(--text-color);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            font-size: 0.6562rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-family);
        }

        .action-btn:hover {
            background-color: var(--gray-50);
            border-color: var(--primary-color);
        }

        .action-btn.active {
            background-color: var(--primary-color);
            color: var(--white);
            border-color: var(--primary-color);
        }

        .action-btn svg {
            width: 0.75rem;
            height: 0.75rem;
        }


        /* Filter Panel */
        .filter-panel {
            display: none;
            background: var(--gray-50);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            padding: 1.125rem;
            margin-bottom: 1.5rem;
            grid-template-columns: repeat(auto-fit, minmax(7.0312rem, 1fr));
            gap: 0.75rem;
        }

        .filter-panel.active {
            display: grid;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .filter-label {
            font-size: 0.5625rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .filter-input, .filter-select {
            padding: 0.375rem 0.5625rem;
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.2812rem;
            font-size: 0.6562rem;
            font-family: var(--font-family);
            background-color: var(--background-white);
            color: var(--text-color);
        }

        .filter-input:focus, .filter-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* Date Range Picker */
        .date-picker-dropdown {
            position: relative;
            display: inline-block;
        }

        .date-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.375rem;
            background: var(--background-white);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            box-shadow: var(--shadow-lg);
            padding: 0.75rem;
            z-index: 1000;
            min-width: 9.8438rem;
        }

        .date-dropdown-menu.active {
            display: block;
        }

        /* KPI Cards */
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(12rem, 1fr));
            gap: 1.125rem;
            margin-bottom: 1.5rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        @media (min-width: 1200px) {
            .kpi-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
        
        @media (max-width: 1199px) {
            .kpi-grid {
                grid-template-columns: repeat(auto-fit, minmax(10rem, 1fr));
            }
        }
        
        @media (max-width: 768px) {
            .kpi-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 480px) {
            .kpi-grid {
                grid-template-columns: 1fr;
            }
        }


        .kpi-card {
            background-color: var(--background-white);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.5625rem;
            padding: 1.125rem;
            box-shadow: var(--shadow-sm);
            transition: box-shadow 0.2s ease;
            min-width: 0;
            width: 100%;
            box-sizing: border-box;
        }

        .kpi-card:hover {
            box-shadow: var(--shadow-md);
        }

        .kpi-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            min-width: 0;
        }

        .kpi-label {
            font-size: 0.6562rem;
            font-weight: 500;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }

        .kpi-date {
            font-size: 0.5625rem;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .kpi-value {
            font-size: clamp(1.25rem, 2vw, 1.875rem);
            font-weight: 700;
            color: var(--text-color);
            margin-bottom: 0.375rem;
            line-height: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .kpi-change {
            font-size: 0.6562rem;
            font-weight: 500;
            margin-bottom: 0.75rem;
        }

        .kpi-change.positive {
            color: var(--success-color);
        }

        .kpi-change.negative {
            color: var(--error-color);
        }

        .coming-soon-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            background-color: var(--gray-50);
            color: var(--text-secondary);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.75rem;
            font-size: 0.6562rem;
            font-weight: 500;
            margin-bottom: 0.375rem;
        }

        .kpi-chart-container {
            height: 2.1094rem;
            margin-top: 0.75rem;
            overflow: hidden;
            position: relative;
        }
        
        .kpi-chart-container canvas {
            max-width: 100%;
            height: 100% !important;
        }

        /* Dashboard Grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 1.125rem;
            margin-bottom: 1.5rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .dashboard-grid .dashboard-card.full-width {
            grid-column: 1 / -1;
        }

        .dashboard-grid .dashboard-card.half-width {
            grid-column: span 6;
        }

        .dashboard-grid .dashboard-card.third-width {
            grid-column: span 4;
        }

        /* Force specific column spans */
        .dashboard-grid > .dashboard-card:nth-child(1) {
            /* Performance Table */
            grid-column: 1 / -1;
        }

        .dashboard-grid > .dashboard-card:nth-child(2) {
            /* Top Performers */
            grid-column: span 6;
        }

        .dashboard-grid > .dashboard-card:nth-child(3) {
            /* Performance by Channel */
            grid-column: span 6;
        }

        .dashboard-grid > .dashboard-card:nth-child(4) {
            /* Performance Analytics */
            grid-column: span 8;
        }

        .dashboard-grid > .dashboard-card:nth-child(5) {
            /* Recent Audits */
            grid-column: span 4;
        }

        .dashboard-grid > .dashboard-card:nth-child(6) {
            /* Top Error Categories */
            grid-column: 1 / -1;
        }

        /* Error Categories Responsive Grid */
        .error-categories-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.125rem;
            margin-bottom: 1.125rem;
        }

        @media (max-width: 768px) {
            .error-categories-grid {
                grid-template-columns: 1fr;
            }
        }

        .dashboard-card {
            background-color: var(--background-white);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.5625rem;
            padding: 1.125rem;
            box-shadow: var(--shadow-sm);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.125rem;
        }

        .card-title {
            font-size: 0.8438rem;
            font-weight: 600;
            color: var(--text-color);
        }

        .card-link {
            font-size: 0.6562rem;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            cursor: pointer;
        }

        .card-link:hover {
            text-decoration: underline;
        }

        /* Performance Table */
        .performance-table {
            width: 100%;
            max-width: 100%;
            border-collapse: collapse;
            margin-top: 0;
            box-sizing: border-box;
        }
        
        .performance-table-container {
            width: 100%;
            max-width: 100%;
            overflow-x: auto;
            box-sizing: border-box;
            border-radius: 0.375rem;
            overflow: hidden;
            border: 0.0469rem solid var(--border-light);
        }

        .performance-table thead {
            background-color: var(--gray-50);
        }

        .performance-table th {
            padding: 0.5625rem;
            text-align: left;
            font-size: 0.6562rem;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 0.0469rem solid var(--border-light);
        }

        .performance-table td {
            padding: 0.5625rem;
            font-size: 0.6562rem;
            color: var(--text-color);
            border-bottom: 0.0469rem solid var(--gray-100);
        }

        .performance-table tbody tr:last-child td {
            border-bottom: none;
        }

        .performance-table tbody tr:hover {
            background-color: var(--gray-50);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.2812rem;
            padding: 0.1875rem 0.5625rem;
            border-radius: 0.75rem;
            font-size: 0.5625rem;
            font-weight: 500;
        }

        .status-badge.exemplary {
            background-color: #dbeafe;
            color: #1e40af;
        }

        .status-badge.exceeding {
            background-color: #d1fae5;
            color: #065f46;
        }

        .status-badge.developing {
            background-color: #fef3c7;
            color: #92400e;
        }

        .status-badge.needs-improvement {
            background-color: #fed7aa;
            color: #9a3412;
        }

        .status-badge.at-risk {
            background-color: #fee2e2;
            color: #991b1b;
        }

        .status-dot {
            width: 0.375rem;
            height: 0.375rem;
            border-radius: 50%;
            display: inline-block;
        }

        .status-dot.exemplary {
            background-color: #3b82f6;
        }

        .status-dot.exceeding {
            background-color: var(--success-color);
        }

        .status-dot.developing {
            background-color: #f59e0b;
        }

        .status-dot.needs-improvement {
            background-color: #f97316;
        }

        .status-dot.at-risk {
            background-color: var(--error-color);
        }

        /* Recent Items */
        .recent-item {
            display: flex;
            align-items: center;
            gap: 0.5625rem;
            padding: 0.5625rem 0;
            border-bottom: 0.0469rem solid var(--gray-100);
        }

        .recent-item:last-child {
            border-bottom: none;
        }

        .recent-icon {
            width: 1.875rem;
            height: 1.875rem;
            background-color: var(--primary-light);
            border-radius: 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .recent-icon svg {
            width: 0.9375rem;
            height: 0.9375rem;
            color: var(--primary-color);
        }

        .recent-content {
            flex: 1;
            min-width: 0;
        }

        .recent-title {
            font-size: 0.6562rem;
            font-weight: 500;
            color: var(--text-color);
            margin-bottom: 0.1875rem;
        }

        .recent-date {
            font-size: 0.5625rem;
            color: var(--text-muted);
        }

        .recent-value {
            font-size: 0.6562rem;
            font-weight: 600;
            color: var(--text-color);
            text-align: right;
        }

        /* Location List */
        .location-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .location-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.375rem 0;
            border-bottom: 0.0469rem solid var(--gray-100);
        }

        .location-item:last-child {
            border-bottom: none;
        }

        .location-name {
            font-size: 0.6562rem;
            color: var(--text-color);
            font-weight: 500;
        }

        .location-value {
            font-size: 0.6562rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .metric-large {
            font-size: 1.875rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.375rem;
        }

        /* Loading State */
        .loading {
            text-align: center;
            padding: 1.5rem;
            color: var(--text-muted);
        }

    </style>
</head>

<body>
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
 <main class="main-content" role="main">
    <div style="width: 100%; max-width: 100%; box-sizing: border-box; padding: 0;">
    <p class="page-heading">Performance Report</p>

    <!-- Action Buttons -->
    <div class="header-actions" style="margin-top: 3rem; margin-bottom: 1.125rem;">
        <!-- Week Navigation -->
        <div style="display: flex; align-items: center; gap: 0.5625rem;">
            <button class="action-btn" id="prevWeekBtn" style="padding: 0.4688rem 0.5625rem;" title="Previous Week">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.75rem; height: 0.75rem;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
            </button>
            <div class="action-btn" id="weekDisplay" style="padding: 0.4688rem 0.75rem; cursor: default; background-color: var(--primary-color); color: var(--white); border-color: var(--primary-color);">
                <span id="weekText">Week -</span>
            </div>
            <button class="action-btn" id="nextWeekBtn" style="padding: 0.4688rem 0.5625rem;" title="Next Week">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.75rem; height: 0.75rem;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
            </button>
        </div>
        <div class="date-picker-dropdown">
            <button class="action-btn" id="dateBtn">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                <span id="dateBtnText">Date Range</span>
                <svg style="width: 0.5625rem; height: 0.5625rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div class="date-dropdown-menu" id="dateDropdown">
                <div class="filter-group">
                    <label class="filter-label">Start Date</label>
                    <input type="date" class="filter-input" id="startDate">
                </div>
                <div class="filter-group">
                    <label class="filter-label">End Date</label>
                    <input type="date" class="filter-input" id="endDate">
                </div>
                <div style="display: flex; gap: 0.375rem; margin-top: 0.375rem;">
                    <button class="action-btn" style="flex: 1;" onclick="applyDateFilter()">Apply</button>
                    <button class="action-btn" style="flex: 1;" onclick="clearDateFilter()">Clear</button>
                </div>
            </div>
        </div>
        <!-- Quick Date Filters -->
        <div style="display: flex; align-items: center; gap: 0.375rem;">
            <button class="action-btn quick-date-btn" id="todayBtn" onclick="applyQuickDateFilter('today')">Today</button>
            <button class="action-btn quick-date-btn" id="yesterdayBtn" onclick="applyQuickDateFilter('yesterday')">Yesterday</button>
            <button class="action-btn quick-date-btn active" id="thisMonthBtn" onclick="applyQuickDateFilter('thisMonth')">This Month</button>
        </div>
        <button class="action-btn" id="exportBtn">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
            </svg>
            <span>Export</span>
            <svg style="width: 0.5625rem; height: 0.5625rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
            </svg>
        </button>
        <button class="action-btn" id="filterBtn">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
            </svg>
        </button>
    </div>

    <!-- Filter Panel -->
    <div class="filter-panel" id="filterPanel">
        <div class="filter-group">
            <label class="filter-label">Channel</label>
            <select class="filter-select" id="filterChannel">
                <option value="">All Channels</option>
            </select>
        </div>
        <div class="filter-group">
            <label class="filter-label">Status</label>
            <select class="filter-select" id="filterStatus">
                <option value="">All Statuses</option>
                <option value="pending">Pending</option>
                <option value="in_progress">In Progress</option>
                <option value="completed">Completed</option>
            </select>
        </div>
        <div class="filter-group">
            <label class="filter-label">Agent</label>
            <select class="filter-select" id="filterAgent">
                <option value="">All Agents</option>
            </select>
        </div>
        <div class="filter-group" style="align-self: flex-end;">
            <button class="action-btn" onclick="applyFilters()" style="margin-top: 1.125rem;">Apply Filters</button>
        </div>
    </div>

    <!-- KPI Cards -->
    <div class="kpi-grid">
        <div class="kpi-card">
            <div class="kpi-header">
                <div class="kpi-label">Interaction Count</div>
                <div class="kpi-date" id="kpi0Date" style="display: none;">-</div>
            </div>
            <div class="kpi-value" id="kpi0Value" style="color: #9333ea;">-</div>
            <div class="kpi-change positive" id="kpi0Change">-</div>
            <div class="kpi-chart-container">
                <canvas id="kpiChart0"></canvas>
            </div>
        </div>

        <div class="kpi-card">
            <div class="kpi-header">
                <div class="kpi-label">Completed Audits</div>
                <div class="kpi-date" id="kpi1Date" style="display: none;">-</div>
            </div>
            <div class="kpi-value" id="kpi1Value">-</div>
            <div class="kpi-change positive" id="kpi1Change">-</div>
            <div class="kpi-chart-container">
                <canvas id="kpiChart1"></canvas>
            </div>
        </div>

        <div class="kpi-card">
            <div class="kpi-header">
                <div class="kpi-label">Error Count Trend</div>
                <div class="kpi-date" id="kpi2Date" style="display: none;">-</div>
            </div>
            <div class="kpi-value" id="kpi2Value" style="color: #ef4444;">-</div>
            <div class="kpi-change negative" id="kpi2Change">-</div>
            <div class="kpi-chart-container">
                <canvas id="kpiChart2"></canvas>
            </div>
        </div>

        <div class="kpi-card">
            <div class="kpi-header">
                <div class="kpi-label">Avg. Quality Score</div>
                <div class="kpi-date" id="kpi3Date" style="display: none;">-</div>
            </div>
            <div class="kpi-value" id="kpi3Value">-</div>
            <div class="kpi-change positive" id="kpi3Change">-</div>
            <div class="kpi-chart-container">
                <canvas id="kpiChart3"></canvas>
            </div>
        </div>
    </div>

    <!-- Main Dashboard Grid -->
    <div class="dashboard-grid">
        <!-- Performance Table - Full Width -->
        <div class="dashboard-card">
            <div class="card-header">
                <div class="card-title">Agent Performance</div>
                <button class="action-btn" style="padding: 0.375rem;" onclick="refreshData()" title="Refresh Data">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                </button>
            </div>
            <div class="performance-table-container">
                <table class="performance-table">
                    <thead>
                        <tr>
                            <th>Employee ID</th>
                            <th>Full Name</th>
                            <th>Total Audits</th>
                            <th>Completed</th>
                            <th>Avg Score</th>
                            <th>Total Error Count</th>
                            <th>Top Error Parameter</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="performanceTableBody">
                        <tr>
                            <td colspan="8" class="loading">Loading performance data...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Top Performers - Left Column -->
        <div class="dashboard-card">
            <div class="card-header">
                <div class="card-title">Top Performers</div>
            </div>
            <div style="height: 8.7891rem;">
                <canvas id="topPerformersChart"></canvas>
            </div>
        </div>

        <!-- Performance by Channel - Right Column -->
        <div class="dashboard-card">
            <div class="card-header">
                <div class="card-title">Performance by Channel</div>
            </div>
            <div class="metric-large" id="topLocationValue">-</div>
            <div class="kpi-change positive" id="locationChange">-</div>
            <div style="height: 7.0312rem; margin-top: 0.75rem;">
                <canvas id="locationChart"></canvas>
            </div>
            <ul class="location-list" id="locationList">
                <li class="location-item">
                    <span class="location-name">Loading...</span>
                    <span class="location-value">-</span>
                </li>
            </ul>
        </div>

        <!-- Performance Analytics - Left 2/3 -->
        <div class="dashboard-card">
            <div class="card-header">
                <div class="card-title">Audit Frequency</div>
                <select class="action-btn" style="padding: 0.2812rem 0.5625rem; cursor: pointer;" id="analyticsPeriod">
                    <option value="daily">Daily</option>
                    <option value="weekly">Weekly</option>
                    <option value="monthly">Monthly</option>
                </select>
            </div>
            <div style="height: 10.5469rem;">
                <canvas id="analyticsChart"></canvas>
            </div>
        </div>

        <!-- Recent Audits - Right 1/3 -->
        <div class="dashboard-card">
            <div class="card-header">
                <div class="card-title">Recent Audits</div>
            </div>
            <div id="recentAuditsList">
                <div class="recent-item">
                    <div class="recent-icon">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                    </div>
                    <div class="recent-content">
                        <div class="recent-title">Loading...</div>
                        <div class="recent-date">-</div>
                    </div>
                    <div class="recent-value">-</div>
                </div>
                </div>
            </div>
        </div>

        <!-- Top Error Categories - Full Width -->
        <div class="dashboard-card">
            <div class="card-header">
                <div class="card-title">Top Error Categories</div>
            </div>
            <div class="error-categories-grid">
                <!-- Error Type Summary -->
                <div>
                    <div style="font-size: 0.6562rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.75rem;">Error Type Distribution</div>
                    <div id="errorTypeSummary" style="display: flex; flex-direction: column; gap: 0.25rem;">
                        <div class="loading">Loading...</div>
                    </div>
                </div>
                <!-- Error Frequency Chart -->
                <div>
                    <div style="font-size: 0.6562rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.75rem;">Error Frequency Distribution</div>
                    <div style="height: 12rem;">
                        <canvas id="errorFrequencyChart"></canvas>
                    </div>
                </div>
            </div>
            <!-- Top Error Categories List -->
            <div>
                <div style="font-size: 0.6562rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.75rem;">Most Common Error Types</div>
                <div id="topErrorCategoriesList" style="overflow-x: auto;">
                    <div class="loading">Loading...</div>
                </div>
            </div>
        </div>
    </div>

</main>

<script>
// ============================================================================
// Register Chart.js Plugins
// ============================================================================
if (typeof ChartDataLabels !== 'undefined') {
    Chart.register(ChartDataLabels);
}

// ============================================================================
// Global Variables
// ============================================================================
let charts = {};
let allAssignments = [];
let allAudits = [];
let filteredAssignments = [];
let allUsers = [];
let allScorecardParameters = {}; // Map of scorecard_id -> parameters
let allScorecards = []; // Store all scorecards for mapping scorecard_id to table_name
let dateFilter = { start: null, end: null };
let currentFilters = { channel: '', status: '', agent: '' };

// ============================================================================
// Cache Configuration
// ============================================================================
const CACHE_KEYS = {
    USERS: 'perf_users',
    ASSIGNMENTS: 'perf_assignments',
    SCORECARDS: 'perf_scorecards',
    SCORECARD_PARAMS: 'perf_scorecard_params',
    AUDITS: 'perf_audits',
    TIMESTAMP: 'perf_cache_timestamp'
};
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes in milliseconds

// ============================================================================
// Cache Functions
// ============================================================================
function getCachedData(key) {
    try {
        const cached = localStorage.getItem(key);
        if (!cached) return null;
        
        const data = JSON.parse(cached);
        return data;
    } catch (error) {
        console.warn(`Error reading cache for ${key}:`, error);
        return null;
    }
}

function setCachedData(key, data) {
    try {
        localStorage.setItem(key, JSON.stringify(data));
    } catch (error) {
        console.warn(`Error writing cache for ${key}:`, error);
        // If storage is full, try to clear old cache
        if (error.name === 'QuotaExceededError') {
            clearCache();
            try {
                localStorage.setItem(key, JSON.stringify(data));
            } catch (retryError) {
                console.error('Failed to cache data after clearing:', retryError);
            }
        }
    }
}

function isCacheValid() {
    try {
        const timestamp = localStorage.getItem(CACHE_KEYS.TIMESTAMP);
        if (!timestamp) return false;
        
        const cacheTime = parseInt(timestamp, 10);
        const now = Date.now();
        return (now - cacheTime) < CACHE_TTL;
    } catch (error) {
        return false;
    }
}

function updateCacheTimestamp() {
    try {
        localStorage.setItem(CACHE_KEYS.TIMESTAMP, Date.now().toString());
    } catch (error) {
        console.warn('Error updating cache timestamp:', error);
    }
}

function clearCache() {
    try {
        Object.values(CACHE_KEYS).forEach(key => {
            localStorage.removeItem(key);
        });
    } catch (error) {
        console.warn('Error clearing cache:', error);
    }
}

// ============================================================================
// Initialization
// ============================================================================
document.addEventListener('DOMContentLoaded', async () => {
    await waitForSupabase();
    initializeMonthFilter();
    await loadAllData();
    setupEventListeners();
});

async function waitForSupabase() {
    let attempts = 0;
    while (!window.supabaseClient && attempts < 50) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
    }
    if (!window.supabaseClient) {
        console.error('Supabase client not initialized');
    }
}

// ============================================================================
// Event Listeners
// ============================================================================
function setupEventListeners() {
    // Week navigation buttons
    document.getElementById('prevWeekBtn').addEventListener('click', () => {
        navigateWeek(-1);
    });
    document.getElementById('nextWeekBtn').addEventListener('click', () => {
        navigateWeek(1);
    });
    
    // Make week display clickable to switch to week view when in month view
    const weekDisplay = document.getElementById('weekDisplay');
    if (weekDisplay) {
        weekDisplay.addEventListener('click', function() {
            if (!useWeekFilter) {
                switchToWeekView();
            }
        });
    }

    // Date button
    document.getElementById('dateBtn').addEventListener('click', (e) => {
        e.stopPropagation();
        const dropdown = document.getElementById('dateDropdown');
        dropdown.classList.toggle('active');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.date-picker-dropdown')) {
            document.getElementById('dateDropdown').classList.remove('active');
        }
    });

    // Filter button
    document.getElementById('filterBtn').addEventListener('click', () => {
        const panel = document.getElementById('filterPanel');
        panel.classList.toggle('active');
        document.getElementById('filterBtn').classList.toggle('active');
    });

    // Export button
    document.getElementById('exportBtn').addEventListener('click', exportToCSV);

    // Analytics period change
    document.getElementById('analyticsPeriod').addEventListener('change', () => {
        updateAnalyticsChart();
    });
}

// ============================================================================
// Data Loading
// ============================================================================
async function loadAllData(forceRefresh = false) {
    try {
        const useCache = !forceRefresh && isCacheValid();
        
        if (useCache) {
            // Load from cache
            console.log('Loading data from cache...');
            const cachedUsers = getCachedData(CACHE_KEYS.USERS);
            const cachedAssignments = getCachedData(CACHE_KEYS.ASSIGNMENTS);
            const cachedScorecards = getCachedData(CACHE_KEYS.SCORECARDS);
            const cachedScorecardParams = getCachedData(CACHE_KEYS.SCORECARD_PARAMS);
            const cachedAudits = getCachedData(CACHE_KEYS.AUDITS);
            
            // Validate that we have all required cache data
            const hasAllCache = cachedUsers && cachedAssignments && cachedScorecards && 
                               cachedScorecardParams && cachedAudits;
            
            if (hasAllCache) {
                allUsers = cachedUsers;
                allAssignments = cachedAssignments;
                allScorecards = cachedScorecards;
                allScorecardParameters = cachedScorecardParams;
                allAudits = cachedAudits;
                
                // Apply filters
                applyAllFilters();
                
                // Load filter options
                populateFilters();
                
                // Initialize charts
                initializeKPIChats();
                
                // Load fresh data in background for next time
                loadAllDataFresh(true);
            } else {
                // Cache is incomplete, load fresh data
                console.log('Cache incomplete, loading fresh data...');
                await loadAllDataFresh(false);
            }
        } else {
            // Load fresh data
            await loadAllDataFresh(false);
        }
    } catch (error) {
        console.error('Error loading data:', error);
        document.getElementById('performanceTableBody').innerHTML = 
            '<tr><td colspan="8" class="loading" style="color: var(--error-color);">Error loading data. Please refresh.</td></tr>';
    }
}

async function loadAllDataFresh(background = false) {
    try {
        // Load all users for employee info
        const { data: users, error: usersError } = await window.supabaseClient
            .from('users')
            .select('email, name, employee_id')
            .eq('is_active', true);

        if (usersError) throw usersError;
        allUsers = users || [];
        setCachedData(CACHE_KEYS.USERS, allUsers);

        // Load all audit assignments
        const { data: assignments, error: assignError } = await window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .order('created_at', { ascending: false });

        if (assignError) throw assignError;
        allAssignments = assignments || [];
        setCachedData(CACHE_KEYS.ASSIGNMENTS, allAssignments);

        // Load scorecard parameters for error parameter mapping
        await loadScorecardParameters();

        // Load all audits from scorecard tables
        await loadAuditsData();

        // Update cache timestamp
        updateCacheTimestamp();

        // Only update UI if not in background mode
        if (!background) {
            // Apply filters
            applyAllFilters();

            // Load filter options
            populateFilters();

            // Initialize charts
            initializeKPIChats();
        } else {
            // In background mode, just update the data silently
            // The UI will use the cached data that was already displayed
            console.log('Background data refresh completed');
        }
    } catch (error) {
        console.error('Error loading fresh data:', error);
        if (!background) {
            document.getElementById('performanceTableBody').innerHTML = 
                '<tr><td colspan="8" class="loading" style="color: var(--error-color);">Error loading data. Please refresh.</td></tr>';
        }
    }
}

async function loadScorecardParameters() {
    try {
        const { data: scorecards, error: scError } = await window.supabaseClient
            .from('scorecards')
            .select('id, table_name')
            .eq('is_active', true);

        if (scError || !scorecards) return;

        // Store scorecards for mapping scorecard_id to table_name
        allScorecards = scorecards || [];
        setCachedData(CACHE_KEYS.SCORECARDS, allScorecards);
        allScorecardParameters = {};
        
        for (const scorecard of scorecards) {
            try {
                const { data: parameters, error } = await window.supabaseClient
                    .from('scorecard_parameters')
                    .select('field_id, error_name, scorecard_id, parameter_type, field_type, error_category')
                    .eq('scorecard_id', scorecard.id)
                    .eq('is_active', true);

                if (!error && parameters) {
                    if (!allScorecardParameters[scorecard.id]) {
                        allScorecardParameters[scorecard.id] = {};
                    }
                    parameters.forEach(param => {
                        allScorecardParameters[scorecard.id][param.field_id] = {
                            name: param.error_name,
                            parameter_type: param.parameter_type || 'error',
                            field_type: param.field_type || 'counter',
                            error_category: param.error_category || 'Significant Error'
                        };
                    });
                }
            } catch (err) {
                console.warn(`Error loading parameters for scorecard ${scorecard.id}:`, err);
            }
        }
        
        // Cache scorecard parameters
        setCachedData(CACHE_KEYS.SCORECARD_PARAMS, allScorecardParameters);
    } catch (error) {
        console.error('Error loading scorecard parameters:', error);
    }
}

async function loadAuditsData() {
    try {
        // Get all active scorecards with their IDs
        const { data: scorecards, error: scError } = await window.supabaseClient
            .from('scorecards')
            .select('id, table_name')
            .eq('is_active', true);

        if (scError || !scorecards) return;

        allAudits = [];
        
        // Load audits from each scorecard table
        for (const scorecard of scorecards) {
            try {
                // First, get all column names to load all parameter fields
                // We'll load total_errors_count and all fields that might be parameters
                const { data: audits, error } = await window.supabaseClient
                    .from(scorecard.table_name)
                    .select('*')
                    .not('average_score', 'is', null);

                if (!error && audits) {
                    allAudits = allAudits.concat(audits.map(a => ({
                        ...a,
                        scorecard_table: scorecard.table_name,
                        scorecard_id: scorecard.id
                    })));
                }
            } catch (err) {
                console.warn(`Error loading audits from ${scorecard.table_name}:`, err);
            }
        }
        
        // Cache audits data
        setCachedData(CACHE_KEYS.AUDITS, allAudits);
    } catch (error) {
        console.error('Error loading audits:', error);
    }
}

// ============================================================================
// Filtering
// ============================================================================
// Helper function to get current period dates based on week/date filter
function getCurrentPeriodDates() {
    let currentPeriodStart, currentPeriodEnd;
    
    if (dateFilter.start || dateFilter.end) {
        currentPeriodStart = dateFilter.start ? getDhakaStartOfDay(parseDhakaDate(dateFilter.start)) : new Date(0);
        currentPeriodEnd = dateFilter.end ? getDhakaEndOfDay(parseDhakaDate(dateFilter.end)) : getDhakaNow();
    } else if (useWeekFilter && currentWeek !== null) {
        const weekDates = getDhakaWeekDates(currentWeek, currentWeekYear);
        currentPeriodStart = weekDates.start;
        currentPeriodEnd = weekDates.end;
    } else {
        const today = getDhakaNow();
        const weekDates = getDhakaWeekDates(getDhakaWeekNumber(today), today.getFullYear());
        currentPeriodStart = weekDates.start;
        currentPeriodEnd = weekDates.end;
    }
    
    return { start: currentPeriodStart, end: currentPeriodEnd };
}

// Helper function to get filtered audits based on submission date
function getFilteredAuditsBySubmissionDate() {
    const { start: periodStart, end: periodEnd } = getCurrentPeriodDates();
    
    // Get employee emails to include
    let employeeEmailsToInclude = new Set();
    if (currentFilters.agent) {
        employeeEmailsToInclude.add(currentFilters.agent);
    } else {
        allAssignments.forEach(a => {
            if (a.employee_email) employeeEmailsToInclude.add(a.employee_email);
        });
    }
    
    // Filter audits by submission date and other filters
    const agentAuditIds = {};
    const filteredAudits = [];
    
    allAudits.forEach(audit => {
        const agentEmail = audit.employee_email || 'Unknown';
        
        // Filter by employee
        if (!employeeEmailsToInclude.has(agentEmail)) return;
        
        // Filter by submission date
        const submitted = new Date(audit.submitted_at);
        if (submitted < periodStart || submitted > periodEnd) return;
        
        // Filter by channel if set
        if (currentFilters.channel && audit.channel !== currentFilters.channel) return;
        
        // Track unique audits per agent
        if (!agentAuditIds[agentEmail]) {
            agentAuditIds[agentEmail] = new Set();
        }
        
        const auditKey = `${audit.id}_${audit.scorecard_id || 'unknown'}`;
        if (!agentAuditIds[agentEmail].has(auditKey)) {
            agentAuditIds[agentEmail].add(auditKey);
            filteredAudits.push(audit);
        }
    });
    
    return filteredAudits;
}

function populateFilters() {
    // Populate channels
    const channels = [...new Set(allAssignments.map(a => a.channel).filter(Boolean))].sort();
    const channelSelect = document.getElementById('filterChannel');
    channels.forEach(channel => {
        const option = document.createElement('option');
        option.value = channel;
        option.textContent = channel;
        channelSelect.appendChild(option);
    });

    // Populate agents
    const agents = [...new Set(allAssignments.map(a => a.employee_email).filter(Boolean))].sort();
    const agentSelect = document.getElementById('filterAgent');
    agents.forEach(agent => {
        const option = document.createElement('option');
        option.value = agent;
        option.textContent = formatAgentName(agent);
        agentSelect.appendChild(option);
    });
}

function applyAllFilters() {
    filteredAssignments = [...allAssignments];

    // Apply date filter (date range overrides week filter)
    if (dateFilter.start || dateFilter.end) {
        useWeekFilter = false;
        filteredAssignments = filteredAssignments.filter(a => {
            const created = toDhakaTime(a.created_at);
            if (dateFilter.start && created < getDhakaStartOfDay(parseDhakaDate(dateFilter.start))) return false;
            if (dateFilter.end) {
                const endDate = getDhakaEndOfDay(parseDhakaDate(dateFilter.end));
                if (created > endDate) return false;
            }
            return true;
        });
    } else if (useWeekFilter && currentWeek !== null) {
        // Apply week filter (default)
        const weekDates = getWeekDates(currentWeek, currentWeekYear);
        filteredAssignments = filteredAssignments.filter(a => {
            const created = toDhakaTime(a.created_at);
            return created >= weekDates.start && created <= weekDates.end;
        });
    }

    // Apply other filters
    if (currentFilters.channel) {
        filteredAssignments = filteredAssignments.filter(a => a.channel === currentFilters.channel);
    }
    if (currentFilters.status) {
        filteredAssignments = filteredAssignments.filter(a => a.status === currentFilters.status);
    }
    if (currentFilters.agent) {
        filteredAssignments = filteredAssignments.filter(a => a.employee_email === currentFilters.agent);
    }

    // Update all views
    updateKPIs();
    updateAgentPerformance();
    updateCharts();
    updateRecentAudits();
    updateErrorCategories();
}

function applyFilters() {
    currentFilters.channel = document.getElementById('filterChannel').value;
    currentFilters.status = document.getElementById('filterStatus').value;
    currentFilters.agent = document.getElementById('filterAgent').value;
    applyAllFilters();
}

function applyDateFilter() {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    
    if (startDate) dateFilter.start = startDate;
    if (endDate) dateFilter.end = endDate;

    const dateBtnTextEl = document.getElementById('dateBtnText');
    if (startDate || endDate) {
        const start = startDate ? formatDhakaDate(parseDhakaDate(startDate), { month: 'short', day: 'numeric' }) : 'Start';
        const end = endDate ? formatDhakaDate(parseDhakaDate(endDate), { month: 'short', day: 'numeric' }) : 'End';
        if (dateBtnTextEl) dateBtnTextEl.textContent = `${start} - ${end}`;
        useWeekFilter = false;
        
        // Clear active state of quick filter buttons when using custom date range
        const quickDateButtons = document.querySelectorAll('.quick-date-btn');
        quickDateButtons.forEach(btn => btn.classList.remove('active'));
        
        updateWeekDisplay(); // Update week display to show "-"
    } else {
        // If both dates are cleared, reset to current month view
        initializeMonthFilter();
    }

    const dateDropdown = document.getElementById('dateDropdown');
    if (dateDropdown) dateDropdown.classList.remove('active');
    applyAllFilters();
}

function clearDateFilter() {
    // Reset to current month view instead of week view
    initializeMonthFilter();
    const dateDropdown = document.getElementById('dateDropdown');
    if (dateDropdown) dateDropdown.classList.remove('active');
    applyAllFilters();
}

// Use shared date filter utility - wrap to provide page-specific callbacks
const originalApplyQuickDateFilter = window.applyQuickDateFilter;
function applyQuickDateFilter(period) {
    originalApplyQuickDateFilter(period, {
        dateFilter: dateFilter,
        setUseWeekFilter: () => { useWeekFilter = false; },
        onUpdate: updateWeekDisplay,
        onRefresh: applyAllFilters
    });
}

// ============================================================================
// KPI Updates
// ============================================================================
function updateKPIs() {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Get current period dates
    const { start: currentPeriodStart, end: currentPeriodEnd } = getCurrentPeriodDates();
    
    // Get filtered audits by submission date
    const filteredAudits = getFilteredAuditsBySubmissionDate();
    
    // Interaction count (total audits submitted in filtered period)
    const interactionCount = filteredAudits.length;
    
    // Completed audits count (all submitted audits are considered completed)
    const completedAudits = filteredAudits.length;

    // Get previous period dates for comparison
    let previousPeriodStart, previousPeriodEnd;
    
    if (dateFilter.start || dateFilter.end) {
        // Using date range filter - calculate previous period of same length
        const periodDays = Math.ceil((currentPeriodEnd - currentPeriodStart) / (1000 * 60 * 60 * 24));
        previousPeriodStart = new Date(currentPeriodStart);
        previousPeriodStart.setDate(previousPeriodStart.getDate() - periodDays);
        previousPeriodEnd = new Date(currentPeriodStart);
        previousPeriodEnd.setDate(previousPeriodEnd.getDate() - 1);
        previousPeriodEnd.setHours(23, 59, 59, 999);
    } else if (useWeekFilter && currentWeek !== null) {
        // Previous week
        let prevWeek = currentWeek - 1;
        let prevWeekYear = currentWeekYear;
        if (prevWeek < 1) {
            prevWeek = 52;
            prevWeekYear -= 1;
        }
        const prevWeekDates = getWeekDates(prevWeek, prevWeekYear);
        previousPeriodStart = prevWeekDates.start;
        previousPeriodEnd = prevWeekDates.end;
    } else {
        // Default to previous week
        const prevWeekDates = getWeekDates(getWeekNumber(today) - 1, today.getFullYear());
        previousPeriodStart = prevWeekDates.start;
        previousPeriodEnd = prevWeekDates.end;
    }
    
    // Get employee emails to include for previous period
    let employeeEmailsForPrev = new Set();
    if (currentFilters.agent) {
        employeeEmailsForPrev.add(currentFilters.agent);
    } else {
        allAssignments.forEach(a => {
            if (a.employee_email) employeeEmailsForPrev.add(a.employee_email);
        });
    }
    
    // Previous period interaction count (audits submitted in previous period)
    const previousAgentAuditIds = {};
    const previousFilteredAudits = [];
    
    allAudits.forEach(audit => {
        const agentEmail = audit.employee_email || 'Unknown';
        if (!employeeEmailsForPrev.has(agentEmail)) return;
        
        const submitted = new Date(audit.submitted_at);
        if (submitted < previousPeriodStart || submitted > previousPeriodEnd) return;
        
        if (currentFilters.channel && audit.channel !== currentFilters.channel) return;
        
        if (!previousAgentAuditIds[agentEmail]) {
            previousAgentAuditIds[agentEmail] = new Set();
        }
        
        const auditKey = `${audit.id}_${audit.scorecard_id || 'unknown'}`;
        if (!previousAgentAuditIds[agentEmail].has(auditKey)) {
            previousAgentAuditIds[agentEmail].add(auditKey);
            previousFilteredAudits.push(audit);
        }
    });
    
    const previousInteractionCount = previousFilteredAudits.length;
    const previousCompletedAudits = previousFilteredAudits.length;

    const interactionChange = previousInteractionCount > 0 
        ? ((interactionCount - previousInteractionCount) / previousInteractionCount * 100) 
        : (interactionCount > 0 ? 100 : 0);
    
    const completedChange = previousCompletedAudits > 0 
        ? ((completedAudits - previousCompletedAudits) / previousCompletedAudits * 100) 
        : (completedAudits > 0 ? 100 : 0);

    // Error count trend - use filtered audits by submission date
    const currentPeriodErrorCount = filteredAudits.reduce((total, audit) => {
        return total + (parseInt(audit.total_errors_count) || 0);
    }, 0);

    // Calculate total errors for previous period
    const previousPeriodErrorCount = previousFilteredAudits.reduce((total, audit) => {
        return total + (parseInt(audit.total_errors_count) || 0);
    }, 0);
    
    // Calculate percentage change
    const errorChange = previousPeriodErrorCount > 0 
        ? ((currentPeriodErrorCount - previousPeriodErrorCount) / previousPeriodErrorCount * 100) 
        : (currentPeriodErrorCount > 0 ? 100 : 0);
    // Note: Negative change (fewer errors) is positive, positive change (more errors) is negative

    // Average quality score - use filtered audits by submission date
    const auditsWithScores = filteredAudits
        .filter(audit => audit.average_score)
        .map(audit => parseFloat(audit.average_score));
    let avgScore = 0;
    if (auditsWithScores.length > 0) {
        const totalScore = auditsWithScores.reduce((sum, score) => sum + score, 0);
        avgScore = Math.round(totalScore / auditsWithScores.length);
    }

    // Previous period average score
    const previousPeriodAuditScores = previousFilteredAudits
        .filter(a => a.average_score)
        .map(a => parseFloat(a.average_score));
    let previousPeriodAvgScore = 0;
    if (previousPeriodAuditScores.length > 0) {
        const totalScore = previousPeriodAuditScores.reduce((sum, score) => sum + score, 0);
        previousPeriodAvgScore = Math.round(totalScore / previousPeriodAuditScores.length);
    }
    const scoreChange = avgScore - previousPeriodAvgScore;

    // Update KPI cards
    // Hide date display
    document.getElementById('kpi0Date').textContent = '';
    // Show "Coming Soon" chip instead of numbers for Interaction Count
    document.getElementById('kpi0Value').innerHTML = '<span class="coming-soon-chip">Coming Soon</span>';
    document.getElementById('kpi0Change').textContent = '';
    document.getElementById('kpi0Change').style.display = 'none';

    document.getElementById('kpi1Date').textContent = '';
    document.getElementById('kpi1Value').textContent = completedAudits.toLocaleString();
    document.getElementById('kpi1Change').textContent = `${completedChange >= 0 ? '+' : ''}${Math.round(completedChange)}% than previous period`;
    document.getElementById('kpi1Change').className = `kpi-change ${completedChange >= 0 ? 'positive' : 'negative'}`;

    // Round error change for display
    const errorChangeRounded = Math.round(errorChange);

    document.getElementById('kpi2Date').textContent = '';
    document.getElementById('kpi2Value').textContent = currentPeriodErrorCount.toLocaleString();
    // For errors: negative change (fewer errors) is good (positive), positive change (more errors) is bad (negative)
    document.getElementById('kpi2Change').textContent = `${errorChangeRounded >= 0 ? '+' : ''}${errorChangeRounded}% than previous period`;
    document.getElementById('kpi2Change').className = `kpi-change ${errorChangeRounded <= 0 ? 'positive' : 'negative'}`;

    document.getElementById('kpi3Date').textContent = '';
    document.getElementById('kpi3Value').textContent = `${avgScore}%`;
    document.getElementById('kpi3Change').textContent = `${scoreChange >= 0 ? '+' : ''}${scoreChange}% than previous period`;
    document.getElementById('kpi3Change').className = `kpi-change ${scoreChange >= 0 ? 'positive' : 'negative'}`;

    // Update KPI trend charts
    // For error trend: negative change (fewer errors) is positive trend
    updateKPITrendCharts(interactionChange >= 0, completedChange >= 0, errorChangeRounded <= 0, scoreChange >= 0);
}

function updateKPITrendCharts(up0, up1, up2, up3) {
    const generateData = (trend) => {
        const data = [];
        let value = 50;
        for (let i = 0; i < 7; i++) {
            value += trend ? Math.random() * 10 - 2 : Math.random() * 10 - 8;
            data.push(Math.max(0, Math.min(100, value)));
        }
        return data;
    };

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
            intersect: false,
            mode: 'nearest'
        },
        layout: {
            padding: {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0
            }
        },
        plugins: { 
            legend: { display: false }, 
            tooltip: { enabled: false },
            datalabels: { display: false }
        },
        scales: { 
            x: { 
                display: false,
                ticks: { display: false },
                grid: { display: false },
                border: { display: false }
            }, 
            y: { 
                display: false,
                ticks: { display: false },
                grid: { display: false },
                border: { display: false },
                min: 0,
                max: 100
            } 
        },
        elements: { point: { radius: 0 }, line: { borderWidth: 2 } }
    };

    if (charts.kpi0) charts.kpi0.destroy();
    charts.kpi0 = new Chart(document.getElementById('kpiChart0'), {
        type: 'line',
        data: {
            labels: Array(7).fill(''),
            datasets: [{
                data: generateData(up0),
                borderColor: '#9333ea',
                backgroundColor: 'rgba(147, 51, 234, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: chartOptions
    });

    if (charts.kpi1) charts.kpi1.destroy();
    charts.kpi1 = new Chart(document.getElementById('kpiChart1'), {
        type: 'line',
        data: {
            labels: Array(7).fill(''),
            datasets: [{
                data: generateData(up1),
                borderColor: up1 ? '#10b981' : '#ef4444',
                backgroundColor: up1 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: chartOptions
    });

    if (charts.kpi2) charts.kpi2.destroy();
    charts.kpi2 = new Chart(document.getElementById('kpiChart2'), {
        type: 'line',
        data: {
            labels: Array(7).fill(''),
            datasets: [{
                data: generateData(up2),
                borderColor: '#ef4444',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: chartOptions
    });

    if (charts.kpi3) charts.kpi3.destroy();
    charts.kpi3 = new Chart(document.getElementById('kpiChart3'), {
        type: 'line',
        data: {
            labels: Array(7).fill(''),
            datasets: [{
                data: generateData(up3),
                borderColor: up3 ? '#10b981' : '#ef4444',
                backgroundColor: up3 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)',
                tension: 0.4,
                fill: true
            }]
        },
        options: chartOptions
    });
}

function initializeKPIChats() {
    updateKPIs(); // This will create the charts
}

// ============================================================================
// Helper Functions
// ============================================================================
// Helper function to find audit by assignment (uses audit_id if available, otherwise email matching)
function findAuditForAssignment(assignment) {
    let audit = null;
    
    // First, try to use audit_id if available (most accurate)
    if (assignment.audit_id && assignment.scorecard_id) {
        const scorecard = allScorecards.find(s => s.id === assignment.scorecard_id);
        if (scorecard) {
            // Find audit in the correct scorecard table by audit_id
            audit = allAudits.find(a => 
                a.id === assignment.audit_id &&
                a.scorecard_id === assignment.scorecard_id
            );
        }
    }
    
    // Fall back to email matching if audit_id is not available (for backward compatibility)
    // But be more selective: only match if scorecard_id matches and dates are reasonable
    if (!audit) {
        // First, try to find audits that match email AND scorecard_id
        let candidateAudits = allAudits.filter(a => 
            a.employee_email === assignment.employee_email &&
            a.auditor_email === assignment.auditor_email &&
            (assignment.scorecard_id ? a.scorecard_id === assignment.scorecard_id : true)
        );
        
        // If we have scorecard_id, prefer audits from that scorecard
        if (assignment.scorecard_id && candidateAudits.length > 0) {
            const scorecardMatches = candidateAudits.filter(a => a.scorecard_id === assignment.scorecard_id);
            if (scorecardMatches.length > 0) {
                candidateAudits = scorecardMatches;
            }
        }
        
        // If multiple candidates, prefer the one closest to assignment creation date
        if (candidateAudits.length > 0) {
            if (candidateAudits.length === 1) {
                audit = candidateAudits[0];
            } else {
                // Multiple matches - find the one closest to assignment.created_at
                const assignmentDate = new Date(assignment.created_at);
                candidateAudits.sort((a, b) => {
                    const dateA = new Date(a.submitted_at || a.created_at || 0);
                    const dateB = new Date(b.submitted_at || b.created_at || 0);
                    const diffA = Math.abs(dateA - assignmentDate);
                    const diffB = Math.abs(dateB - assignmentDate);
                    return diffA - diffB;
                });
                audit = candidateAudits[0];
            }
        }
    }
    
    return audit;
}

// ============================================================================
// Agent Performance Table
// ============================================================================
function updateAgentPerformance() {
    // Get filtered audits by submission date
    const filteredAudits = getFilteredAuditsBySubmissionDate();
    
    // Group by employee_email
    const agentMap = {};
    const agentAuditIds = {}; // Track unique audit IDs per agent to prevent double-counting
    
    // Process all filtered audits
    filteredAudits.forEach(audit => {
        const agentEmail = audit.employee_email || 'Unknown';
        
        // Initialize agent map if needed
        if (!agentMap[agentEmail]) {
            agentMap[agentEmail] = {
                email: agentEmail,
                total: 0,
                completed: 0,
                scores: [],
                audits: [] // Store full audit objects for error analysis
            };
            agentAuditIds[agentEmail] = new Set(); // Track unique audit IDs
        }
        
        // Use Set to ensure we never count the same audit twice
        const auditKey = `${audit.id}_${audit.scorecard_id || 'unknown'}`;
        if (!agentAuditIds[agentEmail].has(auditKey)) {
            agentAuditIds[agentEmail].add(auditKey);
            
            // Count total audits (all submitted audits are counted)
            agentMap[agentEmail].total++;
            agentMap[agentEmail].completed++; // All submitted audits are completed
            
            if (audit.average_score) {
                agentMap[agentEmail].scores.push(parseFloat(audit.average_score));
            }
            // Store full audit for error analysis
            agentMap[agentEmail].audits.push(audit);
        }
    });

    // Calculate averages and error data
    const agentData = Object.values(agentMap).map(agent => {
        const avgScore = agent.scores.length > 0 
            ? Math.round(agent.scores.reduce((a, b) => a + b, 0) / agent.scores.length)
            : 0;
        
        // Calculate total error count
        const totalErrorCount = agent.audits.reduce((sum, audit) => {
            return sum + (parseInt(audit.total_errors_count) || 0);
        }, 0);
        
        // Calculate top error parameter
        const topErrorParameter = getTopErrorParameter(agent.audits);
        
        // Get user info
        const user = allUsers.find(u => u.email && agent.email && 
            u.email.toLowerCase() === agent.email.toLowerCase());
        const employeeId = user?.employee_id || '-';
        const fullName = user?.name || formatAgentName(agent.email);
        
        // Status based on average score
        // >=95% = Exemplary
        // 90-94% = Exceeding
        // 80-89% = Developing
        // 70-79% = Needs Improvement
        // <70% = At Risk
        let status, statusText;
        if (avgScore >= 95) {
            status = 'exemplary';
            statusText = 'Exemplary';
        } else if (avgScore >= 90) {
            status = 'exceeding';
            statusText = 'Exceeding';
        } else if (avgScore >= 80) {
            status = 'developing';
            statusText = 'Developing';
        } else if (avgScore >= 70) {
            status = 'needs-improvement';
            statusText = 'Needs Improvement';
        } else {
            status = 'at-risk';
            statusText = 'At Risk';
        }
        
        return {
            ...agent,
            avgScore,
            totalErrorCount,
            topErrorParameter,
            employeeId,
            fullName,
            status,
            statusText
        };
    }).sort((a, b) => b.avgScore - a.avgScore);

    // Update table
    const tbody = document.getElementById('performanceTableBody');
    if (agentData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" class="loading">No performance data available</td></tr>';
    } else {
        tbody.innerHTML = agentData.map((agent) => {
            return `
                <tr>
                    <td>${escapeHtml(agent.employeeId)}</td>
                    <td>${escapeHtml(agent.fullName)}</td>
                    <td>${agent.total}</td>
                    <td>${agent.completed}</td>
                    <td>${agent.avgScore}%</td>
                    <td>${agent.totalErrorCount}</td>
                    <td>${escapeHtml(agent.topErrorParameter)}</td>
                    <td>
                        <span class="status-badge ${agent.status}">
                            <span class="status-dot ${agent.status}"></span>
                            ${agent.statusText}
                        </span>
                    </td>
                </tr>
            `;
        }).join('');
    }

    // Update top performers chart
    updateTopPerformersChart(agentData.slice(0, 3));
}

function getTopErrorParameter(audits) {
    if (!audits || audits.length === 0) return '-';
    
    // Count errors by parameter field_id
    const errorCounts = {};
    
    audits.forEach(audit => {
        if (!audit.scorecard_id) return;
        
        const parameters = allScorecardParameters[audit.scorecard_id];
        if (!parameters) return;
        
        // Check each parameter field in the audit
        Object.keys(parameters).forEach(fieldId => {
            const paramInfo = parameters[fieldId];
            const value = audit[fieldId];
            let errorCount = 0;
            
            if (value !== null && value !== undefined && value !== '') {
                const paramType = paramInfo.parameter_type || 'error';
                const fieldType = paramInfo.field_type || 'counter';
                
                // For radio buttons
                if (fieldType === 'radio') {
                    let numValue = 0;
                    if (typeof value === 'boolean') {
                        numValue = value ? 1 : 0;
                    } else if (typeof value === 'number') {
                        numValue = value;
                    } else if (typeof value === 'string') {
                        const parsed = parseInt(value);
                        if (!isNaN(parsed)) {
                            numValue = parsed;
                        } else if (value === 'true' || value === '1') {
                            numValue = 1;
                        }
                    }
                    
                    // For achievement/bonus: NO (0) = not achieved = error
                    // For error parameters: YES (1) = error occurred = error
                    if (paramType === 'achievement' || paramType === 'bonus') {
                        errorCount = numValue === 0 ? 1 : 0; // NO = error, YES = no error
                    } else {
                        errorCount = numValue; // YES = error, NO = no error
                    }
                } else {
                    // For counters: the value itself is the error count
                    if (typeof value === 'boolean') {
                        errorCount = value ? 1 : 0;
                    } else if (typeof value === 'number') {
                        errorCount = value;
                    } else if (typeof value === 'string') {
                        const numValue = parseInt(value);
                        if (!isNaN(numValue)) {
                            errorCount = numValue;
                        } else if (value === 'true' || value === '1') {
                            errorCount = 1;
                        }
                    }
                }
            }
            
            if (errorCount > 0) {
                const paramName = paramInfo.name;
                if (!errorCounts[paramName]) {
                    errorCounts[paramName] = 0;
                }
                errorCounts[paramName] += errorCount;
            }
        });
    });
    
    // Find the parameter with the highest error count
    let topParameter = '-';
    let maxCount = 0;
    
    Object.keys(errorCounts).forEach(paramName => {
        if (errorCounts[paramName] > maxCount) {
            maxCount = errorCounts[paramName];
            topParameter = paramName;
        }
    });
    
    return topParameter;
}

function formatAgentName(email) {
    if (!email || email === 'Unknown') return 'Unknown';
    return email.split('@')[0].replace(/\./g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

// ============================================================================
// Charts
// ============================================================================
function updateTopPerformersChart(data) {
    const ctx = document.getElementById('topPerformersChart');
    
    if (charts.topPerformers) {
        charts.topPerformers.destroy();
    }

    if (data.length === 0) {
        // Show empty state
        return;
    }

    charts.topPerformers = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: data.map(a => a.fullName || formatAgentName(a.email)),
            datasets: [{
                label: 'Score %',
                data: data.map(a => a.avgScore),
                backgroundColor: data.map((_, i) => {
                    const colors = ['#1a733e', '#10b981', '#34d399'];
                    return colors[i] || '#6b7280';
                }),
                borderRadius: 4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `Score: ${context.parsed.y}%`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: {
                        callback: function(value) {
                            return value + '%';
                        }
                    }
                }
            }
        }
    });
}

function updateCharts() {
    updateChannelChart();
    updateAnalyticsChart();
}

function updateChannelChart() {
    // Get filtered audits by submission date
    const filteredAudits = getFilteredAuditsBySubmissionDate();
    
    // Group by channel from audits
    const channelMap = {};
    filteredAudits.forEach(audit => {
        const channel = audit.channel || 'Unknown';
        if (!channelMap[channel]) {
            channelMap[channel] = { total: 0, completed: 0, scores: [] };
        }
        channelMap[channel].total++;
        channelMap[channel].completed++;
        if (audit.average_score) {
            channelMap[channel].scores.push(parseFloat(audit.average_score));
        }
    });

    const channels = Object.entries(channelMap)
        .map(([name, data]) => ({
            name,
            completed: data.completed,
            avgScore: data.scores.length > 0 ? Math.round(data.scores.reduce((a, b) => a + b, 0) / data.scores.length) : 0
        }))
        .sort((a, b) => b.completed - a.completed);

    // Update location chart
    const ctx = document.getElementById('locationChart');
    if (charts.location) {
        charts.location.destroy();
    }

    const topChannels = channels.slice(0, 5);
    if (topChannels.length > 0) {
        charts.location = new Chart(ctx, {
            type: 'line',
            data: {
                labels: topChannels.map(c => c.name),
                datasets: [{
                    label: 'Completed Audits',
                    data: topChannels.map(c => c.completed),
                    borderColor: '#1a733e',
                    backgroundColor: 'rgba(26, 115, 62, 0.1)',
                    tension: 0.4,
                    fill: true,
                    pointBackgroundColor: '#1a733e',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.y} audits`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    }
                }
            }
        });

        // Update top location metric
        document.getElementById('topLocationValue').textContent = channels[0].completed.toLocaleString();
        document.getElementById('locationChange').textContent = '+30% than last week'; // Could calculate actual change
    }

    // Update location list
    const list = document.getElementById('locationList');
    if (channels.length === 0) {
        list.innerHTML = '<li class="location-item"><span class="location-name">No data</span><span class="location-value">-</span></li>';
    } else {
        list.innerHTML = channels.map(c => `
            <li class="location-item">
                <span class="location-name">${c.name}</span>
                <span class="location-value">${c.completed}</span>
            </li>
        `).join('');
    }
}

function updateAnalyticsChart() {
    const ctx = document.getElementById('analyticsChart');
    const period = document.getElementById('analyticsPeriod').value;
    
    let labels = [];
    let data = [];
    const today = new Date();

    // Get employee emails to include
    let employeeEmailsToInclude = new Set();
    if (currentFilters.agent) {
        employeeEmailsToInclude.add(currentFilters.agent);
    } else {
        allAssignments.forEach(a => {
            if (a.employee_email) employeeEmailsToInclude.add(a.employee_email);
        });
    }

    if (period === 'daily') {
        // Last 7 days
        for (let i = 6; i >= 0; i--) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            labels.push(formatDhakaDate(date, { month: 'short', day: 'numeric' }));
            
            const dayStart = new Date(date);
            dayStart.setHours(0, 0, 0, 0);
            const dayEnd = new Date(date);
            dayEnd.setHours(23, 59, 59, 999);
            
            // Count audits submitted on this day
            const dayAudits = allAudits.filter(audit => {
                const agentEmail = audit.employee_email || 'Unknown';
                if (!employeeEmailsToInclude.has(agentEmail)) return false;
                if (currentFilters.channel && audit.channel !== currentFilters.channel) return false;
                const submitted = new Date(audit.submitted_at);
                return submitted >= dayStart && submitted <= dayEnd;
            });
            data.push(dayAudits.length);
        }
    } else if (period === 'weekly') {
        // Last 4 weeks
        for (let i = 3; i >= 0; i--) {
            const weekStart = new Date(today);
            weekStart.setDate(weekStart.getDate() - (i + 1) * 7);
            const weekEnd = new Date(today);
            weekEnd.setDate(weekEnd.getDate() - i * 7);
            
            labels.push(`Week ${4 - i}`);
            
            // Count audits submitted in this week
            const weekAudits = allAudits.filter(audit => {
                const agentEmail = audit.employee_email || 'Unknown';
                if (!employeeEmailsToInclude.has(agentEmail)) return false;
                if (currentFilters.channel && audit.channel !== currentFilters.channel) return false;
                const submitted = new Date(audit.submitted_at);
                return submitted >= weekStart && submitted < weekEnd;
            });
            data.push(weekAudits.length);
        }
    } else if (period === 'monthly') {
        // Last 6 months
        for (let i = 5; i >= 0; i--) {
            const monthStart = new Date(today.getFullYear(), today.getMonth() - i, 1);
            const monthEnd = new Date(today.getFullYear(), today.getMonth() - i + 1, 0);
            monthEnd.setHours(23, 59, 59, 999);
            
            labels.push(formatDhakaDate(monthStart, { month: 'short' }));
            
            // Count audits submitted in this month
            const monthAudits = allAudits.filter(audit => {
                const agentEmail = audit.employee_email || 'Unknown';
                if (!employeeEmailsToInclude.has(agentEmail)) return false;
                if (currentFilters.channel && audit.channel !== currentFilters.channel) return false;
                const submitted = new Date(audit.submitted_at);
                return submitted >= monthStart && submitted <= monthEnd;
            });
            data.push(monthAudits.length);
        }
    }

    if (charts.analytics) {
        charts.analytics.destroy();
    }

    charts.analytics = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Completed Audits',
                data: data,
                backgroundColor: data.map((val, idx) => idx === data.length - 1 ? '#1a733e' : 'rgba(26, 115, 62, 0.6)'),
                borderRadius: 4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.parsed.y} audits`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        stepSize: 1
                    }
                }
            }
        }
    });
}

// ============================================================================
// Recent Audits
// ============================================================================
function updateRecentAudits() {
    // Get filtered audits by submission date, sorted by most recent
    const filteredAudits = getFilteredAuditsBySubmissionDate();
    
    const recent = filteredAudits
        .map(audit => ({
            id: audit.id,
            channel: audit.channel || 'Unknown',
            date: new Date(audit.submitted_at),
            score: audit.average_score ? parseFloat(audit.average_score) : 0
        }))
        .sort((a, b) => b.date - a.date)
        .slice(0, 5);

    const list = document.getElementById('recentAuditsList');
    if (recent.length === 0) {
        list.innerHTML = '<div class="recent-item"><div class="recent-content"><div class="recent-title">No recent audits</div></div></div>';
    } else {
        list.innerHTML = recent.map(a => `
            <div class="recent-item">
                <div class="recent-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                    </svg>
                </div>
                <div class="recent-content">
                    <div class="recent-title">${escapeHtml(a.channel)}</div>
                    <div class="recent-date">${formatDhakaDate(a.date, { month: 'short', day: 'numeric', year: 'numeric' })}</div>
                </div>
                <div class="recent-value">${a.score}%</div>
            </div>
        `).join('');
    }
}

// ============================================================================
// Export Functionality
// ============================================================================
function exportToCSV() {
    try {
        // Get filtered audits by submission date (same logic as updateAgentPerformance)
        const filteredAudits = getFilteredAuditsBySubmissionDate();
        
        // Group by employee_email
        const agentMap = {};
        const agentAuditIds = {}; // Track unique audit IDs per agent to prevent double-counting
        
        // Process all filtered audits
        filteredAudits.forEach(audit => {
            const agentEmail = audit.employee_email || 'Unknown';
            
            // Initialize agent map if needed
            if (!agentMap[agentEmail]) {
                agentMap[agentEmail] = {
                    email: agentEmail,
                    total: 0,
                    completed: 0,
                    scores: [],
                    audits: []
                };
                agentAuditIds[agentEmail] = new Set();
            }
            
            // Use Set to ensure we never count the same audit twice
            const auditKey = `${audit.id}_${audit.scorecard_id || 'unknown'}`;
            if (!agentAuditIds[agentEmail].has(auditKey)) {
                agentAuditIds[agentEmail].add(auditKey);
                
                // Count total audits (all submitted audits are counted)
                agentMap[agentEmail].total++;
                agentMap[agentEmail].completed++; // All submitted audits are completed
                
                if (audit.average_score) {
                    agentMap[agentEmail].scores.push(parseFloat(audit.average_score));
                }
                // Store full audit for error analysis
                agentMap[agentEmail].audits.push(audit);
            }
        });

        // Calculate averages and error data
        const agentData = Object.values(agentMap).map(agent => {
            const avgScore = agent.scores.length > 0 
                ? agent.scores.reduce((a, b) => a + b, 0) / agent.scores.length
                : 0;
            
            // Calculate total error count
            const totalErrorCount = agent.audits.reduce((sum, audit) => {
                return sum + (parseInt(audit.total_errors_count) || 0);
            }, 0);
            
            // Calculate top error parameter
            const topErrorParameter = getTopErrorParameter(agent.audits);
            
            // Get user info
            const user = allUsers.find(u => u.email && agent.email && 
                u.email.toLowerCase() === agent.email.toLowerCase());
            const employeeId = user?.employee_id || '-';
            const fullName = user?.name || formatAgentName(agent.email);
            
            // Status based on average score
            // >=95% = Exemplary
            // 90-94% = Exceeding
            // 80-89% = Developing
            // 70-79% = Needs Improvement
            // <70% = At Risk
            let status, statusText;
            if (avgScore >= 95) {
                status = 'exemplary';
                statusText = 'Exemplary';
            } else if (avgScore >= 90) {
                status = 'exceeding';
                statusText = 'Exceeding';
            } else if (avgScore >= 80) {
                status = 'developing';
                statusText = 'Developing';
            } else if (avgScore >= 70) {
                status = 'needs-improvement';
                statusText = 'Needs Improvement';
            } else {
                status = 'at-risk';
                statusText = 'At Risk';
            }
            
            return {
                ...agent,
                avgScore,
                totalErrorCount,
                topErrorParameter,
                employeeId,
                fullName,
                status,
                statusText
            };
        }).sort((a, b) => b.avgScore - a.avgScore);

        // Format for CSV export
        const csvData = agentData.map((agent) => {
            const avgScore = agent.avgScore.toFixed(2);
            return {
                'Employee ID': agent.employeeId || '-',
                'Full Name': agent.fullName || formatAgentName(agent.email),
                'Total Audits': agent.total,
                'Completed': agent.completed,
                'Average Score': `${avgScore}%`,
                'Total Error Count': agent.totalErrorCount || 0,
                'Top Error Parameter': agent.topErrorParameter || '-',
                'Status': agent.statusText
            };
        });

        if (csvData.length === 0) {
            alert('No data available to export.');
            return;
        }

        // Convert to CSV
        const headers = Object.keys(csvData[0]);
        const csvRows = [
            headers.join(','),
            ...csvData.map(row => 
                headers.map(header => {
                    const value = row[header] || '';
                    return `"${String(value).replace(/"/g, '""')}"`;
                }).join(',')
            )
        ];

        const csvContent = csvRows.join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        
        link.setAttribute('href', url);
        link.setAttribute('download', `performance-report-${formatDhakaDateForInput(getDhakaNow())}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } catch (error) {
        console.error('Error exporting CSV:', error);
        alert('Error exporting data. Please try again.');
    }
}

// ============================================================================
// Refresh Data
// ============================================================================
function refreshData() {
    const tbody = document.getElementById('performanceTableBody');
    tbody.innerHTML = '<tr><td colspan="8" class="loading">Refreshing data...</td></tr>';
    clearCache(); // Clear cache to force fresh data load
    loadAllData(true); // Force refresh
}

// ============================================================================
// Week Filter Functions
// ============================================================================
let currentWeek = null; // Current week number (1-52)
let currentWeekYear = null; // Year for the current week
let useWeekFilter = false; // Default to month view instead of week view

function getWeekNumber(date = null) {
    if (!date) date = getDhakaNow();
    return getDhakaWeekNumber(date);
}

function getWeekDates(weekNumber, year) {
    return getDhakaWeekDates(weekNumber, year);
}

function initializeWeekFilter() {
    const today = getDhakaNow();
    currentWeek = getDhakaWeekNumber(today);
    currentWeekYear = today.getFullYear();
    updateWeekDisplay();
}

function initializeMonthFilter() {
    const today = getDhakaNow();
    const firstDay = getDhakaFirstDayOfMonth(today);
    const lastDay = getDhakaLastDayOfMonth(today);
    const firstDayStr = formatDhakaDateForInput(firstDay);
    const lastDayStr = formatDhakaDateForInput(lastDay);
    
    // Set date filter to current month
    dateFilter.start = firstDayStr;
    dateFilter.end = lastDayStr;
    useWeekFilter = false;
    
    // Update date input fields
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const dateBtnTextEl = document.getElementById('dateBtnText');
    
    if (startDateEl) startDateEl.value = firstDayStr;
    if (endDateEl) endDateEl.value = lastDayStr;
    
    // Update date button text to show current month
    if (dateBtnTextEl) {
        const start = formatDhakaDate(firstDay, { month: 'short', day: 'numeric' });
        const end = formatDhakaDate(lastDay, { month: 'short', day: 'numeric' });
        dateBtnTextEl.textContent = `${start} - ${end}`;
    }
    
    // Activate "This Month" button
    const quickDateButtons = document.querySelectorAll('.quick-date-btn');
    quickDateButtons.forEach(btn => btn.classList.remove('active'));
    const thisMonthBtn = document.getElementById('thisMonthBtn');
    if (thisMonthBtn) {
        thisMonthBtn.classList.add('active');
    }
    
    // Update week display to show it's disabled
    updateWeekDisplay();
}

function updateWeekDisplay() {
    const weekTextEl = document.getElementById('weekText');
    const prevWeekBtn = document.getElementById('prevWeekBtn');
    const nextWeekBtn = document.getElementById('nextWeekBtn');
    const weekDisplay = document.getElementById('weekDisplay');
    
    // Initialize current week if not set
    if (currentWeek === null) {
        const today = new Date();
        currentWeek = getWeekNumber(today);
        currentWeekYear = today.getFullYear();
    }
    
    if (weekTextEl) {
        if (useWeekFilter && currentWeek !== null) {
            weekTextEl.textContent = `Week ${currentWeek}`;
        } else {
            weekTextEl.textContent = `Week ${currentWeek || '-'}`;
        }
    }
    
    // Always enable week navigation buttons - they can switch to week view when clicked
    if (prevWeekBtn) {
        prevWeekBtn.disabled = false;
        prevWeekBtn.style.opacity = '1';
        prevWeekBtn.style.cursor = 'pointer';
    }
    
    if (nextWeekBtn) {
        nextWeekBtn.disabled = false;
        nextWeekBtn.style.opacity = '1';
        nextWeekBtn.style.cursor = 'pointer';
    }
    
    // Update week display styling
    if (weekDisplay) {
        if (useWeekFilter) {
            weekDisplay.style.backgroundColor = 'var(--primary-color)';
            weekDisplay.style.color = 'var(--white)';
            weekDisplay.style.borderColor = 'var(--primary-color)';
            weekDisplay.style.cursor = 'default';
        } else {
            weekDisplay.style.backgroundColor = '#f3f4f6';
            weekDisplay.style.color = '#6b7280';
            weekDisplay.style.borderColor = '#e5e7eb';
            weekDisplay.style.cursor = 'pointer';
        }
    }
}

function navigateWeek(direction) {
    // Initialize current week if not set
    if (currentWeek === null) {
        const today = new Date();
        currentWeek = getWeekNumber(today);
        currentWeekYear = today.getFullYear();
    }
    
    currentWeek += direction;
    
    // Handle week overflow/underflow
    if (currentWeek > 52) {
        currentWeek = 1;
        currentWeekYear += 1;
    } else if (currentWeek < 1) {
        currentWeek = 52;
        currentWeekYear -= 1;
    }
    
    // Switch to week view when navigating
    useWeekFilter = true;
    dateFilter.start = null;
    dateFilter.end = null;
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const dateBtnTextEl = document.getElementById('dateBtnText');
    if (startDateEl) startDateEl.value = '';
    if (endDateEl) endDateEl.value = '';
    if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
    
    // Clear active state of quick filter buttons when switching to week view
    const quickDateButtons = document.querySelectorAll('.quick-date-btn');
    quickDateButtons.forEach(btn => btn.classList.remove('active'));
    
    updateWeekDisplay();
    applyAllFilters();
}

// Function to switch to week view when week display is clicked
function switchToWeekView() {
    // Initialize current week if not set
    if (currentWeek === null) {
        const today = new Date();
        currentWeek = getWeekNumber(today);
        currentWeekYear = today.getFullYear();
    }
    
    useWeekFilter = true;
    dateFilter.start = null;
    dateFilter.end = null;
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const dateBtnTextEl = document.getElementById('dateBtnText');
    if (startDateEl) startDateEl.value = '';
    if (endDateEl) endDateEl.value = '';
    if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
    
    // Clear active state of quick filter buttons when switching to week view
    const quickDateButtons = document.querySelectorAll('.quick-date-btn');
    quickDateButtons.forEach(btn => btn.classList.remove('active'));
    
    updateWeekDisplay();
    applyAllFilters();
}

// ============================================================================
// Error Categories Analysis
// ============================================================================
function updateErrorCategories() {
    // Get filtered audits by submission date
    const relevantAudits = getFilteredAuditsBySubmissionDate();
    
    // Analyze errors by category
    const categoryCounts = {
        'Critical Fail Error': 0,
        'Critical Error': 0,
        'Significant Error': 0,
        'Major Error': 0,
        'Minor Error': 0
    };
    
    const errorNameCounts = {}; // Track individual error names
    
    relevantAudits.forEach(audit => {
        if (!audit.scorecard_id) return;
        
        const parameters = allScorecardParameters[audit.scorecard_id];
        if (!parameters) return;
        
        Object.keys(parameters).forEach(fieldId => {
            const paramInfo = parameters[fieldId];
            const value = audit[fieldId];
            let errorCount = 0;
            
            if (value !== null && value !== undefined && value !== '') {
                const paramType = paramInfo.parameter_type || 'error';
                const fieldType = paramInfo.field_type || 'counter';
                
                // Only count error parameters, not achievements or bonuses
                if (paramType !== 'error') return;
                
                if (fieldType === 'radio') {
                    let numValue = 0;
                    if (typeof value === 'boolean') {
                        numValue = value ? 1 : 0;
                    } else if (typeof value === 'number') {
                        numValue = value;
                    } else if (typeof value === 'string') {
                        const parsed = parseInt(value);
                        if (!isNaN(parsed)) {
                            numValue = parsed;
                        } else if (value === 'true' || value === '1') {
                            numValue = 1;
                        }
                    }
                    errorCount = numValue;
                } else {
                    if (typeof value === 'boolean') {
                        errorCount = value ? 1 : 0;
                    } else if (typeof value === 'number') {
                        errorCount = value;
                    } else if (typeof value === 'string') {
                        const numValue = parseInt(value);
                        if (!isNaN(numValue)) {
                            errorCount = numValue;
                        } else if (value === 'true' || value === '1') {
                            errorCount = 1;
                        }
                    }
                }
            }
            
            if (errorCount > 0) {
                const category = paramInfo.error_category || 'Significant Error';
                const errorName = paramInfo.name;
                
                // Count by category
                if (categoryCounts.hasOwnProperty(category)) {
                    categoryCounts[category] += errorCount;
                } else {
                    categoryCounts[category] = errorCount;
                }
                
                // Count by error name
                if (!errorNameCounts[errorName]) {
                    errorNameCounts[errorName] = {
                        count: 0,
                        category: category
                    };
                }
                errorNameCounts[errorName].count += errorCount;
            }
        });
    });
    
    // Update error type summary
    updateErrorTypeSummary(categoryCounts);
    
    // Update error frequency chart
    updateErrorFrequencyChart(categoryCounts);
    
    // Update top error categories list
    updateTopErrorCategoriesList(errorNameCounts);
}

function updateErrorTypeSummary(categoryCounts) {
    const summaryDiv = document.getElementById('errorTypeSummary');
    
    const totalErrors = Object.values(categoryCounts).reduce((sum, count) => sum + count, 0);
    
    if (totalErrors === 0) {
        summaryDiv.innerHTML = '<div style="color: var(--text-muted); font-size: 0.5625rem; padding: 0.25rem 0;">No errors found</div>';
        return;
    }
    
    const categories = [
        { name: 'Critical Fail', key: 'Critical Fail Error', color: '#dc2626' },
        { name: 'Critical', key: 'Critical Error', color: '#ea580c' },
        { name: 'Significant', key: 'Significant Error', color: '#f59e0b' },
        { name: 'Major', key: 'Major Error', color: '#eab308' },
        { name: 'Minor', key: 'Minor Error', color: '#84cc16' }
    ];
    
    summaryDiv.innerHTML = categories.map(cat => {
        const count = categoryCounts[cat.key] || 0;
        const percentage = totalErrors > 0 ? Math.round((count / totalErrors) * 100) : 0;
        
        return `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.1875rem 0;">
                <div style="display: flex; align-items: center; gap: 0.375rem;">
                    <div style="width: 0.375rem; height: 0.375rem; border-radius: 50%; background-color: ${cat.color}; flex-shrink: 0;"></div>
                    <span style="font-size: 0.5625rem; color: var(--text-color); font-weight: 500;">${cat.name}</span>
                </div>
                <div style="display: flex; align-items: center; gap: 0.375rem;">
                    <span style="font-size: 0.5625rem; font-weight: 600; color: var(--text-color);">${count}</span>
                    <span style="font-size: 0.5156rem; color: var(--text-muted);">${percentage}%</span>
                </div>
            </div>
        `;
    }).join('');
}

function updateErrorFrequencyChart(categoryCounts) {
    const ctx = document.getElementById('errorFrequencyChart');
    
    if (charts.errorFrequency) {
        charts.errorFrequency.destroy();
    }
    
    const categories = ['Critical Fail Error', 'Critical Error', 'Significant Error', 'Major Error', 'Minor Error'];
    const labels = ['Critical Fail', 'Critical', 'Significant', 'Major', 'Minor'];
    const data = categories.map(cat => categoryCounts[cat] || 0);
    const colors = ['#dc2626', '#ea580c', '#f59e0b', '#eab308', '#84cc16'];
    
    const totalErrors = data.reduce((sum, val) => sum + val, 0);
    
    if (totalErrors === 0) {
        return;
    }
    
    charts.errorFrequency = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: data,
                backgroundColor: colors,
                borderWidth: 0
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const label = context.label || '';
                            const value = context.parsed || 0;
                            const percentage = totalErrors > 0 ? Math.round((value / totalErrors) * 100) : 0;
                            return `${label}: ${value} (${percentage}%)`;
                        }
                    }
                },
                datalabels: {
                    display: function(context) {
                        // Only show label if the segment is large enough (at least 5% of total)
                        const value = context.parsed || 0;
                        const percentage = totalErrors > 0 ? (value / totalErrors) * 100 : 0;
                        return percentage >= 5;
                    },
                    color: '#ffffff',
                    font: {
                        size: 10,
                        weight: 600,
                        family: 'Poppins, sans-serif'
                    },
                    formatter: function(value, context) {
                        const percentage = totalErrors > 0 ? Math.round((value / totalErrors) * 100) : 0;
                        return percentage > 0 ? `${percentage}%` : '';
                    },
                    textStrokeColor: 'rgba(0, 0, 0, 0.3)',
                    textStrokeWidth: 1
                }
            }
        }
    });
}

function updateTopErrorCategoriesList(errorNameCounts) {
    const listDiv = document.getElementById('topErrorCategoriesList');
    
    // Sort errors by count and get top 10
    const sortedErrors = Object.entries(errorNameCounts)
        .map(([name, data]) => ({
            name,
            count: data.count,
            category: data.category
        }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 10);
    
    if (sortedErrors.length === 0) {
        listDiv.innerHTML = '<div style="color: var(--text-muted); font-size: 0.6562rem; padding: 0.75rem;">No errors found</div>';
        return;
    }
    
    const getCategoryColor = (category) => {
        if (category && category.includes('Fail')) return '#dc2626';
        if (category && category.includes('Critical')) return '#ea580c';
        if (category && category.includes('Significant')) return '#f59e0b';
        if (category && category.includes('Major')) return '#eab308';
        if (category && category.includes('Minor')) return '#84cc16';
        return '#6b7280';
    };
    
    const getCategoryLabel = (category) => {
        if (category && category.includes('Fail')) return 'Critical Fail';
        if (category && category.includes('Critical')) return 'Critical';
        if (category && category.includes('Significant')) return 'Significant';
        if (category && category.includes('Major')) return 'Major';
        if (category && category.includes('Minor')) return 'Minor';
        return 'Other';
    };
    
    // Create compact table view
    listDiv.innerHTML = `
        <div style="border-radius: 0.375rem; overflow: hidden; border: 0.0469rem solid var(--border-light);">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.6562rem;">
                <thead>
                    <tr style="border-bottom: 0.0469rem solid var(--border-light); background-color: var(--gray-50);">
                        <th style="text-align: left; padding: 0.5rem 0.375rem; font-weight: 600; color: var(--text-secondary); font-size: 0.5625rem; text-transform: uppercase; letter-spacing: 0.05em; width: 1.25rem;">#</th>
                        <th style="text-align: left; padding: 0.5rem 0.75rem; font-weight: 600; color: var(--text-secondary); font-size: 0.5625rem; text-transform: uppercase; letter-spacing: 0.05em; min-width: 8rem;">Error Type</th>
                        <th style="text-align: center; padding: 0.5rem 0.75rem; font-weight: 600; color: var(--text-secondary); font-size: 0.5625rem; text-transform: uppercase; letter-spacing: 0.05em; width: 7rem;">Category</th>
                        <th style="text-align: right; padding: 0.5rem 0.75rem; font-weight: 600; color: var(--text-secondary); font-size: 0.5625rem; text-transform: uppercase; letter-spacing: 0.05em; width: 4rem;">Count</th>
                    </tr>
                </thead>
                <tbody>
                    ${sortedErrors.map((error, index) => {
                        const categoryColor = getCategoryColor(error.category);
                        const categoryLabel = getCategoryLabel(error.category);
                        const isLastRow = index === sortedErrors.length - 1;
                        
                        return `
                            <tr style="border-bottom: ${isLastRow ? 'none' : '0.0469rem solid var(--border-light)'}; transition: background-color 0.2s ease;" onmouseover="this.style.backgroundColor='var(--gray-50)'" onmouseout="this.style.backgroundColor='transparent'">
                                <td style="padding: 0.5rem 0.375rem; color: var(--text-muted); font-weight: 600; font-size: 0.5625rem;">${index + 1}</td>
                                <td style="padding: 0.5rem 0.75rem; color: var(--text-color); font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(error.name)}">${escapeHtml(error.name)}</td>
                                <td style="padding: 0.5rem 0.75rem; text-align: center;">
                                    <span style="display: inline-flex; align-items: center; gap: 0.375rem; padding: 0.1875rem 0.5rem; border-radius: 0.1875rem; font-size: 0.5625rem; font-weight: 500; background-color: ${categoryColor}15; color: ${categoryColor}; white-space: nowrap;">
                                        <div style="width: 0.375rem; height: 0.375rem; border-radius: 50%; background-color: ${categoryColor}; flex-shrink: 0;"></div>
                                        ${categoryLabel}
                                    </span>
                                </td>
                                <td style="padding: 0.5rem 0.75rem; text-align: right; color: var(--text-color); font-weight: 600;">${error.count}</td>
                            </tr>
                        `;
                    }).join('')}
                </tbody>
            </table>
        </div>
    `;
}

// ============================================================================
// Utility Functions
// ============================================================================
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
</script>
</body>
</html>