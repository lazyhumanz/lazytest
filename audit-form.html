<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Audit Form | QMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <style>
        .copy-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.25rem;
            background: transparent;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            color: #6b7280;
            transition: all 0.2s;
        }
        .copy-button:hover {
            background-color: #f3f4f6;
            color: #374151;
        }
        .copy-button:active {
            transform: scale(0.95);
        }
        .copy-button svg {
            width: 0.875rem;
            height: 0.875rem;
        }
        .copy-success {
            color: #10b981 !important;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-1.25rem) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes modalSlideOut {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-1.25rem) scale(0.95);
            }
        }
        
        /* Shimmer effect for loading states */
        .shimmer-text {
            position: relative;
            overflow: hidden;
        }

        .shimmer-text::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.4),
                transparent
            );
            animation: shimmer 2s infinite;
        }

        .shimmer-overlay {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        /* Smart Loader Styles */
        #auditSubmitLoader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #auditSubmitLoader.show {
            display: flex;
            opacity: 1;
        }

        .loader-content {
            background: white;
            border-radius: 0.6469rem;
            padding: 2.425rem 3.234rem;
            box-shadow: 0 0.8086rem 2.425rem rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 20rem;
            animation: modalSlideIn 0.3s ease;
        }

        .loader-spinner {
            width: 3.234rem;
            height: 3.234rem;
            border: 0.2425rem solid #e5e7eb;
            border-top-color: #1A733E;
            border-radius: 50%;
            animation: loaderSpin 0.8s linear infinite;
            margin: 0 auto 1.2937rem;
        }

        @keyframes loaderSpin {
            to {
                transform: rotate(360deg);
            }
        }

        .loader-text {
            font-family: 'Poppins', sans-serif;
            font-size: 0.6469rem;
            font-weight: 600;
            color: #374151;
            margin: 0;
        }

        .loader-subtext {
            font-family: 'Poppins', sans-serif;
            font-size: 0.4852rem;
            color: #6b7280;
            margin: 0.3234rem 0 0 0;
        }

        /* Parts tooltip hover effect */
        .parts-tooltip-container:hover .parts-info-icon {
            background: #9ca3af !important;
        }

        /* Ensure tooltip positioning works correctly */
        .parts-tooltip-container,
        .column-tooltip-container {
            overflow: visible !important;
        }

        /* Column tooltip hover effect */
        .column-tooltip-container:hover .info-icon {
            background: #9ca3af !important;
        }

        /* Override main-content padding and width for full-width form */
        .main-content {
            padding: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
        }

        /* Message Content Styling - Professional HTML formatting */
        .message-text-content {
            font-size: 0.5257rem;
            line-height: 1.6;
            word-wrap: break-word;
        }
        
        /* Paragraphs - proper spacing */
        .message-text-content p {
            margin: 0 0 0.4043rem 0;
            padding: 0;
            line-height: 1.6;
        }
        
        .message-text-content p:last-child {
            margin-bottom: 0;
        }
        
        /* Links - clickable and styled */
        .message-text-content a {
            color: #2563eb;
            text-decoration: underline;
            word-break: break-word;
            transition: opacity 0.2s ease;
            cursor: pointer;
        }
        
        .message-text-content a:hover {
            opacity: 0.8;
        }
        
        .message-text-content a:visited {
            color: #7c3aed;
        }
        
        /* Email links */
        .message-text-content a[href^="mailto:"] {
            color: #2563eb;
        }
        
        /* Agent message links (on green background) - lighter blue */
        .message-text-content.agent-message a {
            color: #93c5fd;
        }
        
        .message-text-content.agent-message a:hover {
            opacity: 0.9;
        }
        
        .message-text-content.agent-message a:visited {
            color: #a5b4fc;
        }
        
        /* Text formatting */
        .message-text-content strong,
        .message-text-content b {
            font-weight: 600;
        }
        
        .message-text-content em,
        .message-text-content i {
            font-style: italic;
        }
        
        .message-text-content u {
            text-decoration: underline;
        }
        
        /* Lists */
        .message-text-content ul,
        .message-text-content ol {
            margin: 0.3234rem 0;
            padding-left: 1.2937rem;
            line-height: 1.6;
        }
        
        .message-text-content li {
            margin: 0.1617rem 0;
            line-height: 1.6;
        }
        
        /* Code blocks */
        .message-text-content code {
            background: #f3f4f6;
            color: #374151;
            padding: 0.0808rem 0.2425rem;
            border-radius: 0.1213rem;
            font-family: 'Courier New', 'Monaco', 'Consolas', monospace;
            font-size: 0.4852rem;
            line-height: 1.4;
            display: inline-block;
        }
        
        .message-text-content pre {
            background: #f3f4f6;
            color: #374151;
            padding: 0.4043rem;
            border-radius: 0.2425rem;
            overflow-x: auto;
            margin: 0.3234rem 0;
        }
        
        .message-text-content pre code {
            background: transparent;
            padding: 0;
        }
        
        /* Agent message code blocks */
        .message-text-content.agent-message code {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .message-text-content.agent-message pre {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }
        
        /* Blockquotes */
        .message-text-content blockquote {
            border-left: 0.1617rem solid #d1d5db;
            padding-left: 0.4852rem;
            margin: 0.3234rem 0;
            font-style: italic;
            color: #6b7280;
        }
        
        .message-text-content.agent-message blockquote {
            border-left-color: rgba(255, 255, 255, 0.3);
            color: rgba(255, 255, 255, 0.9);
        }
        
        /* Headings */
        .message-text-content h1,
        .message-text-content h2,
        .message-text-content h3,
        .message-text-content h4,
        .message-text-content h5,
        .message-text-content h6 {
            margin: 0.4043rem 0;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .message-text-content h1 { font-size: 1.2em; }
        .message-text-content h2 { font-size: 1.1em; }
        .message-text-content h3 { font-size: 1.05em; }
        
        /* Line breaks */
        .message-text-content br {
            display: block;
            margin: 0.1617rem 0;
            content: "";
        }

        /* Fix dropdown option colors - ensure options are visible */
        #employeeName option,
        #countryOfEmployee option {
            background-color: #ffffff !important;
            color: #374151 !important;
        }

    </style>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="access-control.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="load-sidebar.js"></script>
    <script src="search.js"></script>
    <script src="form-validation.js"></script>
    <script src="intercom-config.js"></script>
    <script src="audit-template.js"></script>
    <script src="keyboard-shortcuts.js"></script>
</head>
<body style="margin: 0; padding: 0;">
<!-- Audit Timer Chip -->
<div id="auditTimer" style="position: fixed; top: 0.6469rem; right: 3.2344rem; background:var(--primary-color); padding: 0.1294rem 0.3234rem 0.1294rem 0.1294rem; border-radius: 2.0215rem; font-size: 0.6064rem; font-weight: 600; color: #ffffff; font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; letter-spacing: 0.0122rem; flex-shrink: 0; white-space: nowrap; font-variant-numeric: tabular-nums; min-width: 4.8516rem; display: none; align-items: center; gap: 0.3234rem; cursor: grab; user-select: none; z-index: 10001;">
    <button id="timerControlBtn" title="Play/Pause/Reset Timer" style="width: 1.1321rem; height: 1.1321rem; background: rgba(255, 255, 255, 0.2); border: none; border-radius: 50%; color: #ffffff; cursor: pointer; display: flex; align-items: center; justify-content: center; user-select: none; flex-shrink: 0; margin: 0; padding: 0;">
        <svg style="width: 0.5659rem; height: 0.5659rem;" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z"/>
        </svg>
    </button>
    <span style="flex: 1; text-align: center; font-size: 0.6064rem; font-weight: 600; font-variant-numeric: tabular-nums;">Time Keeper</span>
</div>
<!-- End of Audit Timer Chip -->
<main class="main-content" role="main">
<div class="full-width-container" style="width: 100%; padding: 0; margin: 0;">
    <form id="auditForm" method="POST" style="background: white; width: 100%; height: 100vh; display: flex; flex-direction: column; gap: 0; padding: 0; margin: 0; overflow-y: auto;">
    <!-- Hidden audit information fields - populated behind the scenes -->
    <input type="hidden" id="auditDuration" name="auditDuration">
    <input type="hidden" id="auditorEmail" name="auditorEmail">
    <input type="hidden" id="auditorName" name="auditorName">
    <input type="hidden" id="quarter" name="quarter">
    <input type="hidden" id="week" name="week">
    <input type="hidden" id="errorDescription" name="errorDescription">

    <!-- Beautiful Header Section (Report-Style) -->
    <div id="auditFormHeader" style="background: linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%); padding: 0.6469rem 0.9704rem; color: white; box-shadow: 0 0.1213rem 0.1819rem rgba(0,0,0,0.1); margin-bottom: 0.5rem; flex-shrink: 0; transition: background 0.3s ease;">
        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.4852rem;">
            <div style="flex: 1;">
                <h2 style="font-size: 0.7278rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif;">Create New Audit</h2>
            </div>
            <div style="display: flex; align-items: center; gap: 0.3234rem;">
                <button type="button" onclick="closeAuditForm()" style="background: rgba(255,255,255,0.2); border: 0.0606rem solid white; border-radius: 0.2425rem; width: 1.2937rem; height: 1.2937rem; font-size: 0.8086rem; cursor: pointer; color: white; font-weight: bold; transition: all 0.2s; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">✕</button>
            </div>
        </div>
        <div>
            
            <!-- Employee Information in Header -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(6.0644rem, 1fr)); gap: 0.3234rem; margin-bottom: 0.4852rem;">
                <div>
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Employee *</p>
                    <select id="employeeName" name="employeeName" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; background-color: transparent; color: white; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; width: 100%; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23ffffff\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem;">
                        <option value="" style="background-color: #ffffff; color: #374151;">Select Employee...</option>
                    </select>
                </div>
                <div>
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Email *</p>
                    <input type="email" id="employeeEmail" name="employeeEmail" required readonly style="padding: 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; background-color: transparent; color: white; width: 100%; word-break: break-all;">
                </div>
                <div>
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Type</p>
                    <input type="text" id="employeeType" name="employeeType" readonly style="padding: 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; background-color: transparent; color: white; width: 100%;">
                </div>
                <div>
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Department</p>
                    <input type="text" id="employeeDepartment" name="employeeDepartment" readonly style="padding: 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; background-color: transparent; color: white; width: 100%;">
                </div>
                <div>
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Country *</p>
                    <select id="countryOfEmployee" name="countryOfEmployee" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; background-color: transparent; color: white; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; width: 100%; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23ffffff\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem;">
                        <option value="" style="background-color: #ffffff; color: #374151;">Select Country</option>
                        <option value="Bangladesh" selected style="background-color: #ffffff; color: #374151;">Bangladesh</option>
                        <option value="Sri Lanka" style="background-color: #ffffff; color: #374151;">Sri Lanka</option>
                    </select>
                </div>
                <div id="intercomAliasContainer" style="display: none;">
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Intercom Alias</p>
                    <input type="text" id="intercomAlias" name="intercomAlias" readonly style="padding: 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; background-color: rgba(255,255,255,0.1); color: rgba(255,255,255,0.9); width: 100%;" placeholder="Intercom alias...">
                </div>
            </div>
        </div>
        
        <!-- Audit Metadata Cards -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(4.2451rem, 1fr)); gap: 0.3234rem;">
        </div>
    </div>

    <!-- Scorecard Info (moved to Error Details section, keeping scorecardInfo div here for backward compatibility) -->
    <div id="scorecardInfo" style="display: none; position: absolute; visibility: hidden;">
        <div style="display: flex; align-items: center; gap: 0.4852rem; font-size: 0.4447rem; color: #6b7280;">
            <span><strong id="scorecardScoringType" style="color: #1A733E;">--</strong></span>
            <span style="color: #d1d5db;">â€¢</span>
            <span><strong id="scorecardParamsCount" style="color: #1A733E;">--</strong> params</span>
        </div>
    </div>

    <!-- Two Column Layout (matching expert-audits.html) -->
    <div id="auditContent" style="display: flex; padding: 0.5rem 0 0.9704rem 0; max-width: 100%; gap: 0; flex-wrap: nowrap; overflow-x: visible; align-items: stretch; flex: 1; min-height: 0;">
        
        <!-- LEFT COLUMN: Interaction Details + Transcript -->
        <div id="leftColumn" style="display: flex; flex-direction: column; gap: 0.3234rem; flex: 0 0 33%; min-width: 13.6451rem; max-width: 75%; padding-left: 0.9704rem; padding-right: 0.6469rem; overflow-x: visible; overflow-y: visible; box-sizing: border-box;">
            <!-- Transcript -->
            <div style="display: flex; flex-direction: column; gap: 0.3234rem; flex: 1; min-height: 0;">
                <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0; border: 0.0304rem solid #e5e7eb; display: flex; flex-direction: column; flex: 1; min-height: 75vh; max-height: 100vh; transition: height 0.3s ease; overflow: hidden;">
                    <div style="background: #f9fafb; padding: 0.6469rem; border-bottom: 0.0304rem solid #e5e7eb; flex-shrink: 0; display: flex; flex-direction: column; gap: 0.4852rem;">
                        <!-- First Row: Transcript Title and Form Fields -->
                        <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap; justify-content: space-between;">
                            <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                                <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 9h12v2H6V9zm8 5H6v-2h8v2zm4-6H6V6h12v2z"/></svg>
                                    Transcript
                                </h3>
                                <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                    <span style="font-size: 0.4447rem; color: #6b7280; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0092rem; white-space: nowrap;">ID:</span>
                                    <input type="text" id="interactionId" name="interactionId" required placeholder="Enter..." style="padding: 0.1617rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600; min-width: 2.4258rem;">
                                    <button type="button" onclick="copyConversationId(); return false;" style="padding: 0.0808rem; background: transparent; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #6b7280; transition: all 0.2s;" title="Copy ID" onmouseover="this.style.color='#1A733E';" onmouseout="this.style.color='#6b7280';">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                        </svg>
                                    </button>
                                    <button type="button" id="viewChatBtn" disabled style="padding: 0.1617rem 0.3234rem; background-color: #9ca3af; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4447rem; font-family: 'Poppins', sans-serif; cursor: not-allowed; white-space: nowrap; transition: all 0.2s ease; font-weight: 500; opacity: 0.6;" title="Open in Intercom (load conversation first)">Open</button>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                                <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                    <span style="font-size: 0.4447rem; color: #6b7280; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0092rem; white-space: nowrap;">Date:</span>
                                    <input type="date" id="interactionDate" name="interactionDate" required style="padding: 0.1617rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600;">
                                </div>
                                <div style="width: 0.0304rem; height: 0.6469rem; background: #d1d5db;"></div>
                                <div style="display: flex; align-items: center; gap: 0.1617rem; min-width: 0;">
                                    <span style="font-size: 0.4447rem; color: #6b7280; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0092rem; white-space: nowrap; flex-shrink: 0;">Name:</span>
                                    <input type="text" id="clientName" name="clientName" readonly placeholder="Client name..." style="padding: 0.1617rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600; min-width: 3.6387rem; box-sizing: border-box; background-color: #f9fafb;">
                                </div>
                                <div style="width: 0.0304rem; height: 0.6469rem; background: #d1d5db;"></div>
                                <div style="display: flex; align-items: center; gap: 0.1617rem; min-width: 0;">
                                    <span style="font-size: 0.4447rem; color: #6b7280; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0092rem; white-space: nowrap; flex-shrink: 0;">Email:</span>
                                    <input type="email" id="clientEmail" name="clientEmail" placeholder="client@..." style="padding: 0.1617rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600; min-width: 3.6387rem; box-sizing: border-box;">
                                    <button type="button" onclick="copyClientEmail(); return false;" style="padding: 0.0808rem; background: transparent; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #6b7280; transition: all 0.2s;" title="Copy Email" onmouseover="this.style.color='#1A733E';" onmouseout="this.style.color='#6b7280';">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Second Row: Quick Actions (Compact) -->
                        <div id="clientNameSection" style="display: none; align-items: center; justify-content: flex-end; gap: 0.3234rem; padding-top: 0.3234rem; border-top: 0.0304rem solid #e5e7eb;">
                            <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                <button type="button" id="translateChatBtn" onclick="translateChatMessages(); return false;" disabled style="padding: 0.2425rem 0.4043rem; background: #f3f4f6; border: 0.0304rem solid #d1d5db; border-radius: 0.2425rem; font-size: 0.4043rem; font-family: 'Poppins', sans-serif; font-weight: 500; color: #9ca3af; cursor: not-allowed; transition: all 0.2s; display: flex; align-items: center; gap: 0.1617rem; white-space: nowrap; opacity: 0.6;" title="Translation feature is currently disabled">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem;">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"></path>
                                    </svg>
                                    <span>Translate</span>
                                </button>
                            </div>
                        </div>
                        <!-- Third Row: Collapsible Information Grid -->
                        <div id="conversationInfoGrid" style="display: none; padding-top: 0.3234rem; border-top: 0.0304rem solid #e5e7eb; margin-top: 0.3234rem;">
                            <button id="toggleInfoGridBtn" type="button" onclick="toggleConversationInfoGrid()" style="width: 100%; padding: 0.3234rem 0.4852rem; background: #f9fafb; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; font-family: 'Poppins', sans-serif; font-size: 0.4447rem; font-weight: 600; color: #1A733E; cursor: pointer; display: flex; align-items: center; justify-content: space-between; transition: all 0.2s; margin-bottom: 0.3234rem;" onmouseover="this.style.background='#f3f4f6'; this.style.borderColor='#1A733E';" onmouseout="this.style.background='#f9fafb'; this.style.borderColor='#e5e7eb';">
                                <span style="display: flex; align-items: center; gap: 0.2425rem;">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem;">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                    </svg>
                                    <span>Conversation Details</span>
                                </span>
                                <svg id="toggleInfoGridIcon" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem; transition: transform 0.2s; transform: rotate(0deg);">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </button>
                            <div id="conversationInfoGridContent" style="display: none; grid-template-columns: repeat(auto-fit, minmax(8rem, 1fr)); gap: 0.3234rem; font-family: 'Poppins', sans-serif;">
                                <!-- Information cards will be populated here -->
                            </div>
                        </div>
                    </div>
                    <!-- Chat Interface View -->
                    <div id="transcriptChatView" style="display: flex; padding: 0.4852rem; background: #f0f2f5; overflow-y: auto; overflow-x: hidden; flex: 1; flex-direction: column; scrollbar-width: thin; scrollbar-color: #9ca3af #f0f2f5; position: relative; min-height: 0;">
                        <!-- Chat messages will be dynamically inserted here -->
                        <div id="chatMessagesContainer" style="display: flex; flex-direction: column; min-height: 0; width: 100%; gap: 0.3234rem; padding: 0.2426rem 0;">
                            <div style="text-align: center; padding: 1.2937rem; color: #9ca3af; font-size: 0.5659rem;">
                                <p>Enter an Interaction ID to automatically load conversation from Intercom</p>
                            </div>
                        </div>
                    </div>
                    <!-- Text Area View (Fallback) -->
                    <div id="transcriptTextView" style="display: none; padding: 0.6469rem; background: white; overflow-y: auto; flex: 1; position: relative;">
                        <textarea id="transcript" name="transcript" placeholder="Paste the interaction transcript here..." style="width: 100%; height: 100%; padding: 0; border: none; font-size: 0.5257rem; line-height: 1.6; color: #374151; font-family: 'Poppins', sans-serif; background-color: transparent; resize: none; box-sizing: border-box; outline: none; transition: padding-top 0.3s ease;"></textarea>
                    </div>
                </div>
                <!-- Conversation Attributes Panel (Always visible by default) - Below transcript container -->
                <div id="conversationAttributesPanel" style="background: white; border-radius: 0.3234rem; padding: 0; border: 0.0304rem solid #e5e7eb; display: none; box-shadow: 0 0.0606rem 0.1213rem rgba(0,0,0,0.05); overflow-y: auto;">
                    <div id="conversationAttributesContent" style="padding: 0.3234rem; display: block;">
                        <div id="conversationAttributesGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(6.0644rem, 1fr)); gap: 0.3234rem;">
                            <!-- Attributes will be dynamically populated here -->
                        </div>
                    </div>
                </div>
                <!-- Conversation Attributes Panel for text view (Always visible by default) - Below transcript container -->
                <div id="conversationAttributesPanelTextView" style="background: white; border-radius: 0.3234rem; padding: 0.3234rem; border: 0.0304rem solid #e5e7eb; display: none; box-shadow: 0 0.0606rem 0.1213rem rgba(0,0,0,0.05); overflow-y: auto;">
                    <div id="conversationAttributesGridTextView" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(6.0644rem, 1fr)); gap: 0.3234rem;">
                        <!-- Attributes will be dynamically populated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- RESIZABLE SPLITTER -->
        <div id="splitter" style="width: 0.2425rem; background: #e5e7eb; cursor: col-resize; position: relative; flex-shrink: 0; transition: background 0.2s; z-index: 1;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 0.1213rem; height: 1.2128rem; background: #9ca3af; border-radius: 0.0606rem;"></div>
        </div>
        
        <!-- RIGHT COLUMN: Error Details & Recommendations -->
        <div id="rightColumn" style="flex: 1; min-width: 9.0967rem; padding-left: 0.3234rem; padding-right: 0.9704rem; display: flex; flex-direction: column; min-height: 0; overflow-y: auto;">
            
            
            <!-- Error Details (Report-Style Table) -->
            <div id="errorParametersSection" style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4852rem; flex-wrap: wrap; gap: 0.4852rem;">
                    <div style="display: flex; align-items: center; gap: 0.4852rem; flex-wrap: wrap;">
                        <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                            <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
                            Error Details
                        </h3>
                        <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 0.3234rem;">
                                <label for="scorecardSelect" style="font-size: 0.4852rem; font-weight: 500; color: #6b7280; font-family: 'Poppins', sans-serif; white-space: nowrap;">Scorecard:</label>
                                <select id="scorecardSelect" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; min-width: 4.5482rem; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem;">
                                    <option value="">Loading scorecards...</option>
                                </select>
                            </div>
                            <div style="width: 0.0304rem; height: 0.6469rem; background: #d1d5db;"></div>
                            <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                <span style="font-size: 0.4852rem; font-weight: 500; color: #6b7280; font-family: 'Poppins', sans-serif; white-space: nowrap;">Channel:</span>
                                <select id="channel" name="channel" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; min-width: 3.6387rem; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem;">
                                    <option value="">Select...</option>
                                </select>
                            </div>
                        </div>
                        <div style="width: 0.0304rem; height: 0.6469rem; background: #d1d5db;"></div>
                        <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                <label style="font-size: 0.4852rem; font-weight: 500; color: #6b7280; font-family: 'Poppins', sans-serif; white-space: nowrap;">Audit Type:</label>
                                <select id="auditType" name="auditType" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem; min-width: 8rem;">
                                    <option value="">Select</option>
                                    <option value="Routine Audit (Recorded)" selected>Routine (Recorded)</option>
                                    <option value="Focused Audit (Recorded)">Focused (Recorded)</option>
                                    <option value="Focused Audit (Live)">Focused (Live)</option>
                                    <option value="Evaluation and Feedback">Evaluation</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="background: white; border-radius: 0.4852rem; box-shadow: 0 0.0405rem 0.1213rem 0 rgba(0, 0, 0, 0.1); overflow: hidden;">
                    <!-- Table Header -->
                    <div style="background-color: #f8f9fa; padding: 0.4852rem 0.6469rem; border-bottom: 0.0405rem solid #e5e7eb;">
                        <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 3fr; gap: 0.6469rem; align-items: center; font-weight: 700; font-size: 0.5659rem; color: #1f2937; text-transform: uppercase; letter-spacing: 0.05em;">
                            <div>Error Type</div>
                            <div style="text-align: center;">Points</div>
                            <div style="text-align: center;">Severity</div>
                            <div class="error-details-header-status" style="text-align: center;">Status</div>
                            <div>Feedback</div>
                        </div>
                    </div>
                    
                    <!-- Table Body -->
                    <div id="errorParametersContainer" style="padding: 0 0.6469rem 0.6469rem 0.6469rem; box-shadow: 0 -0.0606rem 0.1213rem rgba(0, 0, 0, 0.05);">
                        <!-- Error parameters will be dynamically loaded based on selected scorecard -->
                        <div style="padding: 1.2937rem; text-align: center; color: #6b7280; font-size: 0.5659rem;">
                            <p>Please select a scorecard above to load error parameters.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Avg Score & Passing Status -->
            <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Avg Score</p>
                        <input type="number" id="averageScore" name="averageScore" min="0" max="100" step="0.01" required readonly style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;">
                    </div>
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Status</p>
                        <input type="text" id="passingStatus" name="passingStatus" readonly style="font-size: 0.5659rem; font-weight: 600; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;">
                    </div>
                </div>
            </div>

            <!-- Error Counts: Total Errors, Critical Fail, Critical, Significant -->
            <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Total Errors</p>
                        <input type="number" id="totalErrorsCount" name="totalErrorsCount" min="0" required readonly style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;">
                    </div>
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical Fail</p>
                        <input type="number" id="criticalFailErrorDisplay" name="criticalFailErrorDisplay" min="0" required readonly style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;" value="0">
                    </div>
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical</p>
                        <input type="number" id="criticalErrors" name="criticalErrors" min="0" required readonly style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;">
                    </div>
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Significant Error</p>
                        <input type="number" id="significantError" name="significantError" min="0" required readonly style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;">
                    </div>
                </div>
            </div>

            <!-- Recommendations & Next Steps -->
            <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;">
                <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0 0 0.4852rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/></svg>
                    Recommendations / Next Steps
                </h3>
                <textarea id="recommendations" name="recommendations" rows="4" placeholder="Enter recommendations and next steps for the employee..." style="width: 100%; padding: 0.5659rem; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; font-size: 0.5257rem; line-height: 1.6; color: #374151; font-family: 'Poppins', sans-serif; background-color: white; resize: vertical; box-sizing: border-box;"></textarea>
            </div>
        </div>
    </div> <!-- End Two Column Layout -->

    <!-- Form Actions -->
    <div style="display: flex; justify-content: space-between; align-items: center; gap: 0.4852rem; padding: 0.6469rem 0.9704rem; border-top: 0.0405rem solid #e5e7eb; background-color: #f9fafb; margin-top: auto;">
        <div style="display: flex; align-items: center; gap: 0.4852rem;">
            <div>
                <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.1617rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Validation</p>
                <select id="validationStatus" name="validationStatus" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem; min-width: 8rem;">
                    <option value="Validated" selected>Validated</option>
                    <option value="Pending">Pending</option>
                    <option value="Rejected">Rejected</option>
                </select>
            </div>
        </div>
        <div style="display: flex; gap: 0.4852rem;">
        <button type="button" id="cancelBtn" style="padding: 0.4852rem 1.2937rem; background-color: white; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">Cancel</button>
        <button type="submit" style="padding: 0.4852rem 1.2937rem; background: linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%); color: white; border: none; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 0.0606rem 0.1213rem rgba(26, 115, 62, 0.2);">✓ Submit Audit</button>
        </div>
    </div>
    </form>
</div> <!-- End auditFormModal -->
</div>
</main>

<!-- Smart Loader for Form Submission -->
<div id="auditSubmitLoader">
    <div class="loader-content">
        <div class="loader-spinner"></div>
        <p class="loader-text">Submitting Audit...</p>
        <p class="loader-subtext">Please wait while we process your submission</p>
    </div>
</div>

<script>
// ============================================================================
// Dynamic Scorecard System
// ============================================================================
let currentScorecard = null;
let currentParameters = [];

// Store all available scorecards for filtering
let allAvailableScorecards = [];

// Load available scorecards
async function loadScorecards(channelFilter = null) {
    const scorecardSelect = document.getElementById('scorecardSelect');
    
    try {
        let query = window.supabaseClient
            .from('scorecards')
            .select('*')
            .eq('is_active', true)
            .order('created_at', { ascending: false });
        
        const { data, error } = await query;
        
        if (error) throw error;
        
        // Store all scorecards for filtering
        allAvailableScorecards = data || [];
        
        // Filter by channel if provided
        let filteredScorecards = allAvailableScorecards;
        if (channelFilter) {
            filteredScorecards = allAvailableScorecards.filter(scorecard => {
                if (!scorecard.channels) return false;
                const channelsList = scorecard.channels.split(',').map(c => c.trim());
                return channelsList.includes(channelFilter);
            });
            
            // Sort scorecards: default ones first, then by created_at
            // Handle case where default_for_channels column might not exist
            filteredScorecards.sort((a, b) => {
                const aIsDefault = a.default_for_channels && typeof a.default_for_channels === 'string' && a.default_for_channels.split(',').map(c => c.trim()).includes(channelFilter);
                const bIsDefault = b.default_for_channels && typeof b.default_for_channels === 'string' && b.default_for_channels.split(',').map(c => c.trim()).includes(channelFilter);
                
                if (aIsDefault && !bIsDefault) return -1;
                if (!aIsDefault && bIsDefault) return 1;
                
                // If both are default or neither, sort by created_at (newest first)
                const aDate = new Date(a.created_at || 0);
                const bDate = new Date(b.created_at || 0);
                return bDate - aDate;
            });
        }
        
        scorecardSelect.innerHTML = '<option value="">Select a scorecard...</option>';
        
        if (filteredScorecards && filteredScorecards.length > 0) {
            filteredScorecards.forEach(scorecard => {
                const option = document.createElement('option');
                option.value = scorecard.id;
                
                // Add "(Default)" indicator if this is the default scorecard for the channel
                let displayName = scorecard.name;
                if (channelFilter && scorecard.default_for_channels && typeof scorecard.default_for_channels === 'string') {
                    const defaultChannels = scorecard.default_for_channels.split(',').map(c => c.trim());
                    if (defaultChannels.includes(channelFilter)) {
                        displayName += ' (Default)';
                    }
                }
                
                option.textContent = displayName;
                option.dataset.threshold = scorecard.passing_threshold;
                option.dataset.tableName = scorecard.table_name;
                option.dataset.channels = scorecard.channels || '';
                scorecardSelect.appendChild(option);
            });
            
            // Auto-select the first scorecard if available (whether one or multiple)
            // This will be the default one if it exists, otherwise the newest one
            if (filteredScorecards.length > 0) {
                scorecardSelect.value = filteredScorecards[0].id;
                await loadScorecardParameters(filteredScorecards[0].id);
            }
            // If channel is selected but no matching scorecard, show message
            else if (channelFilter && filteredScorecards.length === 0) {
                scorecardSelect.innerHTML = '<option value="">No scorecard available for selected channel</option>';
            }
        } else {
            if (channelFilter) {
                scorecardSelect.innerHTML = '<option value="">No scorecard available for selected channel</option>';
        } else {
            scorecardSelect.innerHTML = '<option value="">No scorecards available</option>';
            }
        }
    } catch (error) {
        console.error('Error loading scorecards:', error);
        scorecardSelect.innerHTML = '<option value="">Error loading scorecards</option>';
    }
}

// Auto-select scorecard based on selected channel
async function autoSelectScorecardByChannel(channelName) {
    if (!channelName || !channelName.trim()) {
        // If channel is cleared, reload all scorecards and auto-select first
        await loadScorecards();
        return;
    }
    
    // Ensure scorecards are loaded first
    if (allAvailableScorecards.length === 0) {
        await loadScorecards();
    }
    
    // Reload scorecards filtered by channel (this will auto-select first matching scorecard)
    await loadScorecards(channelName.trim());
    
    // The loadScorecards function will already auto-select the first scorecard
    // No additional logic needed here
}


// Load parameters for selected scorecard
async function loadScorecardParameters(scorecardId) {
    // Handle empty, null, or "null" string values
    if (!scorecardId || scorecardId === 'null' || scorecardId === 'undefined' || scorecardId.trim() === '') {
        currentScorecard = null;
        currentParameters = [];
        document.getElementById('scorecardInfo').style.display = 'none';
        clearErrorParameters();
        return;
    }
    
    // Validate UUID format to prevent SQL errors
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(scorecardId)) {
        console.error('Invalid scorecard ID format:', scorecardId);
        currentScorecard = null;
        currentParameters = [];
        document.getElementById('scorecardInfo').style.display = 'none';
        clearErrorParameters();
        return;
    }
    
    try {
        // Load scorecard details
        const { data: scorecard, error: scorecardError } = await window.supabaseClient
            .from('scorecards')
            .select('*')
            .eq('id', scorecardId)
            .single();
        
        if (scorecardError) throw scorecardError;
        
        // Load parameters
        const { data: parameters, error: paramsError } = await window.supabaseClient
            .from('scorecard_parameters')
            .select('*')
            .eq('scorecard_id', scorecardId)
            .eq('is_active', true)
            .order('display_order', { ascending: true });
        
        if (paramsError) throw paramsError;
        
        currentScorecard = scorecard;
        currentParameters = parameters || [];
        
        // Update scorecard info display
        const scorecardScoringType = document.getElementById('scorecardScoringType');
        const scorecardParamsCount = document.getElementById('scorecardParamsCount');
        const scorecardInfo = document.getElementById('scorecardInfo');
        
        if (scorecardScoringType) {
            const scoringTypeText = scorecard.scoring_type 
                ? scorecard.scoring_type.charAt(0).toUpperCase() + scorecard.scoring_type.slice(1)
                : 'Deductive';
            scorecardScoringType.textContent = scoringTypeText;
        }
        if (scorecardParamsCount) scorecardParamsCount.textContent = currentParameters.length;
        if (scorecardInfo) scorecardInfo.style.display = 'flex';
        
        // Render error parameters
        renderErrorParameters();
        
        // Set initial average score based on scoring type
        setInitialAverageScore();
        
    } catch (error) {
        console.error('Error loading scorecard parameters:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to load scorecard parameters: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// ============================================================================
// Your Stats System
// ============================================================================

// Update your stats (assignment progress)
async function updateYourStats() {
    try {
        // Get current user info
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const currentUserEmail = (userInfo.email || '').toLowerCase().trim();
        const currentUserRole = userInfo.role || '';
        const isAgent = currentUserRole === 'Employee';
        
        if (!currentUserEmail) {
            return;
        }
        
        // Load assignments for current user
        // Filter by employee_email if agent, otherwise by auditor_email
        const filterField = isAgent ? 'employee_email' : 'auditor_email';
        const { data: assignments, error: assignmentsError } = await window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .eq(filterField, currentUserEmail)
            .order('created_at', { ascending: false });
        
        // Additional client-side filtering to ensure exact match (case-insensitive)
        const filteredAssignments = (assignments || []).filter(assignment => {
            const emailToCheck = isAgent ? assignment.employee_email : assignment.auditor_email;
            return emailToCheck && emailToCheck.toLowerCase().trim() === currentUserEmail;
        });
        
        if (assignmentsError) {
            console.error('Error loading assignments for stats:', assignmentsError);
            return;
        }
        
        const allAssignments = filteredAssignments;
        const totalAssigned = allAssignments.length;
        const completed = allAssignments.filter(a => a.status === 'completed').length;
        const inProgress = allAssignments.filter(a => a.status === 'in_progress').length;
        const pending = allAssignments.filter(a => a.status === 'pending').length;
        const remaining = pending + inProgress;
        
        // Calculate percentage
        const percentage = totalAssigned > 0 ? Math.round((completed / totalAssigned) * 100) : 0;
        
        // Calculate working days remaining (assuming 5 working days per week)
        const today = new Date();
        const endOfWeek = new Date(today);
        endOfWeek.setDate(today.getDate() + (5 - today.getDay())); // Friday
        const daysRemaining = Math.max(0, Math.ceil((endOfWeek - today) / (1000 * 60 * 60 * 24)));
        
        // Calculate average audit duration
        let avgDuration = 0;
        let avgDurationText = '-';
        
        try {
            // Get all scorecards to query audit tables
            const { data: scorecards, error: scError } = await window.supabaseClient
                .from('scorecards')
                .select('table_name')
                .eq('is_active', true);
            
            if (!scError && scorecards) {
                let totalDuration = 0;
                let auditCount = 0;
                
                // Query each scorecard table for audits by this user
                // Filter by employee_email if agent, otherwise by auditor_email
                const auditFilterField = isAgent ? 'employee_email' : 'auditor_email';
                for (const scorecard of scorecards) {
                    try {
                        const { data: audits, error } = await window.supabaseClient
                            .from(scorecard.table_name)
                            .select('audit_duration, ' + auditFilterField)
                            .not('audit_duration', 'is', null);
                        
                        if (!error && audits) {
                            // Filter by email (case-insensitive) on client side
                            const filteredAudits = audits.filter(audit => {
                                const emailToCheck = audit[auditFilterField];
                                return emailToCheck && emailToCheck.toLowerCase().trim() === currentUserEmail;
                            });
                            
                            filteredAudits.forEach(audit => {
                                // Handle duration conversion (new format: seconds, legacy format: minutes)
                                let durationInMinutes = 0;
                                if (typeof audit.audit_duration === 'number') {
                                    const value = audit.audit_duration;
                                    // If value is >= 1440 (24 hours in minutes), assume it's in seconds (new format)
                                    // Otherwise, assume it's already in minutes (legacy format)
                                    if (value >= 1440) {
                                        durationInMinutes = value / 60; // Convert seconds to minutes
                                    } else {
                                        durationInMinutes = value; // Already in minutes
                                    }
                                } else if (typeof audit.audit_duration === 'string') {
                                    // Try parsing as integer first
                                    const asInt = parseInt(audit.audit_duration);
                                    if (!isNaN(asInt)) {
                                        if (asInt >= 1440) {
                                            durationInMinutes = asInt / 60; // Convert seconds to minutes
                                        } else {
                                            durationInMinutes = asInt; // Already in minutes
                                        }
                                    } else {
                                        // Legacy format: time string (MM:SS or HH:MM:SS)
                                        const timeParts = audit.audit_duration.split(':');
                                        if (timeParts.length === 2) {
                                            // MM:SS format
                                            const minutes = parseInt(timeParts[0]) || 0;
                                            const seconds = parseInt(timeParts[1]) || 0;
                                            durationInMinutes = minutes + (seconds / 60);
                                        } else if (timeParts.length === 3) {
                                            // HH:MM:SS format
                                            const hours = parseInt(timeParts[0]) || 0;
                                            const minutes = parseInt(timeParts[1]) || 0;
                                            const seconds = parseInt(timeParts[2]) || 0;
                                            durationInMinutes = (hours * 60) + minutes + (seconds / 60);
                                        }
                                    }
                                }
                                
                                if (durationInMinutes > 0) {
                                    totalDuration += durationInMinutes; // Add minutes
                                    auditCount++;
                                }
                            });
                        }
                    } catch (err) {
                        console.warn(`Error getting duration from ${scorecard.table_name}:`, err);
                    }
                }
                
                if (auditCount > 0) {
                    avgDuration = totalDuration / auditCount; // Average in minutes
                    
                    // Format duration (avgDuration is in minutes)
                    if (avgDuration >= 60) {
                        const hours = Math.floor(avgDuration / 60);
                        const minutes = Math.round(avgDuration % 60);
                        avgDurationText = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                    } else {
                        avgDurationText = `${Math.round(avgDuration)}m`;
                    }
                }
            }
        } catch (error) {
            console.error('Error calculating average duration:', error);
        }
        
        // Calculate reversal count for current user
        let reversalCount = 0;
        try {
            const { data: scorecards, error: scError } = await window.supabaseClient
                .from('scorecards')
                .select('table_name')
                .eq('is_active', true);
            
            if (!scError && scorecards) {
                // Filter by employee_email if agent, otherwise by auditor_email
                const reversalFilterField = isAgent ? 'employee_email' : 'auditor_email';
                for (const scorecard of scorecards) {
                    try {
                        const { data, error } = await window.supabaseClient
                            .from(scorecard.table_name)
                            .select('id, ' + reversalFilterField)
                            .not('reversal_requested_at', 'is', null);
                        
                        if (!error && data) {
                            // Filter by email (case-insensitive) on client side
                            const filteredReversals = data.filter(reversal => {
                                const emailToCheck = reversal[reversalFilterField];
                                return emailToCheck && emailToCheck.toLowerCase().trim() === currentUserEmail;
                            });
                            reversalCount += filteredReversals.length;
                        }
                    } catch (err) {
                        console.warn(`Error counting reversals in ${scorecard.table_name}:`, err);
                    }
                }
            }
        } catch (error) {
            console.error('Error calculating reversal count:', error);
        }
        
        // Update stat cards (with null checks)
        const statsAssignedCount = document.getElementById('statsAssignedCount');
        const statsCompletedCount = document.getElementById('statsCompletedCount');
        const statsTargetAchieved = document.getElementById('statsTargetAchieved');
        const statsRemainingCount = document.getElementById('statsRemainingCount');
        const statsInProgressCount = document.getElementById('statsInProgressCount');
        const statsDaysRemaining = document.getElementById('statsDaysRemaining');
        const statsReversalCount = document.getElementById('statsReversalCount');
        const statsAvgDuration = document.getElementById('statsAvgDuration');
        const statsAvgDurationSubtitle = document.getElementById('statsAvgDurationSubtitle');
        
        if (statsAssignedCount) statsAssignedCount.textContent = totalAssigned;
        if (statsCompletedCount) statsCompletedCount.textContent = completed;
        if (statsTargetAchieved) statsTargetAchieved.textContent = `${percentage}% Target Achieved`;
        if (statsRemainingCount) statsRemainingCount.textContent = remaining;
        if (statsInProgressCount) statsInProgressCount.textContent = inProgress;
        if (statsDaysRemaining) statsDaysRemaining.textContent = `${daysRemaining} working day${daysRemaining !== 1 ? 's' : ''} remaining`;
        if (statsReversalCount) statsReversalCount.textContent = reversalCount;
        if (statsAvgDuration) statsAvgDuration.textContent = avgDurationText;
        if (statsAvgDurationSubtitle) statsAvgDurationSubtitle.textContent = 'per audit';
        
    } catch (error) {
        console.error('Error updating your stats:', error);
    }
}

// ============================================================================
// Pending Audits System
// ============================================================================
let pendingAudits = [];
let isEditingPendingAudit = false;

// Pagination state for pending audits
let pendingCurrentPage = 1;
let pendingItemsPerPage = 5;
let pendingTotalPages = 1;
let currentEditingAuditId = null;
let currentAssignmentId = null; // Separate tracking for assignment vs audit editing
let showAllAudits = false; // Flag to track if showing all audits or just mine
let isEditingExistingAudit = false; // Flag for editing from audit reports
let currentEditingTableName = null; // Table name for the audit being edited
let currentSortOrder = 'name_asc'; // Current sort order for pending audits

// Filter state
let activeFilters = {
    startDate: null,
    endDate: null,
    status: '',
    scorecard: '',
    search: ''
};
let allPendingAudits = []; // Store all audits before filtering

// Toggle sort menu
function toggleSortMenu() {
    const sortMenu = document.getElementById('sortMenu');
    if (sortMenu) {
        const isVisible = sortMenu.style.display === 'block';
        sortMenu.style.display = isVisible ? 'none' : 'block';
        
        // Close menu when clicking outside
        if (!isVisible) {
            setTimeout(() => {
                document.addEventListener('click', function closeMenuOnOutsideClick(e) {
                    if (!sortMenu.contains(e.target) && e.target.id !== 'sortIconBtn') {
                        sortMenu.style.display = 'none';
                        document.removeEventListener('click', closeMenuOnOutsideClick);
                    }
                });
            }, 0);
        }
    }
}

// Make toggleSortMenu globally accessible
window.toggleSortMenu = toggleSortMenu;

// Toggle between pending/in_progress and completed audits for logged-in user
function toggleAllAuditsView() {
    showAllAudits = !showAllAudits;
    
    // Update button text and title
    const toggleBtn = document.getElementById('toggleBtnText');
    const title = document.getElementById('auditsViewTitle');
    
    if (showAllAudits) {
        toggleBtn.textContent = 'View Pending Only';
        title.textContent = 'My Completed Audits';
    } else {
        toggleBtn.textContent = 'Show Completed audits';
        title.textContent = 'My Assigned Audits';
    }
    
    // Reload audits with new view
    loadPendingAudits();
}

// Sort pending audits based on current sort order
function sortPendingAudits() {
    const sortBy = document.getElementById('auditSortBy');
    if (sortBy) {
        currentSortOrder = sortBy.value;
    }
    
    if (!pendingAudits || pendingAudits.length === 0) {
        return;
    }
    
    // Create a copy to avoid mutating the original array
    const sorted = [...pendingAudits];
    
    const [field, direction] = currentSortOrder.split('_');
    
    sorted.sort((a, b) => {
        let comparison = 0;
        
        switch(field) {
            case 'name':
                const nameA = (a.employee_name || '').toLowerCase();
                const nameB = (b.employee_name || '').toLowerCase();
                comparison = nameA.localeCompare(nameB);
                break;
                
            case 'status':
                // Status order: pending = 1, in_progress = 2
                const statusA = a.status === 'pending' ? 1 : (a.status === 'in_progress' ? 2 : 0);
                const statusB = b.status === 'pending' ? 1 : (b.status === 'in_progress' ? 2 : 0);
                comparison = statusA - statusB;
                break;
                
            case 'priority':
                // Priority: For now, we'll use a default priority of 0 if not defined
                // You can add a priority field to audit_assignments table later
                const priorityA = a.priority || 0;
                const priorityB = b.priority || 0;
                comparison = priorityA - priorityB;
                break;
                
            default:
                return 0;
        }
        
        // Apply direction (asc or desc)
        return direction === 'asc' ? comparison : -comparison;
    });
    
    // Update the pendingAudits array with sorted data
    pendingAudits = sorted;
    
    // Reset pagination to first page after sorting
    pendingCurrentPage = 1;
    
    // Re-display the sorted audits
    displayPendingAudits();
}

// Make sortPendingAudits accessible globally
window.sortPendingAudits = sortPendingAudits;

// View completed audit
window.viewCompletedAudit = function(auditId, scorecardId, tableName) {
    if (!auditId || !scorecardId || !tableName) {
        console.error('Missing required parameters for viewing audit:', { auditId, scorecardId, tableName });
        window.confirmationDialog.show({
            title: 'Error',
            message: 'Cannot view audit: Missing required information.',
            confirmText: 'OK',
            type: 'error'
        });
        return;
    }
    // Use same format as expert-audits.html for consistency
    window.location.href = `audit-view.html?id=${auditId}&scorecard=${scorecardId}&table=${tableName}`;
};

// Load pending audits for current user from audit_assignments table
async function loadPendingAudits() {
    try {
        // Get current user info
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const currentUserEmail = (userInfo.email || '').toLowerCase().trim();
        const currentUserRole = userInfo.role || '';
        const isAgent = currentUserRole === 'Employee';
        
        if (!currentUserEmail) {
            return;
        }
        
        // Determine status filter
        const statusFilter = showAllAudits ? ['completed'] : ['pending', 'in_progress'];
        
        // Load assigned audits from audit_assignments table with scorecard info
        // Filter by employee_email if agent, otherwise by auditor_email
        // showAllAudits controls whether to show completed or pending/in_progress
        const filterField = isAgent ? 'employee_email' : 'auditor_email';
        let query = window.supabaseClient
            .from('audit_assignments')
            .select(`
                *,
                scorecards:scorecard_id (
                    id,
                    name,
                    table_name
                )
            `)
            .eq(filterField, currentUserEmail)
            .order('created_at', { ascending: false });
        
        
        // If showing completed audits, filter by status
        if (showAllAudits) {
            query = query.eq('status', 'completed');
        } else {
            query = query.in('status', statusFilter);
        }
        
        const { data, error } = await query;
        
        if (error) {
            console.error('Error loading assignments:', error);
            throw error;
        }
        
        // Normalize and filter client-side for exact match (case-insensitive)
        // This ensures we match emails correctly regardless of case differences
        const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
        const finalFiltered = (data || []).filter(assignment => {
            const emailToCheck = isAgent ? assignment.employee_email : assignment.auditor_email;
            if (!emailToCheck) return false;
            return emailToCheck.toLowerCase().trim() === normalizedCurrentEmail;
        });
        
        allPendingAudits = finalFiltered; // Store all audits
        
        // Apply filters
        applyFiltersToAudits();
        
        // Apply sorting
        sortPendingAudits();
        
        // Reset pagination to first page when audits reload
        pendingCurrentPage = 1;
        
        // Display pending audits
        displayPendingAudits();
        
        // Update your stats
        await updateYourStats();
        
    } catch (error) {
        console.error('Error loading pending audits:', error);
    }
}

// Display pending audits in the UI
function displayPendingAudits() {
    const section = document.getElementById('pendingAuditsSection');
    const list = document.getElementById('pendingAuditsList');
    const countBadge = document.getElementById('pendingCount');
    const paginationContainer = document.getElementById('pendingAuditsPagination');
    
    // Check if elements exist before accessing them
    if (!section || !list || !countBadge) {
        console.warn('Pending audits section elements not found in DOM');
        return;
    }
    
    // Don't show the section if we're currently editing an audit
    if (!isEditingPendingAudit) {
        section.style.display = 'block';
    }
    
    countBadge.textContent = pendingAudits.length;
    
    // Show empty state if no audits
    if (pendingAudits.length === 0) {
        const emptyStateMessage = showAllAudits 
            ? 'No completed audits found.'
            : 'No audits have been assigned to you yet.';
        
        list.innerHTML = `
            <div style="text-align: center; padding: 1.9406rem 0.9704rem; color: #6b7280;">
                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin: 0 auto 0.6469rem; opacity: 0.4;">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="12" y1="18" x2="12" y2="12"/>
                    <line x1="9" y1="15" x2="15" y2="15"/>
                </svg>
                <p style="font-size: 0.5659rem; font-weight: 500; color: #374151; margin: 0 0 0.3234rem;">${emptyStateMessage}</p>
                <p style="font-size: 0.4852rem; color: #9ca3af; margin: 0;">Audits will appear here once they are assigned to you.</p>
            </div>
        `;
        if (paginationContainer) paginationContainer.style.display = 'none';
        return;
    }
    
    // Calculate pagination
    pendingTotalPages = Math.ceil(pendingAudits.length / pendingItemsPerPage);
    if (pendingCurrentPage > pendingTotalPages && pendingTotalPages > 0) {
        pendingCurrentPage = pendingTotalPages;
    }
    if (pendingCurrentPage < 1) {
        pendingCurrentPage = 1;
    }
    
    // Get paginated audits
    const startIndex = (pendingCurrentPage - 1) * pendingItemsPerPage;
    const endIndex = startIndex + pendingItemsPerPage;
    const paginatedAudits = pendingAudits.slice(startIndex, endIndex);
    
    list.innerHTML = '';
    
    // Get current user info to check if agent
    const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
    const userRole = userInfo.role || '';
    const isAgent = userRole === 'Employee';
    
    paginatedAudits.forEach(audit => {
        const auditCard = document.createElement('div');
        auditCard.style.cssText = `
            background: #f9fafb;
            border: 0.0405rem solid #e5e7eb;
            border-radius: 0.1617rem;
            padding: 0.4852rem;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.4852rem;
        `;
        
        // For agents, show auditor name; for auditors, show employee name
        const displayName = isAgent ? (audit.auditor_email || 'Unknown Auditor') : (audit.employee_name || 'Unknown Employee');
        const displayEmail = isAgent ? (audit.auditor_email || 'No email') : (audit.employee_email || 'No email');
        
        // Status badge - different for completed audits
        let statusBadge = '';
        let actionButton = '';
        
        // Agents can only view completed audits, not start/continue them
        const canEdit = !isAgent;
        
        if (audit.status === 'completed') {
            statusBadge = '<span style="background-color: #dbeafe; color: #1e40af; padding: 0.0808rem 0.3234rem; border-radius: 0.1617rem; font-size: 0.4447rem; font-weight: 600;">Completed</span>';
            // Add View button for completed audits
            // Escape values to prevent XSS and ensure proper parameter passing
            const auditId = audit.audit_id ? String(audit.audit_id).replace(/'/g, "\\'") : '';
            const scorecardId = audit.scorecard_id ? String(audit.scorecard_id).replace(/'/g, "\\'") : '';
            const tableName = audit.scorecards?.table_name ? String(audit.scorecards.table_name).replace(/'/g, "\\'") : '';
            
            if (auditId && scorecardId && tableName) {
                actionButton = `<button 
                    onclick="event.stopPropagation(); viewCompletedAudit('${auditId}', '${scorecardId}', '${tableName}')" 
                    style="padding: 0.3234rem 0.6469rem; background-color: #1A733E; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; white-space: nowrap;"
                    onmouseover="this.style.backgroundColor='#15582E'"
                    onmouseout="this.style.backgroundColor='#1A733E'"
                >
                    View Details
                </button>`;
            } else {
                // No audit_id available, can't view
                actionButton = '';
                console.warn('Cannot show View button - missing required data:', { 
                    audit_id: audit.audit_id, 
                    scorecard_id: audit.scorecard_id, 
                    table_name: audit.scorecards?.table_name 
                });
            }
        } else if (audit.status === 'in_progress') {
            statusBadge = '<span style="background-color: #fef3c7; color: #92400e; padding: 0.0808rem 0.3234rem; border-radius: 0.1617rem; font-size: 0.4447rem; font-weight: 600;">In Progress</span>';
            if (canEdit) {
                actionButton = `<button 
                    onclick="event.stopPropagation(); navigateToAssignment('${audit.id}')" 
                    style="padding: 0.3234rem 0.6469rem; background-color: #1A733E; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; white-space: nowrap;"
                    onmouseover="this.style.backgroundColor='#15582E'"
                    onmouseout="this.style.backgroundColor='#1A733E'"
                >
                    Continue
                </button>`;
            }
        } else {
            statusBadge = '<span style="background-color: #dcfce7; color: #166534; padding: 0.0808rem 0.3234rem; border-radius: 0.1617rem; font-size: 0.4447rem; font-weight: 600;">Pending</span>';
            if (canEdit) {
                actionButton = `<button 
                    onclick="event.stopPropagation(); navigateToAssignment('${audit.id}')" 
                    style="padding: 0.3234rem 0.6469rem; background-color: #1A733E; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; white-space: nowrap;"
                    onmouseover="this.style.backgroundColor='#15582E'"
                    onmouseout="this.style.backgroundColor='#1A733E'"
                >
                    Start Audit
                </button>`;
            }
        }
        
        const clickHandler = audit.status === 'completed' && audit.audit_id 
            ? `onclick="event.stopPropagation(); viewCompletedAudit('${audit.audit_id}', '${audit.scorecard_id}', '${audit.scorecards?.table_name || ''}')"`
            : canEdit ? `onclick="navigateToAssignment('${audit.id}')"` : '';
        
        auditCard.innerHTML = `
            <div style="flex: 1; display: flex; align-items: center; gap: 0.4852rem; ${clickHandler ? 'cursor: pointer;' : ''}" ${clickHandler}>
                <div style="width: 1.6171rem; height: 1.6171rem; border-radius: 0.1617rem; background: #1A733E; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.5659rem; flex-shrink: 0;">
                    ${getInitials(displayName)}
                </div>
                <div style="flex: 1; min-width: 0;">
                    <div style="display: flex; align-items: center; gap: 0.3234rem; margin-bottom: 0.1617rem;">
                        <h4 style="margin: 0; font-size: 0.5659rem; font-weight: 600; color: #1f2937;">
                            ${escapeHtml(displayName)}
                        </h4>
                    </div>
                    <p style="margin: 0; font-size: 0.4852rem; color: #6b7280; display: flex; align-items: center; gap: 0.2425rem; flex-wrap: wrap;">
                        <span>${escapeHtml(displayEmail)}</span>
                        <span style="color: #d1d5db;">â€¢</span>
                        <span style="font-weight: 500; color: #374151;">${escapeHtml(audit.scorecards?.name || 'Unknown Scorecard')}</span>
                        ${audit.completed_at ? `<span style="color: #d1d5db;">â€¢</span><span style="font-size: 0.4447rem; color: #6b7280;">Completed ${formatDate(audit.completed_at)}</span>` : ''}
                    </p>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 0.3234rem; flex-shrink: 0;">
                ${statusBadge}
                ${actionButton}
                ${displayEmail && displayEmail !== 'No email' ? `
                    <button 
                        class="pull-conversations-btn"
                        data-email="${escapeHtml(displayEmail)}"
                        data-name="${escapeHtml(displayName)}"
                        style="padding: 0.2425rem 0.4852rem; background-color: #f0fdf4; color: #1A733E; border: 0.0304rem solid #1A733E; border-radius: 0.1617rem; font-size: 0.4447rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; display: flex; align-items: center; gap: 0.2425rem;"
                        onmouseover="this.style.backgroundColor='#dcfce7'; this.style.borderColor='#15582E'; this.style.color='#15582E';"
                        onmouseout="this.style.backgroundColor='#f0fdf4'; this.style.borderColor='#1A733E'; this.style.color='#1A733E';"
                        title="Pull conversations for ${escapeHtml(displayName)}"
                    >
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                        <span>Pull Conversations</span>
                    </button>
                ` : ''}
            </div>
        `;
        
        // Add event listener to pull conversations button
        if (displayEmail && displayEmail !== 'No email') {
            const pullBtn = auditCard.querySelector('.pull-conversations-btn');
            if (pullBtn) {
                pullBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const email = this.getAttribute('data-email');
                    const name = this.getAttribute('data-name');
                    if (window.pullConversationsForEmployee && typeof window.pullConversationsForEmployee === 'function') {
                        window.pullConversationsForEmployee(email, name);
                    } else {
                        console.error('âŒ pullConversationsForEmployee function not found on window');
                        alert('Function not loaded. Please refresh the page.');
                    }
                });
            }
        }
        
        auditCard.onmouseenter = () => {
            auditCard.style.borderColor = '#1A733E';
            auditCard.style.backgroundColor = '#ffffff';
        };
        
        auditCard.onmouseleave = () => {
            auditCard.style.borderColor = '#e5e7eb';
            auditCard.style.backgroundColor = '#f9fafb';
        };
        
        list.appendChild(auditCard);
    });
    
    // Update pagination UI
    updatePendingPaginationUI();
}

// Calculate pagination for pending audits
function calculatePendingPagination() {
    pendingTotalPages = Math.ceil(pendingAudits.length / pendingItemsPerPage);
    if (pendingCurrentPage > pendingTotalPages && pendingTotalPages > 0) {
        pendingCurrentPage = pendingTotalPages;
    }
    if (pendingCurrentPage < 1) {
        pendingCurrentPage = 1;
    }
}

// Get paginated pending audits
function getPaginatedPendingAudits() {
    const startIndex = (pendingCurrentPage - 1) * pendingItemsPerPage;
    const endIndex = startIndex + pendingItemsPerPage;
    return pendingAudits.slice(startIndex, endIndex);
}

// ============================================================================
// Filter Functions
// ============================================================================

// Apply filters to audits
function applyFiltersToAudits() {
    let filtered = [...allPendingAudits];
    
    // Date range filter
    if (activeFilters.startDate) {
        const startDate = new Date(activeFilters.startDate);
        startDate.setHours(0, 0, 0, 0);
        filtered = filtered.filter(audit => {
            const auditDate = new Date(audit.created_at);
            auditDate.setHours(0, 0, 0, 0);
            return auditDate >= startDate;
        });
    }
    
    if (activeFilters.endDate) {
        const endDate = new Date(activeFilters.endDate);
        endDate.setHours(23, 59, 59, 999);
        filtered = filtered.filter(audit => {
            const auditDate = new Date(audit.created_at);
            return auditDate <= endDate;
        });
    }
    
    // Status filter
    if (activeFilters.status) {
        filtered = filtered.filter(audit => audit.status === activeFilters.status);
    }
    
    // Scorecard filter
    if (activeFilters.scorecard) {
        filtered = filtered.filter(audit => audit.scorecard_id === activeFilters.scorecard);
    }
    
    // Search filter
    if (activeFilters.search) {
        const searchTerm = activeFilters.search.toLowerCase().trim();
        filtered = filtered.filter(audit => {
            const employeeName = (audit.employee_name || '').toLowerCase();
            const employeeEmail = (audit.employee_email || '').toLowerCase();
            const auditorEmail = (audit.auditor_email || '').toLowerCase();
            const scorecardName = (audit.scorecards?.name || '').toLowerCase();
            return employeeName.includes(searchTerm) || 
                   employeeEmail.includes(searchTerm) || 
                   auditorEmail.includes(searchTerm) ||
                   scorecardName.includes(searchTerm);
        });
    }
    
    pendingAudits = filtered;
}

// Apply filters from UI
function applyFilters() {
    const startDateInput = document.getElementById('filterStartDate');
    const endDateInput = document.getElementById('filterEndDate');
    const statusSelect = document.getElementById('filterStatus');
    const scorecardSelect = document.getElementById('filterScorecard');
    const searchInput = document.getElementById('filterSearch');
    
    // Update active filters
    activeFilters.startDate = startDateInput?.value || null;
    activeFilters.endDate = endDateInput?.value || null;
    activeFilters.status = statusSelect?.value || '';
    activeFilters.scorecard = scorecardSelect?.value || '';
    activeFilters.search = searchInput?.value || '';
    
    // Apply filters
    applyFiltersToAudits();
    
    // Reset pagination
    pendingCurrentPage = 1;
    
    // Apply sorting and display
    sortPendingAudits();
    displayPendingAudits();
}

// Clear all filters
function clearFilters() {
    const startDateInput = document.getElementById('filterStartDate');
    const endDateInput = document.getElementById('filterEndDate');
    const statusSelect = document.getElementById('filterStatus');
    const scorecardSelect = document.getElementById('filterScorecard');
    const searchInput = document.getElementById('filterSearch');
    
    // Clear filter inputs
    if (startDateInput) startDateInput.value = '';
    if (endDateInput) endDateInput.value = '';
    if (statusSelect) statusSelect.value = '';
    if (scorecardSelect) scorecardSelect.value = '';
    if (searchInput) searchInput.value = '';
    
    // Reset active filters
    activeFilters = {
        startDate: null,
        endDate: null,
        status: '',
        scorecard: '',
        search: ''
    };
    
    // Apply filters (will reset to all audits)
    applyFiltersToAudits();
    
    // Reset pagination
    pendingCurrentPage = 1;
    
    // Apply sorting and display
    sortPendingAudits();
    displayPendingAudits();
}

// Toggle filters visibility
function toggleFilters() {
    const filtersSection = document.getElementById('filtersSection');
    const showFiltersBtn = document.getElementById('showFiltersBtn');
    
    if (filtersSection && showFiltersBtn) {
        const isCurrentlyHidden = filtersSection.style.display === 'none';
        filtersSection.style.display = isCurrentlyHidden ? 'block' : 'none';
        
        // Update button opacity to indicate active state
        if (isCurrentlyHidden) {
            showFiltersBtn.style.opacity = '1';
            showFiltersBtn.title = 'Hide Filters';
        } else {
            showFiltersBtn.style.opacity = '0.7';
            showFiltersBtn.title = 'Show Filters';
        }
    }
}

// Populate scorecard filter dropdown
async function populateScorecardFilter() {
    const scorecardSelect = document.getElementById('filterScorecard');
    if (!scorecardSelect) return;
    
    try {
        const { data: scorecards, error } = await window.supabaseClient
            .from('scorecards')
            .select('id, name')
            .eq('is_active', true)
            .order('name', { ascending: true });
        
        if (error) {
            console.error('Error loading scorecards for filter:', error);
            return;
        }
        
        // Clear existing options except "All Scorecards"
        scorecardSelect.innerHTML = '<option value="">All Scorecards</option>';
        
        // Add scorecard options
        if (scorecards && scorecards.length > 0) {
            scorecards.forEach(scorecard => {
                const option = document.createElement('option');
                option.value = scorecard.id;
                option.textContent = scorecard.name;
                scorecardSelect.appendChild(option);
            });
        }
    } catch (error) {
        console.error('Error populating scorecard filter:', error);
    }
}

// Make filter functions globally accessible
window.applyFilters = applyFilters;
window.clearFilters = clearFilters;
window.toggleFilters = toggleFilters;

// Update pagination UI for pending audits
function updatePendingPaginationUI() {
    const paginationContainer = document.getElementById('pendingAuditsPagination');
    const paginationInfo = document.getElementById('pendingPaginationInfo');
    const pageNumbers = document.getElementById('pendingPageNumbers');
    const firstPageBtn = document.getElementById('pendingFirstPageBtn');
    const prevPageBtn = document.getElementById('pendingPrevPageBtn');
    const nextPageBtn = document.getElementById('pendingNextPageBtn');
    const lastPageBtn = document.getElementById('pendingLastPageBtn');
    
    if (pendingAudits.length === 0 || pendingTotalPages <= 1) {
        if (paginationContainer) paginationContainer.style.display = 'none';
        return;
    }
    
    if (paginationContainer) {
        paginationContainer.style.display = 'block';
    }
    
    // Update pagination info
    const startIndex = (pendingCurrentPage - 1) * pendingItemsPerPage + 1;
    const endIndex = Math.min(pendingCurrentPage * pendingItemsPerPage, pendingAudits.length);
    if (paginationInfo) {
        paginationInfo.textContent = `Page ${pendingCurrentPage} of ${pendingTotalPages} (Showing ${startIndex}-${endIndex} of ${pendingAudits.length})`;
    }
    
    // Update button states
    if (firstPageBtn) {
        firstPageBtn.disabled = pendingCurrentPage === 1;
        firstPageBtn.style.opacity = pendingCurrentPage === 1 ? '0.5' : '1';
        firstPageBtn.style.cursor = pendingCurrentPage === 1 ? 'not-allowed' : 'pointer';
    }
    if (prevPageBtn) {
        prevPageBtn.disabled = pendingCurrentPage === 1;
        prevPageBtn.style.opacity = pendingCurrentPage === 1 ? '0.5' : '1';
        prevPageBtn.style.cursor = pendingCurrentPage === 1 ? 'not-allowed' : 'pointer';
    }
    if (nextPageBtn) {
        nextPageBtn.disabled = pendingCurrentPage === pendingTotalPages;
        nextPageBtn.style.opacity = pendingCurrentPage === pendingTotalPages ? '0.5' : '1';
        nextPageBtn.style.cursor = pendingCurrentPage === pendingTotalPages ? 'not-allowed' : 'pointer';
    }
    if (lastPageBtn) {
        lastPageBtn.disabled = pendingCurrentPage === pendingTotalPages;
        lastPageBtn.style.opacity = pendingCurrentPage === pendingTotalPages ? '0.5' : '1';
        lastPageBtn.style.cursor = pendingCurrentPage === pendingTotalPages ? 'not-allowed' : 'pointer';
    }
    
    // Generate page numbers
    if (pageNumbers) {
        pageNumbers.innerHTML = '';
        const maxVisiblePages = 5;
        let startPage = Math.max(1, pendingCurrentPage - Math.floor(maxVisiblePages / 2));
        let endPage = Math.min(pendingTotalPages, startPage + maxVisiblePages - 1);
        
        // Adjust start page if we're near the end
        if (endPage - startPage < maxVisiblePages - 1) {
            startPage = Math.max(1, endPage - maxVisiblePages + 1);
        }
        
        // First page
        if (startPage > 1) {
            const firstBtn = document.createElement('button');
            firstBtn.textContent = '1';
            firstBtn.onclick = () => goToPendingPage(1);
            firstBtn.style.cssText = 'padding: 0.3234rem 0.4852rem; background-color: #ffffff; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: \'Poppins\', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;';
            pageNumbers.appendChild(firstBtn);
            
            if (startPage > 2) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = '...';
                ellipsis.style.cssText = 'padding: 0.3234rem 0.1617rem; color: #6b7280; font-size: 0.5659rem;';
                pageNumbers.appendChild(ellipsis);
            }
        }
        
        // Page numbers
        for (let i = startPage; i <= endPage; i++) {
            const pageBtn = document.createElement('button');
            pageBtn.textContent = i.toString();
            pageBtn.onclick = () => goToPendingPage(i);
            if (i === pendingCurrentPage) {
                pageBtn.style.cssText = 'padding: 0.3234rem 0.4852rem; background-color: #1A733E; color: #ffffff; border: 0.0405rem solid #1A733E; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: \'Poppins\', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;';
            } else {
                pageBtn.style.cssText = 'padding: 0.3234rem 0.4852rem; background-color: #ffffff; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: \'Poppins\', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;';
            }
            pageBtn.onmouseover = function() {
                if (i !== pendingCurrentPage) {
                    this.style.backgroundColor = '#f3f4f6';
                }
            };
            pageBtn.onmouseout = function() {
                if (i !== pendingCurrentPage) {
                    this.style.backgroundColor = '#ffffff';
                }
            };
            pageNumbers.appendChild(pageBtn);
        }
        
        // Last page
        if (endPage < pendingTotalPages) {
            if (endPage < pendingTotalPages - 1) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = '...';
                ellipsis.style.cssText = 'padding: 0.3234rem 0.1617rem; color: #6b7280; font-size: 0.5659rem;';
                pageNumbers.appendChild(ellipsis);
            }
            
            const lastBtn = document.createElement('button');
            lastBtn.textContent = pendingTotalPages.toString();
            lastBtn.onclick = () => goToPendingPage(pendingTotalPages);
            lastBtn.style.cssText = 'padding: 0.3234rem 0.4852rem; background-color: #ffffff; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: \'Poppins\', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;';
            pageNumbers.appendChild(lastBtn);
        }
    }
}

// Pagination navigation functions for pending audits
window.goToPendingPage = function(page) {
    if (page >= 1 && page <= pendingTotalPages && page !== pendingCurrentPage) {
        pendingCurrentPage = page;
        displayPendingAudits();
        // Scroll to top of pending audits section
        const pendingSection = document.getElementById('pendingAuditsSection');
        if (pendingSection) {
            pendingSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }
};

window.goToPendingPreviousPage = function() {
    if (pendingCurrentPage > 1) {
        goToPendingPage(pendingCurrentPage - 1);
    }
};

window.goToPendingNextPage = function() {
    if (pendingCurrentPage < pendingTotalPages) {
        goToPendingPage(pendingCurrentPage + 1);
    }
};

window.goToPendingLastPage = function() {
    if (pendingTotalPages > 0) {
        goToPendingPage(pendingTotalPages);
    }
};

// Load pending audit data into the form
window.loadPendingAuditIntoForm = async function(auditId) {
    const audit = pendingAudits.find(a => a.id === auditId);
    
    if (!audit) {
        console.error('Audit not found:', auditId);
        return;
    }
    
    // Set editing mode
    isEditingPendingAudit = true;
    currentEditingAuditId = auditId;
    
    // Pre-fill employee information
    const employeeSelect = document.getElementById('employeeName');
    const employeeEmail = document.getElementById('employeeEmail');
    const employeeType = document.getElementById('employeeType');
    const employeeDepartment = document.getElementById('employeeDepartment');
    const countryOfEmployee = document.getElementById('countryOfEmployee');
    
    // Find and select the employee in dropdown
    if (employeeSelect && audit.employee_email) {
        for (let i = 0; i < employeeSelect.options.length; i++) {
            if (employeeSelect.options[i].dataset.email === audit.employee_email) {
                employeeSelect.selectedIndex = i;
                // Trigger change event to populate other fields
                employeeSelect.dispatchEvent(new Event('change'));
                break;
            }
        }
    }
    
    if (employeeEmail) employeeEmail.value = audit.employee_email || '';
    if (employeeType) employeeType.value = audit.employee_type || '';
    if (employeeDepartment) employeeDepartment.value = audit.employee_department || '';
    if (countryOfEmployee) countryOfEmployee.value = audit.country_of_employee || '';
    
    // Pre-fill any other existing data
    if (audit.channel) {
        const channelField = document.getElementById('channel');
        if (channelField) channelField.value = audit.channel;
    }
    // Scroll to form
    document.getElementById('auditForm').scrollIntoView({ behavior: 'smooth', block: 'start' });
    
    // Show notification
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 2.4258rem;
        right: 0.6064rem;
        background: #1A733E;
        color: white;
        padding: 0.3639rem 0.6064rem;
        border-radius: 0.1819rem;
        font-family: 'Poppins', sans-serif;
        font-size: 0.4245rem;
        z-index: 10000;
        box-shadow: 0 0.1213rem 0.3639rem rgba(0,0,0,0.15);
    `;
    notification.textContent = `Editing pending audit for ${audit.employee_name}`;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 3000);
}

// ============================================================================
// Create Manual Audit Function
// ============================================================================

// Create a manual audit - open blank form for manual audit creation
window.createManualAudit = async function() {
    // Reset all editing and assignment tracking flags
    isEditingPendingAudit = false;
    currentEditingAuditId = null;
    currentAssignmentId = null;
    isEditingExistingAudit = false;
    currentEditingTableName = null;
    
    // Reset the form
    const auditForm = document.getElementById('auditForm');
    if (auditForm) {
        auditForm.reset();
    }
    
    // Reset header back to green (passing state)
    const headerElement = document.getElementById('auditFormHeader');
    if (headerElement) {
        headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
    }
    
    // Reset form header title
    const scorecardDisplay = document.getElementById('formScorecardDisplay');
    if (scorecardDisplay) {
        scorecardDisplay.innerHTML = '<svg style="width: 0.5659rem; height: 0.5659rem; display: inline-block; vertical-align: middle; margin-right: 0.2425rem;" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg> Select a scorecard';
    }
    
    // Clear scorecard parameters container
    const parametersContainer = document.getElementById('scorecardParameters');
    if (parametersContainer) {
        parametersContainer.innerHTML = '';
    }
    
    // Reset scorecard select
    const scorecardSelect = document.getElementById('scorecardSelect');
    if (scorecardSelect) {
        scorecardSelect.value = '';
    }
    
    // Reset employee select
    const employeeSelect = document.getElementById('employeeName');
    if (employeeSelect) {
        employeeSelect.selectedIndex = 0;
        // Trigger change event to clear employee-related fields
        employeeSelect.dispatchEvent(new Event('change'));
    }
    
    // Hide Intercom alias field
    const intercomAliasContainer = document.getElementById('intercomAliasContainer');
    if (intercomAliasContainer) {
        intercomAliasContainer.style.display = 'none';
    }
    
    // Hide the assigned audits section
    const pendingAuditsSection = document.getElementById('pendingAuditsSection');
    if (pendingAuditsSection) {
        pendingAuditsSection.style.display = 'none';
    }
    
    // Show the full screen audit form modal
    const auditFormModal = document.getElementById('auditFormModal');
    if (auditFormModal) {
        auditFormModal.style.display = 'flex';
    }
    
    // Auto-select first available scorecard (or based on channel if selected)
    const channelSelect = document.getElementById('channel');
    if (channelSelect && channelSelect.value) {
        // If channel is already selected, auto-select matching scorecard
        await autoSelectScorecardByChannel(channelSelect.value);
    } else {
        // Otherwise, just reload and auto-select first available scorecard
        await loadScorecards();
    }
    
    // Show and start the timer
    const auditTimer = document.getElementById('auditTimer');
    if (auditTimer) {
        auditTimer.style.display = 'flex';
        // Attach event listeners when timer is shown
        if (window.attachTimerEventListeners) {
            window.attachTimerEventListeners();
        }
    }
    
    // Reset and start the timer
    if (window.resetTimer && window.startTimer) {
        window.resetTimer();
        window.startTimer();
    }
    
    // Scroll to top to show form
    window.scrollTo({ top: 0, behavior: 'smooth' });
    
    // Show notification
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 2.4258rem;
        right: 0.6064rem;
        background: linear-gradient(135deg, #1A733E, #15582E);
        color: white;
        padding: 0.6469rem 0.9704rem;
        border-radius: 0.3234rem;
        box-shadow: 0 0.1213rem 0.3639rem rgba(0, 0, 0, 0.15);
        z-index: 10000;
        font-size: 0.5659rem;
        font-weight: 600;
        animation: slideIn 0.3s ease;
    `;
    notification.textContent = 'Manual audit form opened. Fill in the details to create a new audit.';
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }, 3000);
}

// ============================================================================
// Start Assigned Audit Function
// ============================================================================

// Start an assigned audit - update status and pre-fill form
// Navigate to assignment URL (creates unique URL for each audit)
// Conversations state
let currentEmployeeEmail = null;
let currentEmployeeName = null;
let currentAdminId = null;
let allEmployeeConversations = []; // Filtered conversations for display
let rawEmployeeConversations = []; // All unfiltered conversations (persistent)
let currentConversationsPage = 1;
const conversationsItemsPerPage = 20; // Display 20 conversations per page
const maxConversationsToFetch = 150; // Maximum conversations to fetch from API
let isLoadingEmployeeConversations = false;

/**
 * Cache an admin to Supabase cache table (async, non-blocking)
 * This is called when an admin is found via Intercom API fallback
 */
async function cacheAdminAsync(supabaseClient, admin) {
    try {
        const adminId = admin.id;
        const adminEmail = admin.email || '';
        const adminName = admin.name || '';
        
        if (!adminId) {
            return; // Skip if no ID
        }
        
        const cacheData = {
            id: adminId,
            email: adminEmail.toLowerCase().trim(), // Normalize email
            name: adminName,
            admin_data: admin, // Store all admin fields as JSON
            last_synced_at: new Date().toISOString()
        };
        
        // Upsert (insert or update if exists)
        const { error: upsertError } = await supabaseClient
            .from('intercom_admin_cache')
            .upsert(cacheData, {
                onConflict: 'id',
                ignoreDuplicates: false
            });
        
        if (upsertError) {
            console.warn('Failed to cache admin:', upsertError);
        }
    } catch (error) {
        console.warn('Error caching admin:', error);
        // Non-critical, so we don't throw
    }
}

// View employee conversations - show conversations on the same page
window.viewEmployeeConversations = async function(employeeEmail, employeeName) {
    if (!employeeEmail || !employeeEmail.trim()) {
        alert('Employee email is required to view conversations.');
        return;
    }
    
    try {
        // Get Supabase configuration
        const supabaseUrl = window.SupabaseConfig?.url || '';
        const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
        
        if (!supabaseUrl || !supabaseAnonKey) {
            alert('Configuration error: Supabase credentials not found.');
            return;
        }
        
        // Store current employee info
        currentEmployeeEmail = employeeEmail.trim();
        currentEmployeeName = employeeName || employeeEmail;
        
        // Show conversations section
        const conversationsSection = document.getElementById('conversationsSection');
        const conversationsEmployeeName = document.getElementById('conversationsEmployeeName');
        if (conversationsSection) {
            conversationsSection.style.display = 'block';
            if (conversationsEmployeeName) {
                conversationsEmployeeName.textContent = currentEmployeeName;
            }
            
            // Scroll to conversations section
            conversationsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Set default dates immediately after showing section (use requestAnimationFrame to ensure DOM is ready)
            requestAnimationFrame(() => {
                setDefaultConversationsDateRange();
            });
        }
        
        // Normalize email for lookup (case-insensitive)
        const normalizedEmail = currentEmployeeEmail.toLowerCase().trim();
        
        let adminId = null;
        let adminFound = false;
        
        // First, try to find admin in Supabase cache
        const supabaseClient = window.SupabaseConfig?.getClient?.();
        if (supabaseClient) {
            try {
                const { data: cachedAdmins, error: queryError } = await supabaseClient
                    .from('intercom_admin_cache')
                    .select('id, email, name, admin_data')
                    .eq('email', normalizedEmail)
                    .limit(1);
                
                if (!queryError && cachedAdmins && cachedAdmins.length > 0) {
                    const cachedAdmin = cachedAdmins[0];
                    adminId = cachedAdmin.id || cachedAdmin.admin_data?.id;
                    if (adminId) {
                        adminFound = true;
                    }
                } else if (queryError) {
                    console.warn('âš ï¸ Error querying admin cache:', queryError);
                    // Continue to fallback
                }
            } catch (cacheError) {
                console.warn('âš ï¸ Error accessing Supabase cache:', cacheError);
                // Continue to fallback
            }
        }
        
        // Fallback: If not found in cache, fetch from Intercom API
        if (!adminFound) {
            try {
                // Fetch admins from Intercom API via Supabase Edge Function
                const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=admins`;
                
                const response = await fetch(edgeFunctionUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${supabaseAnonKey}`,
                        'apikey': supabaseAnonKey,
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const admins = data.admins || data || [];
                
                // Find admin with matching email (case-insensitive)
                const admin = admins.find(a => a.email && a.email.toLowerCase() === normalizedEmail);
                
                if (!admin || !admin.id) {
                    showConversationsError(`Admin not found for email: ${employeeEmail}`);
                    return;
                }
                
                adminId = admin.id;
                
                // Optionally cache this admin for future use (async, don't wait)
                if (supabaseClient && admin) {
                    cacheAdminAsync(supabaseClient, admin).catch(err => {
                        console.warn('âš ï¸ Failed to cache admin (non-critical):', err);
                    });
                }
                
            } catch (error) {
                console.error('âŒ Error fetching admin from Intercom API:', error);
                showConversationsError(`Failed to find admin: ${error.message}`);
                return;
            }
        }
        
        if (!adminId) {
            showConversationsError(`Admin ID not found for email: ${employeeEmail}`);
            return;
        }
        
        // Store admin ID
        currentAdminId = adminId;
        
        // Initialize active filters count
        updateActiveFiltersCount();
        
        // Ensure dates are set - wait a bit for DOM to be ready, then verify
        await new Promise(resolve => setTimeout(resolve, 150));
        
        // Verify dates are set, if not set them again
        const startDateInput = document.getElementById('conversationsStartDate');
        const endDateInput = document.getElementById('conversationsEndDate');
        if (startDateInput && endDateInput && (!startDateInput.value || !endDateInput.value)) {
            setDefaultConversationsDateRange();
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Load conversations
        await loadConversationsForEmployee();
        
    } catch (error) {
        console.error('Error finding admin for conversations:', error);
        showConversationsError('Failed to load conversations. Please try again later.');
    }
};

// Close conversations section
window.closeConversationsSection = function() {
    const conversationsSection = document.getElementById('conversationsSection');
    if (conversationsSection) {
        conversationsSection.style.display = 'none';
    }
    // Reset state
    currentEmployeeEmail = null;
    currentEmployeeName = null;
    currentAdminId = null;
    allEmployeeConversations = [];
    rawEmployeeConversations = []; // Clear raw conversations too
    currentConversationsPage = 1;
};

// ============================================================================
// Pull Conversations from Intercom Functions
// ============================================================================

let pullConversationsAdminId = null;
let pullConversationsList = []; // Original unfiltered list from cache/API
let pullConversationsFilteredList = []; // Filtered list for display
let pullConversationsFilters = {
    state: null,
    priority: null,
    rating: null,
    sourceType: null,
    productType: null,
    language: null,
    slaStatus: null,
    minParts: null,
    minReopens: null,
    maxTimeToReply: null,
    clientSearch: null,
    conversationId: null
};

// Pull conversations from Intercom - main function (for current user)
window.pullConversationsFromIntercom = async function() {
    try {
        // Get current user's email from localStorage
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const currentUserEmail = (userInfo.email || '').toLowerCase().trim();
        
        if (!currentUserEmail) {
            showPullConversationsError('User email not found. Please log in again.');
            return;
        }
        
        // Show the section
        const section = document.getElementById('pullConversationsSection');
        if (section) {
            section.style.display = 'block';
            section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        // Set default date to today
        const dateInput = document.getElementById('pullConversationsDate');
        if (dateInput && !dateInput.value) {
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            dateInput.value = todayStr;
        }
        
        // Find admin ID for current user
        await findAdminIdForCurrentUser(currentUserEmail);
        
        // If admin ID found, load conversations
        if (pullConversationsAdminId) {
            const selectedDate = dateInput ? dateInput.value : new Date().toISOString().split('T')[0];
            await fetchConversationsForCurrentUser(selectedDate);
        }
        
    } catch (error) {
        console.error('Error pulling conversations:', error);
        showPullConversationsError(`Failed to pull conversations: ${error.message}`);
    }
};

// Pull conversations for a specific employee (from audit card)
window.pullConversationsForEmployee = async function(employeeEmail, employeeName) {
    try {
        if (!employeeEmail || !employeeEmail.trim()) {
            console.error('âŒ Employee email is required');
            showPullConversationsError('Employee email is required.');
            return;
        }
        
        // Show the section immediately
        const section = document.getElementById('pullConversationsSection');
        if (!section) {
            console.error('âŒ pullConversationsSection element not found!');
            alert('Error: Conversations section not found. Please refresh the page.');
            return;
        }
        
        console.log('âœ… Showing conversations section');
        section.style.display = 'block';
        
        // Hide error and list initially
        const errorDiv = document.getElementById('pullConversationsError');
        const listDiv = document.getElementById('pullConversationsList');
        if (errorDiv) errorDiv.style.display = 'none';
        if (listDiv) listDiv.style.display = 'none';
        
        // Show loading immediately
        const loadingDiv = document.getElementById('pullConversationsLoading');
        if (loadingDiv) {
            loadingDiv.style.display = 'block';
            updateProgressIndicator(10, 'Initializing...');
        }
        
        // Scroll to section
        setTimeout(() => {
            section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);
        
        // Set default date to today
        const dateInput = document.getElementById('pullConversationsDate');
        const today = new Date();
        const todayStr = today.toISOString().split('T')[0];
        if (dateInput) {
            dateInput.value = todayStr;
            console.log('âœ… Date set to:', todayStr);
        }
        
        // Reset admin ID
        pullConversationsAdminId = null;
        
        // Find admin ID for the employee email (look in Supabase cache first)
        console.log('ðŸ” Looking up admin ID for email:', employeeEmail);
        await findAdminIdForEmployee(employeeEmail);
        
        // If admin ID found, load conversations
        if (pullConversationsAdminId) {
            const selectedDate = dateInput ? dateInput.value : todayStr;
            console.log('âœ… Admin ID found:', pullConversationsAdminId);
            console.log('ðŸ“… Fetching conversations for date:', selectedDate);
            await fetchConversationsForCurrentUser(selectedDate);
        } else {
            console.error('âŒ Admin ID not found for email:', employeeEmail);
            if (loadingDiv) loadingDiv.style.display = 'none';
            showPullConversationsError(`Admin ID not found for email: ${employeeEmail}. Please ensure the admin exists in Intercom.`);
        }
        
    } catch (error) {
        console.error('âŒ Error pulling conversations for employee:', error);
        console.error('Error stack:', error.stack);
        const loadingDiv = document.getElementById('pullConversationsLoading');
        if (loadingDiv) loadingDiv.style.display = 'none';
        showPullConversationsError(`Failed to pull conversations: ${error.message}`);
    }
};

// Find admin ID for a specific employee email (looks in Supabase cache first)
// Send email notification to employee when audit is submitted
async function sendAuditEmailNotification(auditData, scorecard) {
    try {
        // Get Supabase configuration
        const supabaseUrl = window.env?.SUPABASE_URL || window.SUPABASE_URL;
        const supabaseAnonKey = window.env?.SUPABASE_ANON_KEY || window.SUPABASE_ANON_KEY;
        
        if (!supabaseUrl || !supabaseAnonKey) {
            console.warn('Supabase configuration not found. Email notification skipped.');
            return;
        }
        
        // Prepare email notification data
        const emailData = {
            employee_email: auditData.employee_email || null,
            employee_name: auditData.employee_name || null,
            auditor_name: auditData.auditor_name || null,
            auditor_email: auditData.auditor_email || null,
            audit_id: auditData.id || null,
            audit_type: auditData.audit_type || null,
            passing_status: auditData.passing_status || null,
            average_score: auditData.average_score || null,
            submitted_at: auditData.submitted_at || null,
            scorecard_name: scorecard?.name || null
        };
        
        // Only send if employee email is available
        if (!emailData.employee_email) {
            console.warn('Employee email not found. Email notification skipped.');
            return;
        }
        
        // Call Supabase Edge Function to send email
        const edgeFunctionUrl = `${supabaseUrl}/functions/v1/send-audit-email`;
        console.log('Sending email notification to:', emailData.employee_email);
        
        const response = await fetch(edgeFunctionUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${supabaseAnonKey}`,
                'apikey': supabaseAnonKey,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(emailData)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Email notification API error:', response.status, response.statusText, errorText);
            // Don't throw - we don't want to fail audit submission if email fails
            return;
        }
        
        const result = await response.json();
        if (result.success) {
            console.log('Email notification sent successfully:', result);
        } else {
            console.warn('Email notification not sent:', result.message || result.warning);
        }
    } catch (error) {
        // Log error but don't throw - we don't want to fail audit submission if email fails
        console.error('Error sending email notification:', error);
    }
}

// Send audit submission webhox                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \
// 
// 
// 
// 
// 


























































//                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \\
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































// Send audit data to n8n workflow
async function sendN8nWebhook(auditData, scorecard) {
    try {
        // Get n8n webhook URL from environment or use default
        // Default URL: https://qaatsaas.app.n8n.cloud/webhook/audit-submission
        const n8nWebhookUrl = window.env?.N8N_WEBHOOK_URL || window.N8N_WEBHOOK_URL || 'https://qaatsaas.app.n8n.cloud/webhook/audit-submission';
        
        if (!n8nWebhookUrl) {
            console.warn('N8N webhook URL not configured. Skipping n8n webhook notification.');
            return;
        }
        
        // Get base URL for audit view link
        const baseUrl = window.location?.origin || window.env?.BASE_URL || window.BASE_URL || '';
        
        // Prepare webhook payload with audit data
        const webhookData = {
            employee_email: auditData.employee_email || null,
            employee_name: auditData.employee_name || null,
            employeeEmail: auditData.employee_email || null, // Alternative field name for compatibility
            employeeName: auditData.employee_name || null,
            auditor_name: auditData.auditor_name || null,
            auditor_email: auditData.auditor_email || null,
            auditorName: auditData.auditor_name || null,
            auditorEmail: auditData.auditor_email || null,
            audit_id: auditData.id || null,
            id: auditData.id || null,
            audit_type: auditData.audit_type || null,
            auditType: auditData.audit_type || null,
            passing_status: auditData.passing_status || null,
            passingStatus: auditData.passing_status || null,
            average_score: auditData.average_score || null,
            averageScore: auditData.average_score || null,
            submitted_at: auditData.submitted_at || null,
            submittedAt: auditData.submitted_at || null,
            scorecard_name: scorecard?.name || null,
            scorecardName: scorecard?.name || null,
            scorecard_id: scorecard?.id || null,
            scorecardId: scorecard?.id || null,
            table_name: scorecard?.table_name || null,
            tableName: scorecard?.table_name || null,
            base_url: baseUrl || null,
            baseUrl: baseUrl || null
        };
        
        // Only send if employee email is available
        if (!webhookData.employee_email) {
            console.warn('Employee email not found. n8n webhook notification skipped.');
            return;
        }
        
        console.log('Sending audit submission to n8n webhook:', n8nWebhookUrl);
        
        const response = await fetch(n8nWebhookUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(webhookData)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('n8n webhook error:', response.status, response.statusText, errorText);
            // Don't throw - we don't want to fail audit submission if webhook fails
            return;
        }
        
        const result = await response.json();
        console.log('n8n webhook triggered successfully:', result);
    } catch (error) {
        // Log error but don't throw - we don't want to fail audit submission if webhook fails
        console.error('Error sending n8n webhook:', error);
    }
}

async function findAdminIdForEmployee(employeeEmail) {
    const normalizedEmail = employeeEmail.toLowerCase().trim();
    let adminId = null;
    let adminFound = false;
    
    // Get Supabase configuration
    const supabaseUrl = window.SupabaseConfig?.url || '';
    const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
    
    if (!supabaseUrl || !supabaseAnonKey) {
        showPullConversationsError('Configuration error: Supabase credentials not found.');
        return;
    }
    
    // First, try to find admin in Supabase cache
    const supabaseClient = window.SupabaseConfig?.getClient?.();
    if (supabaseClient) {
        try {
            console.log('ðŸ” Looking up admin in Supabase cache for email:', normalizedEmail);
            const { data: cachedAdmins, error: queryError } = await supabaseClient
                .from('intercom_admin_cache')
                .select('id, email, name, admin_data')
                .eq('email', normalizedEmail)
                .limit(1);
            
            if (!queryError && cachedAdmins && cachedAdmins.length > 0) {
                const cachedAdmin = cachedAdmins[0];
                adminId = cachedAdmin.id || cachedAdmin.admin_data?.id;
                if (adminId) {
                    console.log('âœ… Admin found in Supabase cache:', adminId);
                    adminFound = true;
                }
            } else if (queryError) {
                console.warn('âš ï¸ Error querying admin cache:', queryError);
            }
        } catch (cacheError) {
            console.warn('âš ï¸ Error accessing Supabase cache:', cacheError);
        }
    }
    
    // Fallback: If not found in cache, fetch from Intercom API
    if (!adminFound) {
        console.log('ðŸ”„ Admin not in cache, fetching from Intercom API...');
        try {
            const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=admins`;
            
            const response = await fetch(edgeFunctionUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${supabaseAnonKey}`,
                    'apikey': supabaseAnonKey,
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            const admins = data.admins || data || [];
            
            // Find admin with matching email (case-insensitive)
            const admin = admins.find(a => a.email && a.email.toLowerCase() === normalizedEmail);
            
            if (!admin || !admin.id) {
                showPullConversationsError(`Admin not found for email: ${employeeEmail}`);
                return;
            }
            
            adminId = admin.id;
            console.log('âœ… Admin found via Intercom API fallback:', adminId);
            
            // Cache this admin for future use (async, don't wait)
            if (supabaseClient && admin) {
                cacheAdminAsync(supabaseClient, admin).catch(err => {
                    console.warn('âš ï¸ Failed to cache admin (non-critical):', err);
                });
            }
            
        } catch (error) {
            console.error('âŒ Error fetching admin from Intercom API:', error);
            showPullConversationsError(`Failed to find admin: ${error.message}`);
            return;
        }
    }
    
    if (!adminId) {
        showPullConversationsError(`Admin ID not found for email: ${employeeEmail}`);
        return;
    }
    
    pullConversationsAdminId = adminId;
}

// Find admin ID for current user
async function findAdminIdForCurrentUser(userEmail) {
    const normalizedEmail = userEmail.toLowerCase().trim();
    let adminId = null;
    let adminFound = false;
    
    // Get Supabase configuration
    const supabaseUrl = window.SupabaseConfig?.url || '';
    const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
    
    if (!supabaseUrl || !supabaseAnonKey) {
        showPullConversationsError('Configuration error: Supabase credentials not found.');
        return;
    }
    
    // First, try to find admin in Supabase cache
    const supabaseClient = window.SupabaseConfig?.getClient?.();
    if (supabaseClient) {
        try {
            console.log('ðŸ” Looking up admin in Supabase cache...');
            const { data: cachedAdmins, error: queryError } = await supabaseClient
                .from('intercom_admin_cache')
                .select('id, email, name, admin_data')
                .eq('email', normalizedEmail)
                .limit(1);
            
            if (!queryError && cachedAdmins && cachedAdmins.length > 0) {
                const cachedAdmin = cachedAdmins[0];
                adminId = cachedAdmin.id || cachedAdmin.admin_data?.id;
                if (adminId) {
                    console.log('âœ… Admin found in Supabase cache');
                    adminFound = true;
                }
            }
        } catch (cacheError) {
            console.warn('âš ï¸ Error accessing Supabase cache:', cacheError);
        }
    }
    
    // Fallback: If not found in cache, fetch from Intercom API
    if (!adminFound) {
        console.log('ðŸ”„ Admin not in cache, fetching from Intercom API...');
        try {
            const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=admins`;
            
            const response = await fetch(edgeFunctionUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${supabaseAnonKey}`,
                    'apikey': supabaseAnonKey,
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            const admins = data.admins || data || [];
            
            // Find admin with matching email (case-insensitive)
            const admin = admins.find(a => a.email && a.email.toLowerCase() === normalizedEmail);
            
            if (!admin || !admin.id) {
                showPullConversationsError(`Admin not found for email: ${employeeEmail}`);
                return;
            }
            
            adminId = admin.id;
            console.log('âœ… Admin found via Intercom API fallback:', adminId);
            
            // Cache this admin for future use (async, don't wait)
            if (supabaseClient && admin) {
                cacheAdminAsync(supabaseClient, admin).catch(err => {
                    console.warn('âš ï¸ Failed to cache admin (non-critical):', err);
                });
            }
            
        } catch (error) {
            console.error('âŒ Error fetching admin from Intercom API:', error);
            showPullConversationsError(`Failed to find admin: ${error.message}`);
            return;
        }
    }
    
    if (!adminId) {
        showPullConversationsError(`Admin ID not found for email: ${employeeEmail}`);
        return;
    }
    
    pullConversationsAdminId = adminId;
    console.log('âœ… Admin ID set:', pullConversationsAdminId);
};

// ============================================================================
// Local Caching Utilities for Conversations (IndexedDB)
// ============================================================================

const CONVERSATION_CACHE_PREFIX = 'conversations_cache_';
const CACHE_EXPIRY_HOURS = 24; // Cache expires after 24 hours
const INDEXEDDB_DB_NAME = 'QMSConversationCache';
const INDEXEDDB_STORE_NAME = 'conversations';
const INDEXEDDB_VERSION = 1;

// Check if IndexedDB is available
const INDEXEDDB_AVAILABLE = typeof indexedDB !== 'undefined';

// Generate cache key from admin ID and date
function getConversationCacheKey(adminId, date) {
    // Normalize adminId to string to ensure consistency
    const normalizedAdminId = String(adminId || '').trim();
    // Normalize date to YYYY-MM-DD format
    let normalizedDate = '';
    if (date) {
        if (typeof date === 'string') {
            normalizedDate = date.trim();
            // If date is in a different format, try to normalize it
            if (normalizedDate.includes('T')) {
                normalizedDate = normalizedDate.split('T')[0];
            }
        } else if (date instanceof Date) {
            normalizedDate = date.toISOString().split('T')[0];
        }
    }
    return `${normalizedAdminId}_${normalizedDate}`;
}

// Initialize IndexedDB database
function initConversationCacheDB() {
    return new Promise((resolve, reject) => {
        if (!INDEXEDDB_AVAILABLE) {
            console.warn('âš ï¸ IndexedDB not available, will use localStorage fallback');
            resolve(null);
            return;
        }

        const request = indexedDB.open(INDEXEDDB_DB_NAME, INDEXEDDB_VERSION);

        request.onerror = () => {
            console.error('âŒ IndexedDB open error:', request.error);
            reject(request.error);
        };

        request.onsuccess = () => {
            console.log('âœ… IndexedDB database opened successfully');
            resolve(request.result);
        };

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            
            // Create object store if it doesn't exist
            if (!db.objectStoreNames.contains(INDEXEDDB_STORE_NAME)) {
                const objectStore = db.createObjectStore(INDEXEDDB_STORE_NAME, { keyPath: 'cacheKey' });
                
                // Create indexes
                objectStore.createIndex('adminId', 'adminId', { unique: false });
                objectStore.createIndex('date', 'date', { unique: false });
                objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                objectStore.createIndex('expiresAt', 'expiresAt', { unique: false });
                
                console.log('âœ… IndexedDB object store and indexes created');
            }
        };
    });
}

// Get database instance (with initialization)
let dbInstance = null;
async function getConversationCacheDB() {
    if (!INDEXEDDB_AVAILABLE) {
        return null;
    }
    
    if (dbInstance) {
        return dbInstance;
    }
    
    try {
        dbInstance = await initConversationCacheDB();
        return dbInstance;
    } catch (error) {
        console.error('âŒ Failed to initialize IndexedDB:', error);
        return null;
    }
}

// Get cached conversations from IndexedDB (with localStorage fallback)
async function getCachedConversations(adminId, date) {
    const cacheKey = getConversationCacheKey(adminId, date);
    console.log('ðŸ” Checking cache with key:', cacheKey, 'for adminId:', adminId, 'date:', date);
    
    // Try IndexedDB first
    const db = await getConversationCacheDB();
    if (db) {
        try {
            return new Promise((resolve) => {
                const transaction = db.transaction([INDEXEDDB_STORE_NAME], 'readonly');
                const store = transaction.objectStore(INDEXEDDB_STORE_NAME);
                const request = store.get(cacheKey);
                
                request.onsuccess = () => {
                    const cachedData = request.result;
                    
                    if (!cachedData) {
                        console.log('ðŸ“¦ No cache found in IndexedDB for:', cacheKey);
                        resolve(null);
                        return;
                    }
                    
                    const now = Date.now();
                    
                    // Check if cache is expired
                    if (cachedData.expiresAt && now > cachedData.expiresAt) {
                        console.log('â° Cache expired for:', cacheKey, 'Expired at:', new Date(cachedData.expiresAt).toISOString());
                        // Delete expired cache
                        deleteCachedConversation(cacheKey);
                        resolve(null);
                        return;
                    }
                    
                    // Validate cache data structure
                    if (!cachedData.data) {
                        console.warn('âš ï¸ Cache data structure invalid, missing data field:', cacheKey);
                        deleteCachedConversation(cacheKey);
                        resolve(null);
                        return;
                    }
                    
                    const conversationCount = cachedData.data.conversations?.length || 0;
                    console.log('âœ… Cache hit in IndexedDB for:', cacheKey, `(${conversationCount} conversations)`, 'Cached at:', new Date(cachedData.timestamp).toISOString());
                    resolve(cachedData.data);
                };
                
                request.onerror = () => {
                    console.warn('âš ï¸ Error reading from IndexedDB:', request.error);
                    resolve(null);
                };
            });
        } catch (error) {
            console.warn('âš ï¸ Error accessing IndexedDB:', error);
            // Fall through to localStorage fallback
        }
    }
    
    // Fallback to localStorage
    try {
        const localStorageKey = CONVERSATION_CACHE_PREFIX + cacheKey;
        const cachedData = localStorage.getItem(localStorageKey);
        
        if (!cachedData) {
            console.log('ðŸ“¦ No cache found in localStorage for:', localStorageKey);
            return null;
        }
        
        const parsed = JSON.parse(cachedData);
        const now = Date.now();
        
        // Check if cache is expired
        if (parsed.expiresAt && now > parsed.expiresAt) {
            console.log('â° Cache expired for:', localStorageKey, 'Expired at:', new Date(parsed.expiresAt).toISOString());
            localStorage.removeItem(localStorageKey);
            return null;
        }
        
        // Validate cache data structure
        if (!parsed.data) {
            console.warn('âš ï¸ Cache data structure invalid, missing data field:', localStorageKey);
            localStorage.removeItem(localStorageKey);
            return null;
        }
        
        const conversationCount = parsed.data.conversations?.length || 0;
        console.log('âœ… Cache hit in localStorage for:', localStorageKey, `(${conversationCount} conversations)`, 'Cached at:', new Date(parsed.timestamp).toISOString());
        return parsed.data;
        
    } catch (error) {
        console.warn('âš ï¸ Error reading from localStorage:', error);
        return null;
    }
}

// Delete a cached conversation
async function deleteCachedConversation(cacheKey) {
    const db = await getConversationCacheDB();
    if (db) {
        try {
            const transaction = db.transaction([INDEXEDDB_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(INDEXEDDB_STORE_NAME);
            store.delete(cacheKey);
        } catch (error) {
            console.warn('âš ï¸ Error deleting from IndexedDB:', error);
        }
    }
    
    // Also try localStorage
    try {
        localStorage.removeItem(CONVERSATION_CACHE_PREFIX + cacheKey);
    } catch (error) {
        // Ignore
    }
}

// Store conversations in cache (IndexedDB with localStorage fallback)
async function cacheConversations(adminId, date, data) {
    // Validate inputs
    if (!adminId || !date || !data) {
        console.warn('âš ï¸ Cannot cache: missing required parameters', { adminId, date, hasData: !!data });
        return false;
    }
    
    const cacheKey = getConversationCacheKey(adminId, date);
    console.log('ðŸ’¾ Cache save attempt - Key:', cacheKey, 'AdminId:', adminId, 'Date:', date);
    
    const expiresAt = Date.now() + (CACHE_EXPIRY_HOURS * 60 * 60 * 1000); // 24 hours from now
    
    const cacheData = {
        cacheKey: cacheKey,
        adminId: String(adminId), // Normalize to string
        date: String(date), // Normalize to string
        data: data,
        timestamp: Date.now(),
        expiresAt: expiresAt,
        conversationCount: data.conversations?.length || 0
    };
    
    // Try IndexedDB first
    const db = await getConversationCacheDB();
    if (db) {
        try {
            return new Promise((resolve) => {
                const transaction = db.transaction([INDEXEDDB_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INDEXEDDB_STORE_NAME);
                const request = store.put(cacheData);
                
                request.onsuccess = () => {
                    const sizeInMB = (JSON.stringify(cacheData).length / (1024 * 1024)).toFixed(2);
                    console.log('âœ… Successfully cached conversations in IndexedDB for:', cacheKey, `(${cacheData.conversationCount} conversations, ${sizeInMB}MB)`, 'Expires:', new Date(expiresAt).toISOString());
                    resolve(true);
                };
                
                request.onerror = async () => {
                    console.warn('âš ï¸ Error saving to IndexedDB:', request.error);
                    // Fall through to localStorage fallback
                    const result = await cacheToLocalStorage(cacheKey, cacheData);
                    resolve(result);
                };
            });
        } catch (error) {
            console.warn('âš ï¸ Error accessing IndexedDB:', error);
            // Fall through to localStorage fallback
            return await cacheToLocalStorage(cacheKey, cacheData);
        }
    }
    
    // Fallback to localStorage
    return await cacheToLocalStorage(cacheKey, cacheData);
}

// Helper function to cache to localStorage (fallback)
async function cacheToLocalStorage(cacheKey, cacheData) {
    try {
        const localStorageKey = CONVERSATION_CACHE_PREFIX + cacheKey;
        const cacheString = JSON.stringify(cacheData);
        const sizeInMB = (cacheString.length / (1024 * 1024)).toFixed(2);
        
        // Check if data is too large for localStorage (limit is ~5-10MB, but be conservative)
        if (cacheString.length > 2 * 1024 * 1024) { // 2MB limit per entry (more conservative)
            console.warn('âš ï¸ Cache data too large for localStorage (' + sizeInMB + 'MB), skipping cache storage.');
            return false;
        }
        
        localStorage.setItem(localStorageKey, cacheString);
        
        // Verify it was saved
        const verifyCache = localStorage.getItem(localStorageKey);
        if (!verifyCache) {
            console.error('âŒ Cache save failed: Item not found after save attempt');
            return false;
        }
        
        console.log('âœ… Successfully cached conversations in localStorage for:', localStorageKey, `(${cacheData.conversationCount} conversations, ${sizeInMB}MB)`, 'Expires:', new Date(cacheData.expiresAt).toISOString());
        return true;
        
    } catch (error) {
        // Handle quota exceeded error
        if (error.name === 'QuotaExceededError' || error.code === 22) {
            console.warn('âš ï¸ localStorage quota exceeded, clearing old cache entries...');
            await clearOldCacheEntries();
            
            // Try once more after clearing
            try {
                const localStorageKey = CONVERSATION_CACHE_PREFIX + cacheKey;
                localStorage.setItem(localStorageKey, JSON.stringify(cacheData));
                const verifyCache = localStorage.getItem(localStorageKey);
                if (verifyCache) {
                    console.log('âœ… Cached to localStorage after clearing old entries');
                    return true;
                }
            } catch (retryError) {
                console.warn('âš ï¸ Still unable to cache to localStorage after clearing:', retryError);
            }
        }
        console.warn('âš ï¸ Error caching to localStorage:', error);
        return false;
    }
}

// Clear old cache entries (keep only last 50 entries for IndexedDB, or last 5 for localStorage)
async function clearOldCacheEntries() {
    const db = await getConversationCacheDB();
    
    if (db) {
        // Use IndexedDB cleanup
        try {
            return new Promise((resolve) => {
                const transaction = db.transaction([INDEXEDDB_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INDEXEDDB_STORE_NAME);
                const index = store.index('timestamp');
                const request = index.openCursor(null, 'prev'); // Descending order (newest first)
                
                const entries = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        entries.push(cursor.value);
                        cursor.continue();
                    } else {
                        // All entries loaded, now process
                        if (entries.length === 0) {
                            console.log('ðŸ“¦ No cache entries to clear in IndexedDB');
                            resolve();
                            return;
                        }
                        
                        // Calculate total size
                        const totalSize = entries.reduce((sum, entry) => {
                            return sum + (JSON.stringify(entry).length || 0);
                        }, 0);
                        const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
                        console.log(`ðŸ“Š IndexedDB cache stats: ${entries.length} entries, ${totalSizeMB}MB total`);
                        
                        // Keep last 50 entries (IndexedDB can handle much more)
                        const maxEntries = 50;
                        if (entries.length > maxEntries) {
                            const toRemove = entries.slice(maxEntries);
                            const deleteTransaction = db.transaction([INDEXEDDB_STORE_NAME], 'readwrite');
                            const deleteStore = deleteTransaction.objectStore(INDEXEDDB_STORE_NAME);
                            
                            let deletedCount = 0;
                            toRemove.forEach(entry => {
                                deleteStore.delete(entry.cacheKey);
                                deletedCount++;
                                console.log(`ðŸ—‘ï¸ Removed old cache from IndexedDB: ${entry.cacheKey} (${entry.conversationCount || 0} conversations)`);
                            });
                            
                            console.log(`ðŸ—‘ï¸ Removed ${deletedCount} old cache entries from IndexedDB`);
                        }
                        
                        // If still too large (more than 500MB), be more aggressive - keep only last 30
                        if (totalSize > 500 * 1024 * 1024 && entries.length > 30) {
                            console.warn('âš ï¸ IndexedDB cache still too large, keeping only last 30 entries');
                            const toRemove = entries.slice(30);
                            const deleteTransaction = db.transaction([INDEXEDDB_STORE_NAME], 'readwrite');
                            const deleteStore = deleteTransaction.objectStore(INDEXEDDB_STORE_NAME);
                            
                            toRemove.forEach(entry => {
                                deleteStore.delete(entry.cacheKey);
                            });
                        }
                        
                        resolve();
                    }
                };
                
                request.onerror = () => {
                    console.warn('âš ï¸ Error reading from IndexedDB for cleanup:', request.error);
                    resolve();
                };
            });
        } catch (error) {
            console.warn('âš ï¸ Error clearing IndexedDB cache:', error);
        }
    }
    
    // Fallback to localStorage cleanup
    try {
        const cacheKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(CONVERSATION_CACHE_PREFIX)) {
                cacheKeys.push(key);
            }
        }
        
        if (cacheKeys.length === 0) {
            console.log('ðŸ“¦ No cache entries to clear in localStorage');
            return;
        }
        
        // Sort by timestamp (newest first) and calculate sizes
        const cacheEntries = cacheKeys.map(key => {
            try {
                const data = localStorage.getItem(key);
                const parsed = JSON.parse(data);
                const size = new Blob([data]).size;
                return { 
                    key, 
                    timestamp: parsed.timestamp || 0,
                    size: size,
                    conversationCount: parsed.data?.conversations?.length || 0
                };
            } catch {
                return { key, timestamp: 0, size: 0, conversationCount: 0 };
            }
        }).sort((a, b) => b.timestamp - a.timestamp);
        
        // Calculate total cache size
        const totalSize = cacheEntries.reduce((sum, entry) => sum + entry.size, 0);
        const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
        console.log(`ðŸ“Š localStorage cache stats: ${cacheEntries.length} entries, ${totalSizeMB}MB total`);
        
        // If we have more than 5 entries, remove oldest ones
        if (cacheEntries.length > 5) {
            const toRemove = cacheEntries.slice(5);
            const removedSize = toRemove.reduce((sum, entry) => sum + entry.size, 0);
            toRemove.forEach(entry => {
                localStorage.removeItem(entry.key);
                console.log(`ðŸ—‘ï¸ Removed old cache from localStorage: ${entry.key} (${entry.conversationCount} conversations, ${(entry.size / 1024).toFixed(1)}KB)`);
            });
            console.log(`ðŸ—‘ï¸ Removed ${toRemove.length} old cache entries from localStorage, freed ${(removedSize / (1024 * 1024)).toFixed(2)}MB`);
        }
    } catch (error) {
        console.warn('âš ï¸ Error clearing localStorage cache:', error);
    }
}

// Clear all conversation caches
function clearAllConversationCaches() {
    try {
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(CONVERSATION_CACHE_PREFIX)) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
        console.log(`ðŸ—‘ï¸ Cleared ${keysToRemove.length} cache entries`);
        return keysToRemove.length;
    } catch (error) {
        console.warn('âš ï¸ Error clearing caches:', error);
        return 0;
    }
}

// Fetch conversations for current user
async function fetchConversationsForCurrentUser(selectedDate) {
    if (!pullConversationsAdminId) {
        showPullConversationsError('Admin ID not found. Please try again.');
        return;
    }
    
    // Hide elements during loading
    hideElementsDuringLoading();
    
    // Show loading state
    const loadingDiv = document.getElementById('pullConversationsLoading');
    const errorDiv = document.getElementById('pullConversationsError');
    const listDiv = document.getElementById('pullConversationsList');
    
    if (loadingDiv) loadingDiv.style.display = 'block';
    if (errorDiv) errorDiv.style.display = 'none';
    if (listDiv) listDiv.style.display = 'none';
    
    // Get Supabase configuration
    const supabaseUrl = window.SupabaseConfig?.url || '';
    const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
    
    // Normalize adminId and date for cache lookup
    const normalizedAdminId = String(pullConversationsAdminId || '').trim();
    const normalizedDate = selectedDate ? String(selectedDate).trim().split('T')[0] : '';
    
    if (!normalizedAdminId || !normalizedDate) {
        console.warn('âš ï¸ Cannot check cache: missing adminId or date', { 
            adminId: normalizedAdminId, 
            date: normalizedDate,
            pullConversationsAdminId: pullConversationsAdminId,
            selectedDate: selectedDate
        });
        // Don't proceed if we don't have required info
        if (!normalizedAdminId) {
            showPullConversationsError('Admin ID is missing. Please pull conversations again.');
            if (loadingDiv) loadingDiv.style.display = 'none';
            return;
        }
        if (!normalizedDate) {
            showPullConversationsError('Please select a date.');
            if (loadingDiv) loadingDiv.style.display = 'none';
            return;
        }
    }
    
    // Check cache first
    console.log('ðŸ” Cache check - AdminId:', normalizedAdminId, 'Date:', normalizedDate, 'Raw adminId:', pullConversationsAdminId, 'Raw date:', selectedDate);
    const cachedData = await getCachedConversations(normalizedAdminId, normalizedDate);
    if (cachedData) {
        console.log('âœ… Using cached data, skipping API call');
        console.log('ðŸ“¦ Using cached data');
        updateProgressIndicator(10, 'Loading from cache...');
        
        // Small delay to show cache loading
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Extract conversations from cached data
        let conversations = [];
        if (cachedData && Array.isArray(cachedData.conversations)) {
            conversations = cachedData.conversations;
        } else if (cachedData && cachedData.type === 'conversation.list' && Array.isArray(cachedData.conversations)) {
            conversations = cachedData.conversations;
        }
        
        const participationCount = cachedData.participation_count || 0;
        
        console.log(`âœ… Loaded ${conversations.length} conversations from cache`);
        console.log('ðŸ“‹ First conversation sample:', conversations[0] ? Object.keys(conversations[0]) : 'No conversations');
        
        // Update progress: Complete
        updateProgressIndicator(100, 'Loaded from cache');
        
        // Small delay to show completion
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Store conversations (original unfiltered list)
        pullConversationsList = conversations;
        
        // Initialize filtered list with all conversations
        pullConversationsFilteredList = [...conversations];
        
        // Only apply filters if any are actually set
        const hasActiveFilters = Object.values(pullConversationsFilters).some(value => value !== null && value !== '');
        if (hasActiveFilters) {
            filterPullConversations();
        } else {
            // No filters, just display all conversations
            displayPullConversationsList(conversations);
            const countElement = document.getElementById('pullConversationsCount');
            if (countElement) {
                countElement.textContent = conversations.length;
            }
        }
        
        // Hide loading and show results
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (listDiv) listDiv.style.display = 'block';
        
        // Show elements after loading
        showElementsAfterLoading();
        
        // Update active filters display
        updatePullConversationsActiveFilters();
        return;
    }
    
    // No cache found, fetch from API
    console.log('ðŸŒ Fetching from API (no cache found)');
    
    // Update progress: Initial
    updateProgressIndicator(10, 'Pulling from Intercom...');
    
    try {
        // Build edge function URL
        const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=conversations&admin_id=${encodeURIComponent(pullConversationsAdminId)}&updated_date=${encodeURIComponent(selectedDate)}`;
        
        console.log('ðŸ“¡ Calling:', edgeFunctionUrl);
        
        // Update progress: Searching
        updateProgressIndicator(20, 'Searching conversations in Intercom...');
        
        const response = await fetch(edgeFunctionUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${supabaseAnonKey}`,
                'apikey': supabaseAnonKey,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            const errorMsg = errorData.error || `HTTP ${response.status}: ${response.statusText}`;
            throw new Error(errorMsg);
        }

        // Update progress: Processing
        updateProgressIndicator(70, 'Processing participation data...');
        
        const data = await response.json();
        
        // Extract conversations from response first to validate
        let conversations = [];
        if (data && Array.isArray(data.conversations)) {
            conversations = data.conversations;
        } else if (data && data.type === 'conversation.list' && Array.isArray(data.conversations)) {
            conversations = data.conversations;
        }
        
        const participationCount = data.participation_count || 0;
        
        // Only cache if we have valid data
        if (data && conversations.length >= 0) {
            console.log('ðŸ’¾ Attempting to cache data...', { adminId: normalizedAdminId, date: normalizedDate, conversationCount: conversations.length });
            const cacheResult = await cacheConversations(normalizedAdminId, normalizedDate, data);
            if (cacheResult) {
                console.log('âœ… Cache saved successfully');
            } else {
                console.warn('âš ï¸ Cache save failed or was skipped');
            }
        } else {
            console.warn('âš ï¸ Not caching: invalid or empty data', data);
        }
        
        console.log(`âœ… Fetched ${conversations.length} participated conversations`);
        
        // Update progress: Complete
        updateProgressIndicator(100, 'Almost done...');
        
        // Small delay to show completion
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Store conversations (original unfiltered list)
        pullConversationsList = conversations;
        
        // Initialize filtered list with all conversations
        pullConversationsFilteredList = [...conversations];
        
        // Only apply filters if any are actually set
        const hasActiveFilters = Object.values(pullConversationsFilters).some(value => value !== null && value !== '');
        if (hasActiveFilters) {
            filterPullConversations();
        } else {
            // No filters, just display all conversations
            displayPullConversationsList(conversations);
            const countElement = document.getElementById('pullConversationsCount');
            if (countElement) {
                countElement.textContent = conversations.length;
            }
        }
        
        // Hide loading and show results
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (listDiv) listDiv.style.display = 'block';
        
        // Show elements after loading
        showElementsAfterLoading();
        
        // Update active filters display
        updatePullConversationsActiveFilters();
        
    } catch (error) {
        console.error('âŒ Error fetching conversations:', error);
        showPullConversationsError(`Failed to fetch conversations: ${error.message}`);
        if (loadingDiv) loadingDiv.style.display = 'none';
    }
}

// Update progress indicator
function updateProgressIndicator(percentage, message) {
    const statusElement = document.getElementById('pullConversationsStatus');
    const progressBar = document.getElementById('pullConversationsProgressBar');
    const progressText = document.getElementById('pullConversationsProgress');
    
    if (statusElement) {
        statusElement.textContent = message || 'Pulling from Intercom...';
    }
    
    if (progressBar) {
        progressBar.style.width = `${percentage}%`;
    }
    
    if (progressText && percentage === 100) {
        progressText.textContent = `âœ… Loaded ${pullConversationsList.length} conversations`;
        setTimeout(() => {
            if (progressText) {
                progressText.textContent = '';
            }
        }, 3000);
    }
}

// Hide elements during loading
function hideElementsDuringLoading() {
    const dateSelector = document.getElementById('pullConversationsDate');
    const countDisplay = document.querySelector('#pullConversationsSection > div:nth-child(2)');
    
    if (dateSelector) {
        dateSelector.style.opacity = '0.5';
        dateSelector.disabled = true;
    }
    if (countDisplay) {
        countDisplay.style.opacity = '0.5';
    }
}

// Show elements after loading
function showElementsAfterLoading() {
    const dateSelector = document.getElementById('pullConversationsDate');
    const countDisplay = document.querySelector('#pullConversationsSection > div:nth-child(2)');
    
    if (dateSelector) {
        dateSelector.style.opacity = '1';
        dateSelector.disabled = false;
    }
    if (countDisplay) {
        countDisplay.style.opacity = '1';
    }
}

// Display conversations list
function displayPullConversationsList(conversations) {
    const tableBody = document.getElementById('pullConversationsTableBody');
    if (!tableBody) return;
    
        tableBody.innerHTML = '';
    
    if (conversations.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="17" style="text-align: center; padding: 1.9406rem; color: #9ca3af;">No conversations found for the selected date.</td></tr>';
        return;
    }
    
    conversations.forEach(conversation => {
        const row = document.createElement('tr');
        row.style.cursor = 'pointer';
        row.onclick = () => {
            window.startAuditFromConversation(conversation);
        };
        
        // Extract data
        const clientName = extractClientName(conversation) || 'Unknown';
        const clientEmail = extractClientEmail(conversation) || '';
        const conversationId = (conversation.id || 'N/A').toString();
        const subject = conversation.source?.subject || (conversation.source?.body ? conversation.source.body.substring(0, 50) : '') || 'No subject';
        // Product type is the subject in this case
        const productType = subject || '-';
        const rating = conversation.conversation_rating?.rating || '-';
        const state = conversation.state || 'unknown';
        const partsCount = conversation.participation_part_count || 0;
        const createdDate = conversation.created_at_iso || (conversation.created_at ? new Date(conversation.created_at * 1000).toLocaleDateString() : '-');
        const updatedDate = conversation.updated_at_iso || (conversation.updated_at ? new Date(conversation.updated_at * 1000).toLocaleDateString() : '-');
        
        // Extract additional attributes
        const sourceType = conversation.source?.type || '-';
        const language = (conversation.custom_attributes?.['Language'] || '-').toString();
        const priority = conversation.priority || 'not_priority';
        const totalParts = conversation.statistics?.count_conversation_parts || 0;
        const timeToReply = conversation.statistics?.time_to_admin_reply;
        const reopens = conversation.statistics?.count_reopens || 0;
        const slaStatus = conversation.sla_applied?.sla_status || '-';
        const slaName = conversation.sla_applied?.sla_name || '';
        const tags = conversation.tags?.tags || [];
        
        // Format rating (compact)
        let ratingHtml = '-';
        if (rating && rating !== '-') {
            const ratingColor = rating >= 4 ? '#10b981' : rating >= 3 ? '#f59e0b' : '#ef4444';
            ratingHtml = `<span style="color: ${ratingColor}; font-weight: 600; font-size: 0.6875rem;">${rating}/5</span>`;
        }
        
        // Format state (compact badge)
        const stateColor = state === 'closed' ? '#10b981' : state === 'open' ? '#f59e0b' : '#6b7280';
        const stateBadge = `<span style="background: ${stateColor === '#10b981' ? '#d1fae5' : stateColor === '#f59e0b' ? '#fef3c7' : '#f3f4f6'}; color: ${stateColor}; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.625rem; font-weight: 500;">${state}</span>`;
        
        // Format source (icon only)
        const sourceIcons = {
            'email': 'âœ‰ï¸',
            'conversation': 'ðŸ’¬',
            'chat': 'ðŸ’¬',
            'facebook': 'ðŸ“˜',
            'twitter': 'ðŸ¦',
            'whatsapp': 'ðŸ’š'
        };
        const sourceIcon = sourceIcons[sourceType.toLowerCase()] || 'ðŸ“§';
        const sourceDisplay = sourceType !== '-' ? sourceIcon : '-';
        
        // Format priority (icon only)
        const priorityBadge = priority === 'priority' 
            ? `<span style="color: #dc2626; font-size: 0.875rem;" title="Priority">ðŸ”´</span>`
            : `<span style="color: #9ca3af; font-size: 0.6875rem;">-</span>`;
        
        // Format time to reply (compact)
        let timeToReplyHtml = '-';
        if (timeToReply !== null && timeToReply !== undefined) {
            const minutes = Math.round(timeToReply / 60);
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            let timeDisplay = '';
            if (hours > 0) {
                timeDisplay = `${hours}h${mins > 0 ? mins + 'm' : ''}`;
            } else {
                timeDisplay = `${mins}m`;
            }
            const timeColor = minutes <= 5 ? '#10b981' : minutes <= 30 ? '#f59e0b' : '#ef4444';
            timeToReplyHtml = `<span style="color: ${timeColor}; font-weight: 600; font-size: 0.6875rem;" title="${timeDisplay}">${timeDisplay}</span>`;
        }
        
        // Format reopens (compact)
        const reopensBadge = reopens > 0
            ? `<span style="color: ${reopens >= 3 ? '#dc2626' : '#d97706'}; font-weight: 600; font-size: 0.6875rem;" title="${reopens} reopen${reopens > 1 ? 's' : ''}">${reopens}</span>`
            : '<span style="color: #9ca3af; font-size: 0.6875rem;">-</span>';
        
        // Format SLA status (icon only)
        let slaStatusHtml = '-';
        if (slaStatus !== '-') {
            const slaIcon = slaStatus === 'active' ? 'âœ…' : slaStatus === 'missed' ? 'âŒ' : 'âšª';
            const slaColor = slaStatus === 'active' ? '#10b981' : slaStatus === 'missed' ? '#ef4444' : '#6b7280';
            slaStatusHtml = `<span style="color: ${slaColor}; font-size: 0.75rem;" title="${slaName} - ${slaStatus}">${slaIcon}</span>`;
        }
        
        // Format tags (compact, show first 2)
        let tagsHtml = '-';
        if (tags && tags.length > 0) {
            const displayTags = tags.slice(0, 2).map(tag => {
                const tagName = (tag.name || tag || '').toString();
                return tagName;
            }).filter(tag => tag);
            if (displayTags.length > 0) {
                tagsHtml = `<div style="display: flex; flex-wrap: wrap; gap: 0.125rem; max-width: 8rem;">
                    ${displayTags.map(tag => `<span style="background: #e0e7ff; color: #4338ca; padding: 0.0625rem 0.25rem; border-radius: 0.125rem; font-size: 0.5625rem; font-weight: 500;">${escapeHtml(tag.substring(0, 8))}</span>`).join('')}
                    ${tags.length > 2 ? `<span style="color: #6b7280; font-size: 0.5625rem;" title="${tags.slice(2).map(t => (t.name || t || '').toString()).join(', ')}">+${tags.length - 2}</span>` : ''}
                </div>`;
            }
        }
        
        // Format dates (compact)
        const createdDateShort = createdDate !== '-' ? new Date(createdDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : '-';
        const updatedDateShort = updatedDate !== '-' ? new Date(updatedDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : '-';
        
        row.innerHTML = `
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle;">
                <div style="font-weight: 500; color: #111827; font-size: 0.75rem; line-height: 1.2;">${escapeHtml(clientName)}</div>
                <div style="font-size: 0.625rem; color: #6b7280; line-height: 1.2;">${clientEmail ? escapeHtml(clientEmail.substring(0, 20)) + (clientEmail.length > 20 ? '...' : '') : '-'}</div>
            </td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle;">
                <div style="display: flex; align-items: center; gap: 0.25rem;">
                    <span style="font-family: monospace; font-size: 0.625rem; color: #6b7280;">${conversationId && conversationId !== 'N/A' ? conversationId.substring(0, 8) + '...' : 'N/A'}</span>
                    <button onclick="event.stopPropagation(); copyToClipboard('${conversationId}', this);" style="padding: 0.125rem; background: transparent; border: none; cursor: pointer; color: #6b7280; transition: all 0.2s;" onmouseover="this.style.color='#1A733E';" onmouseout="this.style.color='#6b7280';" title="Copy ID">
                        <svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                    </button>
                </div>
            </td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle;">
                <div style="max-width: 10rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 0.75rem; color: #374151;" title="${escapeHtml(subject)}">${escapeHtml(subject)}</div>
            </td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center; font-size: 0.875rem;" title="${sourceType}">${sourceDisplay}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center; font-size: 0.6875rem; color: #374151; max-width: 5rem; overflow: hidden; text-overflow: ellipsis;" title="${escapeHtml(productType)}">${escapeHtml(productType)}</td>
                    <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center; font-size: 0.6875rem; color: #6b7280;">${language && language !== '-' ? escapeHtml(language.substring(0, 3)) : '-'}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center;">${ratingHtml}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center;">${stateBadge}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center;">${priorityBadge}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center;">
                ${partsCount > 0 ? `<span style="background: #dbeafe; color: #1e40af; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.6875rem; font-weight: 600; display: inline-block;">${partsCount}</span>` : '<span style="color: #9ca3af; font-size: 0.6875rem;">-</span>'}
            </td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center; font-size: 0.6875rem; color: #374151; font-weight: 500;">${totalParts > 0 ? totalParts : '-'}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center; white-space: nowrap;">${timeToReplyHtml}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center;">${reopensBadge}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center;">${slaStatusHtml}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; max-width: 8rem;">${tagsHtml}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; font-size: 0.6875rem; color: #6b7280; white-space: nowrap; text-align: center;" title="${createdDate}">${createdDateShort}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; font-size: 0.6875rem; color: #6b7280; white-space: nowrap; text-align: center;" title="${updatedDate}">${updatedDateShort}</td>
            <td style="padding: 0.375rem 0.5rem; vertical-align: middle; text-align: center;">
                <button 
                    class="start-audit-from-conversation-btn"
                    data-conversation-id="${conversation.id}"
                    style="padding: 0.25rem 0.5rem; font-size: 0.6875rem; font-weight: 500; color: #1A733E; background: #d1fae5; border: none; border-radius: 0.25rem; cursor: pointer; transition: all 0.2s; white-space: nowrap;"
                    onmouseover="this.style.background='#a7f3d0'"
                    onmouseout="this.style.background='#d1fae5'"
                >
                    Audit
                </button>
            </td>
        `;
        
        // Attach click handler to the button using the conversation from closure
        const auditButton = row.querySelector('.start-audit-from-conversation-btn');
        if (auditButton) {
            auditButton.addEventListener('click', (e) => {
                e.stopPropagation();
                window.startAuditFromConversation(conversation);
            });
        }
        
        tableBody.appendChild(row);
    });
}

// Show error message
function showPullConversationsError(message) {
    const errorDiv = document.getElementById('pullConversationsError');
    const errorMessage = document.getElementById('pullConversationsErrorMessage');
    const loadingDiv = document.getElementById('pullConversationsLoading');
    const listDiv = document.getElementById('pullConversationsList');
    
    if (errorDiv && errorMessage) {
        errorMessage.textContent = message;
        errorDiv.style.display = 'block';
    }
    if (loadingDiv) loadingDiv.style.display = 'none';
    if (listDiv) listDiv.style.display = 'none';
}

// Close pull conversations section
window.closePullConversationsSection = function() {
    const section = document.getElementById('pullConversationsSection');
    if (section) {
        section.style.display = 'none';
    }
    // Reset state
    pullConversationsAdminId = null;
    pullConversationsList = [];
    pullConversationsFilteredList = [];
    pullConversationsFilters = {
        state: null,
        priority: null,
        rating: null,
        sourceType: null,
        productType: null,
        language: null,
        slaStatus: null,
        minParts: null,
        minReopens: null,
        maxTimeToReply: null,
        clientSearch: null,
        conversationId: null
    };
};

// ============================================================================
// Pull Conversations Filtering Functions
// ============================================================================

// Open filter dialog
window.openPullConversationsFilterDialog = function() {
    const modal = document.getElementById('pullConversationsFilterModal');
    if (!modal) return;
    
    // Set current filter values in the form
    document.getElementById('pullFilterState').value = pullConversationsFilters.state || '';
    document.getElementById('pullFilterPriority').value = pullConversationsFilters.priority || '';
    document.getElementById('pullFilterRating').value = pullConversationsFilters.rating || '';
    document.getElementById('pullFilterSourceType').value = pullConversationsFilters.sourceType || '';
    document.getElementById('pullFilterProductType').value = pullConversationsFilters.productType || '';
    document.getElementById('pullFilterLanguage').value = pullConversationsFilters.language || '';
    document.getElementById('pullFilterSlaStatus').value = pullConversationsFilters.slaStatus || '';
    document.getElementById('pullFilterMinParts').value = pullConversationsFilters.minParts || '';
    document.getElementById('pullFilterMinReopens').value = pullConversationsFilters.minReopens || '';
    document.getElementById('pullFilterMaxTimeToReply').value = pullConversationsFilters.maxTimeToReply || '';
    document.getElementById('pullFilterClientSearch').value = pullConversationsFilters.clientSearch || '';
    document.getElementById('pullFilterConversationId').value = pullConversationsFilters.conversationId || '';
    
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    
    // Close on Escape key
    const escapeHandler = (e) => {
        if (e.key === 'Escape') {
            closePullConversationsFilterDialog();
            document.removeEventListener('keydown', escapeHandler);
        }
    };
    document.addEventListener('keydown', escapeHandler);
};

// Close filter dialog
window.closePullConversationsFilterDialog = function() {
    const modal = document.getElementById('pullConversationsFilterModal');
    if (modal) {
        modal.style.display = 'none';
    }
    document.body.style.overflow = '';
};

// Apply filters to conversations
window.applyPullConversationsFilters = function() {
    // Get filter values from form - normalize empty strings to null
    const getValue = (id) => {
        const el = document.getElementById(id);
        const val = el ? el.value : '';
        return val && val.trim() ? val.trim() : null;
    };
    
    const getNumberValue = (id) => {
        const el = document.getElementById(id);
        const val = el ? el.value : '';
        return val && val.trim() ? parseInt(val.trim()) : null;
    };
    
    pullConversationsFilters.state = getValue('pullFilterState');
    pullConversationsFilters.priority = getValue('pullFilterPriority');
    pullConversationsFilters.rating = getValue('pullFilterRating');
    pullConversationsFilters.sourceType = getValue('pullFilterSourceType');
    pullConversationsFilters.productType = getValue('pullFilterProductType');
    pullConversationsFilters.language = getValue('pullFilterLanguage');
    pullConversationsFilters.slaStatus = getValue('pullFilterSlaStatus');
    pullConversationsFilters.minParts = getNumberValue('pullFilterMinParts');
    pullConversationsFilters.minReopens = getNumberValue('pullFilterMinReopens');
    pullConversationsFilters.maxTimeToReply = getNumberValue('pullFilterMaxTimeToReply');
    pullConversationsFilters.clientSearch = getValue('pullFilterClientSearch');
    pullConversationsFilters.conversationId = getValue('pullFilterConversationId');
    
    console.log('ðŸŽ¯ Applied filters:', pullConversationsFilters);
    
    // Apply filters
    filterPullConversations();
    
    // Close modal
    closePullConversationsFilterDialog();
    
    // Update active filters display
    updatePullConversationsActiveFilters();
};

// Filter conversations based on current filters
function filterPullConversations() {
    console.log('ðŸ” Filtering conversations...');
    console.log('ðŸ“Š Original list length:', pullConversationsList?.length || 0);
    console.log('ðŸŽ¯ Active filters:', pullConversationsFilters);
    
    if (!pullConversationsList || pullConversationsList.length === 0) {
        console.log('âš ï¸ No conversations to filter');
        pullConversationsFilteredList = [];
        displayPullConversationsList([]);
        return;
    }
    
    let filtered = [...pullConversationsList]; // Create a copy
    const initialCount = filtered.length;
    
    // Filter by state
    if (pullConversationsFilters.state) {
        const beforeCount = filtered.length;
        filtered = filtered.filter(conv => {
            const matches = conv.state === pullConversationsFilters.state;
            if (!matches && beforeCount <= 5) {
                console.log(`âŒ State filter: conv.state=${conv.state}, filter=${pullConversationsFilters.state}`);
            }
            return matches;
        });
        console.log(`ðŸ” State filter (${pullConversationsFilters.state}): ${beforeCount} â†’ ${filtered.length}`);
    }
    
    // Filter by priority
    if (pullConversationsFilters.priority) {
        const beforeCount = filtered.length;
        filtered = filtered.filter(conv => {
            const matches = conv.priority === pullConversationsFilters.priority;
            if (!matches && beforeCount <= 5) {
                console.log(`âŒ Priority filter: conv.priority=${conv.priority}, filter=${pullConversationsFilters.priority}`);
            }
            return matches;
        });
        console.log(`ðŸ” Priority filter (${pullConversationsFilters.priority}): ${beforeCount} â†’ ${filtered.length}`);
    }
    
    // Filter by rating
    if (pullConversationsFilters.rating) {
        const beforeCount = filtered.length;
        if (pullConversationsFilters.rating === 'unrated') {
            filtered = filtered.filter(conv => !conv.conversation_rating || !conv.conversation_rating.rating);
        } else {
            const ratingNum = parseInt(pullConversationsFilters.rating);
            filtered = filtered.filter(conv => {
                const convRating = conv.conversation_rating?.rating;
                const matches = convRating === ratingNum;
                if (!matches && beforeCount <= 5) {
                    console.log(`âŒ Rating filter: conv.rating=${convRating}, filter=${ratingNum}`);
                }
                return matches;
            });
        }
        console.log(`ðŸ” Rating filter (${pullConversationsFilters.rating}): ${beforeCount} â†’ ${filtered.length}`);
    }
    
    // Filter by source type
    if (pullConversationsFilters.sourceType) {
        const beforeCount = filtered.length;
        filtered = filtered.filter(conv => {
            const matches = conv.source?.type === pullConversationsFilters.sourceType;
            if (!matches && beforeCount <= 5) {
                console.log(`âŒ Source type filter: conv.source.type=${conv.source?.type}, filter=${pullConversationsFilters.sourceType}`);
            }
            return matches;
        });
        console.log(`ðŸ” Source type filter (${pullConversationsFilters.sourceType}): ${beforeCount} â†’ ${filtered.length}`);
    }
    
    // Filter by product type (using subject field - product is the subject in this case)
    if (pullConversationsFilters.productType) {
        const beforeCount = filtered.length;
        filtered = filtered.filter(conv => {
            // Extract subject from conversation source (remove HTML tags if present)
            let subject = conv.source?.subject || conv.source?.body?.substring(0, 50) || '';
            // Remove HTML tags if present
            if (subject.includes('<')) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = subject;
                subject = tempDiv.textContent || tempDiv.innerText || subject;
            }
            const subjectLower = subject.toLowerCase().trim();
            const filterLower = pullConversationsFilters.productType.toLowerCase().trim();
            
            // Check if subject contains the product type
            let matches = false;
            if (filterLower === 'cfd / forex' || filterLower === 'cfd/forex') {
                matches = subjectLower.includes('cfd') && (subjectLower.includes('forex') || subjectLower.includes('/'));
            } else if (filterLower === 'futures') {
                matches = subjectLower.includes('futures') && !subjectLower.includes('cfd');
            } else {
                matches = subjectLower.includes(filterLower);
            }
            
            if (!matches && beforeCount <= 5) {
                console.log(`âŒ Product type filter: conv.subject="${subject}", filter="${pullConversationsFilters.productType}"`);
            }
            return matches;
        });
        console.log(`ðŸ” Product type filter (${pullConversationsFilters.productType}): ${beforeCount} â†’ ${filtered.length}`);
    }
    
    // Filter by language
    if (pullConversationsFilters.language) {
        const languageLower = pullConversationsFilters.language.toLowerCase();
        filtered = filtered.filter(conv => {
            const lang = conv.custom_attributes?.['Language'] || '';
            return lang.toLowerCase().includes(languageLower);
        });
    }
    
    // Filter by SLA status
    if (pullConversationsFilters.slaStatus) {
        if (pullConversationsFilters.slaStatus === 'none') {
            filtered = filtered.filter(conv => !conv.sla_applied || !conv.sla_applied.sla_status);
        } else {
            filtered = filtered.filter(conv => conv.sla_applied?.sla_status === pullConversationsFilters.slaStatus);
        }
    }
    
    // Filter by minimum parts count
    if (pullConversationsFilters.minParts !== null) {
        filtered = filtered.filter(conv => {
            const partsCount = conv.participation_part_count || 0;
            return partsCount >= pullConversationsFilters.minParts;
        });
    }
    
    // Filter by minimum reopens
    if (pullConversationsFilters.minReopens !== null) {
        filtered = filtered.filter(conv => {
            const reopens = conv.statistics?.count_reopens || 0;
            return reopens >= pullConversationsFilters.minReopens;
        });
    }
    
    // Filter by maximum time to reply (in minutes)
    if (pullConversationsFilters.maxTimeToReply !== null) {
        filtered = filtered.filter(conv => {
            const timeToReply = conv.statistics?.time_to_admin_reply;
            if (timeToReply === null || timeToReply === undefined) return false;
            const minutes = Math.round(timeToReply / 60);
            return minutes <= pullConversationsFilters.maxTimeToReply;
        });
    }
    
    // Filter by client search (name or email)
    if (pullConversationsFilters.clientSearch) {
        const searchLower = pullConversationsFilters.clientSearch.toLowerCase();
        filtered = filtered.filter(conv => {
            const clientName = extractClientName(conv).toLowerCase();
            const clientEmail = extractClientEmail(conv)?.toLowerCase() || '';
            return clientName.includes(searchLower) || clientEmail.includes(searchLower);
        });
    }
    
    // Filter by conversation ID
    if (pullConversationsFilters.conversationId) {
        const idSearch = pullConversationsFilters.conversationId.toLowerCase();
        filtered = filtered.filter(conv => {
            const convId = (conv.id || '').toString().toLowerCase();
            return convId.includes(idSearch);
        });
    }
    
    console.log(`âœ… Filtered from ${initialCount} to ${filtered.length} conversations`);
    
    pullConversationsFilteredList = filtered;
    displayPullConversationsList(filtered);
    
    // Update count
    const countElement = document.getElementById('pullConversationsCount');
    if (countElement) {
        countElement.textContent = filtered.length;
    }
}

// Clear all filters
window.clearPullConversationsFilters = function() {
    pullConversationsFilters = {
        state: null,
        priority: null,
        rating: null,
        sourceType: null,
        productType: null,
        language: null,
        slaStatus: null,
        minParts: null,
        minReopens: null,
        maxTimeToReply: null,
        clientSearch: null,
        conversationId: null
    };
    
    // Clear form
    const form = document.getElementById('pullConversationsFilterForm');
    if (form) {
        form.reset();
    }
    
    // Reset filtered list to original
    pullConversationsFilteredList = [...pullConversationsList];
    displayPullConversationsList(pullConversationsFilteredList);
    
    // Update count
    const countElement = document.getElementById('pullConversationsCount');
    if (countElement) {
        countElement.textContent = pullConversationsList.length;
    }
    
    // Update active filters display
    updatePullConversationsActiveFilters();
    
    // Close modal if open
    closePullConversationsFilterDialog();
};

// Update active filters display
function updatePullConversationsActiveFilters() {
    const activeFiltersDiv = document.getElementById('pullConversationsActiveFilters');
    const activeFiltersTags = document.getElementById('pullConversationsActiveFiltersTags');
    const activeFiltersCount = document.getElementById('pullConversationsActiveFiltersCount');
    
    if (!activeFiltersDiv || !activeFiltersTags) return;
    
    const activeFilters = [];
    
    if (pullConversationsFilters.state) activeFilters.push({ label: `State: ${pullConversationsFilters.state}`, key: 'state' });
    if (pullConversationsFilters.priority) activeFilters.push({ label: `Priority: ${pullConversationsFilters.priority}`, key: 'priority' });
    if (pullConversationsFilters.rating) activeFilters.push({ label: `Rating: ${pullConversationsFilters.rating === 'unrated' ? 'Unrated' : pullConversationsFilters.rating + ' Stars'}`, key: 'rating' });
    if (pullConversationsFilters.sourceType) activeFilters.push({ label: `Source: ${pullConversationsFilters.sourceType}`, key: 'sourceType' });
    if (pullConversationsFilters.productType) activeFilters.push({ label: `Product: ${pullConversationsFilters.productType}`, key: 'productType' });
    if (pullConversationsFilters.language) activeFilters.push({ label: `Language: ${pullConversationsFilters.language}`, key: 'language' });
    if (pullConversationsFilters.slaStatus) activeFilters.push({ label: `SLA: ${pullConversationsFilters.slaStatus}`, key: 'slaStatus' });
    if (pullConversationsFilters.minParts !== null) activeFilters.push({ label: `Min Parts: ${pullConversationsFilters.minParts}`, key: 'minParts' });
    if (pullConversationsFilters.minReopens !== null) activeFilters.push({ label: `Min Reopens: ${pullConversationsFilters.minReopens}`, key: 'minReopens' });
    if (pullConversationsFilters.maxTimeToReply !== null) activeFilters.push({ label: `Max Reply Time: ${pullConversationsFilters.maxTimeToReply}min`, key: 'maxTimeToReply' });
    if (pullConversationsFilters.clientSearch) activeFilters.push({ label: `Client: ${pullConversationsFilters.clientSearch}`, key: 'clientSearch' });
    if (pullConversationsFilters.conversationId) activeFilters.push({ label: `ID: ${pullConversationsFilters.conversationId}`, key: 'conversationId' });
    
    if (activeFilters.length === 0) {
        activeFiltersDiv.style.display = 'none';
        if (activeFiltersCount) {
            activeFiltersCount.style.display = 'none';
        }
    } else {
        activeFiltersDiv.style.display = 'block';
        if (activeFiltersCount) {
            activeFiltersCount.textContent = activeFilters.length;
            activeFiltersCount.style.display = 'inline-block';
        }
        
        activeFiltersTags.innerHTML = activeFilters.map(filter => `
            <span style="background: #dbeafe; color: #1e40af; padding: 0.1617rem 0.3234rem; border-radius: 0.1617rem; font-size: 0.4447rem; font-weight: 500; display: flex; align-items: center; gap: 0.1617rem;">
                ${escapeHtml(filter.label)}
                <button onclick="removePullConversationFilter('${filter.key}')" style="background: none; border: none; color: #1e40af; cursor: pointer; padding: 0; margin-left: 0.1617rem; font-size: 0.5659rem; line-height: 1; font-weight: bold;" title="Remove filter">✕</button>
            </span>
        `).join('');
    }
}

// Remove a specific filter
window.removePullConversationFilter = function(filterKey) {
    if (pullConversationsFilters.hasOwnProperty(filterKey)) {
        pullConversationsFilters[filterKey] = null;
    }
    
    // Update form
    const form = document.getElementById('pullConversationsFilterForm');
    if (form) {
        const inputMap = {
            'state': 'pullFilterState',
            'priority': 'pullFilterPriority',
            'rating': 'pullFilterRating',
            'sourceType': 'pullFilterSourceType',
            'productType': 'pullFilterProductType',
            'language': 'pullFilterLanguage',
            'slaStatus': 'pullFilterSlaStatus',
            'minParts': 'pullFilterMinParts',
            'minReopens': 'pullFilterMinReopens',
            'maxTimeToReply': 'pullFilterMaxTimeToReply',
            'clientSearch': 'pullFilterClientSearch',
            'conversationId': 'pullFilterConversationId'
        };
        
        const inputId = inputMap[filterKey];
        if (inputId) {
            const input = document.getElementById(inputId);
            if (input) {
                input.value = '';
            }
        }
    }
    
    // Re-apply filters
    filterPullConversations();
    
    // Update active filters display
    updatePullConversationsActiveFilters();
};

// Copy to clipboard helper
function copyToClipboard(text, buttonElement) {
    navigator.clipboard.writeText(text).then(() => {
        const originalHTML = buttonElement.innerHTML;
        buttonElement.innerHTML = '<svg style="width: 0.875rem; height: 0.875rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>';
        buttonElement.style.color = '#10b981';
        setTimeout(() => {
            buttonElement.innerHTML = originalHTML;
            buttonElement.style.color = '';
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy:', err);
    });
}

// Escape HTML helper
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Set default date range (previous day - one day)
function setDefaultConversationsDateRange() {
    const today = new Date();
    // Set end date to yesterday (previous day)
    const endDate = new Date(today);
    endDate.setDate(today.getDate() - 1);
    endDate.setHours(23, 59, 59, 999); // End of day
    // Set start date to yesterday (same as end date for one day range)
    const startDate = new Date(endDate);
    startDate.setHours(0, 0, 0, 0); // Start of day

    const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    };

    const formattedStartDate = formatDate(startDate);
    const formattedEndDate = formatDate(endDate);

    const startDateInput = document.getElementById('conversationsStartDate');
    const endDateInput = document.getElementById('conversationsEndDate');
    
    if (!startDateInput || !endDateInput) {
        console.warn('âš ï¸ Date inputs not found, will retry...');
        // Retry after a short delay
        setTimeout(() => {
            setDefaultConversationsDateRange();
        }, 200);
        return;
    }
    
    // Set the values directly
    startDateInput.value = formattedStartDate;
    endDateInput.value = formattedEndDate;
    
    // Trigger input event to ensure any listeners are notified
    startDateInput.dispatchEvent(new Event('input', { bubbles: true }));
    endDateInput.dispatchEvent(new Event('input', { bubbles: true }));
    startDateInput.dispatchEvent(new Event('change', { bubbles: true }));
    endDateInput.dispatchEvent(new Event('change', { bubbles: true }));
    
    console.log('âœ… Set default date range:', formattedStartDate, 'to', formattedEndDate);
    
    // Verify they were set, if not retry
    if (startDateInput.value !== formattedStartDate || endDateInput.value !== formattedEndDate) {
        console.warn('âš ï¸ Date values not set correctly, retrying...');
        setTimeout(() => {
            if (startDateInput) {
                startDateInput.value = formattedStartDate;
                startDateInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            if (endDateInput) {
                endDateInput.value = formattedEndDate;
                endDateInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            console.log('ðŸ”„ Retry: Set default dates:', formattedStartDate, 'to', formattedEndDate);
        }, 200);
    }
}

// Reset date range to default
window.resetConversationsDateRange = function() {
    setDefaultConversationsDateRange();
    resetConversationsFilters();
    if (currentAdminId) {
        loadConversationsForEmployee();
    }
};

// Filter state management
let currentConversationFilters = {
    open: null,
    unread: null,
    sort: 'updated_at',
    order: 'desc',
    productType: null, // 'Futures', 'CFD', 'CFD / Forex', or null for all
    dateStart: null, // Date string (YYYY-MM-DD) or null
    dateEnd: null // Date string (YYYY-MM-DD) or null
};

// Open conversations filter dialog
window.openConversationsFilterDialog = function() {
    const modal = document.getElementById('conversationsFilterModal');
    if (!modal) return;
    
    // Set current filter values in the form
    const statusRadio = document.querySelector(`input[name="conversationStatus"][value="${currentConversationFilters.open === null ? 'all' : (currentConversationFilters.open ? 'open' : 'closed')}"]`);
    if (statusRadio) statusRadio.checked = true;
    
    const readStatusRadio = document.querySelector(`input[name="conversationReadStatus"][value="${currentConversationFilters.unread === null ? 'all' : (currentConversationFilters.unread ? 'unread' : 'read')}"]`);
    if (readStatusRadio) readStatusRadio.checked = true;
    
    const sortSelect = document.getElementById('conversationSortBy');
    if (sortSelect) sortSelect.value = currentConversationFilters.sort || 'updated_at';
    
    const sortOrderRadio = document.querySelector(`input[name="conversationSortOrder"][value="${currentConversationFilters.order || 'desc'}"]`);
    if (sortOrderRadio) sortOrderRadio.checked = true;
    
    const productTypeSelect = document.getElementById('conversationProductType');
    if (productTypeSelect) {
        productTypeSelect.value = currentConversationFilters.productType || 'all';
    }
    
    const filterDateStart = document.getElementById('filterDateStart');
    if (filterDateStart) {
        filterDateStart.value = currentConversationFilters.dateStart || '';
    }
    
    const filterDateEnd = document.getElementById('filterDateEnd');
    if (filterDateEnd) {
        filterDateEnd.value = currentConversationFilters.dateEnd || '';
    }
    
    // Update active filters display
    updateActiveFiltersDisplay();
    
    // Show modal
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden'; // Prevent background scrolling
    
    // Close on Escape key
    let escapeHandler = null;
    escapeHandler = (e) => {
        if (e.key === 'Escape') {
            closeConversationsFilterDialog();
            if (escapeHandler) {
                document.removeEventListener('keydown', escapeHandler);
            }
        }
    };
    document.addEventListener('keydown', escapeHandler);
    
    // Close on backdrop click (prevent event propagation)
    const backdropClickHandler = (e) => {
        if (e.target === modal) {
            closeConversationsFilterDialog();
            modal.removeEventListener('click', backdropClickHandler);
        }
    };
    modal.addEventListener('click', backdropClickHandler);
};

// Close conversations filter dialog
window.closeConversationsFilterDialog = function() {
    const modal = document.getElementById('conversationsFilterModal');
    if (!modal) return;
    
    const modalContent = document.getElementById('conversationsFilterModalContent');
    if (modalContent) {
        modalContent.style.animation = 'modalSlideOut 0.3s ease-out';
        setTimeout(() => {
            modal.style.display = 'none';
            document.body.style.overflow = ''; // Restore scrolling
            if (modalContent) {
                modalContent.style.animation = 'modalSlideIn 0.3s ease-out';
            }
        }, 300);
    } else {
        modal.style.display = 'none';
        document.body.style.overflow = '';
    }
};

// Re-apply filters to already-loaded raw conversations (no re-fetch)
function reapplyFilters() {
    if (rawEmployeeConversations.length === 0) {
        console.warn('âš ï¸ No raw conversations to filter. Please load conversations first.');
        return;
    }
    
    // Apply filters to raw conversations
    const filteredConversations = applyClientSideFilters(rawEmployeeConversations, currentConversationFilters);
    allEmployeeConversations = filteredConversations;
    
    // Reset to first page
    currentConversationsPage = 1;
    
    // Update count
    const countSpan = document.getElementById('conversationsCount');
    if (countSpan) {
        countSpan.textContent = filteredConversations.length;
    }
    
    // Update display
    displayEmployeeConversations();
    
    console.log(`ðŸ” Filters reapplied: ${rawEmployeeConversations.length} raw conversations â†’ ${filteredConversations.length} filtered conversations`);
}

// Apply conversations filters
window.applyConversationsFilters = function() {
    // Get filter values from form
    const statusRadio = document.querySelector('input[name="conversationStatus"]:checked');
    const readStatusRadio = document.querySelector('input[name="conversationReadStatus"]:checked');
    const sortSelect = document.getElementById('conversationSortBy');
    const sortOrderRadio = document.querySelector('input[name="conversationSortOrder"]:checked');
    const productTypeSelect = document.getElementById('conversationProductType');
    const filterDateStart = document.getElementById('filterDateStart');
    const filterDateEnd = document.getElementById('filterDateEnd');
    
    // Update filter state
    if (statusRadio) {
        if (statusRadio.value === 'all') {
            currentConversationFilters.open = null;
        } else {
            currentConversationFilters.open = statusRadio.value === 'open';
        }
    }
    
    if (readStatusRadio) {
        if (readStatusRadio.value === 'all') {
            currentConversationFilters.unread = null;
        } else {
            currentConversationFilters.unread = readStatusRadio.value === 'unread';
        }
    }
    
    if (sortSelect) {
        currentConversationFilters.sort = sortSelect.value;
    }
    
    if (sortOrderRadio) {
        currentConversationFilters.order = sortOrderRadio.value;
    }
    
    // Product type filter
    if (productTypeSelect) {
        if (productTypeSelect.value === 'all') {
            currentConversationFilters.productType = null;
        } else {
            currentConversationFilters.productType = productTypeSelect.value;
        }
    }
    
    // Date range filters
    if (filterDateStart) {
        currentConversationFilters.dateStart = filterDateStart.value || null;
    }
    if (filterDateEnd) {
        currentConversationFilters.dateEnd = filterDateEnd.value || null;
    }
    
    // Update active filters display
    updateActiveFiltersDisplay();
    updateActiveFiltersCount();
    
    // Close dialog
    closeConversationsFilterDialog();
    
    // Re-apply filters to already-loaded data (no re-fetch)
    reapplyFilters();
};

// Reset all conversations filters
window.resetConversationsFilters = function() {
    // Reset filter state to defaults
    currentConversationFilters = {
        open: null,
        unread: null,
        sort: 'updated_at',
        order: 'desc',
        productType: null,
        dateStart: null,
        dateEnd: null
    };
    
    // Reset form values
    const statusAll = document.getElementById('statusAll');
    if (statusAll) statusAll.checked = true;
    
    const readStatusAll = document.getElementById('readStatusAll');
    if (readStatusAll) readStatusAll.checked = true;
    
    const sortSelect = document.getElementById('conversationSortBy');
    if (sortSelect) sortSelect.value = 'updated_at';
    
    const sortOrderDesc = document.getElementById('sortOrderDesc');
    if (sortOrderDesc) sortOrderDesc.checked = true;
    
    const productTypeSelect = document.getElementById('conversationProductType');
    if (productTypeSelect) productTypeSelect.value = 'all';
    
    const filterDateStart = document.getElementById('filterDateStart');
    if (filterDateStart) filterDateStart.value = '';
    
    const filterDateEnd = document.getElementById('filterDateEnd');
    if (filterDateEnd) filterDateEnd.value = '';
    
    // Re-apply filters (will show all conversations)
    reapplyFilters();
    
    // Update displays
    updateActiveFiltersDisplay();
    updateActiveFiltersCount();
};

// Update active filters display in dialog
function updateActiveFiltersDisplay() {
    const activeFiltersDisplay = document.getElementById('activeFiltersDisplay');
    const activeFiltersBadges = document.getElementById('activeFiltersBadges');
    
    if (!activeFiltersDisplay || !activeFiltersBadges) return;
    
    const badges = [];
    
    if (currentConversationFilters.open !== null) {
        badges.push({
            label: currentConversationFilters.open ? 'Open' : 'Closed',
            value: currentConversationFilters.open
        });
    }
    
    if (currentConversationFilters.unread !== null) {
        badges.push({
            label: currentConversationFilters.unread ? 'Unread' : 'Read',
            value: currentConversationFilters.unread
        });
    }
    
    if (currentConversationFilters.sort && currentConversationFilters.sort !== 'updated_at') {
        const sortLabels = {
            'created_at': 'Created At',
            'waiting_since': 'Waiting Since'
        };
        badges.push({
            label: `Sort: ${sortLabels[currentConversationFilters.sort] || currentConversationFilters.sort}`,
            value: currentConversationFilters.sort
        });
    }
    
    if (currentConversationFilters.order && currentConversationFilters.order !== 'desc') {
        badges.push({
            label: 'Order: Ascending',
            value: currentConversationFilters.order
        });
    }
    
    if (currentConversationFilters.productType) {
        badges.push({
            label: `Product: ${currentConversationFilters.productType}`,
            value: currentConversationFilters.productType
        });
    }
    
    if (currentConversationFilters.dateStart || currentConversationFilters.dateEnd) {
        const dateRange = [];
        if (currentConversationFilters.dateStart) dateRange.push(currentConversationFilters.dateStart);
        if (currentConversationFilters.dateEnd) dateRange.push(currentConversationFilters.dateEnd);
        badges.push({
            label: `Date: ${dateRange.join(' to ')}`,
            value: dateRange.join(' to ')
        });
    }
    
    if (badges.length > 0) {
        activeFiltersBadges.innerHTML = badges.map(badge => 
            `<span style="background-color: #dbeafe; color: #1e40af; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 500;">${escapeHtml(badge.label)}</span>`
        ).join('');
        activeFiltersDisplay.style.display = 'block';
    } else {
        activeFiltersBadges.innerHTML = '';
        activeFiltersDisplay.style.display = 'none';
    }
}

// Update active filters count badge on filter button
function updateActiveFiltersCount() {
    const activeFiltersCount = document.getElementById('activeFiltersCount');
    if (!activeFiltersCount) return;
    
    let count = 0;
    if (currentConversationFilters.open !== null) count++;
    if (currentConversationFilters.unread !== null) count++;
    if (currentConversationFilters.sort && currentConversationFilters.sort !== 'updated_at') count++;
    if (currentConversationFilters.order && currentConversationFilters.order !== 'desc') count++;
    if (currentConversationFilters.productType) count++;
    if (currentConversationFilters.dateStart || currentConversationFilters.dateEnd) count++;
    
    if (count > 0) {
        activeFiltersCount.textContent = count;
        activeFiltersCount.style.display = 'inline-block';
    } else {
        activeFiltersCount.style.display = 'none';
    }
}

// Apply client-side filters and sorting to conversations
function applyClientSideFilters(conversations, filters) {
    if (!conversations || !Array.isArray(conversations)) {
        return [];
    }
    
    let filtered = [...conversations]; // Create a copy to avoid mutating original
    
    // Filter by open/closed status
    if (filters.open !== null && filters.open !== undefined) {
        filtered = filtered.filter(conv => {
            // Check both 'open' property and 'state' property
            const isOpen = conv.open === true || conv.state === 'open';
            return filters.open ? isOpen : !isOpen;
        });
    }
    
    // Filter by read/unread status
    if (filters.unread !== null && filters.unread !== undefined) {
        filtered = filtered.filter(conv => {
            const isUnread = conv.read === false;
            return filters.unread ? isUnread : !isUnread;
        });
    }
    
    // Filter by product type
    if (filters.productType && filters.productType !== 'all') {
        filtered = filtered.filter(conv => {
            const productType = extractProductType(conv);
            if (!productType) return false;
            
            const productTypeLower = productType.toLowerCase();
            const filterLower = filters.productType.toLowerCase();
            
            // Handle different variations
            if (filterLower === 'cfd') {
                return productTypeLower.includes('cfd');
            } else if (filterLower === 'futures') {
                return productTypeLower.includes('futures') && !productTypeLower.includes('cfd');
            } else if (filterLower === 'cfd / forex' || filterLower === 'cfd/forex') {
                return productTypeLower.includes('cfd') && (productTypeLower.includes('forex') || productTypeLower.includes('/'));
            }
            
            return productTypeLower === filterLower;
        });
    }
    
    // Filter by date range (filter conversations by their created_at or updated_at)
    if (filters.dateStart || filters.dateEnd) {
        filtered = filtered.filter(conv => {
            // Use updated_at as primary, fallback to created_at
            const convDate = conv.updated_at || conv.created_at;
            if (!convDate) return false;
            
            // Convert to timestamp (handle both seconds and milliseconds)
            let timestamp = typeof convDate === 'number' ? convDate : new Date(convDate).getTime();
            if (timestamp < 10000000000) timestamp = timestamp * 1000;
            
            const convDateObj = new Date(timestamp);
            const convDateStr = convDateObj.toISOString().split('T')[0]; // YYYY-MM-DD
            
            if (filters.dateStart && convDateStr < filters.dateStart) {
                return false;
            }
            if (filters.dateEnd && convDateStr > filters.dateEnd) {
                return false;
            }
            
            return true;
        });
    }
    
    // Sort conversations
    const sortField = filters.sort || 'updated_at';
    const sortOrder = filters.order || 'desc';
    
    filtered.sort((a, b) => {
        let aValue, bValue;
        
        switch (sortField) {
            case 'created_at':
                aValue = a.created_at || 0;
                bValue = b.created_at || 0;
                break;
            case 'waiting_since':
                aValue = a.waiting_since || 0;
                bValue = b.waiting_since || 0;
                break;
            case 'updated_at':
            default:
                aValue = a.updated_at || 0;
                bValue = b.updated_at || 0;
                break;
        }
        
        // Ensure we're comparing numbers
        aValue = typeof aValue === 'number' ? aValue : (aValue ? new Date(aValue).getTime() : 0);
        bValue = typeof bValue === 'number' ? bValue : (bValue ? new Date(bValue).getTime() : 0);
        
        // Handle Unix timestamps (seconds vs milliseconds)
        if (aValue < 10000000000) aValue = aValue * 1000;
        if (bValue < 10000000000) bValue = bValue * 1000;
        
        if (sortOrder === 'asc') {
            return aValue - bValue;
        } else {
            return bValue - aValue;
        }
    });
    
    return filtered;
}

// Format date for API
function formatDateForAPI(dateStr) {
    return `${dateStr} 00:00:00`;
}

// Format date for API end date
function formatEndDateForAPI(dateStr) {
    return `${dateStr} 23:59:59`;
}

// Format date for display (DD/MM/YYYY HH:MM)
function formatConversationDateForDisplay(timestamp) {
    if (!timestamp) return 'N/A';
    const date = typeof timestamp === 'number' 
        ? new Date(timestamp < 10000000000 ? timestamp * 1000 : timestamp)
        : new Date(timestamp);
    if (isNaN(date.getTime())) return 'N/A';
    
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${day}/${month}/${year} ${hours}:${minutes}`;
}

// Show error message
function showConversationsError(message) {
    const errorDiv = document.getElementById('conversationsError');
    const errorMessage = document.getElementById('conversationsErrorMessage');
    const loadingDiv = document.getElementById('conversationsLoading');
    const listDiv = document.getElementById('conversationsList');
    
    if (errorDiv && errorMessage) {
        errorMessage.textContent = message;
        errorDiv.style.display = 'block';
    }
    if (loadingDiv) loadingDiv.style.display = 'none';
    if (listDiv) listDiv.style.display = 'none';
}

// Fetch conversations progressively: fast initial load + complete data fetching
// Helper function to fetch with retry logic
async function fetchWithRetry(url, options, maxRetries = 3, retryDelay = 1000, timeoutMs = 60000) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const controller = new AbortController();
            // Increase timeout on retries (exponential backoff for timeout too)
            const currentTimeout = timeoutMs * (1 + (attempt - 1) * 0.5); // 60s, 90s, 120s
            const timeoutId = setTimeout(() => controller.abort(), currentTimeout);
            
            console.log(`ðŸ”„ Fetch attempt ${attempt}/${maxRetries} (timeout: ${currentTimeout/1000}s)...`);
            
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            // Check if response is ok
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const errorMsg = errorData.error || `HTTP ${response.status}: ${response.statusText}`;
                throw new Error(errorMsg);
            }
            
            return response;
        } catch (error) {
            const isTimeout = error.name === 'AbortError' || error.message.includes('timeout');
            const isLastAttempt = attempt === maxRetries;
            
            if (isLastAttempt) {
                if (isTimeout) {
                    throw new Error(`Request timeout after ${maxRetries} attempts. The server may be processing a large dataset. Please try a smaller date range or try again later.`);
                }
                throw error;
            }
            
            // Wait before retrying with exponential backoff
            const delay = retryDelay * Math.pow(2, attempt - 1);
            if (isTimeout) {
                console.warn(`âš ï¸ Request timeout on attempt ${attempt}, retrying in ${delay}ms with longer timeout...`);
            } else {
                console.warn(`âš ï¸ Fetch attempt ${attempt} failed, retrying in ${delay}ms...`, error.message);
            }
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

async function fetchEmployeeConversationsProgressively(adminId, updatedSince, updatedBefore, filters = null) {
    isLoadingEmployeeConversations = true;
    allEmployeeConversations = [];
    rawEmployeeConversations = []; // Clear and store fresh raw data

    // Use provided filters or current filter state (always use currentConversationFilters as fallback)
    const activeFilters = filters !== null ? filters : currentConversationFilters;
    
    console.log('ðŸ“Š Using filters for client-side filtering:', activeFilters);

    // Show loading indicator next to count
    const countLoader = document.getElementById('conversationsCountLoader');
    if (countLoader) {
        countLoader.style.display = 'inline-block';
    }

    try {
        // Step 1: Fast initial load - fetch first 150 conversations immediately
        let startingAfter = null;
        let hasMore = true;
        let pageCount = 0;
        const maxPages = 100; // Safety limit

        while (hasMore && pageCount < maxPages) {
            pageCount++;
            
            // Build API URL - only include date range and per_page limit (no filters - done client-side)
            let edgeFunctionUrl = `${window.SupabaseConfig?.url || ''}/functions/v1/intercom-proxy?endpoint=conversations&admin_id=${encodeURIComponent(adminId)}&updated_since=${encodeURIComponent(updatedSince)}&updated_before=${encodeURIComponent(updatedBefore)}&per_page=${maxConversationsToFetch}`;
            
            // Add pagination cursor if we have one (validate and encode properly)
            if (startingAfter) {
                // Ensure cursor is a valid string and properly encoded
                const cursorValue = String(startingAfter).trim();
                if (cursorValue && cursorValue.length > 0) {
                    edgeFunctionUrl += `&starting_after=${encodeURIComponent(cursorValue)}`;
                } else {
                    console.warn('âš ï¸ Invalid cursor value, skipping pagination');
                    hasMore = false;
                    break;
                }
            }

            if (pageCount === 1) {
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('ðŸš€ FETCHING CONVERSATIONS (Client-side filtering)');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('ðŸ“‹ Active filters (will apply after fetch):', JSON.stringify(activeFilters, null, 2));
                console.log('ðŸ”— API URL:', edgeFunctionUrl);
                console.log('ðŸ“… Date range:', updatedSince, 'to', updatedBefore);
                console.log('ðŸ‘¤ Admin ID:', adminId);
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            } else {
                console.log(`ðŸ”„ Background fetch: Loading page ${pageCount}...`);
            }

            let response;
            try {
                // Use longer timeout for conversation fetching (60 seconds, with retries up to 120s)
                response = await fetchWithRetry(edgeFunctionUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${window.SupabaseConfig?.anonKey || ''}`,
                        'apikey': window.SupabaseConfig?.anonKey || '',
                        'Accept': 'application/json'
                    }
                }, 3, 2000, 60000); // maxRetries=3, retryDelay=2s, timeout=60s
            } catch (fetchError) {
                // If it's a network error on subsequent pages, log but don't fail completely
                if (pageCount > 1) {
                    console.warn(`âš ï¸ Failed to fetch page ${pageCount}, but continuing with ${allEmployeeConversations.length} conversations already loaded:`, fetchError.message);
                    hasMore = false;
                    break;
                }
                throw fetchError;
            }

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const errorMsg = errorData.error || `HTTP ${response.status}: ${response.statusText}`;
                
                // If it's a 400/404 on subsequent pages, might be invalid cursor - stop pagination
                if (pageCount > 1 && (response.status === 400 || response.status === 404)) {
                    console.warn(`âš ï¸ Invalid cursor on page ${pageCount}, stopping pagination. Loaded ${allEmployeeConversations.length} conversations.`);
                    hasMore = false;
                    break;
                }
                
                throw new Error(errorMsg);
            }

            const data = await response.json();
            
            // Extract conversations from response
            let pageConversations = [];
            if (data && Array.isArray(data.conversations)) {
                pageConversations = data.conversations;
            } else if (data && data.type === 'conversation.list' && Array.isArray(data.conversations)) {
                pageConversations = data.conversations;
            } else if (data && data.conversations && Array.isArray(data.conversations)) {
                pageConversations = data.conversations;
            }

            if (pageConversations.length > 0) {
                // Add conversations to raw array (unfiltered) - store in global variable
                rawEmployeeConversations = rawEmployeeConversations.concat(pageConversations);
                
                // Update count to show progress (raw count during loading)
                const countSpan = document.getElementById('conversationsCount');
                if (countSpan) {
                    countSpan.textContent = rawEmployeeConversations.length;
                }
                
                // Don't display during progressive loading - wait until all data is fetched
                console.log(`ðŸ“¥ Page ${pageCount} loaded: ${pageConversations.length} conversations (Total fetched: ${rawEmployeeConversations.length})`);
            }

            // Check if there are more pages to fetch
            hasMore = false;
            startingAfter = null;

            if (data.pages && data.pages.next) {
                const next = data.pages.next;
                if (typeof next === 'string') {
                    try {
                        if (next.includes('?')) {
                            const urlParts = next.split('?');
                            const urlParams = new URLSearchParams(urlParts[1]);
                            startingAfter = urlParams.get('starting_after');
                        } else {
                            // If it's just a cursor string, use it directly
                            startingAfter = next;
                        }
                        
                        // Validate cursor value
                        if (startingAfter && typeof startingAfter === 'string' && startingAfter.trim().length > 0) {
                            startingAfter = startingAfter.trim();
                        } else {
                            startingAfter = null;
                        }
                    } catch (e) {
                        console.warn('âš ï¸ Error parsing next URL:', e);
                        startingAfter = null;
                    }
                } else if (next && typeof next === 'object') {
                    startingAfter = next.starting_after || next.cursor || null;
                    // Validate cursor value
                    if (startingAfter && typeof startingAfter === 'string' && startingAfter.trim().length > 0) {
                        startingAfter = startingAfter.trim();
                    } else {
                        startingAfter = null;
                    }
                }
                hasMore = !!startingAfter;
            }

            // Stop if no more conversations or invalid cursor
            if (pageConversations.length === 0 || !startingAfter) {
                hasMore = false;
                break;
            }
        }

        console.log(`âœ… All conversations loaded: ${rawEmployeeConversations.length} total conversations fetched`);
        
        // Apply final client-side filtering and sorting to all raw conversations
        const filteredConversations = applyClientSideFilters(rawEmployeeConversations, activeFilters);
        allEmployeeConversations = filteredConversations;
        console.log(`ðŸ” After filtering: ${filteredConversations.length} conversations`);
        
        // Update count with final filtered count
        const countSpan = document.getElementById('conversationsCount');
        if (countSpan) {
            countSpan.textContent = filteredConversations.length;
        }
        
        // Hide loading and show results
        const loadingDiv = document.getElementById('conversationsLoading');
        const listDiv = document.getElementById('conversationsList');
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (listDiv) listDiv.style.display = 'block';
        
        displayEmployeeConversations();
        
    } catch (error) {
        console.error('âŒ Error fetching conversations:', error);
        throw error;
    } finally {
        isLoadingEmployeeConversations = false;
        
        // Hide loading indicator when done
        const countLoader = document.getElementById('conversationsCountLoader');
        if (countLoader) {
            countLoader.style.display = 'none';
        }
    }
}

// Load conversations for employee
window.loadConversationsForEmployee = async function() {
    if (!currentAdminId) {
        showConversationsError('Admin ID is missing.');
        return;
    }

    const startDateInput = document.getElementById('conversationsStartDate');
    const endDateInput = document.getElementById('conversationsEndDate');
    
    // If dates are not set, set default dates first
    if (!startDateInput || !endDateInput) {
        showConversationsError('Date inputs not found. Please refresh the page.');
        return;
    }
    
    // If dates are empty, set default dates
    if (!startDateInput.value || !endDateInput.value) {
        console.log('âš ï¸ Date inputs are empty, setting default dates...');
        setDefaultConversationsDateRange();
        // Wait a bit for dates to be set
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Check again after setting defaults
        if (!startDateInput.value || !endDateInput.value) {
            showConversationsError('Please select both start and end dates.');
            return;
        }
    }

    const startDate = startDateInput.value;
    const endDate = endDateInput.value;

    if (new Date(startDate) > new Date(endDate)) {
        showConversationsError('Start date must be before end date.');
        return;
    }

    const loadingDiv = document.getElementById('conversationsLoading');
    const errorDiv = document.getElementById('conversationsError');
    const listDiv = document.getElementById('conversationsList');
    
    if (loadingDiv) loadingDiv.style.display = 'block';
    if (errorDiv) errorDiv.style.display = 'none';
    if (listDiv) listDiv.style.display = 'none';

    const updatedSince = formatDateForAPI(startDate);
    const updatedBefore = formatEndDateForAPI(endDate);

    try {
        allEmployeeConversations = [];
        currentConversationsPage = 1;
        
        // Pass current filters for client-side filtering
        await fetchEmployeeConversationsProgressively(currentAdminId, updatedSince, updatedBefore, currentConversationFilters);
    } catch (error) {
        console.error('Error loading conversations:', error);
        
        // Provide more helpful error messages
        let errorMessage = 'Failed to fetch conversations.';
        if (error.message) {
            if (error.message.includes('timeout')) {
                errorMessage = 'Request timed out. The server may be processing a large dataset. Please try:\n\n' +
                              'â€¢ Selecting a smaller date range\n' +
                              'â€¢ Waiting a few moments and trying again\n' +
                              'â€¢ Checking your internet connection';
            } else if (error.message.includes('Failed to fetch') || error.message.includes('ERR_QUIC') || error.message.includes('ERR_')) {
                errorMessage = 'Network error. Please check your internet connection and try again.';
            } else {
                errorMessage = error.message;
            }
        }
        
        showConversationsError(errorMessage);
    } finally {
        if (loadingDiv) loadingDiv.style.display = 'none';
    }
};

// Extract client name from conversation
function extractClientName(conversation) {
    if (conversation.source?.author?.name) {
        return conversation.source.author.name;
    }
    if (conversation.source?.author?.email) {
        return conversation.source.author.email;
    }
    if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
        const contact = conversation.contacts.contacts[0];
        return contact.name || contact.email || 'Unknown';
    }
    return 'Unknown';
}

// Extract client email from conversation
function extractClientEmail(conversation) {
    if (conversation.source?.author?.email) {
        return conversation.source.author.email;
    }
    if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
        const contact = conversation.contacts.contacts[0];
        return contact.email || null;
    }
    return null;
}

// Extract admin information from conversation (Intercom admin who participated)
function extractAdminFromConversation(conversation) {
    // Check teammates.admins array first
    if (conversation.teammates?.admins && Array.isArray(conversation.teammates.admins) && conversation.teammates.admins.length > 0) {
        const admin = conversation.teammates.admins[0];
        return {
            id: admin.id || conversation.admin_assignee_id,
            name: admin.name || null, // This is the Intercom alias
            email: admin.email || null
        };
    }
    
    // Check admin_assignee_id
    if (conversation.admin_assignee_id) {
        return {
            id: conversation.admin_assignee_id,
            name: null, // Will need to look up
            email: null // Will need to look up
        };
    }
    
    return null;
}

// Get rating from conversation
function getConversationRating(conversation) {
    if (conversation.conversation_rating?.rating) {
        const rating = parseInt(conversation.conversation_rating.rating, 10);
        if (!isNaN(rating) && rating >= 1 && rating <= 5) {
            return rating;
        }
    }
    return null;
}

// Extract product type from conversation
function extractProductType(conversation) {
    // Priority 1: Check ticket custom_attributes for Product Type
    if (conversation.ticket?.custom_attributes?.["Product Type"]) {
        const productType = conversation.ticket.custom_attributes["Product Type"];
        // Handle object with value property
        if (productType && typeof productType === 'object' && productType.value) {
            return productType.value;
        }
        // Sometimes it's a direct string value
        if (typeof productType === 'string' && productType.trim()) {
            return productType;
        }
    }
    
    // Priority 2: Check tags for product type indicators
    if (conversation.tags?.tags && Array.isArray(conversation.tags.tags)) {
        for (const tag of conversation.tags.tags) {
            const tagName = tag.name || '';
            // Check for CFD indicators
            if (tagName.includes('CFD') || tagName === 'CFD Conversation' || tagName.includes('CFD FIN')) {
                return 'CFD';
            }
            // Check for Futures indicators
            if (tagName.includes('Futures') || tagName === 'Future Conversations' || tagName.includes('Futures FIN')) {
                return 'Futures';
            }
        }
    }
    
    // Priority 3: Check source body for user-selected product type
    if (conversation.source?.body) {
        const body = conversation.source.body.toLowerCase();
        // Check for CFD / Forex (handle HTML tags)
        if (body.includes('cfd / forex') || body.includes('cfd/forex') || body.includes('<p>cfd / forex</p>')) {
            return 'CFD / Forex';
        }
        // Check for Futures (handle HTML tags)
        if (body.includes('<p>futures</p>') || (body.includes('futures') && !body.includes('cfd'))) {
            return 'Futures';
        }
    }
    
    // Priority 4: Check topics for product type indicators
    if (conversation.topics?.topics && Array.isArray(conversation.topics.topics)) {
        for (const topic of conversation.topics.topics) {
            const topicName = topic.name || '';
            if (topicName.includes('Futures')) {
                return 'Futures';
            }
            if (topicName.includes('CFD')) {
                return 'CFD';
            }
        }
    }
    
    // Priority 5: Check team names in statistics
    if (conversation.statistics?.assigned_team_first_response_time && Array.isArray(conversation.statistics.assigned_team_first_response_time)) {
        for (const team of conversation.statistics.assigned_team_first_response_time) {
            const teamName = team.team_name || '';
            if (teamName.includes('(CFD)')) {
                return 'CFD';
            }
            if (teamName.includes('(FUT)')) {
                return 'Futures';
            }
        }
    }
    
    return null;
}

// Generate star rating HTML
function generateStarRating(rating) {
    const maxStars = 5;
    const filledStars = rating || 0;
    const emptyStars = maxStars - filledStars;
    
    let starsHtml = '<div style="display: flex; align-items: center; gap: 0.125rem;">';
    
    for (let i = 0; i < filledStars; i++) {
        starsHtml += `
            <svg aria-hidden="true" style="width: 1rem; height: 1rem; color: #fbbf24;" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
            </svg>
        `;
    }
    
    for (let i = 0; i < emptyStars; i++) {
        starsHtml += `
            <svg aria-hidden="true" style="width: 1rem; height: 1rem; color: #d1d5db;" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
            </svg>
        `;
    }
    
    starsHtml += '</div>';
    return starsHtml;
}

// Copy conversation ID to clipboard
window.copyConversationId = function(conversationId, buttonElement) {
    if (!conversationId || conversationId === 'N/A') {
        return;
    }

    // Copy to clipboard
    navigator.clipboard.writeText(conversationId).then(() => {
        // Visual feedback
        const originalHTML = buttonElement.innerHTML;
        buttonElement.classList.add('copy-success');
        buttonElement.innerHTML = `
            <svg aria-hidden="true" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
        `;
        buttonElement.title = 'Copied!';

        // Reset after 2 seconds
        setTimeout(() => {
            buttonElement.classList.remove('copy-success');
            buttonElement.innerHTML = originalHTML;
            buttonElement.title = 'Copy conversation ID';
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy conversation ID:', err);
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = conversationId;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            const originalHTML = buttonElement.innerHTML;
            buttonElement.innerHTML = '✓';
            setTimeout(() => {
                buttonElement.innerHTML = originalHTML;
            }, 2000);
        } catch (fallbackErr) {
            console.error('Fallback copy failed:', fallbackErr);
        }
        document.body.removeChild(textArea);
    });
};

// Display conversations in table
function displayEmployeeConversations() {
    const tableBody = document.getElementById('conversationsTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';

    if (allEmployeeConversations.length === 0) {
        const listDiv = document.getElementById('conversationsList');
        if (listDiv) listDiv.style.display = 'block';
        const paginationDiv = document.getElementById('conversationsPagination');
        if (paginationDiv) paginationDiv.style.display = 'none';
        tableBody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 1.9406rem; color: #9ca3af;">No conversations found for this date range.</td></tr>';
        return;
    }

    const totalPages = Math.ceil(allEmployeeConversations.length / conversationsItemsPerPage);
    const startIndex = (currentConversationsPage - 1) * conversationsItemsPerPage;
    const endIndex = Math.min(startIndex + conversationsItemsPerPage, allEmployeeConversations.length);
    const pageConversations = allEmployeeConversations.slice(startIndex, endIndex);

    const paginationStart = document.getElementById('conversationsPaginationStart');
    const paginationEnd = document.getElementById('conversationsPaginationEnd');
    const paginationTotal = document.getElementById('conversationsPaginationTotal');
    
    if (paginationStart) paginationStart.textContent = allEmployeeConversations.length > 0 ? startIndex + 1 : 0;
    if (paginationEnd) paginationEnd.textContent = endIndex;
    if (paginationTotal) {
        paginationTotal.textContent = allEmployeeConversations.length;
        if (isLoadingEmployeeConversations) {
            paginationTotal.textContent = `${allEmployeeConversations.length}+`;
        }
    }

    pageConversations.forEach(conversation => {
        const row = document.createElement('tr');
        row.style.borderBottom = '0.0625rem solid #e5e7eb';
        row.style.cursor = 'pointer';
        row.onmouseenter = () => {
            row.style.backgroundColor = '#f9fafb';
        };
        row.onmouseleave = () => {
            row.style.backgroundColor = 'transparent';
        };
        
        const clientName = extractClientName(conversation);
        const clientEmail = extractClientEmail(conversation);
        const createdDate = formatConversationDateForDisplay(conversation.created_at || conversation.created_at_time);
        const subject = conversation.source?.subject || 
                       conversation.conversation_parts?.[0]?.body?.substring(0, 100) || 
                       'No subject';
        const subjectDisplay = subject.length > 50 ? subject.substring(0, 50) + '...' : subject;
        const state = conversation.state || 'unknown';
        const stateBadge = state === 'open' 
            ? '<span style="background-color: #fef3c7; color: #92400e; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">Open</span>'
            : state === 'closed'
            ? '<span style="background-color: #dcfce7; color: #166534; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">Closed</span>'
            : '<span style="background-color: #fee2e2; color: #991b1b; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">' + escapeHtml(state) + '</span>';
        const rating = getConversationRating(conversation);
        const ratingHtml = generateStarRating(rating);
        const conversationId = conversation.id || 'N/A';
        
        // Extract product type
        const productType = extractProductType(conversation);
        let productTypeBadge = '';
        if (productType) {
            const isCFD = productType.toLowerCase().includes('cfd') || productType === 'CFD / Forex';
            const isFutures = productType.toLowerCase().includes('futures');
            const bgColor = isCFD ? '#dbeafe' : isFutures ? '#fef3c7' : '#f3f4f6';
            const textColor = isCFD ? '#1e40af' : isFutures ? '#92400e' : '#374151';
            productTypeBadge = `<span style="background-color: ${bgColor}; color: ${textColor}; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">${escapeHtml(productType)}</span>`;
        } else {
            productTypeBadge = '<span style="color: #9ca3af; font-size: 0.75rem;">â€”</span>';
        }

        row.innerHTML = `
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">
                <div style="font-weight: 500; color: #111827; font-size: 0.875rem; line-height: 1.4;">${escapeHtml(clientName)}</div>
                ${clientEmail ? `<div style="font-size: 0.75rem; color: #6b7280; margin-top: 0.125rem;">${escapeHtml(clientEmail)}</div>` : ''}
            </td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <div style="font-family: 'Courier New', monospace; font-size: 0.8125rem; color: #4b5563; font-weight: 500;">${conversationId}</div>
                    <button 
                        class="copy-button"
                        onclick="event.stopPropagation(); copyConversationId('${conversationId}', this);"
                        title="Copy conversation ID"
                        style="display: inline-flex; align-items: center; justify-content: center; padding: 0.25rem; background: transparent; border: none; border-radius: 0.25rem; cursor: pointer; color: #6b7280; transition: all 0.2s;"
                        onmouseover="this.style.backgroundColor='#f3f4f6'; this.style.color='#374151'"
                        onmouseout="this.style.backgroundColor='transparent'; this.style.color='#6b7280'"
                    >
                        <svg aria-hidden="true" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width: 1rem; height: 1rem;">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                    </button>
                </div>
            </td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">
                <div style="max-width: 16rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 0.875rem; color: #374151; line-height: 1.4;" title="${escapeHtml(subject)}">${escapeHtml(subjectDisplay)}</div>
            </td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">${productTypeBadge}</td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">${ratingHtml}</td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">${stateBadge}</td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle; font-size: 0.875rem; color: #6b7280; white-space: nowrap;">${createdDate}</td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">
                <button 
                    onclick="event.stopPropagation(); window.open('audit-view.html?conversation_id=${conversation.id}', '_blank');"
                    style="padding: 0.375rem 0.75rem; font-size: 0.8125rem; font-weight: 500; color: #1A733E; background: #d1fae5; border: none; border-radius: 0.375rem; cursor: pointer; transition: all 0.2s; white-space: nowrap;"
                    onmouseover="this.style.background='#a7f3d0'"
                    onmouseout="this.style.background='#d1fae5'"
                >
                    Audit
                </button>
            </td>
        `;

        tableBody.appendChild(row);
    });

    updateConversationsPaginationControls(totalPages);
    const paginationDiv = document.getElementById('conversationsPagination');
    if (paginationDiv) paginationDiv.style.display = totalPages > 1 ? 'block' : 'none';
}

// Update pagination controls
function updateConversationsPaginationControls(totalPages) {
    const paginationPages = document.getElementById('conversationsPaginationPages');
    const paginationPrev = document.getElementById('conversationsPaginationPrev');
    const paginationNext = document.getElementById('conversationsPaginationNext');
    
    if (!paginationPages || !paginationPrev || !paginationNext) return;
    
    paginationPages.innerHTML = '';
    
    if (totalPages <= 1) {
        paginationPrev.disabled = true;
        paginationNext.disabled = true;
        return;
    }
    
    paginationPrev.disabled = currentConversationsPage === 1;
    paginationNext.disabled = currentConversationsPage === totalPages;
    
    const maxVisiblePages = 5;
    let startPage = Math.max(1, currentConversationsPage - Math.floor(maxVisiblePages / 2));
    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
    
    if (endPage - startPage < maxVisiblePages - 1) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
    }
    
    for (let i = startPage; i <= endPage; i++) {
        const pageBtn = document.createElement('button');
        pageBtn.type = 'button';
        pageBtn.style.cssText = 'padding: 0.1617rem 0.3234rem; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4043rem; cursor: pointer; color: #6b7280; transition: all 0.2s;';
        if (i === currentConversationsPage) {
            pageBtn.style.background = '#1A733E';
            pageBtn.style.color = 'white';
            pageBtn.style.borderColor = '#1A733E';
        }
        pageBtn.textContent = i;
        pageBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            conversationsGoToPage(i);
        };
        paginationPages.appendChild(pageBtn);
    }
}

// Go to specific page
window.conversationsGoToPage = function(page) {
    const totalPages = Math.ceil(allEmployeeConversations.length / conversationsItemsPerPage);
    if (page < 1 || page > totalPages) return;
    
    currentConversationsPage = page;
    displayEmployeeConversations();
};

window.navigateToAssignment = function(assignmentId) {
    // Update URL with assignment parameter
    const newUrl = `${window.location.pathname}?assignment=${assignmentId}`;
    window.history.pushState({ assignment: assignmentId }, '', newUrl);
    
    // Load the assignment from URL (this will trigger loadAssignmentFromURL)
    loadAssignmentFromURL(assignmentId);
};

window.startAssignedAudit = async function(assignmentId, employeeEmail, scorecardId) {
    try {
        // Update assignment status to 'in_progress'
        const { error: updateError } = await window.supabaseClient
            .from('audit_assignments')
            .update({ status: 'in_progress' })
            .eq('id', assignmentId);
        
        if (updateError) throw updateError;
        
        // Update local state
        const assignmentIndex = pendingAudits.findIndex(a => a.id === assignmentId);
        if (assignmentIndex !== -1) {
            pendingAudits[assignmentIndex].status = 'in_progress';
        }
        
        // Set assignment mode (NOT editing existing audit, but completing an assignment)
        isEditingPendingAudit = false; // This is a NEW audit from assignment
        currentEditingAuditId = null;
        currentAssignmentId = assignmentId; // Track the assignment ID separately
        
        // Hide the assigned audits section
        const pendingAuditsSection = document.getElementById('pendingAuditsSection');
        if (pendingAuditsSection) {
            pendingAuditsSection.style.display = 'none';
        }
        
        // Show the full screen audit form modal
        const auditFormModal = document.getElementById('auditFormModal');
        if (auditFormModal) {
            auditFormModal.style.display = 'flex';
        }
        
        // Auto-select the scorecard from assignment
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect && scorecardId) {
            // First, ensure scorecards are loaded
            await loadScorecards();
            // Then select the assigned scorecard
            scorecardSelect.value = scorecardId;
            // Load the scorecard parameters
            await loadScorecardParameters(scorecardId);
        } else if (scorecardSelect) {
            // If no scorecard ID provided, auto-select first available
            await loadScorecards();
            // The loadScorecards function will auto-select the first one
        }
        
        // Pre-fill employee information
        const employeeSelect = document.getElementById('employeeName');
        
        // Find and select the employee in dropdown
        if (employeeSelect && employeeEmail) {
            for (let i = 0; i < employeeSelect.options.length; i++) {
                if (employeeSelect.options[i].dataset.email === employeeEmail) {
                    employeeSelect.selectedIndex = i;
                    // Trigger change event to populate other fields
                    employeeSelect.dispatchEvent(new Event('change'));
                    break;
                }
            }
        }
        
        // Scroll to top to show scorecard selector
        window.scrollTo({ top: 0, behavior: 'smooth' });
        
        // Show and start the timer
        const auditTimer = document.getElementById('auditTimer');
        if (auditTimer) {
            auditTimer.style.display = 'flex';
            // Attach event listeners when timer is shown
            if (window.attachTimerEventListeners) {
                window.attachTimerEventListeners();
            }
        }
        
        // Reset and start the timer
        if (window.resetTimer && window.startTimer) {
            window.resetTimer();
            window.startTimer();
        }
        
        // Show notification
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 2.4258rem;
            right: 0.6064rem;
            background: linear-gradient(135deg, #1A733E, #15582E);
            color: white;
            padding: 0.6469rem 0.9704rem;
            border-radius: 0.3234rem;
            box-shadow: 0 0.1213rem 0.3639rem rgba(0, 0, 0, 0.15);
            z-index: 10000;
            font-size: 0.5659rem;
            font-weight: 600;
            animation: slideIn 0.3s ease;
        `;
        notification.textContent = 'Audit started! Scorecard & employee info pre-filled.';
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
        
        // Reload pending audits to update the UI
        await loadPendingAudits();
        
    } catch (error) {
        console.error('Error starting assigned audit:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to start audit: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
};

// Start audit from Intercom conversation
window.startAuditFromConversation = async function(conversation) {
    try {
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('ðŸš€ START AUDIT FROM CONVERSATION');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('Conversation:', conversation);
        
        // Extract admin information from conversation
        const adminInfo = extractAdminFromConversation(conversation);
        
        if (!adminInfo || !adminInfo.id) {
            await window.confirmationDialog.show({
                title: 'Admin Not Found',
                message: 'Could not find admin information in this conversation. Please select the employee manually.',
                confirmText: 'OK',
                type: 'warning'
            });
        }
        
        // If admin email is not available, try to look it up
        let adminEmail = adminInfo?.email;
        if (!adminEmail && adminInfo?.id) {
            console.log('ðŸ” Looking up admin email for ID:', adminInfo.id);
            
            // Try to find in Supabase cache first
            const supabaseClient = window.SupabaseConfig?.getClient?.();
            if (supabaseClient) {
                try {
                    const { data: cachedAdmins, error: queryError } = await supabaseClient
                        .from('intercom_admin_cache')
                        .select('id, email, name, admin_data')
                        .eq('id', String(adminInfo.id))
                        .limit(1);
                    
                    if (!queryError && cachedAdmins && cachedAdmins.length > 0) {
                        const cachedAdmin = cachedAdmins[0];
                        adminEmail = cachedAdmin.email || cachedAdmin.admin_data?.email;
                        if (!adminInfo.name && cachedAdmin.name) {
                            adminInfo.name = cachedAdmin.name;
                        }
                        console.log('âœ… Admin found in cache:', adminEmail);
                    }
                } catch (cacheError) {
                    console.warn('âš ï¸ Error accessing Supabase cache:', cacheError);
                }
            }
            
            // If still not found, fetch from Intercom API
            if (!adminEmail) {
                try {
                    const supabaseUrl = window.SupabaseConfig?.url || '';
                    const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
                    const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=admins`;
                    
                    const response = await fetch(edgeFunctionUrl, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${supabaseAnonKey}`,
                            'apikey': supabaseAnonKey,
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const admins = data.admins || data || [];
                        const admin = admins.find(a => String(a.id) === String(adminInfo.id));
                        
                        if (admin) {
                            adminEmail = admin.email;
                            if (!adminInfo.name && admin.name) {
                                adminInfo.name = admin.name;
                            }
                            console.log('âœ… Admin found via Intercom API:', adminEmail);
                        }
                    }
                } catch (apiError) {
                    console.warn('âš ï¸ Error fetching admin from Intercom API:', apiError);
                }
            }
        }
        
        // Hide the pull conversations section
        const pullConversationsSection = document.getElementById('pullConversationsSection');
        if (pullConversationsSection) {
            pullConversationsSection.style.display = 'none';
        }
        
        // Show the full screen audit form modal
        const auditFormModal = document.getElementById('auditFormModal');
        if (auditFormModal) {
            auditFormModal.style.display = 'flex';
        }
        
        // Ensure employees are loaded
        await loadEmployees();
        
        // Pre-fill employee information
        const employeeSelect = document.getElementById('employeeName');
        let employeeFound = false;
        
        if (employeeSelect && adminEmail) {
            // Find and select the employee in dropdown by email
            const normalizedEmail = adminEmail.toLowerCase().trim();
            for (let i = 0; i < employeeSelect.options.length; i++) {
                const optionEmail = (employeeSelect.options[i].dataset.email || '').toLowerCase().trim();
                if (optionEmail === normalizedEmail) {
                    employeeSelect.selectedIndex = i;
                    // Trigger change event to populate other fields
                    employeeSelect.dispatchEvent(new Event('change'));
                    employeeFound = true;
                    console.log('âœ… Employee found and selected:', adminEmail);
                    break;
                }
            }
        }
        
        if (!employeeFound && adminEmail) {
            console.warn('âš ï¸ Employee not found in dropdown for email:', adminEmail);
            await window.confirmationDialog.show({
                title: 'Employee Not Found',
                message: `Employee with email ${adminEmail} not found in the system. Please select the employee manually.`,
                confirmText: 'OK',
                type: 'warning'
            });
        } else if (!adminEmail) {
            console.warn('âš ï¸ Admin email not available');
        }
        
        // Display Intercom alias if available and different from employee name
        const intercomAliasContainer = document.getElementById('intercomAliasContainer');
        const intercomAliasInput = document.getElementById('intercomAlias');
        if (adminInfo?.name && intercomAliasContainer && intercomAliasInput) {
            // Get the selected employee name
            const selectedEmployeeName = employeeSelect?.options[employeeSelect.selectedIndex]?.textContent || '';
            
            // Only show if alias is different from employee name
            if (adminInfo.name !== selectedEmployeeName) {
                intercomAliasInput.value = adminInfo.name;
                intercomAliasContainer.style.display = 'block';
                console.log('âœ… Intercom alias displayed:', adminInfo.name);
            } else {
                intercomAliasContainer.style.display = 'none';
            }
        } else if (intercomAliasContainer) {
            intercomAliasContainer.style.display = 'none';
        }
        
        // Pre-fill conversation ID
        const interactionIdField = document.getElementById('interactionId');
        if (interactionIdField && conversation.id) {
            interactionIdField.value = conversation.id;
            console.log('âœ… Conversation ID pre-filled:', conversation.id);
            
            // Ensure chat view is shown
            const transcriptChatView = document.getElementById('transcriptChatView');
            const transcriptTextView = document.getElementById('transcriptTextView');
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
            }
            
            // Wait a bit for DOM to be ready, then load the conversation
            setTimeout(async () => {
                if (window.loadConversationFromIntercom && typeof window.loadConversationFromIntercom === 'function') {
                    console.log('ðŸ”„ Loading conversation from Intercom...');
                    await window.loadConversationFromIntercom(conversation.id);
                } else {
                    console.warn('âš ï¸ loadConversationFromIntercom function not available yet, retrying...');
                    // Retry after a longer delay if function not ready
                    setTimeout(async () => {
                        if (window.loadConversationFromIntercom && typeof window.loadConversationFromIntercom === 'function') {
                            await window.loadConversationFromIntercom(conversation.id);
                        } else {
                            console.error('âŒ loadConversationFromIntercom function still not available');
                        }
                    }, 1000);
                }
            }, 300);
        }
        
        // Pre-fill conversation date if available
        const interactionDateField = document.getElementById('interactionDate');
        if (interactionDateField && conversation.created_at) {
            const conversationDate = new Date(conversation.created_at * 1000);
            const dateStr = conversationDate.toISOString().split('T')[0];
            interactionDateField.value = dateStr;
            console.log('âœ… Conversation date pre-filled:', dateStr);
        }
        
        // Pre-fill client information
        const clientNameField = document.getElementById('clientName');
        const clientEmailField = document.getElementById('clientEmail');
        if (clientNameField) {
            const clientName = extractClientName(conversation);
            clientNameField.value = clientName;
        }
        if (clientEmailField) {
            const clientEmail = extractClientEmail(conversation);
            if (clientEmail) {
                clientEmailField.value = clientEmail;
            }
        }
        
        // Auto-select first scorecard if available
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect) {
            await loadScorecards();
            // The loadScorecards function will auto-select the first one
        }
        
        // Scroll to top to show form
        window.scrollTo({ top: 0, behavior: 'smooth' });
        
        // Show and start the timer
        const auditTimer = document.getElementById('auditTimer');
        if (auditTimer) {
            auditTimer.style.display = 'flex';
            // Attach event listeners when timer is shown
            if (window.attachTimerEventListeners) {
                window.attachTimerEventListeners();
            }
        }
        
        // Reset and start the timer
        if (window.resetTimer && window.startTimer) {
            window.resetTimer();
            window.startTimer();
        }
        
        // Show notification
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 2.4258rem;
            right: 0.6064rem;
            background: linear-gradient(135deg, #1A733E, #15582E);
            color: white;
            padding: 0.6469rem 0.9704rem;
            border-radius: 0.3234rem;
            box-shadow: 0 0.1213rem 0.3639rem rgba(0, 0, 0, 0.15);
            z-index: 10000;
            font-size: 0.5659rem;
            font-weight: 600;
            animation: slideIn 0.3s ease;
        `;
        notification.textContent = 'Audit started from conversation! Employee info pre-filled.';
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
        
    } catch (error) {
        console.error('Error starting audit from conversation:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to start audit from conversation: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
};

// ============================================================================
// Helper Functions
// ============================================================================

// Helper function to get initials
function getInitials(name) {
    if (!name) return '?';
    return name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
}

// Helper function to format date
function formatDate(dateString) {
    if (!dateString) return 'Unknown';
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    
    return date.toLocaleDateString();
}

// Helper function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Set initial average score based on scoring type
function setInitialAverageScore() {
    if (!currentScorecard) return;
    
    const averageScoreField = document.getElementById('averageScore');
    if (!averageScoreField) return;
    
    const scoringType = currentScorecard.scoring_type || 'deductive';
    let initialScore = 0;
    
    switch(scoringType) {
        case 'deductive':
            initialScore = 100; // Start at 100%, deduct errors
            break;
        case 'additive':
            initialScore = 0; // Start at 0%, add achievements
            break;
        case 'hybrid':
            initialScore = 100; // Start at 100%, can deduct errors and add bonuses
            break;
        default:
            initialScore = 100;
    }
    
    averageScoreField.value = initialScore.toFixed(2);
    updatePassingStatus(initialScore);
}

// Update feedback boxes for a parameter based on error count (max 10)
function updateFeedbackBoxesForParameter(fieldId, fieldType, paramType) {
    const feedbackContainer = document.getElementById(`feedback_container_${fieldId}`);
    if (!feedbackContainer) return;
    
    // Get current error count
    let errorCount = 0;
    if (fieldType === 'radio') {
        const selectedRadio = document.querySelector(`input[name="${fieldId}"]:checked`);
        if (selectedRadio) {
            const value = parseInt(selectedRadio.value) || 0;
            // For additive/achievement: NO (0) = not achieved = error
            // For error parameters: YES (1) = error occurred = error
            if (paramType === 'achievement' || paramType === 'bonus') {
                errorCount = value === 0 ? 1 : 0;
            } else {
                errorCount = value;
            }
        }
    } else {
        const field = document.getElementById(fieldId);
        errorCount = field ? (parseInt(field.value) || 0) : 0;
    }
    
    // Always show at least 1 feedback box, but limit to max 10 based on error count
    // If errorCount is 0, show 1 box (optional)
    // If errorCount > 0, show up to errorCount boxes (max 10), all required
    const feedbackCount = errorCount === 0 ? 1 : Math.min(errorCount, 10);
    const isRequired = errorCount > 0;
    
    // Get existing feedback values (if loading from saved audit)
    const existingFeedbacks = [];
    const existingTextareas = feedbackContainer.querySelectorAll(`textarea[id^="feedback_${fieldId}_"]`);
    existingTextareas.forEach(textarea => {
        const index = parseInt(textarea.id.split('_').pop()) || 0;
        existingFeedbacks[index] = textarea.value;
    });
    
    // Clear container
    feedbackContainer.innerHTML = '';
    
    // Create feedback boxes
    for (let i = 0; i < feedbackCount; i++) {
        const feedbackDiv = document.createElement('div');
        const feedbackId = `feedback_${fieldId}_${i}`;
        // Make required if errorCount > 0, otherwise optional
        const requiredAttr = isRequired ? 'required' : '';
        const placeholder = errorCount === 0 
            ? 'Enter feedback (optional)...' 
            : (feedbackCount === 1 
                ? 'Enter feedback (required)...' 
                : `Feedback ${i + 1} of ${feedbackCount} (required)...`);
        
        feedbackDiv.innerHTML = `
            <textarea 
                id="${feedbackId}" 
                name="${feedbackId}" 
                ${requiredAttr}
                placeholder="${placeholder}" 
                rows="1" 
                class="w-full px-2 py-1 bg-white text-sm focus:outline-none resize-none" 
                style="font-family: 'Poppins', sans-serif; font-size: 0.5659rem; line-height: 1.2; min-height: 1rem; max-height: 50rem; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; padding: 0.2425rem 0.3234rem;"
            >${existingFeedbacks[i] || ''}</textarea>
        `;
        feedbackContainer.appendChild(feedbackDiv);
        
        // Setup auto-expand for this textarea
        const textarea = feedbackDiv.querySelector('textarea');
        if (textarea) {
            setupFeedbackTextareaAutoExpand(feedbackId, textarea);
        }
    }
}

// Setup auto-expand functionality for feedback textarea
function setupFeedbackTextareaAutoExpand(fieldId, textareaElement = null) {
    const textarea = textareaElement || document.getElementById(fieldId);
    if (!textarea) return;
    
    // Auto-expand function
    const autoExpand = function() {
        textarea.style.height = 'auto';
        const scrollHeightRem = textarea.scrollHeight / 16;
        textarea.style.height = Math.min(scrollHeightRem, 50.0) + 'rem';
    };
    
    // Add focus/input styles for green border
    textarea.addEventListener('focus', function() {
        this.style.borderColor = '#10b981';
    });
    textarea.addEventListener('input', function() {
        // Clear validation error styling when user starts typing
        if (this.value && this.value.trim()) {
            this.style.borderColor = '#10b981';
        }
        autoExpand();
    });
    textarea.addEventListener('blur', function() {
        // Keep green border if there's content, otherwise default gray
        if (this.value && this.value.trim()) {
            this.style.borderColor = '#10b981';
        } else {
            this.style.borderColor = '#d1d5db';
        }
    });
    
    // Hide scrollbar but keep scrolling functional
    textarea.style.setProperty('scrollbar-width', 'none', 'important');
    textarea.style.setProperty('-ms-overflow-style', 'none', 'important');
    
    // For webkit browsers
    const style = document.createElement('style');
    style.textContent = `#${fieldId}::-webkit-scrollbar { display: none; }`;
    document.head.appendChild(style);
    
    // Trigger on initial load if there's content
    setTimeout(autoExpand, 0);
}

// Render error parameter fields dynamically
function renderErrorParameters() {
    const container = document.getElementById('errorParametersContainer');
    container.innerHTML = '';
    
    if (currentParameters.length === 0) {
        container.innerHTML = '<div style="padding: 1.2937rem; text-align: center; color: #6b7280; font-size: 0.5659rem;"><p>No parameters defined for this scorecard.</p></div>';
        // Reset header to default "Status"
        const headerStatusCol = document.querySelector('#errorParametersSection .error-details-header-status');
        if (headerStatusCol) {
            headerStatusCol.textContent = 'Status';
        }
        return;
    }
    
    // Determine column header based on field types (matching audit-view.html logic)
    let statusColumnHeader = 'Status';
    const allCounters = currentParameters.every(param => param.field_type === 'counter');
    const allRadio = currentParameters.every(param => param.field_type === 'radio');
    
    if (allCounters) {
        statusColumnHeader = 'Counts';
    } else if (allRadio) {
        statusColumnHeader = 'Achieved?';
    }
    
    // Update the header dynamically
    const headerStatusCol = document.querySelector('#errorParametersSection .error-details-header-status');
    if (headerStatusCol) {
        headerStatusCol.textContent = statusColumnHeader;
    }
    
    // Update scorecard display in header
    const scorecardDisplay = document.getElementById('formScorecardDisplay');
    if (scorecardDisplay && currentScorecard) {
        let scoringTypeIcon = '';
        let scoringTypeText = '';
        if (currentScorecard.scoring_type === 'deductive') {
            scoringTypeIcon = '<svg style="width: 0.4043rem; height: 0.4043rem; display: inline-block; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor"><path d="M7 10l5 5 5-5z"/></svg>';
            scoringTypeText = 'DEDUCTIVE';
        } else if (currentScorecard.scoring_type === 'additive') {
            scoringTypeIcon = '<svg style="width: 0.4043rem; height: 0.4043rem; display: inline-block; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14l5-5 5 5z"/></svg>';
            scoringTypeText = 'ADDITIVE';
        } else if (currentScorecard.scoring_type === 'hybrid') {
            scoringTypeIcon = '<svg style="width: 0.4043rem; height: 0.4043rem; display: inline-block; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor"><path d="M2 12h20M12 2v20"/></svg>';
            scoringTypeText = 'HYBRID';
        }
        
        scorecardDisplay.innerHTML = `<svg style="width: 0.5659rem; height: 0.5659rem; display: inline-block; vertical-align: middle; margin-right: 0.2425rem;" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg> ${currentScorecard.name}${scoringTypeText ? ' <span style="background: rgba(255,255,255,0.25); padding: 0.0971rem 0.3234rem; border-radius: 0.1617rem; font-size: 0.4043rem; font-weight: 600; text-transform: uppercase; border: 0.0304rem solid rgba(255,255,255,0.4); margin-left: 0.3234rem; display: inline-flex; align-items: center; gap: 0.1617rem;">' + scoringTypeIcon + ' ' + scoringTypeText + '</span>' : ''}`;
    }
    
    currentParameters.forEach(param => {
        // Determine parameter styling based on type
        const paramType = param.parameter_type || 'error';
        const paramIcon = paramType === 'error' ? '-' : (paramType === 'achievement' || paramType === 'bonus' ? '+' : '');
        
        // Different colors for different parameter types (matching expert-audits.html exactly)
        let severityColor = '#3b82f6';
        let severityBg = '#eff6ff';
        
        if (paramType === 'error') {
            if (param.error_category.includes('Fail')) {
                severityColor = '#ef4444';
                severityBg = '#fee2e2';
            } else if (param.error_category.includes('Critical')) {
                severityColor = '#f59e0b';
                severityBg = '#fef3c7';
            }
        } else if (paramType === 'achievement' || paramType === 'bonus') {
            severityColor = '#10b981';
            severityBg = '#d1fae5';
        }
        
        // Map error category to severity label
        let mappedSeverity = 'Significant'; // default
        const category = param.error_category || '';
        if (category.includes('Fail')) {
            mappedSeverity = 'Critical Fail';
        } else if (category.includes('Critical')) {
            mappedSeverity = 'Critical';
        } else if (category.includes('Significant')) {
            mappedSeverity = 'Significant';
        } else if (category.includes('Major')) {
            mappedSeverity = 'Major';
        } else if (category.includes('Minor')) {
            mappedSeverity = 'Minor';
        }
        
        const severityLabel = (paramType === 'achievement' || paramType === 'bonus') && param.field_type !== 'radio' ? 'ACHIEVEMENT' : mappedSeverity;
        
        let inputHtml = '';
        
        if (param.field_type === 'radio') {
            // Radio button field (YES/NO)
            inputHtml = `
                <div style="display: flex; align-items: center; gap: 0.3234rem;">
                    <label style="display: flex; align-items: center; gap: 0.1617rem; cursor: pointer;">
                        <input type="radio" name="${param.field_id}" id="${param.field_id}_yes" value="1" required data-penalty="${param.penalty_points}" data-category="${param.error_category}" data-param-type="${paramType}" onchange="calculateAverageScore()" style="width: 0.6469rem; height: 0.6469rem; cursor: pointer; accent-color: #10b981;">
                        <span style="font-size: 0.4852rem; font-weight: 600; color: #10b981;">✓ YES</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.1617rem; cursor: pointer;">
                        <input type="radio" name="${param.field_id}" id="${param.field_id}_no" value="0" required data-penalty="${param.penalty_points}" data-category="${param.error_category}" data-param-type="${paramType}" onchange="calculateAverageScore()" style="width: 0.6469rem; height: 0.6469rem; cursor: pointer; accent-color: #ef4444;">
                        <span style="font-size: 0.4852rem; font-weight: 600; color: #ef4444;">âœ— NO</span>
                    </label>
                </div>
            `;
        } else {
            // Counter field (default) - plain text display for counter value (no container)
            inputHtml = `
                <div style="display: flex; align-items: center; gap: 0.2425rem;">
                    <button type="button" class="counter-btn" data-action="decrement" data-target="${param.field_id}" style="width: 1.1321rem; height: 1.1321rem; display: flex; align-items: center; justify-content: center; border: 0.0304rem solid #d1d5db; background-color: #ffffff; color: #4b5563; border-radius: 0.1617rem; font-size: 0.6469rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: 'Poppins', sans-serif; padding: 0; line-height: 1;">-</button>
                    <span id="${param.field_id}_display" style="font-size: 0.5659rem; font-weight: 700; font-family: 'Poppins', sans-serif; color: #1f2937; min-width: 0.8086rem; text-align: center;">0</span>
                    <button type="button" class="counter-btn" data-action="increment" data-target="${param.field_id}" style="width: 1.1321rem; height: 1.1321rem; display: flex; align-items: center; justify-content: center; border: 0.0304rem solid #d1d5db; background-color: #ffffff; color: #4b5563; border-radius: 0.1617rem; font-size: 0.6469rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: 'Poppins', sans-serif; padding: 0; line-height: 1;">+</button>
                    <input type="number" id="${param.field_id}" name="${param.field_id}" min="0" max="10" value="0" readonly data-penalty="${param.penalty_points}" data-category="${param.error_category}" data-param-type="${paramType}" style="display: none;">
                </div>
            `;
        }
        
        // Create row matching expert-audits.html exactly (lines 1232-1243)
        const rowDiv = document.createElement('div');
        rowDiv.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 3fr; gap: 0.6469rem; align-items: center; padding: 0.3234rem 0; border-bottom: 0.0405rem solid #f3f4f6;';
        
        rowDiv.innerHTML = `
            <div style="font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif;">
                <span style="font-weight: 700; color: ${paramType === 'error' ? '#dc2626' : '#10b981'};">${paramIcon}</span> ${param.error_name}
            </div>
            <div style="display: flex; justify-content: center; font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif;">
                ${param.penalty_points}
            </div>
            <div style="display: flex; justify-content: center;">
                <span style="background: ${severityBg}; color: ${severityColor}; padding: 0.1617rem 0.4852rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 600; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem;">${severityLabel}</span>
            </div>
            <div style="display: flex; justify-content: center;">
                ${inputHtml}
            </div>
            <div id="feedback_container_${param.field_id}" style="display: flex; flex-direction: column; gap: 0.3234rem;">
                <!-- Feedback boxes will be dynamically added here based on error count -->
            </div>
        `;
        
        container.appendChild(rowDiv);
        
        // Initialize feedback boxes based on current error count (initially 0, so no boxes shown)
        updateFeedbackBoxesForParameter(param.field_id, param.field_type || 'counter', param.parameter_type || 'error');
        
        // Setup auto-expand functionality helper
        setupFeedbackTextareaAutoExpand(param.field_id);
    });
    
    // Update summary badges when scores change
    calculateAverageScore();
}

// Clear error parameters
function clearErrorParameters() {
    const container = document.getElementById('errorParametersContainer');
    container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 1.2937rem; color: #6b7280; font-size: 0.5659rem;"><p>Please select a scorecard above to load error parameters.</p></div>';
}

// ============================================================================
// Audit Timer Functionality
(function() {
    let timerInterval = null;
    let startTime = null;
    let elapsedTime = 0;
    let isRunning = false;
    let auditStartTimestamp = null; // Store the absolute audit start timestamp
    
    let timerDisplay = null;
    let timerControlBtn = null;
    
    // Initialize timer elements (will be set when timer is shown)
    function initializeTimerElements() {
        if (!timerDisplay) {
            timerDisplay = document.querySelector('#auditTimer span');
        }
        if (!timerControlBtn) {
            timerControlBtn = document.querySelector('#timerControlBtn');
        }
    }
    const playIcon = '<path d="M8 5v14l11-7z"/>';
    const pauseIcon = '<path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>';
    const resetIcon = '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>';
    
    function formatTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        
        if (hours > 0) {
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        } else {
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
    }
    
    // Helper function to parse duration from database
    // Handles both legacy format (minutes) and new format (seconds)
    // Also handles legacy time strings (HH:MM:SS or MM:SS format)
    function parseDurationFromDatabase(duration) {
        if (duration === null || duration === undefined || duration === '') {
            return 0;
        }
        
        // If it's already a number
        if (typeof duration === 'number' || (!isNaN(duration) && !isNaN(parseFloat(duration)))) {
            const value = parseInt(duration);
            // If value is less than 1440 (24 hours in minutes), assume it's in minutes (legacy format)
            // Otherwise, assume it's already in seconds (new format)
            if (value < 1440) {
                return value * 60; // Convert minutes to seconds
            } else {
                return value; // Already in seconds
            }
        }
        
        // If it's a string, try to parse it
        if (typeof duration === 'string') {
            // Try parsing as integer first
            const asInt = parseInt(duration);
            if (!isNaN(asInt)) {
                // If value is less than 1440 (24 hours in minutes), assume it's in minutes (legacy format)
                // Otherwise, assume it's already in seconds (new format)
                if (asInt < 1440) {
                    return asInt * 60; // Convert minutes to seconds
                } else {
                    return asInt; // Already in seconds
                }
            }
            
            // Try parsing as time string (HH:MM:SS or MM:SS format)
            const timeParts = duration.split(':');
            if (timeParts.length === 2) {
                // MM:SS format
                const minutes = parseInt(timeParts[0]) || 0;
                const seconds = parseInt(timeParts[1]) || 0;
                return (minutes * 60) + seconds;
            } else if (timeParts.length === 3) {
                // HH:MM:SS format
                const hours = parseInt(timeParts[0]) || 0;
                const minutes = parseInt(timeParts[1]) || 0;
                const seconds = parseInt(timeParts[2]) || 0;
                return (hours * 3600) + (minutes * 60) + seconds;
            }
        }
        
        // Default fallback
        return 0;
    }
    
    // Helper function to convert duration to minutes (integer) for database storage
    // Future-proof: handles integer minutes, seconds, and legacy time strings
    function convertDurationToMinutes(duration) {
        if (duration === null || duration === undefined || duration === '') {
            return null;
        }
        
        // If it's already a number
        if (typeof duration === 'number') {
            // If it's less than 1440 (24 hours in minutes), assume it's already in minutes
            if (duration < 1440) {
                return Math.floor(duration);
            }
            // Otherwise assume it's in seconds and convert to minutes
            return Math.floor(duration / 60);
        }
        
        // If it's a string, parse it first
        if (typeof duration === 'string') {
            // Trim whitespace
            duration = duration.trim();
            
            // Try parsing as integer first
            const asInt = parseInt(duration);
            if (!isNaN(asInt)) {
                // If it's less than 1440, likely already in minutes
                if (asInt < 1440) {
                    return asInt;
                }
                // Otherwise assume it's in seconds
                return Math.floor(asInt / 60);
            }
            
            // Try parsing as time string (MM:SS or HH:MM:SS format)
            const timeParts = duration.split(':');
            if (timeParts.length === 2) {
                // MM:SS format
                const minutes = parseInt(timeParts[0]) || 0;
                const seconds = parseInt(timeParts[1]) || 0;
                return minutes + Math.floor(seconds / 60);
            } else if (timeParts.length === 3) {
                // HH:MM:SS format
                const hours = parseInt(timeParts[0]) || 0;
                const minutes = parseInt(timeParts[1]) || 0;
                const seconds = parseInt(timeParts[2]) || 0;
                return (hours * 60) + minutes + Math.floor(seconds / 60);
            }
        }
        
        // Default fallback
        return null;
    }
    
    
    function startTimer() {
        initializeTimerElements();
        if (!isRunning) {
            // If this is the first time starting (no elapsed time), capture the audit start timestamp
            if (elapsedTime === 0 && auditStartTimestamp === null) {
                auditStartTimestamp = new Date().toISOString();
            }
            startTime = Date.now() - (elapsedTime * 1000);
            isRunning = true;
            timerInterval = setInterval(updateDisplay, 1000);
            if (timerControlBtn) {
            timerControlBtn.innerHTML = `<svg style="width: 0.5659rem; height: 0.5659rem;" viewBox="0 0 24 24" fill="currentColor">${pauseIcon}</svg>`;
            timerControlBtn.title = "Pause Timer";
            }
        }
    }
    
    function pauseTimer() {
        initializeTimerElements();
        if (isRunning) {
            isRunning = false;
            clearInterval(timerInterval);
            if (timerControlBtn) {
            timerControlBtn.innerHTML = `<svg style="width: 0.5659rem; height: 0.5659rem;" viewBox="0 0 24 24" fill="currentColor">${playIcon}</svg>`;
            timerControlBtn.title = "Resume Timer";
            }
        }
    }
    
    function resetTimer() {
        initializeTimerElements();
        isRunning = false;
        clearInterval(timerInterval);
        elapsedTime = 0;
        startTime = null;
        auditStartTimestamp = null; // Reset audit start timestamp
        if (timerDisplay) {
        timerDisplay.textContent = '00:00';
        }
        if (timerControlBtn) {
        timerControlBtn.innerHTML = `<svg style="width: 0.5659rem; height: 0.5659rem;" viewBox="0 0 24 24" fill="currentColor">${playIcon}</svg>`;
        timerControlBtn.title = "Start Timer";
        }
        updateAuditDuration();
    }
    
    // Function to get the audit start timestamp
    function getAuditStartTimestamp() {
        return auditStartTimestamp;
    }
    
    // Function to restore the audit start timestamp (used when editing existing audit)
    function restoreAuditStartTimestamp(timestamp) {
        if (timestamp) {
            auditStartTimestamp = timestamp;
        }
    }
    
    function toggleTimer() {
        if (isRunning) {
            pauseTimer();
        } else {
            startTimer();
        }
    }
    
    // Make timer draggable
    let auditTimerEl = null;
    function getAuditTimerElement() {
        if (!auditTimerEl) {
            auditTimerEl = document.querySelector('#auditTimer');
        }
        return auditTimerEl;
    }
    
    // Event listeners for timer (attached when timer is shown)
    function attachTimerEventListeners() {
        initializeTimerElements();
        
        if (timerControlBtn) {
            // Remove existing listeners to avoid duplicates
            const newBtn = timerControlBtn.cloneNode(true);
            timerControlBtn.parentNode.replaceChild(newBtn, timerControlBtn);
            timerControlBtn = newBtn;
            
            timerControlBtn.addEventListener('click', toggleTimer);
            // Double-click to reset
            timerControlBtn.addEventListener('dblclick', (e) => {
                e.preventDefault();
                resetTimer();
            });
        }
        
        const timerEl = getAuditTimerElement();
        if (timerEl) {
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    
            timerEl.addEventListener('mousedown', (e) => {
                initializeTimerElements();
                if (e.target === timerControlBtn || e.target.closest('#timerControlBtn')) return;
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
                const rect = timerEl.getBoundingClientRect();
        startLeft = rect.left;
        startTop = rect.top;
                timerEl.style.cursor = 'grabbing';
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
                timerEl.style.left = (startLeft + deltaX) + 'px';
                timerEl.style.top = (startTop + deltaY) + 'px';
                timerEl.style.right = 'auto';
    });
    
    document.addEventListener('mouseup', () => {
        if (isDragging) {
            isDragging = false;
                    timerEl.style.cursor = 'grab';
                }
            });
        }
    }
    
    // Initialize timer - start immediately
    function initializeTimer() {
        // Capture audit start timestamp if not already set
        if (auditStartTimestamp === null) {
            auditStartTimestamp = new Date().toISOString();
        }
        startTime = Date.now();
        isRunning = true;
        timerInterval = setInterval(updateDisplay, 1000);
        timerControlBtn.innerHTML = `<svg style="width: 0.5659rem; height: 0.5659rem;" viewBox="0 0 24 24" fill="currentColor">${pauseIcon}</svg>`;
        timerControlBtn.title = "Pause Timer";
        updateDisplay();
        
        // Audit timestamp will be set on submission (hidden field)
        
        // Load user data from cache and populate auditor fields
        loadUserData();
        
        // Update week and quarter based on current date
        updateWeekAndQuarter();
    }
    
    // Load user data from localStorage cache (behind the scenes)
    function loadUserData() {
        try {
            const userInfo = localStorage.getItem('userInfo');
            if (userInfo) {
                const user = JSON.parse(userInfo);
                
                // Populate hidden auditor fields from cached user data
                const auditorEmail = document.getElementById('auditorEmail');
                const auditorName = document.getElementById('auditorName');
                
                if (auditorEmail && user.email) {
                    auditorEmail.value = user.email;
                }
                if (auditorName && user.name) {
                    auditorName.value = user.name;
                }
            } else {
                // Fallback to default values if no cached data
                const auditorEmail = document.getElementById('auditorEmail');
                const auditorName = document.getElementById('auditorName');
                if (auditorEmail) {
                    auditorEmail.value = 'auditor@company.com';
                }
                if (auditorName) {
                    auditorName.value = 'John Auditor';
                }
            }
        } catch (error) {
            console.error('Error loading user data from cache:', error);
            // Fallback to default values on error
            const auditorEmail = document.getElementById('auditorEmail');
            const auditorName = document.getElementById('auditorName');
            if (auditorEmail) {
                auditorEmail.value = 'auditor@company.com';
            }
            if (auditorName) {
                auditorName.value = 'John Auditor';
            }
        }
    }
    
    // Calculate week number (1-52) from date
    function getWeekNumber(date) {
        // Get the first day of the year
        const startOfYear = new Date(date.getFullYear(), 0, 1);
        
        // Calculate the Monday of week 1 (the Monday of the week containing Jan 1)
        // If Jan 1 is Sunday (getDay() === 0), Monday is 6 days before (previous Monday)
        // Otherwise, Monday is (getDay() - 1) days before Jan 1
        const dayOfWeek = startOfYear.getDay();
        const daysToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
        const mondayOfWeek1 = new Date(startOfYear);
        mondayOfWeek1.setDate(startOfYear.getDate() + daysToMonday);
        mondayOfWeek1.setHours(0, 0, 0, 0);
        
        // Calculate the Monday of the week containing the given date
        const dateDay = date.getDay();
        const dateDaysToMonday = dateDay === 0 ? -6 : 1 - dateDay;
        const mondayOfDateWeek = new Date(date);
        mondayOfDateWeek.setDate(date.getDate() + dateDaysToMonday);
        mondayOfDateWeek.setHours(0, 0, 0, 0);
        
        // Calculate the number of days from Monday of week 1 to Monday of date's week
        const daysSinceWeek1 = Math.floor((mondayOfDateWeek - mondayOfWeek1) / (24 * 60 * 60 * 1000));
        
        // Calculate the week number (starting from 1)
        const weekNumber = Math.floor(daysSinceWeek1 / 7) + 1;
        
        return weekNumber;
    }
    
    // Calculate quarter (Q1-Q4) from date
    function getQuarter(date) {
        const month = date.getMonth() + 1; // getMonth() returns 0-11
        if (month >= 1 && month <= 3) return 'Q1';
        if (month >= 4 && month <= 6) return 'Q2';
        if (month >= 7 && month <= 9) return 'Q3';
        if (month >= 10 && month <= 12) return 'Q4';
        return 'Q1'; // fallback
    }
    
    // Update week and quarter based on current date
    function updateWeekAndQuarter() {
        const weekField = document.getElementById('week');
        const quarterField = document.getElementById('quarter');
        const now = new Date();
        
        if (weekField) {
            weekField.value = getWeekNumber(now);
        }
        if (quarterField) {
            quarterField.value = getQuarter(now);
        }
    }
    
    // Get current elapsed time (accounting for running timer)
    function getCurrentElapsedTime() {
        if (isRunning && startTime) {
            // Timer is running, calculate current elapsed time
            return Math.floor((Date.now() - startTime) / 1000);
        } else {
            // Timer is paused or stopped, use stored elapsedTime
            return elapsedTime;
        }
    }
    
    // Update hidden audit duration field when timer changes
    // Store duration in seconds (integer) for database, not formatted string
    function updateAuditDuration() {
        const auditDuration = document.getElementById('auditDuration');
        if (auditDuration) {
            // Get current elapsed time (whether timer is running or paused)
            const currentElapsedTime = getCurrentElapsedTime();
            // Store elapsed time in seconds as integer for database
            auditDuration.value = currentElapsedTime;
        }
    }
    
    // Restore timer from saved duration (used when editing existing audit)
    function restoreTimerFromDuration(duration) {
        const durationInSeconds = parseDurationFromDatabase(duration);
        elapsedTime = durationInSeconds;
        
        // Update display
        if (timerDisplay) {
            timerDisplay.textContent = formatTime(elapsedTime);
        }
        
        // Update hidden field
        updateAuditDuration();
    }
    
    // Modified updateDisplay to also update audit duration
    function updateDisplay() {
        if (isRunning && startTime) {
            elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        }
        timerDisplay.textContent = formatTime(elapsedTime);
        updateAuditDuration();
    }
    
    // Make functions globally accessible
    window.resetTimer = resetTimer;
    window.startTimer = startTimer;
    window.loadUserData = loadUserData;
    window.updateWeekAndQuarter = updateWeekAndQuarter;
    window.restoreTimerFromDuration = restoreTimerFromDuration;
    window.parseDurationFromDatabase = parseDurationFromDatabase;
    window.convertDurationToMinutes = convertDurationToMinutes;
    window.attachTimerEventListeners = attachTimerEventListeners;
    window.updateAuditDuration = updateAuditDuration;
    window.getAuditStartTimestamp = getAuditStartTimestamp;
    window.restoreAuditStartTimestamp = restoreAuditStartTimestamp;
    
    // Timer will start when user clicks "Start Audit" button
    // Don't auto-start on page load
})();

// Employee List and Auto-Population Functionality
let allEmployees = []; // Store all employees loaded from Supabase

// Load employees from Supabase
async function loadEmployees() {
    try {
        const employeeSelect = document.getElementById('employeeName');
        
        // Check if Supabase is available
        if (!window.SupabaseUsers) {
            console.error('Supabase not initialized');
            employeeSelect.innerHTML = '<option value="">Error: Supabase not initialized</option>';
            return;
        }
        
        // Load users from Supabase
        allEmployees = await window.SupabaseUsers.getAllUsers({
            orderBy: { column: 'name', ascending: true }
        });
        
        // Populate the dropdown
        employeeSelect.innerHTML = '<option value="">Select Employee</option>';
        
        allEmployees.forEach(user => {
            const option = document.createElement('option');
            option.value = user.email; // Use email as the value
            option.textContent = user.name;
            option.dataset.email = user.email;
            option.dataset.role = user.role || '';
            option.dataset.department = user.department || '';
            option.dataset.designation = user.designation || '';
            option.dataset.employeeId = user.employee_id || '';
            option.dataset.country = user.country || '';
            option.dataset.channel = user.channel || '';
            employeeSelect.appendChild(option);
        });
        
    } catch (error) {
        console.error('Error loading employees:', error);
        const employeeSelect = document.getElementById('employeeName');
        employeeSelect.innerHTML = '<option value="">Error loading employees</option>';
    }
}

// Load channels from channels table
async function loadChannels() {
    try {
        const channelSelect = document.getElementById('channel');
        
        if (!window.supabaseClient) {
            console.error('Supabase client not initialized');
            channelSelect.innerHTML = '<option value="">Error: Supabase not initialized</option>';
            return;
        }
        
        // Fetch active channels from channels table
        const { data, error } = await window.supabaseClient
            .from('channels')
            .select('name')
            .eq('is_active', true)
            .order('name', { ascending: true });
        
        if (error) throw error;
        
        // Populate the dropdown
        channelSelect.innerHTML = '<option value="">Select Channel</option>';
        
        data.forEach(channel => {
            const option = document.createElement('option');
            option.value = channel.name;
            option.textContent = channel.name;
            channelSelect.appendChild(option);
        });
        
        // Set first channel as default if available
        if (data.length > 0) {
            channelSelect.value = data[0].name;
            // Auto-select matching scorecard after a short delay to ensure scorecards are loaded
            setTimeout(async () => {
                await autoSelectScorecardByChannel(data[0].name);
            }, 500);
        } else {
            // If no channels available, still auto-select first scorecard
            setTimeout(async () => {
                const scorecardSelect = document.getElementById('scorecardSelect');
                if (scorecardSelect && (!scorecardSelect.value || scorecardSelect.value === '')) {
                    await loadScorecards();
                }
            }, 500);
        }
        
        console.log('Loaded channels from channels table:', data.map(c => c.name));
        
    } catch (error) {
        console.error('Error loading channels:', error);
        const channelSelect = document.getElementById('channel');
        channelSelect.innerHTML = '<option value="">Error loading channels</option>';
    }
}


// Function to auto-populate Error Description from individual feedback fields (Dynamic)
function populateErrorDescription() {
    const allFeedback = [];
    
    currentParameters.forEach(param => {
        const feedbackElement = document.getElementById(`feedback_${param.field_id}`);
        if (feedbackElement && feedbackElement.value.trim()) {
            allFeedback.push(`${param.error_name}: ${feedbackElement.value.trim()}`);
        }
    });
    
    const errorDescription = document.getElementById('errorDescription');
    if (errorDescription) {
        errorDescription.value = allFeedback.join('\n\n');
    }
}

// ============================================================================
// Close Audit Form Function
// ============================================================================
window.closeAuditForm = async function() {
    // Navigate back to create-audit.html instead of closing modal
    window.location.href = 'create-audit.html';
};

// ============================================================================
// Load Audit for Editing from URL Parameters
// ============================================================================
// Calibration mode detection
let isCalibrationMode = false;
let calibrationSessionId = null;
let calibrationSampleAuditId = null;
let calibrationInteractionId = null;
let calibrationScorecardId = null;
let calibrationTableName = null;

// Check if we're in calibration mode
function checkCalibrationMode() {
    const urlParams = new URLSearchParams(window.location.search);
    const calibration = urlParams.get('calibration');
    
    if (calibration === 'true') {
        isCalibrationMode = true;
        calibrationSessionId = urlParams.get('sessionId');
        calibrationSampleAuditId = urlParams.get('auditId');
        calibrationInteractionId = urlParams.get('interactionId');
        calibrationScorecardId = urlParams.get('scorecardId');
        calibrationTableName = urlParams.get('tableName');
        
        console.log('Calibration mode detected:', {
            sessionId: calibrationSessionId,
            auditId: calibrationSampleAuditId,
            interactionId: calibrationInteractionId,
            scorecardId: calibrationScorecardId,
            tableName: calibrationTableName
        });
        
        return true;
    }
    return false;
}

async function loadAuditForEditing() {
    const urlParams = new URLSearchParams(window.location.search);
    const auditId = urlParams.get('edit');
    const scorecardId = urlParams.get('scorecard');
    const tableName = urlParams.get('table');
    
    // Check for calibration mode first
    if (checkCalibrationMode()) {
        await loadCalibrationSampleAudit();
        return;
    }
    
    if (!auditId || !tableName) {
        return; // No edit parameters, normal create mode
    }
    
    try {
        console.log('Loading audit for editing:', auditId, 'from table:', tableName);
        
        // Load the audit data from the specified table
        const { data, error } = await window.supabaseClient
            .from(tableName)
            .select('*')
            .eq('id', auditId)
            .single();
        
        if (error) throw error;
        
        if (!data) {
            alert('Audit not found');
            return;
        }
        
        console.log('Loaded audit data:', data);
        
        // Set editing mode flag FIRST to prevent event handlers from interfering
        isEditingExistingAudit = true;
        currentEditingAuditId = auditId;
        currentEditingTableName = tableName;
        
        // Show the audit form modal
        const auditFormModal = document.getElementById('auditFormModal');
        if (auditFormModal) {
            auditFormModal.style.display = 'flex';
        }
        
        // Hide pending audits section when editing
        const pendingAuditsSection = document.getElementById('pendingAuditsSection');
        if (pendingAuditsSection) {
            pendingAuditsSection.style.display = 'none';
        }
        
        // Load and select the scorecard
        if (scorecardId) {
            const scorecardSelect = document.getElementById('scorecardSelect');
            if (scorecardSelect) {
                // Wait for scorecard options to be populated
                let attempts = 0;
                while (scorecardSelect.options.length <= 1 && attempts < 50) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                if (scorecardSelect.options.length > 1) {
                    // Set the value (this will trigger the change event, but that's okay since we're in edit mode)
                    scorecardSelect.value = scorecardId;
                    
                    // Wait for scorecard parameters to fully load
                    // The isEditingExistingAudit flag should prevent the change handler from clearing the form
                    await loadScorecardParameters(scorecardId);
                    
                    // Additional wait to ensure parameters are rendered in DOM
                    await new Promise(resolve => setTimeout(resolve, 300));
                } else {
                    console.error('Scorecard dropdown not populated yet');
                    alert('Error: Scorecard dropdown not ready. Please refresh the page.');
                    return;
                }
            } else {
                console.error('Scorecard select element not found');
                alert('Error: Scorecard select element not found. Please refresh the page.');
                return;
            }
        }
        
        // Populate form fields with audit data
        await populateFormWithAuditData(data);
        
        // Update header to indicate editing mode
        const formHeader = document.getElementById('formScorecardDisplay');
        if (formHeader) {
            formHeader.innerHTML = 'Editing Audit - ' + formHeader.innerHTML;
        }
        
        // Restore audit start timestamp if editing existing audit
        if (window.restoreAuditStartTimestamp && data.audit_start_time) {
            window.restoreAuditStartTimestamp(data.audit_start_time);
        }
        
        // Restore timer from saved duration if editing existing audit
        if (window.restoreTimerFromDuration && data.audit_duration !== null && data.audit_duration !== undefined) {
            window.restoreTimerFromDuration(data.audit_duration);
        } else {
            // Start fresh timer if no saved duration
        if (window.resetTimer && window.startTimer) {
            window.resetTimer();
            window.startTimer();
            }
        }
        
    } catch (error) {
        console.error('Error loading audit for editing:', error);
        alert('Failed to load audit for editing: ' + error.message);
    }
}

// ============================================================================
// Populate Form with Audit Data
// ============================================================================
async function populateFormWithAuditData(audit) {
    try {
        // Populate employee information
        const employeeSelect = document.getElementById('employeeName');
        const employeeEmail = document.getElementById('employeeEmail');
        const employeeType = document.getElementById('employeeType');
        const employeeDepartment = document.getElementById('employeeDepartment');
        const countryOfEmployee = document.getElementById('countryOfEmployee');
        
        if (employeeSelect && audit.employee_email) {
            // Wait for employee options to be populated if not ready
            let attempts = 0;
            while (employeeSelect.options.length === 0 && attempts < 50) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            // Find and select the employee in dropdown
            let employeeFound = false;
            const normalizedEmail = (audit.employee_email || '').toLowerCase().trim();
            for (let i = 0; i < employeeSelect.options.length; i++) {
                const optionEmail = (employeeSelect.options[i].dataset.email || '').toLowerCase().trim();
                if (optionEmail === normalizedEmail) {
                    employeeSelect.selectedIndex = i;
                    // Trigger change event to populate other fields
                    employeeSelect.dispatchEvent(new Event('change'));
                    employeeFound = true;
                    break;
                }
            }
            
            if (!employeeFound && employeeSelect.options.length > 0) {
                console.warn('Employee not found in dropdown:', audit.employee_email);
            }
        }
        
        // Set employee fields directly from audit data (in case dropdown selection fails)
        if (employeeEmail) employeeEmail.value = audit.employee_email || '';
        if (employeeType) employeeType.value = audit.employee_type || '';
        if (employeeDepartment) employeeDepartment.value = audit.employee_department || '';
        if (countryOfEmployee) countryOfEmployee.value = audit.country_of_employee || '';
        
        // Populate interaction details
        const interactionId = document.getElementById('interactionId');
        const interactionDate = document.getElementById('interactionDate');
        const channel = document.getElementById('channel');
        const clientEmail = document.getElementById('clientEmail');
        
        if (interactionId) interactionId.value = audit.interaction_id || '';
        if (interactionDate) interactionDate.value = audit.interaction_date || '';
        if (channel) channel.value = audit.channel || '';
        if (clientEmail) clientEmail.value = audit.client_email || '';
        
        // Populate audit type and validation
        const auditType = document.getElementById('auditType');
        const validationStatus = document.getElementById('validationStatus');
        
        if (auditType) auditType.value = audit.audit_type || '';
        if (validationStatus) validationStatus.value = audit.validation_status || '';
        
        // Populate transcript and recommendations
        const transcript = document.getElementById('transcript');
        const recommendations = document.getElementById('recommendations');
        
        if (transcript) transcript.value = audit.transcript || '';
        if (recommendations) recommendations.value = audit.recommendations || '';
        
        // Wait for scorecard parameters to be fully loaded and rendered
        let attempts = 0;
        while ((!currentParameters || currentParameters.length === 0) && attempts < 30) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }
        
        if (attempts >= 30) {
            console.warn('Timeout waiting for scorecard parameters to load');
        }
        
        // Populate error parameters
        if (currentParameters && currentParameters.length > 0) {
            currentParameters.forEach(param => {
                const fieldValue = audit[param.field_id];
                
                if (param.field_type === 'radio') {
                    // Set radio button selection
                    const radioYes = document.getElementById(`${param.field_id}_yes`);
                    const radioNo = document.getElementById(`${param.field_id}_no`);
                    
                    if (fieldValue === 1 || fieldValue === true || fieldValue === 'true' || fieldValue === '1') {
                        if (radioYes) radioYes.checked = true;
                    } else {
                        if (radioNo) radioNo.checked = true;
                    }
                } else {
                    // Set counter value
                    const field = document.getElementById(param.field_id);
                    const counterValue = fieldValue || 0;
                    if (field) {
                        field.value = counterValue;
                    }
                    
                    // Update plain text display
                    const displayElement = document.getElementById(`${param.field_id}_display`);
                    if (displayElement) {
                        displayElement.textContent = counterValue;
                        // Update color based on value
                        if (counterValue > 0) {
                            displayElement.style.color = '#ef4444';
                            displayElement.style.fontWeight = '700';
                        } else {
                            displayElement.style.color = '#1f2937';
                            displayElement.style.fontWeight = '700';
                        }
                    }
                }
                
                // Populate feedback - handle both old format (string) and new format (JSON array)
                const feedbackData = audit[`feedback_${param.field_id}`];
                let feedbackArray = [];
                
                if (feedbackData) {
                    if (typeof feedbackData === 'string') {
                        // Try to parse as JSON array, fallback to single string
                        try {
                            const parsed = JSON.parse(feedbackData);
                            feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                        } catch (e) {
                            // If not valid JSON, treat as single string (backward compatibility)
                            feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                        }
                    } else if (Array.isArray(feedbackData)) {
                        feedbackArray = feedbackData;
                    } else {
                        feedbackArray = feedbackData ? [feedbackData] : [];
                    }
                }
                
                // Update feedback boxes based on error count first, then populate values
                const paramType = param.parameter_type || 'error';
                updateFeedbackBoxesForParameter(param.field_id, param.field_type || 'counter', paramType);
                
                // Populate feedback values into the boxes
                if (feedbackArray.length > 0) {
                    const feedbackContainer = document.getElementById(`feedback_container_${param.field_id}`);
                    if (feedbackContainer) {
                        feedbackArray.forEach((feedbackText, index) => {
                            const feedbackId = `feedback_${param.field_id}_${index}`;
                            const textarea = document.getElementById(feedbackId);
                            if (textarea && feedbackText) {
                                textarea.value = feedbackText;
                                // Trigger auto-expand
                                setTimeout(() => {
                                    textarea.style.height = 'auto';
                                    const scrollHeightRem = textarea.scrollHeight / 16;
                                    textarea.style.height = Math.min(scrollHeightRem, 50.0) + 'rem';
                                }, 100);
                            }
                        });
                    }
                }
            });
        }
        
        // Recalculate scores
        calculateAverageScore();
        
        console.log('Form populated with audit data');
        
    } catch (error) {
        console.error('Error populating form with audit data:', error);
    }
}

// ============================================================================
// Save Calibration Result
// ============================================================================
async function saveCalibrationResult(auditPayload, auditData) {
    try {
        // Get current user info
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const participantEmail = userInfo.email || '';
        const participantName = userInfo.name || '';

        // Build error parameters JSONB
        const errorParameters = {};
        const feedbackParameters = {};
        
        currentParameters.forEach(param => {
            const fieldValue = auditData[param.field_id];
            errorParameters[param.field_id] = fieldValue ? parseInt(fieldValue) : 0;
            
            const feedbackKey = `feedback_${param.field_id}`;
            if (auditData[feedbackKey]) {
                feedbackParameters[param.field_id] = auditData[feedbackKey];
            }
        });

        const calibrationResult = {
            calibration_session_id: calibrationSessionId,
            participant_email: participantEmail,
            participant_name: participantName,
            scorecard_id: calibrationScorecardId,
            sample_audit_id: calibrationSampleAuditId,
            
            // Audit timing
            audit_start_time: auditPayload.audit_start_time,
            audit_end_time: auditPayload.audit_end_time,
            audit_duration: auditPayload.audit_duration,
            
            // Employee info (from sample)
            employee_name: auditPayload.employee_name,
            employee_email: auditPayload.employee_email,
            employee_type: auditPayload.employee_type,
            employee_department: auditPayload.employee_department,
            country_of_employee: auditPayload.country_of_employee,
            
            // Interaction details (from sample)
            interaction_id: auditPayload.interaction_id,
            interaction_date: auditPayload.interaction_date,
            channel: auditPayload.channel,
            client_email: auditPayload.client_email,
            
            // Audit metadata
            audit_type: auditPayload.audit_type,
            passing_status: auditPayload.passing_status,
            validation_status: 'Validated',
            
            // Scores
            average_score: auditPayload.average_score,
            critical_errors: auditPayload.critical_errors || 0,
            critical_fail_error: auditPayload.critical_fail_error || 0,
            significant_error: auditPayload.significant_error || 0,
            total_errors_count: auditPayload.total_errors_count || 0,
            
            // Content
            transcript: auditPayload.transcript,
            recommendations: auditPayload.recommendations,
            
            // Dynamic parameters
            error_parameters: errorParameters,
            feedback_parameters: feedbackParameters,
            
            status: 'submitted'
        };

        console.log('Saving calibration result:', calibrationResult);

        const { data, error } = await window.supabaseClient
            .from('calibration_results')
            .insert([calibrationResult])
            .select();

        if (error) throw error;

        console.log('Calibration result saved successfully:', data);

        await window.confirmationDialog.show({
            title: 'Calibration Submitted!',
            message: 'Your calibration audit has been submitted successfully.',
            confirmText: 'OK',
            type: 'success'
        });

        // Close the form
        closeAuditForm();

        // If opened from calibration page, notify parent window
        if (window.opener) {
            window.opener.postMessage({ type: 'calibration_submitted', sessionId: calibrationSessionId }, '*');
            window.close();
        }

    } catch (error) {
        console.error('Error saving calibration result:', error);
        await window.confirmationDialog.show({
            title: 'Submission Error',
            message: 'Failed to submit calibration audit: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// Load calibration sample audit and populate form
async function loadCalibrationSampleAudit() {
    try {
        if (!isCalibrationMode || !calibrationScorecardId) {
            console.error('Missing calibration parameters');
            return;
        }

        // Check if we have audit_id or interaction_id
        if (!calibrationSampleAuditId && !calibrationInteractionId) {
            console.error('Missing audit ID or interaction ID');
            return;
        }

        console.log('Loading calibration sample audit...');

        let sampleAudit = null;
        
        if (calibrationSampleAuditId && calibrationTableName) {
            // Load the sample audit from database
            const { data, error: auditError } = await window.supabaseClient
                .from(calibrationTableName)
                .select('*')
                .eq('id', calibrationSampleAuditId)
                .single();

            if (auditError || !data) {
                alert('Error loading sample audit: ' + (auditError?.message || 'Audit not found'));
                return;
            }
            sampleAudit = data;
        } else if (calibrationInteractionId) {
            // Create minimal audit object from interaction_id
            // The interaction details will be loaded from Intercom
            sampleAudit = {
                interaction_id: calibrationInteractionId,
                scorecard_id: calibrationScorecardId,
                // Other fields will be populated from Intercom if available
            };
        }
        
        if (!sampleAudit) {
            alert('Error: Could not load sample audit or interaction');
            return;
        }

        // Load scorecard and parameters
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect) {
            scorecardSelect.value = calibrationScorecardId;
            await loadScorecardParameters(calibrationScorecardId);
        }

        // Wait a bit for parameters to load
        await new Promise(resolve => setTimeout(resolve, 500));

        // Show the audit form modal
        const auditFormModal = document.getElementById('auditFormModal');
        if (auditFormModal) {
            auditFormModal.style.display = 'flex';
        }

        // Hide pending audits section
        const pendingAuditsSection = document.getElementById('pendingAuditsSection');
        if (pendingAuditsSection) {
            pendingAuditsSection.style.display = 'none';
        }

        // Update header to indicate calibration mode
        const formHeader = document.getElementById('auditFormHeader');
        const scorecardDisplay = document.getElementById('formScorecardDisplay');
        if (formHeader && scorecardDisplay) {
            const h2 = formHeader.querySelector('h2');
            if (h2) h2.textContent = 'Calibration Audit';
            scorecardDisplay.innerHTML = '<svg style="width: 0.5659rem; height: 0.5659rem; display: inline-block; vertical-align: middle; margin-right: 0.2425rem;" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg> Calibration Mode';
        }

        // Populate form with sample audit data (read-only for some fields)
        await populateFormWithCalibrationSample(sampleAudit);

        // Start timer
        if (window.resetTimer && window.startTimer) {
            window.resetTimer();
            window.startTimer();
        }

        // Show timer
        const auditTimer = document.getElementById('auditTimer');
        if (auditTimer) {
            auditTimer.style.display = 'flex';
        }

    } catch (error) {
        console.error('Error loading calibration sample audit:', error);
        alert('Error loading calibration sample audit: ' + error.message);
    }
}

// Populate form with calibration sample audit (make certain fields read-only)
async function populateFormWithCalibrationSample(sampleAudit) {
    try {
        // First, ensure employees are loaded
        await loadEmployees();
        
        // Employee name dropdown (read-only - select from sample)
        const employeeSelect = document.getElementById('employeeName');
        if (employeeSelect && sampleAudit.employee_email) {
            // Find and select the employee in dropdown
            for (let i = 0; i < employeeSelect.options.length; i++) {
                if (employeeSelect.options[i].dataset.email === sampleAudit.employee_email) {
                    employeeSelect.selectedIndex = i;
                    break;
                }
            }
            employeeSelect.disabled = true;
            employeeSelect.style.backgroundColor = 'transparent';
            employeeSelect.style.color = 'white';
            employeeSelect.style.cursor = 'not-allowed';
            employeeSelect.style.opacity = '0.9';
        }

        // Employee information (read-only - from sample)
        const employeeEmail = document.getElementById('employeeEmail');
        const employeeType = document.getElementById('employeeType');
        const employeeDepartment = document.getElementById('employeeDepartment');
        const countryOfEmployee = document.getElementById('countryOfEmployee');

        // Set employee info from sample (read-only) - WHITE TEXT ON GREEN BACKGROUND
        if (employeeEmail) {
            employeeEmail.value = sampleAudit.employee_email || '';
            employeeEmail.readOnly = true;
            employeeEmail.style.backgroundColor = 'transparent';
            employeeEmail.style.color = 'white';
            employeeEmail.style.cursor = 'not-allowed';
            employeeEmail.style.opacity = '0.9';
        }

        if (employeeType) {
            employeeType.value = sampleAudit.employee_type || '';
            employeeType.readOnly = true;
            employeeType.style.backgroundColor = 'transparent';
            employeeType.style.color = 'white';
            employeeType.style.cursor = 'not-allowed';
            employeeType.style.opacity = '0.9';
        }

        if (employeeDepartment) {
            employeeDepartment.value = sampleAudit.employee_department || '';
            employeeDepartment.readOnly = true;
            employeeDepartment.style.backgroundColor = 'transparent';
            employeeDepartment.style.color = 'white';
            employeeDepartment.style.cursor = 'not-allowed';
            employeeDepartment.style.opacity = '0.9';
        }

        if (countryOfEmployee) {
            countryOfEmployee.value = sampleAudit.country_of_employee || '';
            countryOfEmployee.disabled = true;
            countryOfEmployee.style.backgroundColor = 'transparent';
            countryOfEmployee.style.color = 'white';
            countryOfEmployee.style.cursor = 'not-allowed';
            countryOfEmployee.style.opacity = '0.9';
        }

        // Interaction details (read-only - from sample) - NOT in header, so gray background
        // These fields should NOT be editable during calibration
        const interactionId = document.getElementById('interactionId');
        const interactionDate = document.getElementById('interactionDate');
        const channel = document.getElementById('channel');
        const clientEmail = document.getElementById('clientEmail');
        const viewChatBtn = document.getElementById('viewChatBtn');

        if (interactionId) {
            interactionId.value = sampleAudit.interaction_id || '';
            interactionId.readOnly = true;
            interactionId.disabled = true; // Disable to prevent editing
            interactionId.style.backgroundColor = '#f3f4f6';
            interactionId.style.cursor = 'not-allowed';
        }

        if (interactionDate) {
            interactionDate.value = sampleAudit.interaction_date || '';
            interactionDate.readOnly = true;
            interactionDate.disabled = true; // Disable to prevent editing
            interactionDate.style.backgroundColor = '#f3f4f6';
            interactionDate.style.cursor = 'not-allowed';
        }

        if (channel) {
            channel.value = sampleAudit.channel || '';
            channel.disabled = true;
            channel.style.backgroundColor = '#f3f4f6';
            channel.style.cursor = 'not-allowed';
        }

        if (clientEmail) {
            clientEmail.value = sampleAudit.client_email || '';
            clientEmail.readOnly = true;
            clientEmail.disabled = true; // Disable to prevent editing
            clientEmail.style.backgroundColor = '#f3f4f6';
            clientEmail.style.cursor = 'not-allowed';
        }

        // Disable "Open" button for interaction ID - interaction is read-only
        if (viewChatBtn) {
            viewChatBtn.disabled = true;
            viewChatBtn.style.opacity = '0.5';
            viewChatBtn.style.cursor = 'not-allowed';
        }

        // Show chat view by default for calibration (like audit-view.html)
        const transcriptChatView = document.getElementById('transcriptChatView');
        const transcriptTextView = document.getElementById('transcriptTextView');
        const chatMessagesContainer = document.getElementById('chatMessagesContainer');
        
        if (transcriptChatView && transcriptTextView) {
            // Show chat view by default
            transcriptChatView.style.display = 'flex';
            transcriptTextView.style.display = 'none';
            // Set global flag if available
            if (typeof window !== 'undefined') {
                window.isChatViewActive = true;
            }
        }

        // Load conversation from Intercom if interaction ID exists
        if (sampleAudit.interaction_id) {
            // Show loading state immediately
            if (chatMessagesContainer) {
                chatMessagesContainer.innerHTML = `
                    <div style="text-align: center; padding: 1.2937rem; color: #6b7280;">
                        <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
                    </div>
                `;
            }
            // Wait for the function to be available (it's defined in DOMContentLoaded)
            // Try multiple times to ensure DOMContentLoaded has fired
            let attempts = 0;
            const maxAttempts = 20;
            const checkAndLoad = setInterval(() => {
                attempts++;
                if (window.loadConversationFromIntercom && typeof window.loadConversationFromIntercom === 'function') {
                    clearInterval(checkAndLoad);
                    window.loadConversationFromIntercom(sampleAudit.interaction_id);
                } else if (attempts >= maxAttempts) {
                    clearInterval(checkAndLoad);
                    console.error('loadConversationFromIntercom function not available after waiting');
                    // Auto-fallback to text view on error
                    if (transcriptChatView && transcriptTextView) {
                        transcriptChatView.style.display = 'none';
                        transcriptTextView.style.display = 'flex';
                        if (typeof window !== 'undefined') {
                            window.isChatViewActive = false;
                        }
                    }
                }
            }, 100);
        } else {
            // No interaction ID - auto-fallback to text view with database transcript
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'none';
                transcriptTextView.style.display = 'flex';
                if (typeof window !== 'undefined') {
                    window.isChatViewActive = false;
                }
            }
        }

        // Transcript (read-only - from sample)
        const transcript = document.getElementById('transcript');
        if (transcript) {
            transcript.value = sampleAudit.transcript || '';
            transcript.readOnly = true;
            transcript.style.backgroundColor = '#f3f4f6';
            transcript.style.cursor = 'not-allowed';
        }

        // Audit type (from sample - read-only)
        const auditType = document.getElementById('auditType');
        if (auditType) {
            auditType.value = sampleAudit.audit_type || '';
            auditType.disabled = true;
            auditType.style.backgroundColor = '#f3f4f6';
            auditType.style.cursor = 'not-allowed';
        }

        // Validation status (read-only - always Validated for calibration)
        const validationStatus = document.getElementById('validationStatus');
        if (validationStatus) {
            validationStatus.value = 'Validated';
            validationStatus.disabled = true;
            validationStatus.style.backgroundColor = '#f3f4f6';
            validationStatus.style.cursor = 'not-allowed';
        }

        // Scorecard select (read-only - already selected) - check if it's in header
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect) {
            scorecardSelect.disabled = true;
            // Check if scorecard is in header (green background section)
            const headerElement = document.getElementById('auditFormHeader');
            if (headerElement && headerElement.contains(scorecardSelect)) {
                scorecardSelect.style.backgroundColor = 'transparent';
                scorecardSelect.style.color = 'white';
                scorecardSelect.style.opacity = '0.9';
            } else {
                scorecardSelect.style.backgroundColor = '#f3f4f6';
            }
            scorecardSelect.style.cursor = 'not-allowed';
        }

        // Populate error parameters (these are editable - participant scores them)
        // Don't pre-populate - let participant score fresh
        if (currentParameters && currentParameters.length > 0) {
            currentParameters.forEach(param => {
                if (param.field_type === 'radio') {
                    const radioYes = document.getElementById(`${param.field_id}_yes`);
                    const radioNo = document.getElementById(`${param.field_id}_no`);
                    if (radioYes) radioYes.checked = false;
                    if (radioNo) radioNo.checked = false;
                } else {
                    const field = document.getElementById(param.field_id);
                    if (field) {
                        field.value = 0;
                    }
                }
                
                // Clear feedback (participant provides their own)
                const feedbackField = document.getElementById(`feedback_${param.field_id}`);
                if (feedbackField) {
                    feedbackField.value = '';
                }
            });
        }

        // Initialize score calculation
        if (typeof calculateAverageScore === 'function') {
            calculateAverageScore();
        }

        console.log('Calibration form populated with sample audit data');

    } catch (error) {
        console.error('Error populating calibration form:', error);
    }
}

// Audit Form Submission Handler

document.addEventListener('DOMContentLoaded', function() {
    // Header dropdown functionality
    const headerDropdownBtn = document.getElementById('headerDropdownBtn');
    const headerDropdownMenu = document.getElementById('headerDropdownMenu');
    const headerDropdownIcon = document.getElementById('headerDropdownIcon');
    
    if (headerDropdownBtn && headerDropdownMenu) {
        // Toggle dropdown on button click
        headerDropdownBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            const isHidden = headerDropdownMenu.classList.contains('hidden');
            
            if (isHidden) {
                headerDropdownMenu.classList.remove('hidden');
                if (headerDropdownIcon) {
                    headerDropdownIcon.style.transform = 'rotate(180deg)';
                }
            } else {
                headerDropdownMenu.classList.add('hidden');
                if (headerDropdownIcon) {
                    headerDropdownIcon.style.transform = 'rotate(0deg)';
                }
            }
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!headerDropdownBtn.contains(e.target) && !headerDropdownMenu.contains(e.target)) {
                headerDropdownMenu.classList.add('hidden');
                if (headerDropdownIcon) {
                    headerDropdownIcon.style.transform = 'rotate(0deg)';
                }
            }
        });
    }
    
    // Helper function to copy conversation ID
    window.copyConversationId = function() {
        const interactionId = document.getElementById('interactionId');
        if (interactionId && interactionId.value) {
            navigator.clipboard.writeText(interactionId.value).then(() => {
                showNotification('Conversation ID copied to clipboard!', 'success');
            }).catch(() => {
                showNotification('Failed to copy Conversation ID', 'error');
            });
        } else {
            showNotification('No Conversation ID available', 'error');
        }
    };
    
    // Helper function to copy client email
    window.copyClientEmail = function() {
        const clientEmail = document.getElementById('clientEmail');
        if (clientEmail && clientEmail.value) {
            navigator.clipboard.writeText(clientEmail.value).then(() => {
                showNotification('Client email copied to clipboard!', 'success');
            }).catch(() => {
                showNotification('Failed to copy client email', 'error');
            });
        } else {
            showNotification('No client email available', 'error');
        }
    };
    console.log('DOMContentLoaded fired');
    
    // Check page access using centralized access control
    if (!window.accessControl || !window.accessControl.enforcePageAccess('audit-form.html')) {
        return; // Access denied, user will be redirected
    }
    
    // Initialize form immediately - the submit handler will wait for Supabase
    initializeForm();
    
    function initializeForm() {
        // Check if user is an Employee and hide create manual audit button
        try {
            const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
            const userRole = userInfo.role || '';
            
            if (userRole === 'Employee') {
                const createManualAuditBtn = document.getElementById('createManualAuditBtn');
                if (createManualAuditBtn) {
                    createManualAuditBtn.style.display = 'none';
                }
            }
        } catch (error) {
            console.error('Error checking user role for button visibility:', error);
        }
        
        const auditForm = document.getElementById('auditForm');
        const cancelBtn = document.getElementById('cancelBtn');
        const employeeSelect = document.getElementById('employeeName');
        const employeeEmail = document.getElementById('employeeEmail');
        const employeeType = document.getElementById('employeeType');
        const countryOfEmployee = document.getElementById('countryOfEmployee');
        
        if (!auditForm) {
            console.error('auditForm element not found!');
            window.confirmationDialog.show({
                title: 'Form Error',
                message: 'Error: Form element not found! Please refresh the page.',
                confirmText: 'Refresh',
                cancelText: 'OK',
                type: 'error'
            });
            return;
        }
        
        console.log('Form element found:', auditForm);
        
        // Load scorecards when page loads
        loadScorecards();
        
        // Initialize sort dropdown
        const sortBy = document.getElementById('auditSortBy');
        if (sortBy) {
            sortBy.value = currentSortOrder;
        }
        
        // Load pending audits when page loads (all assigned audits)
        loadPendingAudits();
        
        // Initialize date selector for pull conversations
        const pullConversationsDateInput = document.getElementById('pullConversationsDate');
        if (pullConversationsDateInput) {
            pullConversationsDateInput.addEventListener('change', async function() {
                if (pullConversationsAdminId && this.value) {
                    await fetchConversationsForCurrentUser(this.value);
                }
            });
        }

        // Setup tooltip positioning for all column headers
        function setupColumnTooltips() {
            const tooltipContainers = document.querySelectorAll('.column-tooltip-container');
            tooltipContainers.forEach(container => {
                const infoIcon = container.querySelector('.info-icon');
                const tooltip = container.querySelector('.column-tooltip');
                
                if (infoIcon && tooltip) {
                    // Remove existing listeners by cloning
                    const newInfoIcon = infoIcon.cloneNode(true);
                    const newTooltip = tooltip.cloneNode(true);
                    infoIcon.parentNode.replaceChild(newInfoIcon, infoIcon);
                    tooltip.parentNode.replaceChild(newTooltip, tooltip);
                    
                    newInfoIcon.addEventListener('mouseenter', function(e) {
                        const rect = newInfoIcon.getBoundingClientRect();
                        
                        // Position tooltip above the icon, aligned to the right
                        let top = rect.top - 10; // Start above, will adjust if needed
                        let left = rect.right - 320; // 20rem = 320px, align right edge
                        
                        // If tooltip would go off screen to the left, align to icon's left edge
                        if (left < 8) {
                            left = rect.left;
                        }
                        
                        // Temporarily show tooltip to measure its height
                        newTooltip.style.position = 'fixed';
                        newTooltip.style.top = '-9999px';
                        newTooltip.style.left = left + 'px';
                        newTooltip.style.opacity = '1';
                        newTooltip.style.visibility = 'visible';
                        const tooltipHeight = newTooltip.offsetHeight;
                        
                        // Now position it correctly above the icon
                        top = rect.top - tooltipHeight - 8;
                        
                        // If tooltip would go off screen to the top, position below instead
                        if (top < 8) {
                            top = rect.bottom + 8;
                        }
                        
                        newTooltip.style.top = top + 'px';
                        newTooltip.style.right = 'auto';
                        newTooltip.style.bottom = 'auto';
                        newTooltip.style.transform = 'none';
                        newTooltip.style.zIndex = '9999';
                    });
                    
                    newInfoIcon.addEventListener('mouseleave', function() {
                        newTooltip.style.opacity = '0';
                        newTooltip.style.visibility = 'hidden';
                    });
                }
            });
        }

        // Setup tooltip after page load
        document.addEventListener('DOMContentLoaded', function() {
            setupColumnTooltips();
        });

        // Also setup after conversations are displayed
        const originalDisplayPullConversationsList = window.displayPullConversationsList;
        if (originalDisplayPullConversationsList) {
            window.displayPullConversationsList = function(conversations) {
                originalDisplayPullConversationsList(conversations);
                setTimeout(setupColumnTooltips, 100);
            };
        }
        
        // Initialize filters
        populateScorecardFilter();
        
        // Add event listener for search input (real-time filtering with debounce)
        const searchInput = document.getElementById('filterSearch');
        if (searchInput) {
            let searchTimeout;
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    applyFilters();
                }, 300); // Debounce search by 300ms
            });
        }
        
        // All other filters (date, status, scorecard) already have onchange="applyFilters()" in HTML
        
        // Load your stats when page loads
        updateYourStats();
        
        // Load employees when page loads
        loadEmployees();
        
        // Check if we're editing an existing audit from URL parameters
        // Wait for dependencies to load: Supabase, scorecards, and employees
        setTimeout(async () => {
            // Ensure scorecards and employees are loaded before editing
            let attempts = 0;
            const maxAttempts = 30; // 3 seconds max wait
            
            while (attempts < maxAttempts) {
                // Check if scorecards dropdown has options (other than the default "Select a scorecard..." option)
                const scorecardSelect = document.getElementById('scorecardSelect');
                const employeeSelect = document.getElementById('employeeName');
                
                const scorecardsLoaded = scorecardSelect && scorecardSelect.options.length > 1;
                const employeesLoaded = employeeSelect && employeeSelect.options.length > 0;
                const supabaseReady = window.supabaseClient;
                
                if (scorecardsLoaded && employeesLoaded && supabaseReady) {
                    console.log('Dependencies loaded, proceeding with edit mode');
                    await loadAuditForEditing();
                    break;
                }
                
                attempts++;
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (attempts >= maxAttempts) {
                console.warn('Timeout waiting for dependencies, attempting to load audit anyway');
                await loadAuditForEditing();
            }
        }, 500); // Start checking after 500ms
        
        // Handle scorecard selection change
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect) {
            scorecardSelect.addEventListener('change', async function() {
                // Don't clear form if we're in edit mode
                if (isEditingExistingAudit) {
                    return; // Let the edit mode handler manage the scorecard selection
                }
                
                const selectedValue = this.value;
                // Validate before loading to prevent UUID errors
                if (selectedValue && selectedValue !== 'null' && selectedValue !== 'undefined' && selectedValue.trim() !== '') {
                    await loadScorecardParameters(selectedValue);
                } else {
                    // Clear scorecard info if invalid selection
                    currentScorecard = null;
                    currentParameters = [];
                    document.getElementById('scorecardInfo').style.display = 'none';
                    clearErrorParameters();
                }
            });
        }
        
        // Load employees when page loads
        loadEmployees();
        
        // Load channels from users' teams
        loadChannels();
        
        // Handle channel selection change - auto-select matching scorecard
        const channelSelect = document.getElementById('channel');
        if (channelSelect) {
            channelSelect.addEventListener('change', async function() {
                const selectedChannel = this.value;
                if (selectedChannel) {
                    await autoSelectScorecardByChannel(selectedChannel);
                } else {
                    // If channel is cleared, reload all scorecards
                    await loadScorecards();
                }
            });
            
            // Also trigger on page load if channel is already selected
            if (channelSelect.value) {
                setTimeout(async () => {
                    await autoSelectScorecardByChannel(channelSelect.value);
                }, 500);
            } else {
                // If no channel selected, ensure first scorecard is auto-selected after a delay
                setTimeout(async () => {
                    const scorecardSelect = document.getElementById('scorecardSelect');
                    if (scorecardSelect && (!scorecardSelect.value || scorecardSelect.value === '')) {
                        await loadScorecards();
                    }
                }, 800);
            }
        }
        
        // Handle employee selection change
        employeeSelect.addEventListener('change', function() {
            const selectedOption = this.options[this.selectedIndex];
            
            if (selectedOption && selectedOption.value) {
                // Auto-populate email from the selected employee
                const email = selectedOption.dataset.email || selectedOption.value;
                if (employeeEmail) {
                    employeeEmail.value = email;
                }
                
                // Auto-populate employee type from designation
                const designation = selectedOption.dataset.designation || '';
                if (employeeType && designation) {
                    employeeType.value = designation;
                }
                
                // Auto-populate department from selected employee
                const department = selectedOption.dataset.department || '';
                const employeeDepartment = document.getElementById('employeeDepartment');
                if (employeeDepartment) {
                    employeeDepartment.value = department;
                }
                
                // Auto-populate country from selected employee
                const country = selectedOption.dataset.country || '';
                if (countryOfEmployee && country) {
                    countryOfEmployee.value = country;
                }
                
                // Auto-populate channel from selected employee
                const channel = selectedOption.dataset.channel || '';
                const channelSelect = document.getElementById('channel');
                if (channelSelect && channel) {
                    // Check if the channel exists in the dropdown
                    const channelExists = Array.from(channelSelect.options).some(
                        opt => opt.value === channel
                    );
                    if (channelExists) {
                        channelSelect.value = channel;
                        // Trigger change event to auto-select matching scorecard
                        channelSelect.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }
            } else {
                // Clear fields if no employee selected
                if (employeeEmail) {
                    employeeEmail.value = '';
                }
                if (employeeType) {
                    employeeType.value = '';
                }
                const employeeDepartment = document.getElementById('employeeDepartment');
                if (employeeDepartment) {
                    employeeDepartment.value = '';
                }
                if (countryOfEmployee) {
                    countryOfEmployee.value = '';
                }
                // Clear channel field
                const channelSelect = document.getElementById('channel');
                if (channelSelect) {
                    channelSelect.value = '';
                    // Trigger change event to reload scorecards without channel filter
                    channelSelect.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }
        });
        
        // Load user data when page loads
        loadUserData();
        
        // Update week and quarter when page loads
        updateWeekAndQuarter();
        
        // Refresh user data when window gains focus (in case user data was updated)
        window.addEventListener('focus', function() {
            loadUserData();
            updateWeekAndQuarter();
        });
        
        // Handle form submission
        console.log('Setting up form submission handler...');
        
        // Also add click handler to submit button for debugging
        const submitBtn = auditForm.querySelector('button[type="submit"]');
        if (submitBtn) {
            console.log('Submit button found:', submitBtn);
            submitBtn.addEventListener('click', function(e) {
                console.log('Submit button clicked!');
            });
        } else {
            console.log('Submit button not found');
        }
        
        console.log('Attaching submit event listener to form...');
        
        // Guard to prevent duplicate submissions
        let isSubmitting = false;
        
        // Handler function
        const handleSubmit = async function(e) {
            console.log('DEBUG: Form submit event fired!'); // Debug log only
            console.log('Submit event fired! Event object:', e);
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            // Prevent duplicate submissions
            if (isSubmitting) {
                console.log('Submission already in progress, ignoring duplicate submit event');
                return;
            }
            
            isSubmitting = true;
            
            // Show smart loader
            const loader = document.getElementById('auditSubmitLoader');
            if (loader) {
                loader.classList.add('show');
            }
            
            console.log('===== FORM SUBMISSION STARTED =====');
            
            // Validate scorecard selection
            if (!currentScorecard || !currentParameters || currentParameters.length === 0) {
                // Hide loader if validation fails
                const loader = document.getElementById('auditSubmitLoader');
                if (loader) {
                    loader.classList.remove('show');
                }
                await window.confirmationDialog.show({
                    title: 'No Scorecard Selected',
                    message: 'Please select a scorecard before submitting the audit.',
                    confirmText: 'OK',
                    type: 'warning'
                });
                isSubmitting = false;
                return;
            }
            
            // Wait for Supabase client to be ready (maximum 5 seconds)
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds with 100ms intervals
            while (!window.supabaseClient && attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (!window.supabaseClient) {
                // Hide loader if Supabase client not ready
                const loader = document.getElementById('auditSubmitLoader');
                if (loader) {
                    loader.classList.remove('show');
                }
                await window.confirmationDialog.show({
                    title: 'Initialization Error',
                    message: 'Supabase client not initialized. Please refresh the page and try again.',
                    confirmText: 'Refresh Page',
                    cancelText: 'OK',
                    type: 'error'
                });
                console.error('Supabase client not available after waiting');
                isSubmitting = false;
                return;
            }
            
            console.log('Supabase client is ready');
            console.log('Saving to table:', currentScorecard.table_name);
            
            // Update week and quarter based on current date
            updateWeekAndQuarter();
            
            // Auto-populate Error Description from individual feedback fields
            populateErrorDescription();
            
            // Update audit duration from timer before collecting form data
            if (window.updateAuditDuration) {
                window.updateAuditDuration();
            }
            
            // Sync chat messages to textarea before form submission (if chat view is active)
            const chatMessagesContainer = document.getElementById('chatMessagesContainer');
            const transcriptTextarea = document.getElementById('transcript');
            if (chatMessagesContainer && transcriptTextarea && chatMessagesContainer.children.length > 0) {
                syncChatMessagesToTextarea();
            }
            
            // Collect all form data
            const formData = new FormData(auditForm);
            const auditData = {};
            
            // Convert FormData to object
            for (let [key, value] of formData.entries()) {
                auditData[key] = value;
            }
            
            // Log audit duration for debugging
            const auditDurationField = document.getElementById('auditDuration');
            if (auditDurationField) {
                console.log('Audit duration from timer (seconds):', auditDurationField.value);
            }
            
            console.log('Form validation completed');
            
            // Validate interaction ID is provided
            const interactionIdField = document.getElementById('interactionId');
            if (!interactionIdField || !interactionIdField.value || !interactionIdField.value.trim()) {
                // Hide loader if validation fails
                const loader = document.getElementById('auditSubmitLoader');
                if (loader) {
                    loader.classList.remove('show');
                }
                await window.confirmationDialog.show({
                    title: 'Validation Error',
                    message: 'Interaction ID is required. Please enter an Interaction ID before submitting.',
                    confirmText: 'OK',
                    type: 'error'
                });
                if (interactionIdField) {
                    interactionIdField.focus();
                }
                isSubmitting = false;
                return;
            }
            
            // Validate feedback fields when error count > 0
            let validationErrors = [];
            currentParameters.forEach(param => {
                // Get error count for this parameter
                let errorCount = 0;
                if (param.field_type === 'radio') {
                    const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
                    if (selectedRadio) {
                        const value = parseInt(selectedRadio.value) || 0;
                        const paramType = param.parameter_type || 'error';
                        if (paramType === 'achievement' || paramType === 'bonus') {
                            errorCount = value === 0 ? 1 : 0;
                        } else {
                            errorCount = value;
                        }
                    }
                } else {
                    const field = document.getElementById(param.field_id);
                    errorCount = field ? (parseInt(field.value) || 0) : 0;
                }
                
                // If error count > 0, validate that all feedback boxes are filled
                if (errorCount > 0) {
                    const feedbackCount = Math.min(errorCount, 10);
                    for (let i = 0; i < feedbackCount; i++) {
                        const feedbackId = `feedback_${param.field_id}_${i}`;
                        const feedbackField = document.getElementById(feedbackId);
                        if (!feedbackField || !feedbackField.value || !feedbackField.value.trim()) {
                            validationErrors.push(`Feedback is required for "${param.error_name}" (Feedback ${i + 1} of ${feedbackCount})`);
                            if (feedbackField) {
                                feedbackField.style.borderColor = '#ef4444';
                                feedbackField.focus();
                            }
                        }
                    }
                }
            });
            
            // If there are validation errors, show them and stop submission
            if (validationErrors.length > 0) {
                // Hide loader if validation fails
                const loader = document.getElementById('auditSubmitLoader');
                if (loader) {
                    loader.classList.remove('show');
                }
                await window.confirmationDialog.show({
                    title: 'Validation Error',
                    message: 'Please fill in all required feedback fields:\n\n' + validationErrors.slice(0, 5).join('\n') + (validationErrors.length > 5 ? `\n... and ${validationErrors.length - 5} more` : ''),
                    confirmText: 'OK',
                    type: 'error'
                });
                isSubmitting = false;
                return;
            }
            
            // Explicitly handle dynamic parameter fields (counters and radio buttons)
            currentParameters.forEach(param => {
                if (param.field_type === 'radio') {
                    // For radio buttons, get the selected value
                    const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
                    auditData[param.field_id] = selectedRadio ? parseInt(selectedRadio.value) : 0;
                } else {
                    // For counters, store the numeric value
                    const field = document.getElementById(param.field_id);
                    auditData[param.field_id] = field ? (parseInt(field.value) || 0) : 0;
                }
                
                // Collect all feedback boxes for this parameter as an array
                const feedbacks = [];
                const feedbackContainer = document.getElementById(`feedback_container_${param.field_id}`);
                if (feedbackContainer) {
                    const feedbackTextareas = feedbackContainer.querySelectorAll(`textarea[id^="feedback_${param.field_id}_"]`);
                    feedbackTextareas.forEach(textarea => {
                        if (textarea.value && textarea.value.trim()) {
                            feedbacks.push(textarea.value.trim());
                        }
                    });
                }
                auditData[`feedback_${param.field_id}`] = feedbacks.length > 0 ? feedbacks : null;
                
                // Collect parameter comments from comment input fields
                // Comments should be saved even if error count is 0
                const commentInputs = document.querySelectorAll(`input[data-param-key="${param.field_id}"]`);
                const comments = [];
                commentInputs.forEach(input => {
                    if (input.value && input.value.trim()) {
                        comments.push(input.value.trim());
                    }
                });
                
                // Store comments in auditData if there are any (even if error count is 0)
                if (comments.length > 0) {
                    if (!auditData.parameter_comments) {
                        auditData.parameter_comments = {};
                    }
                    // Get current user email for commented_by
                    const userEmail = (typeof getCurrentUserEmail === 'function' ? getCurrentUserEmail() : null) || 
                                     (typeof currentUserEmail !== 'undefined' ? currentUserEmail : null) || 
                                     '';
                    auditData.parameter_comments[param.field_id] = {
                        comments: comments,
                        commented_at: new Date().toISOString(),
                        commented_by: userEmail
                    };
                }
            });
            
            // Update employeeName with the actual name from the selected option
            const selectedEmployeeOption = employeeSelect.options[employeeSelect.selectedIndex];
            if (selectedEmployeeOption && selectedEmployeeOption.textContent) {
                auditData.employeeName = selectedEmployeeOption.textContent;
            }
            
            // Ensure auditorName is populated (from hidden field)
            const auditorNameField = document.getElementById('auditorName');
            if (auditorNameField && auditorNameField.value) {
                auditData.auditorName = auditorNameField.value;
            }
            
            // Ensure quarter and week are included
            const quarterField = document.getElementById('quarter');
            if (quarterField && quarterField.value) {
                auditData.quarter = quarterField.value;
            }
            
            const weekField = document.getElementById('week');
            if (weekField && weekField.value) {
                auditData.week = weekField.value;
            }
            
            // Add unique ID and submission timestamp
            auditData.id = 'audit_' + Date.now();
            auditData.submittedAt = new Date().toISOString();
            
            // FIXED: Recalculate passing status right before saving to ensure is_fail_all is checked
            const finalScore = parseFloat(auditData.averageScore) || 0;
            const threshold = currentScorecard ? parseFloat(currentScorecard.passing_threshold) : 85;
            
            // Check if any "fail all" parameters have errors
            let hasFailAllError = false;
            currentParameters.forEach(param => {
                if (param.is_fail_all) {
                    const paramType = param.parameter_type || 'error';
                    const fieldValue = auditData[param.field_id];
                    let errorCount = 0;
                    
                    if (param.field_type === 'radio') {
                        errorCount = fieldValue ? parseInt(fieldValue) : 0;
                    } else {
                        errorCount = fieldValue ? parseInt(fieldValue) : 0;
                    }
                    
                    if (errorCount > 0) {
                        hasFailAllError = true;
                    }
                }
            });
            
            // Set passing status based on fail-all errors first, then score
            if (hasFailAllError) {
                auditData.passingStatus = 'Not Passing';
            } else if (finalScore >= threshold) {
                auditData.passingStatus = 'Passing';
            } else {
                auditData.passingStatus = 'Not Passing';
            }
            
            // Capture audit start and end timestamps
            // For editing existing audits, preserve original start time if it exists
            let auditStartTime = null;
            if (isEditingExistingAudit && currentEditingAuditId && currentEditingTableName) {
                // When editing, try to preserve original start time from database
                // We'll fetch it if not already restored, otherwise use restored value
                auditStartTime = window.getAuditStartTimestamp ? window.getAuditStartTimestamp() : null;
                // If still null and we're editing, it means we didn't restore it, so it will remain null
                // (we should preserve the original from the database in the update, but for now let's use restored value or current)
            } else {
                // For new audits, use the captured start timestamp
                auditStartTime = window.getAuditStartTimestamp ? window.getAuditStartTimestamp() : null;
            }
            const auditEndTime = new Date().toISOString();
            
            console.log('All form data keys:', Object.keys(auditData));
            console.log('Audit data to be saved:', auditData);
            console.log('Audit start time:', auditStartTime);
            console.log('Audit end time:', auditEndTime);
            
            // Save to Supabase
            console.log('Saving to Supabase...');
            
            try {
                // Build base payload
                // The hidden field stores duration in seconds as integer, but FormData converts it to string
                let auditDurationSeconds = null;
                if (auditData.auditDuration && auditData.auditDuration !== '' && auditData.auditDuration !== 'null' && auditData.auditDuration !== null) {
                    // The hidden field contains seconds as integer, but FormData makes it a string
                    // So we parse it as integer (already in seconds)
                    const parsed = parseInt(auditData.auditDuration);
                    if (!isNaN(parsed) && parsed >= 0) {
                        auditDurationSeconds = parsed; // Already in seconds
                    } else {
                        // Fallback: if somehow we got a time string or minutes, try to convert it
                        if (window.convertDurationToMinutes) {
                            const minutes = window.convertDurationToMinutes(auditData.auditDuration);
                            if (minutes !== null && !isNaN(minutes)) {
                                auditDurationSeconds = minutes * 60; // Convert minutes to seconds
                            }
                        }
                    }
                    // Final validation: ensure it's a valid non-negative integer
                    if (auditDurationSeconds !== null && (isNaN(auditDurationSeconds) || auditDurationSeconds < 0)) {
                        auditDurationSeconds = null;
                    }
                }
                
                const auditPayload = {
                    id: auditData.id,
                    submitted_at: auditData.submittedAt,
                    audit_start_time: auditStartTime,
                    audit_end_time: auditEndTime,
                    audit_duration: auditDurationSeconds,
                    auditor_email: auditData.auditorEmail || null,
                    auditor_name: auditData.auditorName || null,
                    employee_name: auditData.employeeName || null,
                    employee_email: auditData.employeeEmail || null,
                    employee_type: auditData.employeeType || null,
                    employee_department: auditData.employeeDepartment || null,
                    interaction_id: auditData.interactionId || null,
                    interaction_date: auditData.interactionDate || null,
                    audit_type: auditData.auditType || null,
                    channel: auditData.channel || null,
                    quarter: auditData.quarter || null,
                    week: auditData.week ? parseInt(auditData.week) : null,
                    country_of_employee: auditData.countryOfEmployee || null,
                    client_email: auditData.clientEmail || null,
                    passing_status: auditData.passingStatus || null,
                    validation_status: auditData.validationStatus || null,
                    average_score: auditData.averageScore ? parseFloat(auditData.averageScore) : null,
                    critical_errors: auditData.criticalErrors ? parseInt(auditData.criticalErrors) : 0,
                    critical_fail_error: auditData.criticalFailError ? parseInt(auditData.criticalFailError) : 0,
                    significant_error: auditData.significantError ? parseInt(auditData.significantError) : 0,
                    total_errors_count: auditData.totalErrorsCount ? parseInt(auditData.totalErrorsCount) : 0,
                    transcript: auditData.transcript || null,
                    error_description: auditData.errorDescription || null,
                    recommendations: auditData.recommendations || null,
                    // Reversal tracking fields
                    reversal_requested_at: auditData.reversalRequestedAt || null,
                    reversal_responded_at: auditData.reversalRespondedAt || null,
                    sla_in_hours: auditData.slaInHours ? parseFloat(auditData.slaInHours) : null,
                    response_from_auditor: auditData.reasonForReversalResponseDelay || null,
                    reversal_approved: auditData.reversalApproved !== undefined ? auditData.reversalApproved : null,
                    within_auditor_scope: auditData.withinAuditorScope !== undefined ? auditData.withinAuditorScope : null,
                    score_before_appeal: auditData.scoreBeforeAppeal ? parseFloat(auditData.scoreBeforeAppeal) : null,
                    score_after_appeal: auditData.scoreAfterAppeal ? parseFloat(auditData.scoreAfterAppeal) : null,
                    did_result_in_pass: auditData.didResultInPass !== undefined ? auditData.didResultInPass : null,
                    reversal_type: auditData.reversalType || null,
                    reversal_metrics_parameters: auditData.reversalMetricsParameters || null,
                    reversal_justification_from_agent: auditData.reversalJustificationFromAgent || null,
                    reversal_attachments: auditData.reversalAttachments || null,
                    reversal_approved_by: auditData.reversalApprovedBy || null,
                    reversal_resolved_by: auditData.reversalResolvedBy || null,
                    // Acknowledgement tracking fields
                    acknowledgement_status: auditData.acknowledgementStatus || 'Pending',
                    acknowledgement_status_updated_at: auditData.acknowledgementStatusUpdatedAt || null
                };
                
                // Add dynamic error fields based on currentParameters
                currentParameters.forEach(param => {
                    const fieldValue = auditData[param.field_id];
                    auditPayload[param.field_id] = fieldValue ? parseInt(fieldValue) : 0;
                    
                    // Add feedback field as JSONB array (send array directly, Supabase will handle JSONB conversion)
                    const feedbackKey = `feedback_${param.field_id}`;
                    const feedbackValue = auditData[feedbackKey];
                    // Send array directly if non-empty, null otherwise
                    // Supabase will automatically convert JavaScript arrays to JSONB
                    auditPayload[feedbackKey] = Array.isArray(feedbackValue) && feedbackValue.length > 0 
                        ? feedbackValue 
                        : null;
                });
                
                // Add parameter comments (always include, even if empty, to ensure comments are saved)
                // Comments should be saved even if error count is 0
                if (auditData.parameter_comments && Object.keys(auditData.parameter_comments).length > 0) {
                    auditPayload.parameter_comments = auditData.parameter_comments;
                } else {
                    // Initialize empty object if no comments (to ensure field exists in database)
                    auditPayload.parameter_comments = {};
                }
                
                console.log('Payload to save:', auditPayload);
                console.log('Target table:', currentScorecard.table_name);
                console.log('Is editing pending audit:', isEditingPendingAudit);
                console.log('Current editing audit ID:', currentEditingAuditId);
                console.log('Is calibration mode:', isCalibrationMode);
                
                // If in calibration mode, save to calibration_results instead
                if (isCalibrationMode) {
                    await saveCalibrationResult(auditPayload, auditData);
                    return;
                }
                
                let data, error;
                const wasEditingExistingAudit = isEditingExistingAudit; // Store before resetting
                
                // Helper function to retry database operations on schema cache errors
                async function retryOnSchemaCacheError(operation, maxRetries = 3) {
                    for (let attempt = 0; attempt < maxRetries; attempt++) {
                        if (attempt > 0) {
                            // Wait longer on each retry (exponential backoff)
                            console.log(`Retrying database operation (attempt ${attempt + 1}/${maxRetries})...`);
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                        }
                        
                        const result = await operation();
                        
                        // If no error, return success
                        if (!result.error) {
                            return result;
                        }
                        
                        // Don't retry on missing column errors - these require manual SQL fix
                        const isMissingColumnError = result.error.message && (
                            (result.error.message.includes('Could not find') && result.error.message.includes('column')) ||
                            (result.error.message.includes('column') && result.error.message.includes('does not exist')) ||
                            result.error.code === 'PGRST204'
                        );
                        
                        if (isMissingColumnError) {
                            console.error('Missing column error detected - will not retry (requires manual SQL fix)');
                            return result;
                        }
                        
                        // If it's a schema cache error, retry
                        if (result.error.message && result.error.message.includes('schema cache')) {
                            console.log(`Schema cache not ready, retrying (attempt ${attempt + 1}/${maxRetries})...`);
                            continue;
                        }
                        
                        // If it's not a schema cache error, return immediately
                        return result;
                    }
                    
                    // Return last result after all retries exhausted
                    return await operation();
                }
                
                // Check if we're editing an existing audit from audit reports
                if (isEditingExistingAudit && currentEditingAuditId && currentEditingTableName) {
                    // UPDATE existing audit record
                    console.log('Updating existing audit from reports...');
                    
                    // Keep the original ID and submitted_at
                    auditPayload.id = currentEditingAuditId;
                    // Don't update submitted_at when editing, keep original
                    delete auditPayload.submitted_at;
                    
                    // For editing, only update audit_start_time if it wasn't previously set
                    // Otherwise preserve the original start time (don't include it in update)
                    // If auditStartTime is null, remove it from payload to preserve existing value
                    if (!auditStartTime) {
                        delete auditPayload.audit_start_time;
                    }
                    // Always update end time and duration when editing
                    
                    const result = await retryOnSchemaCacheError(async () => {
                        return await window.supabaseClient
                            .from(currentEditingTableName)
                            .update(auditPayload)
                            .eq('id', currentEditingAuditId)
                            .select();
                    });
                    
                    data = result.data;
                    error = result.error;
                    
                    if (!error) {
                        console.log('Successfully updated audit from reports:', data);
                        
                        // Reset editing mode
                        isEditingExistingAudit = false;
                        currentEditingAuditId = null;
                        currentEditingTableName = null;
                    }
                    
                } else if (isEditingPendingAudit && currentEditingAuditId) {
                    // UPDATE existing pending audit record
                    console.log('Updating existing pending audit...');
                    
                    // Update validation status to 'Validated' when completing the audit
                    auditPayload.validation_status = 'Validated';
                    auditPayload.submitted_at = new Date().toISOString();
                    
                    const result = await retryOnSchemaCacheError(async () => {
                        return await window.supabaseClient
                            .from(currentScorecard.table_name)
                            .update(auditPayload)
                            .eq('id', currentEditingAuditId)
                            .select();
                    });
                    
                    data = result.data;
                    error = result.error;
                    
                    if (!error) {
                        console.log('Successfully updated pending audit:', data);
                        
                        // If this was from an audit assignment, mark it as completed
                        if (isEditingPendingAudit && currentEditingAuditId) {
                            try {
                                const { data: updateData, error: assignmentError } = await window.supabaseClient
                                    .from('audit_assignments')
                                    .update({ 
                                        status: 'completed',
                                        completed_at: new Date().toISOString(),
                                        ...(pendingConversationId ? { conversation_id: pendingConversationId } : {})
                                    })
                                    .eq('id', currentEditingAuditId)
                                    .select();
                                
                                if (assignmentError) {
                                    console.error('Error marking assignment as completed:', assignmentError);
                                } else {
                                    console.log('Successfully marked assignment as completed:', updateData);
                                }
                            } catch (assignmentError) {
                                console.error('Exception marking assignment as completed:', assignmentError);
                                // Don't fail the audit submission if marking as completed fails
                            }
                        }
                        
                        // Reset editing mode
                        isEditingPendingAudit = false;
                        currentEditingAuditId = null;
                    }
                    
                } else {
                    // INSERT new audit record
                    console.log('Inserting new audit...');
                    
                    const result = await retryOnSchemaCacheError(async () => {
                        return await window.supabaseClient
                            .from(currentScorecard.table_name)
                            .insert([auditPayload])
                            .select();
                    });
                    
                    data = result.data;
                    error = result.error;
                    
                    if (!error) {
                        console.log('Successfully inserted new audit:', data);
                        
                        // If this was from an audit assignment, mark it as completed
                        if (currentAssignmentId) {
                            try {
                                // Build update object
                                const assignmentUpdate = { 
                                        status: 'completed',
                                        completed_at: new Date().toISOString(),
                                        audit_id: auditPayload.id  // Link the completed audit
                                };
                                
                                // Include conversation_id if available (from starting audit from conversation)
                                if (pendingConversationId) {
                                    assignmentUpdate.conversation_id = pendingConversationId;
                                }
                                
                                const { data: updateData, error: assignmentError } = await window.supabaseClient
                                    .from('audit_assignments')
                                    .update(assignmentUpdate)
                                    .eq('id', currentAssignmentId)
                                    .select();
                                
                                if (assignmentError) {
                                    console.error('Error marking assignment as completed:', assignmentError);
                                } else {
                                    console.log('Successfully marked assignment as completed:', updateData);
                                }
                            } catch (assignmentError) {
                                console.error('Exception marking assignment as completed:', assignmentError);
                                // Don't fail the audit submission if marking as completed fails
                            }
                        }
                    }
                }
                
                if (error) {
                    console.error('Error saving to Supabase:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    
                    // Check if this is a missing column error
                    const isMissingColumnError = error.message && (
                        error.message.includes('Could not find') && error.message.includes('column') ||
                        error.message.includes('column') && error.message.includes('does not exist') ||
                        error.code === 'PGRST204'
                    );
                    
                    let errorMessage = 'An error occurred while saving the audit: ' + error.message;
                    
                    if (isMissingColumnError) {
                        // Extract column name from error message - handle different error formats
                        let columnName = 'audit_type'; // default
                        const columnMatch1 = error.message.match(/column ['"]([^'"]+)['"]/i);
                        const columnMatch2 = error.message.match(/Could not find the '([^']+)' column/i);
                        const columnMatch3 = error.message.match(/column ([a-z_]+) of/i);
                        
                        if (columnMatch2) {
                            columnName = columnMatch2[1];
                        } else if (columnMatch1) {
                            columnName = columnMatch1[1];
                        } else if (columnMatch3) {
                            columnName = columnMatch3[1];
                        }
                        
                        const tableName = currentScorecard?.table_name || 'the audit table';
                        
                        errorMessage = `Missing database column: "${columnName}"\n\n` +
                            `The table "${tableName}" is missing the "${columnName}" column.\n\n` +
                            `To fix this, run this SQL in Supabase SQL Editor:\n\n` +
                            `ALTER TABLE ${tableName} ADD COLUMN IF NOT EXISTS ${columnName} TEXT;\n\n` +
                            `After running the SQL, refresh this page and try again.`;
                        
                        console.error('🔧 FIX REQUIRED: Missing column detected');
                        console.error(`Table: ${tableName}`);
                        console.error(`Missing column: ${columnName}`);
                        console.error(`\nRun this SQL in Supabase SQL Editor:\n`);
                        console.error(`ALTER TABLE ${tableName} ADD COLUMN IF NOT EXISTS ${columnName} TEXT;`);
                    }
                    
                    await window.confirmationDialog.show({
                        title: 'Error Saving Audit',
                        message: errorMessage,
                        confirmText: 'OK',
                        cancelText: 'Close',
                        type: 'error'
                    });
                    return;
                }
                
                // Store audit ID for redirect (before any variables get cleared)
                const savedAuditId = data && data[0] ? data[0].id : (currentEditingAuditId || null);
                
                // Send email notification to the audited employee
                if (data && data[0] && (data[0].employee_email || auditPayload.employee_email)) {
                    try {
                        await sendAuditEmailNotification(data[0], currentScorecard);
                    } catch (emailError) {
                        // Log error but don't fail the audit submission
                        console.error('Error sending email notification:', emailError);
                    }
                    
                    // Send webhook to n8n workflow for email notification
                    try {
                        await sendN8nWebhook(data[0], currentScorecard);
                    } catch (n8nError) {
                        // Log error but don't fail the audit submission
                        console.error('Error sending n8n webhook:', n8nError);
                    }
                }
                
                // Hide loader before showing success message
                const loader = document.getElementById('auditSubmitLoader');
                if (loader) {
                    loader.classList.remove('show');
                }
                
                // Show success message
                const message = wasEditingExistingAudit ? 'Audit updated successfully!' : 'Audit submitted successfully!';
                const confirmed = await window.confirmationDialog.show({
                    title: 'Success!',
                    message: message,
                    confirmText: 'View Audit',
                    cancelText: 'Stay Here',
                    type: 'success'
                });
                
                // Reset form
                auditForm.reset();
                
                // Reset header back to green (passing state)
                const headerElement = document.getElementById('auditFormHeader');
                if (headerElement) {
                    headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
                }
                
                // Hide timer
                const auditTimer = document.getElementById('auditTimer');
                if (auditTimer) {
                    auditTimer.style.display = 'none';
                }
                
                // Reset timer
                if (window.resetTimer) {
                    window.resetTimer();
                }
                
                // Hide form modal, show pending audits section
                const auditFormModal = document.getElementById('auditFormModal');
                if (auditFormModal) {
                    auditFormModal.style.display = 'none';
                }
                
                // Reload pending audits (in case there are more)
                await loadPendingAudits();
                
                // Update stats after submission
                await updateYourStats();
                
                // Redirect to audit view if user clicked "View Audit"
                if (confirmed) {
                    const scorecardId = currentScorecard ? currentScorecard.id : null;
                    const tableName = currentScorecard ? currentScorecard.table_name : null;
                    
                    if (savedAuditId && scorecardId && tableName) {
                        window.location.href = `audit-view.html?id=${savedAuditId}&scorecard=${scorecardId}&table=${tableName}`;
                    } else {
                        // Fallback to expert-audits if we don't have the required info
                        window.location.href = 'expert-audits.html';
                    }
                } else {
                    // Scroll to top to show pending audits
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
                
            } catch (err) {
                console.error('Exception saving to Supabase:', err);
                console.error('Exception stack:', err.stack);
                
                // Hide loader on error
                const loader = document.getElementById('auditSubmitLoader');
                if (loader) {
                    loader.classList.remove('show');
                }
                
                await window.confirmationDialog.show({
                    title: 'Error Saving Audit',
                    message: 'An error occurred while saving the audit: ' + err.message,
                    confirmText: 'OK',
                    cancelText: 'Close',
                    type: 'error'
                });
            } finally {
                // Always reset the submitting flag
                isSubmitting = false;
            }
        };
        
        // Attach the handler to the form submit event
        auditForm.addEventListener('submit', handleSubmit);
        
        console.log('Event listeners attached successfully');
        
        // Handle cancel button
        cancelBtn.addEventListener('click', async function() {
            const confirmed = await window.confirmationDialog.show({
                title: 'Cancel Audit',
                message: 'Are you sure you want to cancel? All data will be lost.',
                confirmText: 'Cancel Audit',
                cancelText: 'Keep Editing',
                type: 'warning'
            });
            
            if (confirmed) {
                auditForm.reset();
                
                // Reset header back to green (passing state)
                const headerElement = document.getElementById('auditFormHeader');
                if (headerElement) {
                    headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
                }
                
                // Hide timer
                const auditTimer = document.getElementById('auditTimer');
                if (auditTimer) {
                    auditTimer.style.display = 'none';
                }
                
                if (window.resetTimer) {
                    window.resetTimer();
                }
                
                // Reset editing mode and assignment tracking
                isEditingPendingAudit = false;
                currentEditingAuditId = null;
                currentAssignmentId = null;
                isEditingExistingAudit = false;
                currentEditingTableName = null;
                pendingConversationId = null; // Clear conversation ID after use
                
                // Hide form modal
                const auditFormModal = document.getElementById('auditFormModal');
                if (auditFormModal) {
                    auditFormModal.style.display = 'none';
                }
                
                // Reload and show pending audits
                await loadPendingAudits();
                
                // Update stats
                await updateYourStats();
                
                // Scroll to top to show pending audits
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        });
    } // End of initializeForm()
    // Check for assignment parameter in URL
    const urlParams = new URLSearchParams(window.location.search);
    const assignmentId = urlParams.get('assignment');
    
    if (assignmentId) {
        // Load the assignment and start the audit
        loadAssignmentFromURL(assignmentId);
    }
}); // End of DOMContentLoaded

// Load assignment from URL parameter and start audit
async function loadAssignmentFromURL(assignmentId) {
    try {
        console.log('Loading assignment from URL:', assignmentId);
        
        // Wait for Supabase to be ready
        let attempts = 0;
        while (!window.supabaseClient && attempts < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }
        
        if (!window.supabaseClient) {
            console.error('Supabase client not initialized');
            alert('Error: Database connection not ready. Please refresh the page.');
            return;
        }
        
        // Load the assignment from database with scorecard info
        const { data: assignment, error } = await window.supabaseClient
            .from('audit_assignments')
            .select(`
                *,
                scorecards:scorecard_id (
                    id,
                    name,
                    table_name
                )
            `)
            .eq('id', assignmentId)
            .single();
        
        if (error) {
            console.error('Error loading assignment:', error);
            alert('Error: Assignment not found. It may have been deleted or you may not have access.');
            // Clean URL
            window.history.replaceState({}, document.title, window.location.pathname);
            return;
        }
        
        if (!assignment) {
            alert('Assignment not found');
            // Clean URL
            window.history.replaceState({}, document.title, window.location.pathname);
            return;
        }
        
        // Check resource access using centralized access control
        const resourceAccess = window.accessControl?.canAccessResource('audit_assignment', assignment);
        if (!resourceAccess || !resourceAccess.allowed) {
            alert(resourceAccess?.reason || 'You do not have permission to access this assignment.');
            // Clean URL
            window.history.replaceState({}, document.title, window.location.pathname);
            return;
        }
        
        // Get the table name from the scorecard
        const assignmentTable = assignment.scorecards?.table_name || assignment.scorecard_table_name;
        const scorecardId = assignment.scorecard_id || assignment._scorecard_id;
        
        // Check if assignment is already completed
        if (assignment.status === 'completed' || assignment.audit_status === 'completed') {
            // Redirect to view the completed audit
            if (scorecardId && assignmentTable) {
                window.location.href = `audit-view.html?id=${assignment.id}&scorecard=${scorecardId}&table=${assignmentTable}`;
                return;
            }
            alert('This assignment has already been completed.');
            // Clean URL
            window.history.replaceState({}, document.title, window.location.pathname);
            return;
        }
        
        // Map assignment to expected format
        const mappedAssignment = {
            id: assignment.id,
            employee_email: assignment.employee_email,
            employee_name: assignment.employee_name,
            auditor_email: assignment.auditor_email,
            scorecard_id: scorecardId,
            status: assignment.status || assignment.audit_status,
            conversation_id: assignment.conversation_id || null,
            scorecards: {
                id: scorecardId,
                table_name: assignmentTable
            }
        };
        
        // Update assignment status to 'in_progress' (only if it's pending)
        if (mappedAssignment.status === 'pending') {
            const { error: updateError } = await window.supabaseClient
                .from('audit_assignments')
                .update({ status: 'in_progress' })
                .eq('id', mappedAssignment.id);
            
            if (updateError) {
                console.error('Error updating assignment status:', updateError);
            }
        }
        
        // Set assignment tracking
        currentAssignmentId = mappedAssignment.id;
        isEditingPendingAudit = false;
        currentEditingAuditId = null;
        isEditingExistingAudit = false;
        currentEditingTableName = null;
        
        // Store conversation ID for later use
        if (mappedAssignment.conversation_id) {
            pendingConversationId = mappedAssignment.conversation_id;
        }
        
        // Auto-select the scorecard from assignment
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect && mappedAssignment.scorecard_id) {
            // First, ensure scorecards are loaded
            await loadScorecards();
            // Then select the assigned scorecard
            scorecardSelect.value = mappedAssignment.scorecard_id;
            // Load the scorecard parameters
            await loadScorecardParameters(mappedAssignment.scorecard_id);
        } else if (scorecardSelect) {
            // If no scorecard ID provided, auto-select first available
            await loadScorecards();
        }
        
        // Show the full screen audit form modal
        const auditFormModal = document.getElementById('auditFormModal');
        if (auditFormModal) {
            auditFormModal.style.display = 'flex';
        }
        
        // Hide the assigned audits section
        const pendingAuditsSection = document.getElementById('pendingAuditsSection');
        if (pendingAuditsSection) {
            pendingAuditsSection.style.display = 'none';
        }
        
        // Ensure employees are loaded before trying to select
        await loadEmployees();
        
        // Pre-fill employee information
        const employeeSelect = document.getElementById('employeeName');
        let employeeFound = false;
        
        // Find and select the employee in dropdown
        if (employeeSelect && mappedAssignment.employee_email) {
            const normalizedEmail = mappedAssignment.employee_email.toLowerCase().trim();
            for (let i = 0; i < employeeSelect.options.length; i++) {
                const optionEmail = (employeeSelect.options[i].dataset.email || '').toLowerCase().trim();
                if (optionEmail === normalizedEmail) {
                    employeeSelect.selectedIndex = i;
                    // Trigger change event to populate other fields
                    employeeSelect.dispatchEvent(new Event('change'));
                    employeeFound = true;
                    console.log('✅ Employee found and selected:', mappedAssignment.employee_email);
                    break;
                }
            }
        }
        
        if (!employeeFound && mappedAssignment.employee_email) {
            console.warn('⚠️ Employee not found in dropdown for email:', mappedAssignment.employee_email);
        }
        
        // Pre-fill channel if available in assignment
        const channelField = document.getElementById('channel');
        if (channelField && assignment.channel) {
            channelField.value = assignment.channel;
            console.log('✅ Channel pre-filled:', assignment.channel);
        }
        
        // Pre-fill interaction date if available
        const interactionDateField = document.getElementById('interactionDate');
        if (interactionDateField && assignment.interaction_date) {
            interactionDateField.value = assignment.interaction_date;
            console.log('✅ Interaction date pre-filled:', assignment.interaction_date);
        } else if (interactionDateField && assignment.created_at) {
            // Use assignment creation date as fallback
            const assignmentDate = new Date(assignment.created_at);
            const dateStr = assignmentDate.toISOString().split('T')[0];
            interactionDateField.value = dateStr;
            console.log('✅ Interaction date pre-filled from assignment date:', dateStr);
        }
        
        // Pre-fill client information if available
        const clientNameField = document.getElementById('clientName');
        const clientEmailField = document.getElementById('clientEmail');
        if (clientNameField && assignment.client_name) {
            clientNameField.value = assignment.client_name;
            console.log('✅ Client name pre-filled:', assignment.client_name);
        }
        if (clientEmailField && assignment.client_email) {
            clientEmailField.value = assignment.client_email;
            console.log('✅ Client email pre-filled:', assignment.client_email);
        }
        
        // If assignment has a conversation_id, load that conversation
        if (mappedAssignment.conversation_id) {
            console.log('📌 Loading linked conversation:', mappedAssignment.conversation_id);
            
            // Set the interaction ID field
            const interactionIdField = document.getElementById('interactionId');
            if (interactionIdField) {
                interactionIdField.value = mappedAssignment.conversation_id;
                
                // Ensure chat view is shown
                const transcriptChatView = document.getElementById('transcriptChatView');
                const transcriptTextView = document.getElementById('transcriptTextView');
                if (transcriptChatView && transcriptTextView) {
                    transcriptChatView.style.display = 'flex';
                    transcriptTextView.style.display = 'none';
                }
                
                // Load the conversation after a short delay to ensure form is ready
                setTimeout(async () => {
                    if (window.loadConversationFromIntercom && typeof window.loadConversationFromIntercom === 'function') {
                        await window.loadConversationFromIntercom(mappedAssignment.conversation_id);
                    } else {
                        // Retry if function not ready
                        setTimeout(async () => {
                            if (window.loadConversationFromIntercom && typeof window.loadConversationFromIntercom === 'function') {
                                await window.loadConversationFromIntercom(mappedAssignment.conversation_id);
                            }
                        }, 500);
                    }
                }, 300);
            }
        }
        
        // Show and start the timer
        const auditTimer = document.getElementById('auditTimer');
        if (auditTimer) {
            auditTimer.style.display = 'flex';
            // Attach event listeners when timer is shown
            if (window.attachTimerEventListeners) {
                window.attachTimerEventListeners();
            }
        }
        
        // Reset and start the timer
        if (window.resetTimer && window.startTimer) {
            window.resetTimer();
            window.startTimer();
        }
        
        // Scroll to top to show form
        window.scrollTo({ top: 0, behavior: 'smooth' });
        
    } catch (error) {
        console.error('Error loading assignment from URL:', error);
        alert('Error loading assignment: ' + error.message);
        // Clean URL
        window.history.replaceState({}, document.title, window.location.pathname);
    }
}

// Calculate errors by category (Dynamic)
function calculateErrorsByCategory() {
    const categoryCounts = {
        'Critical Fail Error': 0,
        'Critical Error': 0,
        'Significant Error': 0
    };
    
    const scoringType = currentScorecard ? currentScorecard.scoring_type : 'deductive';
    
    currentParameters.forEach(param => {
        // FIXED: Default to 'error' if parameter_type is null/undefined/empty
        const paramType = param.parameter_type || 'error';
        
        // Only count error parameters, not achievements/bonuses
        if (paramType === 'achievement' || paramType === 'bonus') {
            return; // Skip achievements/bonuses for error counting
        }
        
        let count = 0;
        
        if (param.field_type === 'radio') {
            // Get the selected radio button value
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            
            // Only count if something is actually selected
            if (selectedRadio) {
                const selectedValue = parseInt(selectedRadio.value);
                // For error types: YES (1) = error occurred = counts as error
                count = selectedValue; // YES = 1 error, NO = 0 errors
            }
            // If nothing selected, count = 0 (don't count as error yet)
        } else {
            // Counter field - the value itself is the error count
            const field = document.getElementById(param.field_id);
            count = field ? (parseInt(field.value) || 0) : 0;
        }
        
        if (categoryCounts.hasOwnProperty(param.error_category)) {
            categoryCounts[param.error_category] += count;
        }
    });
    
    // Update fields
    const criticalFailField = document.getElementById('criticalFailError');
    const criticalField = document.getElementById('criticalErrors');
    const significantField = document.getElementById('significantError');
    
    if (criticalFailField) criticalFailField.value = categoryCounts['Critical Fail Error'];
    if (criticalField) criticalField.value = categoryCounts['Critical Error'];
    if (significantField) significantField.value = categoryCounts['Significant Error'];
    
    return categoryCounts;
}

// Calculate average score based on dynamic parameters
function calculateAverageScore() {
    if (!currentParameters || currentParameters.length === 0 || !currentScorecard) {
        return 100; // Default if no parameters loaded
    }
    
    const scoringType = currentScorecard.scoring_type || 'deductive';
    let score = 0;
    
    switch(scoringType) {
        case 'deductive':
            score = calculateDeductiveScore();
            break;
        case 'additive':
            score = calculateAdditiveScore();
            break;
        case 'hybrid':
            score = calculateHybridScore();
            break;
        default:
            score = calculateDeductiveScore();
    }
    
    // Update average score field
    const averageScoreField = document.getElementById('averageScore');
    if (averageScoreField) {
        averageScoreField.value = score.toFixed(2);
    }
    
    // Calculate and update error counts and summary badges
    let criticalFailCount = 0;
    let criticalCount = 0;
    let significantCount = 0;
    let totalErrorsCount = 0;
    
    currentParameters.forEach(param => {
        // FIXED: Default to 'error' if parameter_type is null/undefined/empty
        const paramType = param.parameter_type || 'error';
        
        // Only count error parameters, not achievements/bonuses
        if (paramType === 'achievement' || paramType === 'bonus') {
            return; // Skip achievements/bonuses for error counting
        }
        
        let value = 0;
        let errorCount = 0;
        
        if (param.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
            // For error parameters: YES (1) = error occurred = error
            errorCount = value; // YES = error, NO = no error
        } else {
            // Counter field - count is the value itself
            const field = document.getElementById(param.field_id);
            errorCount = field ? (parseInt(field.value) || 0) : 0;
        }
        
        if (errorCount > 0) {
            // Determine severity - properly map all error categories
            const category = param.error_category || '';
            let severity = 'Significant'; // default
            if (category.includes('Fail')) {
                severity = 'Critical Fail';
            } else if (category.includes('Critical')) {
                severity = 'Critical';
            } else if (category.includes('Significant')) {
                severity = 'Significant';
            } else if (category.includes('Major')) {
                severity = 'Major';
            } else if (category.includes('Minor')) {
                severity = 'Minor';
            }
            
            if (severity === 'Critical Fail') {
                criticalFailCount += errorCount;
            } else if (severity === 'Critical') {
                criticalCount += errorCount;
            } else if (severity === 'Significant' || severity === 'Major' || severity === 'Minor') {
                // For now, Significant, Major, and Minor all count as significant errors
                // This maintains backward compatibility with existing error counting
                significantCount += errorCount;
            }
            
            totalErrorsCount += errorCount;
        }
    });
    
    // Update hidden error count fields for form submission
    const criticalErrorsField = document.getElementById('criticalErrors');
    const criticalFailErrorField = document.getElementById('criticalFailError');
    const significantErrorField = document.getElementById('significantError');
    const totalErrorsField = document.getElementById('totalErrorsCount');
    
    // Update display fields
    const criticalFailErrorDisplay = document.getElementById('criticalFailErrorDisplay');
    
    if (criticalErrorsField) criticalErrorsField.value = criticalCount;
    if (criticalFailErrorField) criticalFailErrorField.value = criticalFailCount;
    if (significantErrorField) significantErrorField.value = significantCount;
    if (totalErrorsField) totalErrorsField.value = totalErrorsCount;
    if (criticalFailErrorDisplay) criticalFailErrorDisplay.value = criticalFailCount;
    
    // Update passing status based on score and threshold
    updatePassingStatus(score);
    
    return score;
}

// Deductive scoring: Start at 100, subtract for errors
function calculateDeductiveScore() {
    let totalDeduction = 0;
    
    currentParameters.forEach(param => {
        // Skip only if it's explicitly an achievement or bonus type (not an error type)
        // Include if: parameter_type is 'error', points_direction is 'subtract', or parameter_type is null/undefined/empty (default to error)
        const paramType = param.parameter_type || 'error';
        const pointsDirection = param.points_direction;
        
        // Skip achievement/bonus types that don't have subtract direction
        if ((paramType === 'achievement' || paramType === 'bonus') && pointsDirection !== 'subtract') {
            return;
        }
        
        let value = 0;
        
        if (param.field_type === 'radio') {
            // Get the selected radio button value
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            // Counter field
            const field = document.getElementById(param.field_id);
            value = field ? (parseInt(field.value) || 0) : 0;
        }
        
        const penalty = parseFloat(param.penalty_points) || 0;
        totalDeduction += value * penalty;
    });
    
    return Math.max(0, 100 - totalDeduction);
}

// Additive scoring: Start at 0, add for achievements
function calculateAdditiveScore() {
    let totalPoints = 0;
    let maxPossiblePoints = 0;
    
    currentParameters.forEach(param => {
        if (param.parameter_type !== 'achievement' && param.points_direction !== 'add') return;
        
        const points = parseFloat(param.penalty_points) || 0;
        
        // Max possible is if all achievements were completed
        if (param.field_type === 'radio') {
            maxPossiblePoints += points;
        } else {
            // For counters in additive, we assume max count of 1 unless specified
            maxPossiblePoints += points;
        }
        
        let value = 0;
        
        if (param.field_type === 'radio') {
            // Get the selected radio button value
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            // Counter field
            const field = document.getElementById(param.field_id);
            value = field ? (parseInt(field.value) || 0) : 0;
        }
        
        totalPoints += value * points;
    });
    
    // Convert to percentage
    if (maxPossiblePoints === 0) return 0;
    return Math.min(100, (totalPoints / maxPossiblePoints) * 100);
}

// Hybrid scoring: Deduct for errors, add for achievements
function calculateHybridScore() {
    let baseScore = 100;
    let bonusPoints = 0;
    
    currentParameters.forEach(param => {
        let value = 0;
        
        if (param.field_type === 'radio') {
            // Get the selected radio button value
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            // Counter field
            const field = document.getElementById(param.field_id);
            value = field ? (parseInt(field.value) || 0) : 0;
        }
        
        const points = parseFloat(param.penalty_points) || 0;
        
        // Default to 'error' if parameter_type is null/undefined/empty
        const paramType = param.parameter_type || 'error';
        const pointsDirection = param.points_direction;
        
        if (paramType === 'error' || pointsDirection === 'subtract') {
            // Subtract from base score
            baseScore -= value * points;
        } else if (paramType === 'achievement' || paramType === 'bonus' || pointsDirection === 'add') {
            // Add to bonus
            bonusPoints += value * points;
        }
        // If parameter doesn't match any condition, it's skipped (no deduction or bonus)
    });
    
    // Apply max bonus cap if set
    const maxBonus = parseFloat(currentScorecard.max_bonus_points) || 0;
    if (maxBonus > 0) {
        bonusPoints = Math.min(bonusPoints, maxBonus);
    }
    
    // Calculate final score
    let finalScore = baseScore + bonusPoints;
    
    // Apply over 100% cap if not allowed
    const allowOver100 = currentScorecard.allow_over_100 || false;
    if (!allowOver100) {
        finalScore = Math.min(100, finalScore);
    }
    
    // Ensure minimum of 0
    finalScore = Math.max(0, finalScore);
    
    return finalScore;
}

// Update passing status based on average score and scorecard threshold
function updatePassingStatus(score) {
    const passingStatusField = document.getElementById('passingStatus');
    const headerElement = document.getElementById('auditFormHeader');
    
    if (passingStatusField) {
        const threshold = currentScorecard ? parseFloat(currentScorecard.passing_threshold) : 85;
        
        // Check if any "fail all" parameters have errors
        let failAllErrorCount = 0;
        
        currentParameters.forEach(param => {
            // Check if this parameter causes automatic fail
            if (param.is_fail_all) {
                const paramType = param.parameter_type || 'error';
                let errorCount = 0;
                
                if (param.field_type === 'radio') {
                    const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
                    const value = selectedRadio ? parseInt(selectedRadio.value) : 0;
                    
                    // For additive/achievement: NO (0) = error
                    // For error parameters: YES (1) = error
                    if (paramType === 'achievement' || paramType === 'bonus') {
                        errorCount = value === 0 ? 1 : 0;
                    } else {
                        errorCount = value;
                    }
                } else {
                    // Counter field
                    const field = document.getElementById(param.field_id);
                    errorCount = field ? (parseInt(field.value) || 0) : 0;
                }
                
                failAllErrorCount += errorCount;
            }
        });
        
        let isPassing = false;
        
        // Check for "fail all" conditions first
        if (failAllErrorCount > 0) {
            // Any fail-all parameter has errors = automatic fail
            passingStatusField.value = 'Not Passing';
            isPassing = false;
        } else if (score >= threshold) {
            // No fail-all errors and score meets threshold = pass
            passingStatusField.value = 'Passing';
            isPassing = true;
        } else {
            // No fail-all errors but score below threshold = fail
            passingStatusField.value = 'Not Passing';
            isPassing = false;
        }
        
        // Update header background color based on passing status
        if (headerElement) {
            if (isPassing) {
                headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
            } else {
                headerElement.style.background = 'linear-gradient(135deg, #d41212 0%, #b91c1c 100%)';
            }
        }
    }
}

// Calculate total errors count (Dynamic)
function calculateTotalErrorsCount() {
    let totalCount = 0;
    
    currentParameters.forEach(param => {
        // FIXED: Default to 'error' if parameter_type is null/undefined/empty
        const paramType = param.parameter_type || 'error';
        
        // Only count error parameters, not achievements/bonuses
        if (paramType === 'achievement' || paramType === 'bonus') {
            return; // Skip achievements/bonuses for error counting
        }
        
        let count = 0;
        
        if (param.field_type === 'radio') {
            // Get the selected radio button value
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            
            // Only count if something is actually selected
            if (selectedRadio) {
                const selectedValue = parseInt(selectedRadio.value);
                // For error types: YES (1) = error occurred = counts as error
                count = selectedValue; // YES = 1 error, NO = 0 errors
            }
            // If nothing selected, count = 0 (don't count as error yet)
        } else {
            // Counter field - the value itself is the error count
            const field = document.getElementById(param.field_id);
            count = field ? (parseInt(field.value) || 0) : 0;
        }
        
        totalCount += count;
    });
    
    // Update total errors count field
    const totalErrorsField = document.getElementById('totalErrorsCount');
    if (totalErrorsField) {
        totalErrorsField.value = totalCount;
    }
    
    return totalCount;
}

// Counter Button Functionality
document.addEventListener('click', function(e) {
    if (e.target.classList.contains('counter-btn')) {
        const action = e.target.getAttribute('data-action');
        const targetId = e.target.getAttribute('data-target');
        const targetInput = document.getElementById(targetId);
        
        if (targetInput) {
            let currentValue = parseInt(targetInput.value) || 0;
            
            if (action === 'increment') {
                // Cap at maximum of 10
                currentValue = Math.min(currentValue + 1, 10);
            } else if (action === 'decrement') {
                currentValue = Math.max(0, currentValue - 1);
            }
            
            targetInput.value = currentValue;
            
            // Update plain text display
            const displayElement = document.getElementById(`${targetId}_display`);
            if (displayElement) {
                displayElement.textContent = currentValue;
                // Update color based on value
                if (currentValue > 0) {
                    displayElement.style.color = '#ef4444';
                    displayElement.style.fontWeight = '700';
                } else {
                    displayElement.style.color = '#1f2937';
                    displayElement.style.fontWeight = '700';
                }
            }
            
            // Calculate total errors count and average score whenever any error count changes
            calculateTotalErrorsCount();
            calculateAverageScore();
            calculateErrorsByCategory();
            
            // Update feedback boxes based on error count
            const param = currentParameters.find(p => p.field_id === targetId);
            if (param) {
                updateFeedbackBoxesForParameter(targetId, param.field_type || 'counter', param.parameter_type || 'error');
                
                // Clear any validation error styling when value changes
                const feedbackContainer = document.getElementById(`feedback_container_${targetId}`);
                if (feedbackContainer) {
                    const feedbackFields = feedbackContainer.querySelectorAll('textarea');
                    feedbackFields.forEach(field => {
                        if (field.value && field.value.trim()) {
                            field.style.borderColor = '#d1d5db';
                        }
                    });
                }
            }
        }
    }
});

// Radio Button Change Handler (for achievements/yes-no fields)
document.addEventListener('change', function(e) {
    if (e.target.type === 'radio' && e.target.dataset.penalty) {
        const fieldName = e.target.name;
        const selectedValue = parseInt(e.target.value) || 0;
        
        // Calculate totals
        calculateTotalErrorsCount();
        calculateAverageScore();
        calculateErrorsByCategory();
        
        // Update feedback boxes based on error count
        const param = currentParameters.find(p => p.field_id === fieldName);
        if (param) {
            updateFeedbackBoxesForParameter(fieldName, param.field_type || 'radio', param.parameter_type || 'error');
            
            // Clear any validation error styling when value changes
            const feedbackContainer = document.getElementById(`feedback_container_${fieldName}`);
            if (feedbackContainer) {
                const feedbackFields = feedbackContainer.querySelectorAll('textarea');
                feedbackFields.forEach(field => {
                    if (field.value && field.value.trim()) {
                        field.style.borderColor = '#d1d5db';
                    }
                });
            }
        }
    }
});

// ============================================================================
// Intercom API Integration and Chat Interface
// ============================================================================
document.addEventListener('DOMContentLoaded', function() {
    const interactionIdInput = document.getElementById('interactionId');
    const viewChatBtn = document.getElementById('viewChatBtn');
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    const transcriptTextarea = document.getElementById('transcript');
    
    let isChatViewActive = false;
    let currentConversationData = null;

    // Configuration - Uses intercom-config.js (generated from environment variables)
    const INTERCOM_CONFIG = window.intercomConfig || {
        appId: '',
        apiBaseUrl: 'https://api.intercom.io',
        baseUrl: 'https://app.intercom.com/a/inbox'
    };

    // Get Supabase URL for Edge Function (generated from environment variables)
    const SUPABASE_URL = window.SupabaseConfig?.url || '';
    const SUPABASE_ANON_KEY = window.SupabaseConfig?.anonKey || '';

    // Show chat view by default (will auto-load transcripts or fallback to text view on failure)
    if (transcriptChatView && transcriptTextView) {
            transcriptChatView.style.display = 'flex';
            transcriptTextView.style.display = 'none';
        isChatViewActive = true;
    }

    // Auto-load conversation when Interaction ID changes
    let loadTimeout = null;
    if (interactionIdInput) {
        interactionIdInput.addEventListener('input', function() {
        const interactionId = interactionIdInput.value.trim();
        
            // Clear previous timeout
            if (loadTimeout) {
                clearTimeout(loadTimeout);
            }
            
            // Disable Open button while typing
            if (viewChatBtn) {
                viewChatBtn.disabled = true;
                viewChatBtn.style.backgroundColor = '#9ca3af';
                viewChatBtn.style.cursor = 'not-allowed';
                viewChatBtn.style.opacity = '0.6';
                viewChatBtn.title = 'Open in Intercom (load conversation first)';
            }
            
            // Debounce: wait 500ms after user stops typing before loading
            if (interactionId) {
                loadTimeout = setTimeout(async () => {
        await loadConversationFromIntercom(interactionId);
                }, 500);
            }
    });
    }

    // View in Intercom button - opens in new tab
    if (viewChatBtn) {
    viewChatBtn.addEventListener('click', async function() {
        const interactionId = interactionIdInput.value.trim();
        
        if (!interactionId) {
            await window.confirmationDialog.show({
                title: 'Interaction ID Required',
                message: 'Please enter an Interaction ID to view the chat in Intercom.',
                confirmText: 'OK',
                cancelText: 'Close',
                type: 'info'
            });
            interactionIdInput.focus();
            return;
        }

        const conversationUrl = `https://app.intercom.com/a/inbox/aphmhtyj/inbox/conversation/${interactionId}?view`;
        window.open(conversationUrl, '_blank', 'noopener,noreferrer,width=1200,height=800,scrollbars=yes,resizable=yes');
    });
    }

    // Auto-focus Interaction ID when page loads
    if (interactionIdInput) {
        interactionIdInput.focus();
    }

    // Fetch conversation from Intercom API
    // Make it globally available for calibration mode
    window.loadConversationFromIntercom = async function(conversationId) {
        // Show loading state
        if (viewChatBtn) {
            viewChatBtn.disabled = true;
            viewChatBtn.style.backgroundColor = '#9ca3af';
            viewChatBtn.style.cursor = 'not-allowed';
            viewChatBtn.style.opacity = '0.6';
            viewChatBtn.textContent = 'Loading...';
            viewChatBtn.title = 'Loading conversation...';
        }
        
        chatMessagesContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: #6b7280;">
                <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
            </div>
        `;

        try {
            // Fetch conversation data from Intercom API via Supabase Edge Function (to avoid CORS)
            // Use display_as=html to get proper HTML with image tags, or plaintext for text-based references
            // We'll handle both formats in the parsing logic
            const edgeFunctionUrl = `${SUPABASE_URL}/functions/v1/intercom-proxy?conversation_id=${encodeURIComponent(conversationId)}&display_as=html`;
            
            const response = await fetch(edgeFunctionUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'apikey': SUPABASE_ANON_KEY,
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
            }

            const conversation = await response.json();
            currentConversationData = conversation;

            // DEBUG: Log raw API response
            console.log('=== RAW API RESPONSE ===');
            console.log('Full conversation object:', conversation);
            console.log('Total conversation parts:', conversation.conversation_parts?.conversation_parts?.length || 0);
            
            // Check specific email parts to see if email_message_metadata is present
            if (conversation.conversation_parts?.conversation_parts) {
                const part32842906801 = conversation.conversation_parts.conversation_parts.find(p => p.id === '32842906801');
                const part32842914590 = conversation.conversation_parts.conversation_parts.find(p => p.id === '32842914590');
                
                if (part32842906801) {
                    console.log('=== PART 32842906801 (should be email) ===');
                    console.log('Full part:', JSON.stringify(part32842906801, null, 2));
                    console.log('Has email_message_metadata key?', 'email_message_metadata' in part32842906801);
                    console.log('email_message_metadata value:', part32842906801.email_message_metadata);
                    console.log('All keys:', Object.keys(part32842906801));
                }
                
                if (part32842914590) {
                    console.log('=== PART 32842914590 (should be email) ===');
                    console.log('Full part:', JSON.stringify(part32842914590, null, 2));
                    console.log('Has email_message_metadata key?', 'email_message_metadata' in part32842914590);
                    console.log('email_message_metadata value:', part32842914590.email_message_metadata);
                    console.log('All keys:', Object.keys(part32842914590));
                }
            }
            console.log('========================');

            // Autofill email and date from conversation data (only if not in calibration mode)
            if (!isCalibrationMode) {
                autofillConversationFields(conversation);
            }

            // Parse and display conversation messages
            displayConversationMessages(conversation);

            // Extract and display all conversation attributes
            displayConversationAttributes(conversation);

            // Ensure chat view is active (it should already be)
            if (!isChatViewActive) {
                isChatViewActive = true;
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
            }

            // Enable Open button after successful load
            if (viewChatBtn) {
                viewChatBtn.disabled = false;
                viewChatBtn.style.backgroundColor = '#6b7280';
                viewChatBtn.style.cursor = 'pointer';
                viewChatBtn.style.opacity = '1';
                viewChatBtn.textContent = 'Open';
                viewChatBtn.title = 'Open in Intercom';
            }

            // Show success notification
            showNotification('Conversation loaded successfully!', 'success');

        } catch (error) {
            console.error('Error loading conversation from Intercom:', error);
            
            // Auto-fallback to text view on error
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'none';
                transcriptTextView.style.display = 'flex';
                isChatViewActive = false;
            }

            // Keep Open button disabled on error
            if (viewChatBtn) {
                viewChatBtn.disabled = true;
                viewChatBtn.style.backgroundColor = '#9ca3af';
                viewChatBtn.style.cursor = 'not-allowed';
                viewChatBtn.style.opacity = '0.6';
                viewChatBtn.textContent = 'Open';
                viewChatBtn.title = 'Open in Intercom (load conversation first)';
            }

            // Show error message in chat container (for debugging, but user will see text view)
            chatMessagesContainer.innerHTML = `
                <div style="text-align: center; padding: 1.2937rem; color: #ef4444;">
                    <svg style="width: 1.9406rem; height: 1.9406rem; margin: 0 auto 0.6469rem; opacity: 0.5;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <p style="font-size: 0.5659rem; font-weight: 600; margin-bottom: 0.3234rem;">Failed to load conversation from Intercom</p>
                    <p style="font-size: 0.4852rem; color: #6b7280;">${escapeHtml(error.message)}</p>
                    <p style="font-size: 0.4852rem; color: #9ca3af; margin-top: 0.3234rem;">Falling back to text view.</p>
                </div>
            `;
        }
    };
    // Also create a local reference for backward compatibility
    const loadConversationFromIntercom = window.loadConversationFromIntercom;

    // Autofill email and date from conversation data
    function autofillConversationFields(conversation) {
        // Extract email from conversation
        // Try multiple possible locations in the Intercom API response
        let email = null;
        
        // Check source.author.email (user/contact who initiated conversation)
        if (conversation.source?.author?.email) {
            email = conversation.source.author.email;
        }
        // Check source.owner.email (assigned agent/team)
        else if (conversation.source?.owner?.email) {
            email = conversation.source.owner.email;
        }
        // Check contacts associated with conversation
        else if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
            const contact = conversation.contacts.contacts[0];
            if (contact.email) {
                email = contact.email;
            }
        }
        // Check source.contacts
        else if (conversation.source?.contacts?.contacts && conversation.source.contacts.contacts.length > 0) {
            const contact = conversation.source.contacts.contacts[0];
            if (contact.email) {
                email = contact.email;
            }
        }
        // Check source.author.contacts
        else if (conversation.source?.author?.contacts && conversation.source.author.contacts.length > 0) {
            const contact = conversation.source.author.contacts[0];
            if (contact.email) {
                email = contact.email;
            }
        }
        // Check conversation_parts for user email (from first user message)
        else if (conversation.conversation_parts?.conversation_parts) {
            for (const part of conversation.conversation_parts.conversation_parts) {
                if (part.author?.type === 'user' || part.author?.type === 'contact') {
                    if (part.author.email) {
                        email = part.author.email;
                        break;
                    }
                }
            }
        }
        
        // Extract date from message timestamps (preferred method)
        // Intercom API returns Unix timestamps (in seconds), not ISO strings
        // Get the earliest message timestamp from conversation_parts
        let conversationDate = null;
        
        // Helper function to convert Unix timestamp (seconds) to Date object
        function unixTimestampToDate(timestamp) {
            if (!timestamp) return null;
            // If it's already a Date object, return it
            if (timestamp instanceof Date) return timestamp;
            // If it's a number (Unix timestamp in seconds), convert it
            if (typeof timestamp === 'number') {
                // If timestamp is less than 10^10, it's in seconds (multiply by 1000)
                // If timestamp is 10^10 or more, it's in milliseconds
                const timestampMs = timestamp < 10000000000 ? timestamp * 1000 : timestamp;
                return new Date(timestampMs);
            }
            // If it's a string, try to parse as ISO date
            if (typeof timestamp === 'string') {
                return new Date(timestamp);
            }
            return null;
        }
        
        if (conversation.conversation_parts?.conversation_parts && conversation.conversation_parts.conversation_parts.length > 0) {
            // Find the earliest message timestamp
            let earliestTimestamp = null;
            for (const part of conversation.conversation_parts.conversation_parts) {
                if (part.created_at) {
                    const partDate = unixTimestampToDate(part.created_at);
                    if (partDate && !isNaN(partDate.getTime())) {
                        if (!earliestTimestamp || partDate < earliestTimestamp) {
                            earliestTimestamp = partDate;
                        }
                    }
                }
            }
            
            if (earliestTimestamp) {
                conversationDate = earliestTimestamp;
            }
        }
        
        // Fallback to conversation-level dates if no message timestamps found
        if (!conversationDate) {
            if (conversation.created_at) {
                conversationDate = unixTimestampToDate(conversation.created_at);
            } else if (conversation.updated_at) {
                conversationDate = unixTimestampToDate(conversation.updated_at);
            } else if (conversation.source?.created_at) {
                conversationDate = unixTimestampToDate(conversation.source.created_at);
            }
        }
        
        // Autofill email field if email was found and field is empty
        const emailInput = document.getElementById('clientEmail');
        if (email && emailInput && (!emailInput.value || emailInput.value.trim() === '')) {
            emailInput.value = email;
            // Trigger change event to notify any listeners
            emailInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        // Autofill date field if date was found and field is empty
        const dateInput = document.getElementById('interactionDate');
        if (conversationDate && dateInput && (!dateInput.value || dateInput.value.trim() === '')) {
            // conversationDate should already be a Date object at this point
            if (!isNaN(conversationDate.getTime())) {
                const year = conversationDate.getFullYear();
                const month = String(conversationDate.getMonth() + 1).padStart(2, '0');
                const day = String(conversationDate.getDate()).padStart(2, '0');
                dateInput.value = `${year}-${month}-${day}`;
                
                // Format date as DD-MMM-YY (e.g., 21-Aug-25)
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const formattedDate = `${day}-${monthNames[conversationDate.getMonth()]}-${String(year).slice(-2)}`;
                console.log('Date from Intercom formatted as:', formattedDate);
                
                // Trigger change event to notify any listeners
                dateInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
        }
        
        console.log('Autofilled from Intercom:', {
            email: email || 'not found',
            date: conversationDate ? conversationDate.toISOString() : 'not found',
            formattedDate: conversationDate ? `${String(conversationDate.getDate()).padStart(2, '0')}-${['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][conversationDate.getMonth()]}-${String(conversationDate.getFullYear()).slice(-2)}` : 'not found'
        });
    }

    // Display conversation messages in chat interface
    // Helper function to generate avatar with initials
    function generateAvatar(name, type) {
        // Extract initials from name
        const getInitials = (name) => {
            if (!name || name === 'Unknown') return '?';
            const parts = name.trim().split(/\s+/);
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        };
        
        const initials = getInitials(name);
        
        // Determine colors and gradients based on type
        let bgGradient, textColor, label, borderColor;
        if (type === 'user' || type === 'contact') {
            // Blue gradient for client
            bgGradient = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
            textColor = '#ffffff';
            label = 'Client'; // Use "Client" label under avatar
            borderColor = '#2563eb';
        } else if (type === 'ai' || type === 'bot') {
            // Darker green gradient for AI
            bgGradient = 'linear-gradient(135deg, #15803d 0%, #166534 100%)';
            textColor = '#ffffff';
            label = 'AI';
            borderColor = '#166534';
        } else {
            // Green gradient for agent
            bgGradient = 'linear-gradient(135deg, #1A733E 0%, #14532d 100%)';
            textColor = '#ffffff';
            label = 'Agent';
            borderColor = '#14532d';
        }
        
        return {
            initials,
            bgGradient,
            textColor,
            label,
            borderColor
        };
    }

    function displayConversationMessages(conversation) {
        const parts = conversation.conversation_parts?.conversation_parts || [];
        
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('ðŸ”„ displayConversationMessages called');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('Total parts:', parts.length);
        console.log('Conversation ID:', conversation.id);
        
        // Log conversation structure for debugging
        if (parts.length > 0) {
            console.log('Sample part structure:', {
                partId: parts[0].id,
                partType: parts[0].part_type,
                hasBody: !!parts[0].body,
                bodyType: typeof parts[0].body,
                bodyPreview: typeof parts[0].body === 'string' ? parts[0].body.substring(0, 200) : 'object/other',
                hasAttachments: !!(parts[0].attachments && parts[0].attachments.length > 0),
                attachmentCount: parts[0].attachments?.length || 0
            });
        }
        
        // Extract client name from conversation
        let clientName = null;
        // Try to get client name from source.author
        if (conversation.source?.author?.name) {
            clientName = conversation.source.author.name;
        }
        // Try contacts
        else if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
            const contact = conversation.contacts.contacts[0];
            if (contact.name) {
                clientName = contact.name;
            }
        }
        // Try to find first user/contact in conversation parts
        else if (parts.length > 0) {
            for (const part of parts) {
                if (part.author && (part.author.type === 'user' || part.author.type === 'contact')) {
                    if (part.author.name) {
                        clientName = part.author.name;
                        break;
                    }
                }
            }
        }
        
        // Update conversation heading with client name
        const transcriptHeading = document.querySelector('h3');
        if (transcriptHeading && clientName) {
            // Update heading text (keep the icon)
            const icon = transcriptHeading.querySelector('svg');
            if (icon) {
                // Keep the SVG icon and replace "Transcript" with client name
                transcriptHeading.innerHTML = icon.outerHTML + ' ' + escapeHtml(clientName);
            } else {
                transcriptHeading.textContent = clientName;
            }
        }
        
        // Update client name in header section
        const clientNameInput = document.getElementById('clientName');
        if (clientNameInput) {
            if (clientName) {
                clientNameInput.value = clientName;
            } else {
                clientNameInput.value = '';
            }
        }
        
        // Log all part types to see what we're getting
        const partTypes = parts.map(p => ({ id: p.id, type: p.part_type, hasEmailMeta: !!p.email_message_metadata, hasAttachments: (p.attachments || []).length > 0 }));
        console.log('Part types:', partTypes);
        
        if (parts.length === 0) {
            chatMessagesContainer.innerHTML = `
                <div style="text-align: center; padding: 1.2937rem; color: #9ca3af;">
                    <p>No messages found in this conversation.</p>
                </div>
            `;
            syncChatToTextarea();
            return;
        }

        // Sort parts by created_at timestamp
        const sortedParts = [...parts].sort((a, b) => {
            // Handle Unix timestamps (in seconds) and Date objects
            const timeA = typeof a.created_at === 'number' 
                ? (a.created_at < 10000000000 ? a.created_at * 1000 : a.created_at)
                : new Date(a.created_at).getTime();
            const timeB = typeof b.created_at === 'number'
                ? (b.created_at < 10000000000 ? b.created_at * 1000 : b.created_at)
                : new Date(b.created_at).getTime();
            return timeA - timeB;
        });

        // Clear container and remove empty state message
        chatMessagesContainer.innerHTML = '';
        chatMessagesContainer.style.gap = '0.3234rem';
        
        // Reset images array
        allConversationImages = [];

        sortedParts.forEach(part => {
            const message = part.body || '';
            const author = part.author || {};
            const authorName = author.name || author.email || 'Unknown';
            const authorType = author.type || 'unknown'; // 'user', 'admin', 'bot', etc.
            const partType = part.part_type || 'comment'; // 'comment', 'assignment', etc.
            
            // Convert Unix timestamp to Date object (Intercom returns timestamps in seconds)
            let timestamp;
            if (typeof part.created_at === 'number') {
                // Unix timestamp in seconds - convert to milliseconds
                timestamp = new Date(part.created_at < 10000000000 ? part.created_at * 1000 : part.created_at);
            } else {
                timestamp = new Date(part.created_at);
            }
            
            // Format timestamp for display
            const timeStr = timestamp.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });
            const dateStr = timestamp.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });
            
            // Check if this is a system comment part type (should be displayed outside chat bubbles)
            const systemCommentTypes = [
                'user_became_idle',
                'close',
                'fin_guidance_applied',
                'conversation_attribute_updated_by_admin',
                'attribute_collected'
            ];
            const isSystemComment = systemCommentTypes.includes(partType);
            
            // If this is a system comment, render it differently (outside chat bubbles)
            if (isSystemComment) {
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    width: 100%;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    margin: 0.4043rem 0;
                    padding: 0 0.8086rem;
                `;
                
                // Format the message body
                let messageData;
                try {
                    messageData = formatMessageBody(message);
                } catch (e) {
                    console.error('Error formatting message body for system comment:', e);
                    messageData = { text: '', html: null, images: [] };
                }
                const formattedText = messageData?.text || '';
                const formattedHtml = messageData?.html || null;
                
                // Create human-readable label for the part type
                const partTypeLabels = {
                    'user_became_idle': 'User became idle',
                    'close': 'Conversation closed',
                    'fin_guidance_applied': 'Guidance applied',
                    'conversation_attribute_updated_by_admin': 'Attribute updated by admin',
                    'attribute_collected': 'Attribute collected'
                };
                const partTypeLabel = partTypeLabels[partType] || partType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                
                // Build the system comment content
                let commentContent = '';
                // Use text version for system comments to avoid HTML rendering issues
                if (formattedText && formattedText.trim() !== '' && formattedText.trim() !== '{}') {
                    commentContent = formattedText;
                } else if (part.body && String(part.body).trim() !== '') {
                    // Fallback: strip HTML tags from body and get plain text
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = String(part.body);
                    commentContent = tempDiv.textContent || tempDiv.innerText || '';
                }
                
                // Escape HTML for safe display
                if (commentContent) {
                    const tempEscDiv = document.createElement('div');
                    tempEscDiv.textContent = commentContent;
                    commentContent = tempEscDiv.innerHTML;
                }
                
                messageDiv.innerHTML = `
                    <div style="
                        background: #f3f4f6;
                        border: 0.0304rem solid #e5e7eb;
                        border-radius: 0.2426rem;
                        padding: 0.3234rem 0.4852rem;
                        max-width: 80%;
                        text-align: center;
                        font-size: 0.4447rem;
                        color: #6b7280;
                        line-height: 1.5;
                    ">
                        <div style="
                            font-weight: 600;
                            color: #4b5563;
                            margin-bottom: 0.1213rem;
                            text-transform: uppercase;
                            letter-spacing: 0.0405rem;
                            font-size: 0.4043rem;
                        ">${partTypeLabel.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}</div>
                        ${commentContent ? `<div style="margin-top: 0.1617rem; color: #6b7280; font-size: 0.4447rem;">${commentContent}</div>` : ''}
                        <div style="
                            margin-top: 0.1617rem;
                            font-size: 0.3639rem;
                            color: #9ca3af;
                            opacity: 0.8;
                        ">${timeStr} • ${dateStr}</div>
                    </div>
                `;
                
                chatMessagesContainer.appendChild(messageDiv);
                return; // Skip normal message rendering for system comments
            }
            
            // Continue with normal message rendering for non-system-comment parts
            const isUser = authorType === 'user' || authorType === 'contact';
            const isAdmin = authorType === 'admin' || authorType === 'team';
            // Detect AI/Bot messages - be strict: only if explicitly bot type or has AI flags
            // Don't check name for "ai" as admins might be labeled as "AI" but are actually agents
            const isAI = authorType === 'bot' || 
                        author.from_ai_agent === true || 
                        author.is_ai_answer === true ||
                        (part.from_ai_agent === true) ||
                        (part.is_ai_answer === true);
            
            // Debug logging for message type detection
            if (isAdmin && !isUser) {
                console.log(`Message from ${authorName} (${authorType}):`, {
                    isAI: isAI,
                    isAdmin: isAdmin,
                    authorType: authorType,
                    from_ai_agent: author.from_ai_agent,
                    is_ai_answer: author.is_ai_answer,
                    part_from_ai_agent: part.from_ai_agent,
                    part_is_ai_answer: part.is_ai_answer,
                    willBeTreatedAs: isAI ? 'AI (dark)' : 'Agent (green)'
                });
            }
            
            // Format the message body to check if it has content
            // This extracts images from HTML img tags and text-based [Image "..."] references
            const messageData = formatMessageBody(message);
            const formattedText = messageData.text;
            const formattedHtml = messageData.html || null; // HTML with inline images
            const images = messageData.images || [];
            
            // Debug logging for message body parsing
            if (images.length > 0 || (message && typeof message === 'string' && message.includes('[Image'))) {
                console.log(`ðŸ“ Part ${part.id} body parsing:`, {
                    hasFormattedText: !!formattedText,
                    hasFormattedHtml: !!formattedHtml,
                    imagesFromBody: images.length,
                    messagePreview: typeof message === 'string' ? message.substring(0, 200) : 'object/other',
                    hasImageReferences: typeof message === 'string' && message.includes('[Image')
                });
            }
            
            // Check if this is an email interaction
            // email_message_metadata is either null (not an email) or an object with properties (is an email)
            // Note: typeof null === 'object' in JavaScript, so we must explicitly check for null
            const isEmail = !!(part.email_message_metadata && 
                part.email_message_metadata !== null && 
                typeof part.email_message_metadata === 'object' && 
                Object.keys(part.email_message_metadata).length > 0);
            const emailMetadata = isEmail ? part.email_message_metadata : {};
            
            // Debug logging for email detection
            if (partType === 'open' || partType === 'comment') {
                console.log(`Part ${part.id} (${partType}):`, {
                    hasEmailMetadataKey: 'email_message_metadata' in part,
                    hasEmailMetadata: !!part.email_message_metadata,
                    emailMetadataType: typeof part.email_message_metadata,
                    emailMetadataValue: part.email_message_metadata,
                    isEmail: isEmail,
                    subject: part.email_message_metadata?.subject || 'N/A',
                    allKeys: Object.keys(part).slice(0, 15) // First 15 keys to see structure
                });
            }
            
            if (isEmail) {
                console.log('âœ… Email detected:', {
                    partId: part.id,
                    partType: partType,
                    subject: emailMetadata.subject,
                    from: emailMetadata.email_address_headers?.find(h => h.type === 'from')?.email_address,
                    to: emailMetadata.email_address_headers?.find(h => h.type === 'to')?.email_address,
                    hasAttachments: (part.attachments || []).length > 0
                });
            }
            
            // Extract attachments from attachments array (separate from body images)
            const attachments = part.attachments || [];
            
            // Extract image attachments - check multiple possible structures
            const attachmentImages = [];
            attachments.forEach(att => {
                // Check if it's an image attachment
                const isImage = (
                    (att.type === 'upload' || att.type === 'image' || !att.type) &&
                    (
                        (att.content_type && att.content_type.startsWith('image/')) ||
                        (att.url && /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i.test(att.url))
                    ) &&
                    att.url
                );
                
                if (isImage && att.url) {
                    attachmentImages.push(att.url);
                }
            });
            
            // Debug logging for attachments
            if (attachments.length > 0) {
                console.log(`ðŸ“Ž Part ${part.id} has ${attachments.length} attachments:`, {
                    totalAttachments: attachments.length,
                    imageAttachments: attachmentImages.length,
                    attachmentTypes: attachments.map(a => ({ type: a.type, contentType: a.content_type, hasUrl: !!a.url }))
                });
            }
            
            // Combine body images and attachment images
            // Body images come first (they appear inline in text), then attachments
            const allImages = [...images, ...attachmentImages];
            
            // Debug logging for combined images
            if (allImages.length > 0) {
                console.log(`ðŸ–¼ï¸ Part ${part.id} total images: ${allImages.length}`, {
                    fromBody: images.length,
                    fromAttachments: attachmentImages.length,
                    allImageUrls: allImages
                });
            }
            
            // Add images to global array with their index for viewer navigation
            const imageStartIndex = allConversationImages.length;
            allImages.forEach((imgSrc, idx) => {
                allConversationImages.push({
                    src: imgSrc,
                    partIndex: sortedParts.indexOf(part),
                    localIndex: idx
                });
            });
            
            // REMOVED: No longer skipping any parts - show ALL parts in the chatbox
            // Always display parts so users can see everything, even if empty
            
            // Check what content this part has (for display purposes)
            const hasBody = !!(part.body && String(part.body).trim() !== '');
            const hasText = !!(formattedText && formattedText.trim() !== '' && formattedText.trim() !== '{}');
            const hasHtml = !!formattedHtml;
            const hasImages = allImages.length > 0;
            const hasAttachments = attachments.length > 0;
            
            // Build content info badge to show in UI what this part contains
            // Always show part_type for all parts
            let contentInfoBadge = '';
            const contentTypes = [];
            
            // Always include part_type first
            if (partType) {
                contentTypes.push(`Type: ${partType}`);
            }
            
            // Then add content types
            if (hasText || hasHtml) contentTypes.push('Text');
            if (hasImages) contentTypes.push(`${allImages.length} Image${allImages.length > 1 ? 's' : ''}`);
            if (hasAttachments) contentTypes.push(`${attachments.length} Attachment${attachments.length > 1 ? 's' : ''}`);
            if (isEmail) contentTypes.push('Email');
            
            // Always show badge if we have part_type or any content
            if (contentTypes.length > 0 || partType) {
                contentInfoBadge = `<div style="
                    font-size: 0.3639rem;
                    color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.7)'};
                    margin-bottom: 0.1617rem;
                    padding: 0.1213rem 0.2426rem;
                    background: ${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'};
                    border-radius: 0.1617rem;
                    display: inline-block;
                ">
                    ${contentTypes.length > 0 ? contentTypes.join(' • ') : (partType ? `Part Type: ${partType}` : 'Empty Part')}
                </div>`;
            }
            
            // Timestamp already formatted above (before system comment check)
            // timeStr and dateStr are already available here

            // Determine message type for avatar and styling
            // Important: Agents should be green, AI should be dark gray
            const messageType = isUser ? 'user' : (isAI ? 'ai' : 'agent');
            const avatar = generateAvatar(authorName, messageType);
            
            // Debug: Log if we're treating an admin as AI when they should be an agent
            if (isAdmin && isAI && authorType !== 'bot') {
                console.warn(`âš ï¸ Admin "${authorName}" is being treated as AI. Check AI detection flags.`);
            }
            
            // Create message bubble container (avatar will be added in innerHTML)
            const messageDiv = document.createElement('div');

            // Colors: User = white, Agent = #1A733E, AI = #1d1d1d (dark gray)
            const bubbleStyle = isUser 
                ? `
                    background: white;
                    color: #374151;
                    border: 0.0304rem solid #e5e7eb;
                    border-radius: 0.4852rem 0.4852rem 0.4852rem 0.1617rem;
                    max-width: 100%;
                    width: fit-content;
                    margin-right: auto;
                    margin-left: 0;
                `
                : isAI
                ? `
                    background: #1d1d1d;
                    color: white;
                    border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                    max-width: 100%;
                    width: fit-content;
                    margin-left: auto;
                    margin-right: 0;
                `
                : `
                    background: #1A733E;
                    color: white;
                    border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                    max-width: 100%;
                    width: fit-content;
                    margin-left: auto;
                    margin-right: 0;
                `;

            // Build email header if this is an email
            let emailHeaderHTML = '';
            if (isEmail) {
                const emailHeaders = emailMetadata.email_address_headers || [];
                const fromHeader = emailHeaders.find(h => h.type === 'from') || {};
                const toHeader = emailHeaders.find(h => h.type === 'to') || {};
                const replyToHeader = emailHeaders.find(h => h.type === 'reply_to') || {};
                const subject = emailMetadata.subject || 'No Subject';
                
                // Format email addresses
                const formatEmailAddress = (header) => {
                    if (!header) return '';
                    const name = header.name || '';
                    const email = header.email_address || '';
                    if (name && email) {
                        return `${escapeHtml(name)} <${escapeHtml(email)}>`;
                    } else if (email) {
                        return escapeHtml(email);
                    } else if (name) {
                        return escapeHtml(name);
                    }
                    return '';
                };
                
                const fromStr = formatEmailAddress(fromHeader);
                const toStr = formatEmailAddress(toHeader);
                const replyToStr = formatEmailAddress(replyToHeader);
                
                // For agent emails, use a more prominent blue background that stands out from green
                // For user emails, use a light blue background
                // For AI emails, use dark gray background matching chat bubble
                const emailBgColor = isUser ? '#e0f2fe' : (isAI ? '#2d2d2d' : '#1e40af');
                const emailBorderColor = isUser ? '#0284c7' : (isAI ? '#1d1d1d' : '#3b82f6');
                const emailIconColor = isUser ? '#0284c7' : (isAI ? '#ffffff' : '#93c5fd');
                const emailTextColor = isUser ? '#0369a1' : (isAI ? '#ffffff' : '#bfdbfe');
                const emailLabelColor = isUser ? '#0369a1' : (isAI ? '#ffffff' : '#bfdbfe');
                const emailSubjectColor = isUser ? '#0c4a6e' : (isAI ? '#ffffff' : '#dbeafe');
                const emailFieldColor = isUser ? '#075985' : (isAI ? '#e5e7eb' : '#bfdbfe');
                const emailBorderBottomColor = isUser ? 'rgba(2, 132, 199, 0.2)' : (isAI ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.2)');
                
                emailHeaderHTML = `
                    <div style="
                        background: ${emailBgColor};
                        border: 0.0606rem solid ${emailBorderColor};
                        padding: 0.4852rem 0.5659rem;
                        margin-bottom: 0.4043rem;
                        border-radius: 0.3234rem;
                        font-size: 0.4447rem;
                        box-shadow: 0 0.0405rem 0.1213rem rgba(0,0,0,0.1);
                    ">
                        <div style="display: flex; align-items: center; gap: 0.3234rem; margin-bottom: 0.2426rem; padding-bottom: 0.1617rem; border-bottom: 0.0304rem solid ${emailBorderBottomColor};">
                            <svg style="width: 0.6064rem; height: 0.6064rem; color: ${emailIconColor}; flex-shrink: 0;" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"></path>
                                <path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"></path>
                            </svg>
                            <span style="font-weight: 700; color: ${emailLabelColor}; text-transform: uppercase; font-size: 0.4043rem; letter-spacing: 0.0405rem;">Email</span>
                        </div>
                        ${subject ? `<div style="color: ${emailSubjectColor}; margin-bottom: 0.2426rem; font-weight: 600;">
                            <span style="color: ${emailFieldColor}; font-weight: 700;">Subject:</span> ${escapeHtml(subject)}
                        </div>` : ''}
                        <div style="color: ${emailSubjectColor}; font-size: 0.4043rem; line-height: 1.6;">
                            ${fromStr ? `<div style="margin-bottom: 0.1213rem;"><span style="color: ${emailFieldColor}; font-weight: 600;">From:</span> ${fromStr}</div>` : ''}
                            ${toStr ? `<div style="margin-bottom: 0.1213rem;"><span style="color: ${emailFieldColor}; font-weight: 600;">To:</span> ${toStr}</div>` : ''}
                            ${replyToStr ? `<div style="margin-top: 0.1213rem; font-size: 0.3639rem; opacity: 0.9;"><span style="color: ${emailFieldColor}; font-weight: 600;">Reply-To:</span> ${replyToStr}</div>` : ''}
                        </div>
                    </div>
                `;
            }

            // Build attachments HTML (non-image attachments)
            let attachmentsHTML = '';
            const nonImageAttachments = attachments.filter(att => 
                att.type === 'upload' && 
                (!att.content_type || !att.content_type.startsWith('image/'))
            );
            if (nonImageAttachments.length > 0) {
                attachmentsHTML = '<div style="margin-top: 0.3234rem; display: flex; flex-direction: column; gap: 0.1617rem;">';
                nonImageAttachments.forEach(att => {
                    attachmentsHTML += `
                        <a 
                            href="${escapeHtml(att.url)}" 
                            target="_blank"
                            rel="noopener noreferrer"
                            style="
                                display: flex;
                                align-items: center;
                                gap: 0.2426rem;
                                padding: 0.2426rem 0.3234rem;
                                background: ${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'};
                                border-radius: 0.2426rem;
                                text-decoration: none;
                                color: ${isUser ? '#374151' : 'white'};
                                font-size: 0.4447rem;
                                transition: background 0.2s ease;
                            "
                            onmouseover="this.style.background='${isUser ? '#e5e7eb' : 'rgba(255,255,255,0.15)'}'"
                            onmouseout="this.style.background='${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'}'"
                        >
                            <svg style="width: 0.4852rem; height: 0.4852rem; flex-shrink: 0;" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd"/>
                            </svg>
                            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(att.name || 'Attachment')}</span>
                            ${att.filesize ? `<span style="color: ${isUser ? '#9ca3af' : 'rgba(255,255,255,0.7)'}; font-size: 0.3639rem;">${(att.filesize / 1024).toFixed(1)} KB</span>` : ''}
                        </a>
                    `;
                });
                attachmentsHTML += '</div>';
            }

            // Build images HTML (for images that aren't inline in text)
            let imagesHTML = '';
            if (allImages.length > 0 && !formattedHtml) {
                imagesHTML = '<div style="margin-top: 0.3234rem; display: flex; flex-wrap: wrap; gap: 0.3234rem;">';
                allImages.forEach((imgSrc, idx) => {
                    const globalIndex = imageStartIndex + idx;
                    const escapedSrc = escapeHtmlAttribute(imgSrc);
                    imagesHTML += `<img src="${escapedSrc}" alt="Attachment ${idx + 1}" onclick="window.openImageViewer(${globalIndex})" style="max-width: 200px; max-height: 200px; border-radius: 0.3234rem; cursor: pointer; object-fit: cover; border: 0.0304rem solid ${isUser ? '#e5e7eb' : 'rgba(255,255,255,0.3)'}; transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0.1617rem 0.4852rem rgba(0,0,0,0.2)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'" onerror="console.error('Failed to load image:', this.src);" loading="lazy" />`;
                });
                imagesHTML += '</div>';
            }

            // Compact layout: timestamp next to sender name for both user and agent messages
            // For emails, make the border more prominent
            const emailBorderStyle = isEmail ? `border: 0.0808rem solid ${isUser ? '#0284c7' : (isAI ? '#1d1d1d' : '#3b82f6')} !important; box-shadow: 0 0.0606rem 0.1617rem ${isUser ? 'rgba(2, 132, 199, 0.3)' : (isAI ? 'rgba(29, 29, 29, 0.3)' : 'rgba(59, 130, 246, 0.3)')} !important;` : '';
            
            // Avatar alignment: Client on left, Agent/AI on right
            const avatarAlign = isUser ? 'flex-start' : 'flex-end';
            const avatarMargin = isUser ? 'margin-right: 0.3234rem;' : 'margin-left: 0.3234rem;';
            const avatarOrder = isUser ? '1' : '3';
            
            // Avatar HTML - Client left, Agent/AI right
            // For AI, use the image avatar; for others, use gradient with initials
            const avatarHTML = isAI ? `
                <div style="display: flex; flex-direction: column; align-items: ${avatarAlign}; margin-bottom: 0.2426rem; ${avatarMargin} flex-shrink: 0; order: ${avatarOrder};">
                    <div style="
                        width: 1.455rem;
                        height: 1.455rem;
                        border-radius: 50%;
                        background: ${avatar.bgGradient};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-shrink: 0;
                        box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1);
                        border: 0.0203rem solid ${avatar.borderColor};
                        position: relative;
                        overflow: hidden;
                    ">
                        <img src="./assets/logos/ai_avatar.webp" alt="AI Avatar" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" onerror="console.error('AI avatar image failed to load:', this.src); this.style.display='none'; this.parentElement.innerHTML='<span style=\\'position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2); color: ${avatar.textColor}; font-size: 0.5257rem; font-weight: 700;\\'>${avatar.initials}</span>';" />
                    </div>
                    <span style="
                        font-size: 0.3639rem;
                        font-weight: 600;
                        color: ${isUser ? '#6b7280' : (isAI ? '#1d1d1d' : '#1A733E')};
                        margin-top: 0.0808rem;
                        text-transform: uppercase;
                        letter-spacing: 0.0203rem;
                    ">${avatar.label}</span>
                </div>
            ` : `
                <div style="display: flex; flex-direction: column; align-items: ${avatarAlign}; margin-bottom: 0.2426rem; ${avatarMargin} flex-shrink: 0; order: ${avatarOrder};">
                    <div style="
                        width: 1.455rem;
                        height: 1.455rem;
                        border-radius: 50%;
                        background: ${avatar.bgGradient};
                        color: ${avatar.textColor};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 0.5257rem;
                        font-weight: 700;
                        flex-shrink: 0;
                        box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1), inset 0 0.0203rem 0 rgba(255,255,255,0.2);
                        border: 0.0203rem solid ${avatar.borderColor};
                        position: relative;
                        overflow: hidden;
                    ">
                        <span style="position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2);">${avatar.initials}</span>
                    </div>
                    <span style="
                        font-size: 0.3639rem;
                        font-weight: 600;
                        color: ${isUser ? '#6b7280' : (isAI ? '#1d1d1d' : '#1A733E')};
                        margin-top: 0.0808rem;
                        text-transform: uppercase;
                        letter-spacing: 0.0203rem;
                    ">${avatar.label}</span>
                </div>
            `;
            
            // Message container: Client avatar left, Agent/AI avatar right
            messageDiv.style.cssText = `
                display: flex;
                flex-direction: row;
                align-items: flex-start;
                margin-bottom: 0;
                width: 100%;
                justify-content: ${isUser ? 'flex-start' : 'flex-end'};
                gap: 0.3234rem;
            `;
            
            messageDiv.innerHTML = `
                ${isUser ? avatarHTML : ''}
                <div style="flex: 1; display: flex; flex-direction: column; align-items: ${isUser ? 'flex-start' : 'flex-end'}; order: ${isUser ? '2' : '1'}; min-width: 0; max-width: calc(100% - 3.5rem);">
                    <div style="${bubbleStyle} padding: 0.4043rem 0.5659rem; box-shadow: 0 0.0304rem 0.0606rem rgba(0,0,0,0.08); ${emailBorderStyle} word-wrap: break-word; overflow-wrap: break-word;">
                    ${isUser ? `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${isEmail ? '0' : '0.1213rem'}; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: #6b7280;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.7; color: #6b7280; white-space: nowrap;">${timeStr} â€¢ ${dateStr}</span></div>` : `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${isEmail ? '0' : '0.1213rem'}; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: white;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.8; color: white; white-space: nowrap;">${timeStr} â€¢ ${dateStr}</span></div>`}
                    ${emailHeaderHTML}
                    ${contentInfoBadge}
                    ${formattedHtml ? renderMessageWithInlineImages(formattedHtml, images, imageStartIndex, part.id, isUser) : 
                      (hasText ? 
                        `<div class="message-text-content" data-original-text="${escapeHtml(formattedText.replace(/"/g, '&quot;'))}" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#374151' : 'white'};">${formattedText}</div>` : 
                        (partType && partType.trim() !== '' ? 
                            `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.8)'}; font-style: italic;">
                                <span style="text-transform: uppercase; font-weight: 600; letter-spacing: 0.0405rem; font-size: 0.4447rem; opacity: 0.8;">${escapeHtml(partType)}</span>
                                ${hasBody ? '<span style="margin-left: 0.2426rem; font-size: 0.4043rem; opacity: 0.6;">(body exists but no displayable content)</span>' : ''}
                            </div>` : 
                            (hasBody || hasImages || hasAttachments || isEmail ? 
                                `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.8)'}; font-style: italic;">
                                    <span style="opacity: 0.7;">Part ID: ${part.id}</span>
                                    ${hasBody ? '<span style="margin-left: 0.2426rem;">• Has body (no displayable text)</span>' : ''}
                                </div>` : 
                                `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#9ca3af' : 'rgba(255,255,255,0.5)'}; font-style: italic;">
                                    <span style="opacity: 0.6;">Empty part (ID: ${part.id})</span>
                                </div>`
                            )
                        )
                    )}
                    ${!formattedHtml && imagesHTML ? imagesHTML : ''}
                    ${attachmentsHTML}
                    </div>
                </div>
                ${!isUser ? avatarHTML : ''}
            `;

            chatMessagesContainer.appendChild(messageDiv);
        });

        // Scroll to bottom after a brief delay to ensure DOM is updated
        setTimeout(() => {
            const transcriptChatView = document.getElementById('transcriptChatView');
            if (transcriptChatView) {
                transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
            }
        }, 100);

        // Sync to textarea for form submission
        syncChatToTextarea();
    }

    // Format message body (handle HTML/plain text and extract images)
    function formatMessageBody(body) {
        if (!body) return { text: '', images: [], html: null };
        
        // If body is an object, extract text
        if (typeof body === 'object') {
            // Handle empty objects
            if (Object.keys(body).length === 0) return { text: '', images: [], html: null };
            
            // Check for text content in various possible fields
            if (body.plaintext) {
                const text = String(body.plaintext).trim();
                return { text: text ? escapeHtml(text) : '', images: [], html: null };
            }
            if (body.text) {
                const text = String(body.text).trim();
                return { text: text ? escapeHtml(text) : '', images: [], html: null };
            }
            if (body.body) {
                return parseHtmlBody(String(body.body));
            }
            
            // Check for HTML content
            if (body.html) {
                return parseHtmlBody(String(body.html));
            }
            
            // If object has no text content, return empty
            // Don't stringify as that would just show "{}"
            return { text: '', images: [], html: null };
        }
        
        // Handle string body (which may contain HTML)
        return parseHtmlBody(String(body));
    }
    
    // Escape HTML attribute value (for src attributes, preserve URL structure)
    // Important: Only escape characters that would break HTML attributes
    // Don't double-encode URL parameters (they're already properly encoded)
    function escapeHtmlAttribute(value) {
        if (!value) return '';
        const str = String(value);
        
        // Only escape characters that would break the HTML attribute
        // Preserve URL structure including query parameters
        return str
            .replace(/&/g, '&amp;')  // Must escape & first
            .replace(/"/g, '&quot;')  // Escape quotes
            .replace(/'/g, '&#x27;')  // Escape single quotes
            .replace(/</g, '&lt;')    // Escape <
            .replace(/>/g, '&gt;');   // Escape >
        
        // Note: We don't escape spaces, slashes, or other URL characters
        // as they're already properly encoded in the URL
    }
    
    // Render message with inline images (replace placeholders with actual image elements)
    function renderMessageWithInlineImages(htmlWithPlaceholders, images, imageStartIndex, messageId, isUser) {
        if (!htmlWithPlaceholders) return '';
        
        let renderedHtml = htmlWithPlaceholders;
        let replacedCount = 0;
        
        // Replace each image placeholder with an actual image element
        images.forEach((imgSrc, idx) => {
            const globalIndex = imageStartIndex + idx;
            const placeholder = `__IMAGE_PLACEHOLDER_${idx}__`;
            
            // Escape the image src for HTML attribute (preserve URL structure)
            // Only escape characters that would break the HTML attribute, preserve URL structure
            const escapedSrc = escapeHtmlAttribute(imgSrc);
            
            // Create image HTML with proper styling and click handler
            // Use proper attribute escaping for src, but don't double-encode URL parameters
            const imageHtml = `<img src="${escapedSrc}" alt="Image ${idx + 1}" onclick="window.openImageViewer(${globalIndex})" onerror="console.error('Failed to load image:', this.src); this.style.display='none';" style="max-width: 100%; max-height: 20rem; border-radius: 0.3234rem; margin: 0.3234rem 0; cursor: pointer; display: block; box-shadow: 0 0.1213rem 0.2426rem rgba(0,0,0,0.1); transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 0.2426rem 0.4852rem rgba(0,0,0,0.15)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0.1213rem 0.2426rem rgba(0,0,0,0.1)';" loading="lazy" />`;
            
            if (renderedHtml.includes(placeholder)) {
                renderedHtml = renderedHtml.replace(placeholder, imageHtml);
                replacedCount++;
            } else {
                console.warn(`âš ï¸ Image placeholder ${placeholder} not found in HTML for message ${messageId}`);
            }
        });
        
        // Clean up any remaining placeholders (shouldn't happen, but just in case)
        const remainingPlaceholders = (renderedHtml.match(/__IMAGE_PLACEHOLDER_\d+__/g) || []).length;
        if (remainingPlaceholders > 0) {
            console.warn(`âš ï¸ ${remainingPlaceholders} image placeholders not replaced in message ${messageId}`);
            renderedHtml = renderedHtml.replace(/__IMAGE_PLACEHOLDER_\d+__/g, '');
        }
        
        // Debug logging
        if (images.length > 0) {
            console.log(`ðŸ–¼ï¸ Rendered ${replacedCount}/${images.length} images inline for message ${messageId}`);
        }
        
        // Add CSS class based on message type for styling
        const messageClass = isUser ? '' : 'agent-message';
        const textColor = isUser ? '#374151' : 'white';
        
        return `<div class="message-text-content ${messageClass}" data-message-id="${messageId}" style="font-size: 0.5257rem; line-height: 1.6; word-wrap: break-word; margin-top: 0; margin-bottom: 0; color: ${textColor};">
            ${renderedHtml}
        </div>`;
    }

    // Parse HTML body to extract text and images (preserve inline images)
    // Handles both HTML <img> tags and text-based [Image "..."] references
    function parseHtmlBody(htmlBody) {
        if (!htmlBody) return { text: '', images: [], html: '' };
        
        const htmlString = String(htmlBody);
        const images = [];
        let processedHtml = htmlString;
        
        // Step 1: Extract images from HTML <img> tags
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlString;
        
        const imgTags = tempDiv.querySelectorAll('img');
        let imageIndex = 0;
        
        imgTags.forEach((img) => {
            const src = img.getAttribute('src') || '';
            if (src) {
                // Decode HTML entities in URL (but preserve the original URL structure)
                let decodedSrc = src;
                // Only decode if it's clearly an HTML entity, not part of URL encoding
                if (src.includes('&amp;') && !src.includes('?')) {
                    decodedSrc = src.replace(/&amp;/g, '&');
                }
                images.push(decodedSrc);
                
                // Replace img tag with a placeholder
                const placeholder = document.createTextNode(`__IMAGE_PLACEHOLDER_${imageIndex}__`);
                if (img.parentNode) {
                    img.parentNode.replaceChild(placeholder, img);
                }
                imageIndex++;
            }
        });
        
        // Get HTML with placeholders from img tags
        processedHtml = tempDiv.innerHTML;
        
        // Step 2: Extract images from text-based [Image "..."] references
        // Pattern: [Image "URL"] or [Image 'URL'] or [Image URL]
        // Need to handle URLs with query parameters that might contain quotes
        // More robust pattern: [Image "..."], [Image '...'], or [Image ...]
        const imageReferencePattern = /\[Image\s+(?:"([^"]+)"|'([^']+)'|([^\]]+))\]/gi;
        let match;
        const textImageMatches = [];
        
        // Find all matches and their positions
        while ((match = imageReferencePattern.exec(htmlString)) !== null) {
            // match[1] = double-quoted URL, match[2] = single-quoted URL, match[3] = unquoted URL
            const imageUrl = match[1] || match[2] || match[3];
            const fullMatch = match[0];
            const matchIndex = match.index;
            
            if (imageUrl && imageUrl.trim() && !images.includes(imageUrl.trim())) {
                const trimmedUrl = imageUrl.trim();
                // Only add if not already found in HTML img tags
                textImageMatches.push({
                    url: trimmedUrl,
                    fullMatch: fullMatch,
                    index: matchIndex,
                    placeholderIndex: imageIndex
                });
                images.push(trimmedUrl);
                imageIndex++;
            }
        }
        
        // Replace text-based image references with placeholders (in reverse order to preserve indices)
        textImageMatches.reverse().forEach(match => {
            const placeholder = `__IMAGE_PLACEHOLDER_${match.placeholderIndex}__`;
            processedHtml = processedHtml.substring(0, match.index) + 
                          placeholder + 
                          processedHtml.substring(match.index + match.fullMatch.length);
        });
        
        // Step 3: Sanitize HTML using DOMPurify (security + clean HTML)
        if (typeof DOMPurify !== 'undefined') {
            processedHtml = DOMPurify.sanitize(processedHtml, {
                ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'b', 'i', 'u', 'a', 'ul', 'ol', 'li', 'code', 'pre', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
                ALLOWED_ATTR: ['href', 'target', 'rel', 'class'],
                ALLOW_DATA_ATTR: false,
                KEEP_CONTENT: true,
                RETURN_DOM: false,
                RETURN_DOM_FRAGMENT: false
            });
        }
        
        // Step 4: Extract plain text for fallback (remove placeholders)
        const tempDiv2 = document.createElement('div');
        tempDiv2.innerHTML = processedHtml;
        const plainText = tempDiv2.textContent || tempDiv2.innerText || '';
        const cleanedText = plainText.replace(/__IMAGE_PLACEHOLDER_\d+__/g, '').trim();
        
        // Debug logging
        if (images.length > 0) {
            console.log(`📸 Extracted ${images.length} images from message body:`, {
                htmlImages: imgTags.length,
                textReferences: textImageMatches.length,
                totalImages: images.length,
                imageUrls: images
            });
        }
        
        // Return HTML with placeholders, plain text, and images array
        return { 
            text: cleanedText, 
            images: images, 
            html: processedHtml // HTML with image placeholders, sanitized and preserving formatting
        };
    }

    // Store all images from conversation for image viewer
    let allConversationImages = [];
    let currentImageIndex = 0;

    // Open image viewer modal
    window.openImageViewer = function(index) {
        if (!allConversationImages || allConversationImages.length === 0) return;
        
        currentImageIndex = Math.max(0, Math.min(index, allConversationImages.length - 1));
        const modal = document.getElementById('imageViewerModal');
        const img = document.getElementById('imageViewerImg');
        const prevBtn = document.getElementById('imageViewerPrev');
        const nextBtn = document.getElementById('imageViewerNext');
        const counter = document.getElementById('imageViewerCounter');
        const closeBtn = document.getElementById('imageViewerClose');
        
        if (modal && img) {
            img.src = allConversationImages[currentImageIndex].src;
            img.style.display = 'block';
            
            // Update counter
            if (counter) {
                counter.textContent = `${currentImageIndex + 1} / ${allConversationImages.length}`;
            }
            
            // Show/hide navigation buttons
            if (prevBtn) {
                prevBtn.style.display = allConversationImages.length > 1 ? 'flex' : 'none';
            }
            if (nextBtn) {
                nextBtn.style.display = allConversationImages.length > 1 ? 'flex' : 'none';
            }
            
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Focus on modal for keyboard navigation
            modal.focus();
        }
    };

    // Close image viewer modal
    window.closeImageViewer = function() {
        const modal = document.getElementById('imageViewerModal');
        if (modal) {
            modal.style.display = 'none';
            document.body.style.overflow = '';
        }
    };

    // Navigate to previous image
    window.navigateImage = function(direction) {
        if (!allConversationImages || allConversationImages.length === 0) return;
        
        if (direction === 'prev') {
            currentImageIndex = (currentImageIndex - 1 + allConversationImages.length) % allConversationImages.length;
        } else if (direction === 'next') {
            currentImageIndex = (currentImageIndex + 1) % allConversationImages.length;
        }
        
        const img = document.getElementById('imageViewerImg');
        const counter = document.getElementById('imageViewerCounter');
        
        if (img) {
            img.style.display = 'none';
            setTimeout(() => {
                img.src = allConversationImages[currentImageIndex].src;
                img.style.display = 'block';
            }, 150);
        }
        
        if (counter) {
            counter.textContent = `${currentImageIndex + 1} / ${allConversationImages.length}`;
        }
    };

    // Sync chat messages to textarea for form submission
    function syncChatToTextarea() {
        if (!chatMessagesContainer || !transcriptTextarea) return;
        
        const messages = chatMessagesContainer.querySelectorAll('div[style*="display: flex"]');
        const transcriptLines = [];
        
        messages.forEach(msgDiv => {
            const authorDiv = msgDiv.querySelector('div[style*="font-size: 0.4852rem"]');
            const messageDiv = msgDiv.querySelector('div[style*="white-space: pre-wrap"]');
            const timeDiv = msgDiv.querySelector('div[style*="font-size: 0.4043rem"]');
            
            if (messageDiv) {
                const author = authorDiv ? authorDiv.textContent.trim() : 'User';
                const message = messageDiv.textContent.trim();
                const time = timeDiv ? timeDiv.textContent.trim() : '';
                
                if (message) {
                    transcriptLines.push(`${author} (${time}): ${message}`);
                }
            }
        });
        
        transcriptTextarea.value = transcriptLines.join('\n\n');
    }

    // Show notification
    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        const bgColor = type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#1A733E';
        
        notification.style.cssText = `
            position: fixed;
            top: 0.6064rem;
            right: 0.6064rem;
            background: ${bgColor};
            color: white;
            padding: 0.3639rem 0.6064rem;
            border-radius: 0.1819rem;
            font-family: 'Poppins', sans-serif;
            font-size: 0.4245rem;
            z-index: 10000;
            box-shadow: 0 0.1213rem 0.3639rem rgba(0,0,0,0.15);
            animation: slideInRight 0.3s ease-out;
        `;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }

    // Escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Add CSS animation for spinner and custom scrollbar
    if (!document.getElementById('intercomChatStyles')) {
        const style = document.createElement('style');
        style.id = 'intercomChatStyles';
        style.textContent = `
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }
            /* Custom scrollbar for chat interface */
            #transcriptChatView::-webkit-scrollbar {
                width: 0.1819rem;
            }
            #transcriptChatView::-webkit-scrollbar-track {
                background: #f0f2f5;
                border-radius: 0.091rem;
            }
            #transcriptChatView::-webkit-scrollbar-thumb {
                background: #9ca3af;
                border-radius: 0.091rem;
            }
            #transcriptChatView::-webkit-scrollbar-thumb:hover {
                background: #6b7280;
            }
            /* Ensure Interaction Details Bar doesn't get cut off */
            #leftColumn {
                min-width: 13.6451rem !important;
            }
            #leftColumn > div:first-child {
                overflow-x: auto !important;
            }
            #leftColumn > div:first-child::-webkit-scrollbar {
                height: 0.1819rem;
            }
            #leftColumn > div:first-child::-webkit-scrollbar-track {
                background: #f9fafb;
                border-radius: 0.091rem;
            }
            #leftColumn > div:first-child::-webkit-scrollbar-thumb {
                background: #9ca3af;
                border-radius: 0.091rem;
            }
            #leftColumn > div:first-child::-webkit-scrollbar-thumb:hover {
                background: #6b7280;
            }
            /* Custom scrollbar for conversation attributes panels */
            #conversationAttributesContent::-webkit-scrollbar,
            #conversationAttributesPanelTextView::-webkit-scrollbar {
                width: 0.1819rem;
            }
            #conversationAttributesContent::-webkit-scrollbar-track,
            #conversationAttributesPanelTextView::-webkit-scrollbar-track {
                background: #f9fafb;
                border-radius: 0.091rem;
            }
            #conversationAttributesContent::-webkit-scrollbar-thumb,
            #conversationAttributesPanelTextView::-webkit-scrollbar-thumb {
                background: #9ca3af;
                border-radius: 0.091rem;
            }
            #conversationAttributesContent::-webkit-scrollbar-thumb:hover,
            #conversationAttributesPanelTextView::-webkit-scrollbar-thumb:hover {
                background: #6b7280;
            }
        `;
        document.head.appendChild(style);
    }

    // Make sync function globally accessible for form submission
    window.syncChatMessagesToTextarea = syncChatToTextarea;

    // Function removed - attributes are now always shown by default

    // Display all conversation attributes in UI-friendly format
    // Toggle function for conversation info grid
    function toggleConversationInfoGrid() {
        const content = document.getElementById('conversationInfoGridContent');
        const icon = document.getElementById('toggleInfoGridIcon');
        if (!content || !icon) return;
        
        const isHidden = content.style.display === 'none';
        content.style.display = isHidden ? 'grid' : 'none';
        icon.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
    }
    
    // Make toggle function globally accessible
    window.toggleConversationInfoGrid = toggleConversationInfoGrid;
    
    // Language detection function - simple heuristic to detect non-English text
    function detectLanguage(text) {
        if (!text || text.trim().length === 0) return 'en';
        
        // Remove HTML tags and get plain text
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        const plainText = tempDiv.textContent || tempDiv.innerText || '';
        
        // Simple heuristic: check for common English patterns
        // Count English letters vs non-English characters
        const englishPattern = /[a-zA-Z]/g;
        const nonEnglishPattern = /[^\x00-\x7F]/g;
        
        const englishChars = (plainText.match(englishPattern) || []).length;
        const nonEnglishChars = (plainText.match(nonEnglishPattern) || []).length;
        const totalChars = plainText.replace(/\s/g, '').length;
        
        // If more than 30% non-ASCII characters, likely not English
        if (totalChars > 0 && (nonEnglishChars / totalChars) > 0.3) {
            return 'auto'; // Needs translation
        }
        
        // Check for common non-English language patterns
        const commonNonEnglishPatterns = [
            /[\u0600-\u06FF]/g, // Arabic
            /[\u4E00-\u9FFF]/g, // Chinese
            /[\u3040-\u309F\u30A0-\u30FF]/g, // Japanese
            /[\u0400-\u04FF]/g, // Cyrillic
            /[\u0590-\u05FF]/g, // Hebrew
            /[\u0E00-\u0E7F]/g, // Thai
        ];
        
        for (const pattern of commonNonEnglishPatterns) {
            if (pattern.test(plainText)) {
                return 'auto'; // Needs translation
            }
        }
        
        return 'en'; // Likely English
    }
    
    // Translate text using LibreTranslate API with retry logic
    async function translateText(text, targetLang = 'en', retryCount = 0) {
        if (!text || text.trim().length === 0) return text;
        
        const maxRetries = 3;
        const baseDelay = 1000; // Start with 1 second delay
        
        try {
            // Use LibreTranslate public API
            const response = await fetch('https://libretranslate.com/translate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    q: text,
                    source: 'auto',
                    target: targetLang,
                    format: 'text'
                })
            });
            
            // Handle rate limiting with exponential backoff
            if (response.status === 429) {
                if (retryCount < maxRetries) {
                    const delay = baseDelay * Math.pow(2, retryCount); // Exponential backoff: 1s, 2s, 4s
                    console.log(`Rate limited. Retrying in ${delay}ms... (attempt ${retryCount + 1}/${maxRetries})`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return translateText(text, targetLang, retryCount + 1);
                } else {
                    throw new Error('Rate limit exceeded. Please try again later.');
                }
            }
            
            // Handle bad requests (400) - skip this message
            if (response.status === 400) {
                console.warn('Bad request for translation, skipping:', text.substring(0, 50));
                return text; // Return original text
            }
            
            if (!response.ok) {
                throw new Error(`Translation API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.translatedText || text;
        } catch (error) {
            // If it's a rate limit error and we've exhausted retries, try fallback
            if (error.message.includes('Rate limit') && retryCount >= maxRetries) {
                console.log('Trying fallback translation API...');
                // Fallback: try MyMemory Translation API
                try {
                    const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=auto|en`);
                    const data = await response.json();
                    if (data.responseData && data.responseData.translatedText) {
                        return data.responseData.translatedText;
                    }
                } catch (fallbackError) {
                    console.error('Fallback translation error:', fallbackError);
                }
            }
            
            // If error doesn't mention rate limit, log it but return original text
            if (!error.message.includes('Rate limit')) {
                console.error('Translation error:', error);
            }
            
            return text; // Return original if translation fails
        }
    }
    
    // Main translation function
    async function translateChatMessages() {
        // Feature is currently disabled
        const translateBtn = document.getElementById('translateChatBtn');
        if (translateBtn && translateBtn.disabled) {
            return;
        }
        
        const chatMessagesContainer = document.getElementById('chatMessagesContainer');
        
        if (!chatMessagesContainer) {
            showNotification('Chat messages container not found', 'error');
            return;
        }
        
        // Get all message text elements
        const messageTextElements = chatMessagesContainer.querySelectorAll('.message-text-content');
        
        if (messageTextElements.length === 0) {
            showNotification('No messages to translate', 'info');
            return;
        }
        
        // Disable button and show loading state
        if (translateBtn) {
            translateBtn.disabled = true;
            const originalText = translateBtn.querySelector('span').textContent;
            translateBtn.querySelector('span').textContent = 'Translating...';
            translateBtn.style.opacity = '0.6';
            translateBtn.style.cursor = 'not-allowed';
        }
        
        let translatedCount = 0;
        let skippedCount = 0;
        
        // Process messages sequentially to avoid rate limiting
        // Use longer delays for public API (500ms between requests)
        const delayBetweenRequests = 500;
        
        for (let i = 0; i < messageTextElements.length; i++) {
            const element = messageTextElements[i];
            const originalText = element.getAttribute('data-original-text');
            if (!originalText) continue;
            
            // Decode HTML entities to get plain text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalText;
            const plainText = tempDiv.textContent || tempDiv.innerText || '';
            
            // Skip if text is too short or empty
            if (plainText.trim().length < 3) {
                skippedCount++;
                continue;
            }
            
            // Detect language
            const detectedLang = detectLanguage(plainText);
            
            if (detectedLang === 'en') {
                skippedCount++;
                continue; // Skip English messages
            }
            
            // Update button text to show progress
            if (translateBtn && i % 5 === 0) {
                const remaining = messageTextElements.length - i;
                translateBtn.querySelector('span').textContent = `Translating... (${remaining} remaining)`;
            }
            
            // Translate the text
            try {
                const translatedText = await translateText(plainText, 'en');
                
                // Only update if translation is different from original
                if (translatedText && translatedText.trim() !== plainText.trim() && translatedText !== plainText) {
                    // Update the element with translated text (escape HTML for safety)
                    element.innerHTML = escapeHtml(translatedText);
                    translatedCount++;
                } else {
                    skippedCount++;
                }
                
                // Delay between requests to avoid rate limiting (500ms)
                // Skip delay for last message
                if (i < messageTextElements.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, delayBetweenRequests));
                }
            } catch (error) {
                console.error('Error translating message:', error);
                skippedCount++;
                // If rate limited, add extra delay
                if (error.message && error.message.includes('Rate limit')) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
        }
        
        // Re-enable button
        if (translateBtn) {
            translateBtn.disabled = false;
            translateBtn.querySelector('span').textContent = 'Translate';
            translateBtn.style.opacity = '1';
            translateBtn.style.cursor = 'pointer';
        }
        
        // Show completion notification
        if (translatedCount > 0) {
            showNotification(`Translated ${translatedCount} message(s) to English`, 'success');
        } else if (skippedCount > 0) {
            showNotification('All messages are already in English', 'info');
        } else {
            showNotification('No messages found to translate', 'info');
        }
    }
    
    // Make translation function globally accessible
    window.translateChatMessages = translateChatMessages;
    
    function displayConversationAttributes(conversation) {
        // Hide the old panels
        const chatPanel = document.getElementById('conversationAttributesPanel');
        const textPanel = document.getElementById('conversationAttributesPanelTextView');
        if (chatPanel) chatPanel.style.display = 'none';
        if (textPanel) textPanel.style.display = 'none';
        
        // Show and populate the expanded info grid
        const infoGrid = document.getElementById('conversationInfoGrid');
        if (!infoGrid) return;
        
        const attributes = extractConversationAttributes(conversation);
        infoGrid.style.display = 'block';
        
        // Helper function to format value
        const formatValue = (key, value) => {
            if (value === null || value === undefined) return null;
            if (typeof value === 'boolean') return value ? 'Yes' : 'No';
            
            // Handle URLs (for Web Link)
            if (key.toLowerCase().includes('link') || key.toLowerCase().includes('url')) {
                const url = String(value);
                if (url.startsWith('http://') || url.startsWith('https://')) {
                    return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" style="color: #1A733E; text-decoration: underline; font-weight: 600;">View in Intercom â†’</a>`;
                }
            }
            
            if (typeof value === 'object') {
                if (Array.isArray(value)) {
                    if (value.length === 0) return null;
                    return value.map(item => {
                        if (typeof item === 'object') {
                            return Object.values(item).filter(v => v).join(' - ');
                        }
                        return String(item);
                    }).join(', ');
                }
                return JSON.stringify(value, null, 2);
            }
            return String(value);
        };
        
        // Helper function to get icon and color for a key
        const getIconAndColor = (key) => {
            const iconMap = {
                'State': { icon: 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z', color: '#1A733E' },
                'Priority': { icon: 'M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z', color: '#f59e0b' },
                'Total Messages': { icon: 'M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z', color: '#3b82f6' },
                'Time to Admin Reply': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
                'Time to Assignment': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
                'Time to First Close': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
                'Time to Last Close': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
                'Median Time to Reply': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
                'Author Email': { icon: 'M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z', color: '#ec4899' },
                'Assigned To': { icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z', color: '#10b981' },
                'Created At': { icon: 'M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z', color: '#6366f1' },
                'Updated At': { icon: 'M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z', color: '#6366f1' },
                'Rating': { icon: 'M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z', color: '#f97316' },
                'Tags': { icon: 'M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z', color: '#06b6d4' },
                'User Messages': { icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z', color: '#3b82f6' },
                'Admin Messages': { icon: 'M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z', color: '#10b981' },
                'Reopens Count': { icon: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15', color: '#f59e0b' },
                'Assignments Count': { icon: 'M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2', color: '#8b5cf6' }
            };
            
            return iconMap[key] || { icon: 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z', color: '#6b7280' };
        };
        
        // Helper function to create copy button
        const createCopyButton = (value, fieldName) => {
            if (!value) return '';
            return `
                <button onclick="event.stopPropagation(); navigator.clipboard.writeText('${escapeHtml(String(value))}').then(() => showNotification('${fieldName} copied!', 'success')).catch(() => showNotification('Failed to copy', 'error')); return false;" 
                    style="padding: 0.0808rem; background: rgba(26, 115, 62, 0.1); border: none; border-radius: 0.1617rem; cursor: pointer; transition: all 0.2s; margin-left: 0.1617rem;"
                    onmouseover="this.style.background='rgba(26, 115, 62, 0.2)';" onmouseout="this.style.background='rgba(26, 115, 62, 0.1)';"
                    title="Copy ${fieldName}">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.3234rem; height: 0.3234rem; color: #1A733E;">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                    </svg>
                </button>
            `;
        };
        
        let html = '';
        const gridContainer = document.getElementById('conversationInfoGridContent');
        if (!gridContainer) return;
        
        // Display ALL attributes
        Object.keys(attributes).forEach(key => {
            const value = formatValue(key, attributes[key]);
            if (!value) return;
            
            const label = formatLabelForAttribute(key);
            const { icon, color } = getIconAndColor(key);
            const needsCopyButton = key === 'Author Email' || key === 'Custom: Account Number (MT4/MT5)' || key === 'Conversation ID';
            const copyBtn = needsCopyButton ? createCopyButton(attributes[key], label) : '';
            
            html += `
                <div style="background: #ffffff; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; padding: 0.3234rem; box-shadow: 0 0.0203rem 0.0606rem rgba(0,0,0,0.05); transition: all 0.2s;" onmouseover="this.style.boxShadow='0 0.0405rem 0.1213rem rgba(0,0,0,0.1)'; this.style.borderColor='#1A733E';" onmouseout="this.style.boxShadow='0 0.0203rem 0.0606rem rgba(0,0,0,0.05)'; this.style.borderColor='#e5e7eb';">
                    <div style="display: flex; align-items: center; gap: 0.2425rem; margin-bottom: 0.1617rem;">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem; color: ${color}; flex-shrink: 0;">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${icon}"></path>
                        </svg>
                        <span style="font-size: 0.3639rem; font-weight: 600; color: #6b7280; text-transform: uppercase; letter-spacing: 0.0092rem;">${escapeHtml(label)}</span>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <span style="font-size: 0.4447rem; font-weight: 600; color: #1f2937; word-break: break-word; flex: 1;">${key.toLowerCase().includes('link') ? value : escapeHtml(String(value))}</span>
                        ${copyBtn}
                    </div>
                </div>
            `;
        });
        
        gridContainer.innerHTML = html;
    }
    
    // Helper function to format label (used in both functions)
    function formatLabelForAttribute(label) {
        return label.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    }
    
    // Extract all relevant conversation attributes from Intercom API response
    function extractConversationAttributes(conversation) {
        const attributes = {};
        
        // Helper function to convert Unix timestamp to readable date
        const formatTimestamp = (timestamp) => {
            if (!timestamp) return null;
            const date = typeof timestamp === 'number' 
                ? new Date(timestamp < 10000000000 ? timestamp * 1000 : timestamp)
                : new Date(timestamp);
            if (isNaN(date.getTime())) return null;
            return date.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true
            });
        };
        
        // Basic Information
        if (conversation.id) attributes['Conversation ID'] = conversation.id;
        if (conversation.type) attributes['Type'] = conversation.type;
        if (conversation.state) attributes['State'] = conversation.state;
        if (conversation.read) attributes['Read'] = conversation.read;
        if (conversation.created_at) attributes['Created At'] = formatTimestamp(conversation.created_at);
        if (conversation.updated_at) attributes['Updated At'] = formatTimestamp(conversation.updated_at);
        if (conversation.waiting_since) attributes['Waiting Since'] = formatTimestamp(conversation.waiting_since);
        
        // Source Information
        if (conversation.source) {
            if (conversation.source.type) attributes['Source Type'] = conversation.source.type;
            if (conversation.source.id) attributes['Source ID'] = conversation.source.id;
            if (conversation.source.delivered_as) attributes['Delivered As'] = conversation.source.delivered_as;
            if (conversation.source.subject) attributes['Subject'] = conversation.source.subject;
            
            // Author (who initiated)
            if (conversation.source.author) {
                const author = conversation.source.author;
                if (author.type) attributes['Author Type'] = author.type;
                if (author.id) attributes['Author ID'] = author.id;
                if (author.name) attributes['Author Name'] = author.name;
                if (author.email) attributes['Author Email'] = author.email;
            }
            
            // Owner (assigned to)
            if (conversation.source.owner) {
                const owner = conversation.source.owner;
                if (owner.type) attributes['Owner Type'] = owner.type;
                if (owner.id) attributes['Owner ID'] = owner.id;
                if (owner.name) attributes['Assigned To'] = owner.name;
                if (owner.email) attributes['Owner Email'] = owner.email;
            }
        }
        
        // Statistics
        if (conversation.statistics) {
            const stats = conversation.statistics;
            if (stats.time_to_assignment !== undefined && stats.time_to_assignment !== null) attributes['Time to Assignment'] = `${Math.round(stats.time_to_assignment / 60)} minutes`;
            if (stats.time_to_admin_reply !== undefined && stats.time_to_admin_reply !== null) attributes['Time to Admin Reply'] = `${Math.round(stats.time_to_admin_reply / 60)} minutes`;
            if (stats.time_to_first_close !== undefined && stats.time_to_first_close !== null) attributes['Time to First Close'] = `${Math.round(stats.time_to_first_close / 60)} minutes`;
            if (stats.time_to_last_close !== undefined && stats.time_to_last_close !== null) attributes['Time to Last Close'] = `${Math.round(stats.time_to_last_close / 60)} minutes`;
            if (stats.median_time_to_reply !== undefined && stats.median_time_to_reply !== null) attributes['Median Time to Reply'] = `${Math.round(stats.median_time_to_reply / 60)} minutes`;
            if (stats.first_contact_reply_at) attributes['First Contact Reply At'] = formatTimestamp(stats.first_contact_reply_at);
            if (stats.first_admin_reply_at) attributes['First Admin Reply At'] = formatTimestamp(stats.first_admin_reply_at);
            if (stats.last_contact_reply_at) attributes['Last Contact Reply At'] = formatTimestamp(stats.last_contact_reply_at);
            if (stats.last_admin_reply_at) attributes['Last Admin Reply At'] = formatTimestamp(stats.last_admin_reply_at);
            if (stats.count_reopens) attributes['Reopens Count'] = stats.count_reopens;
            if (stats.count_assignments) attributes['Assignments Count'] = stats.count_assignments;
        }
        
        // Tags
        if (conversation.tags && conversation.tags.tags && conversation.tags.tags.length > 0) {
            attributes['Tags'] = conversation.tags.tags.map(tag => tag.name || tag).join(', ');
        }
        
        // Teammates (participating admins)
        if (conversation.teammates && conversation.teammates.teammates && conversation.teammates.teammates.length > 0) {
            attributes['Teammates'] = conversation.teammates.teammates.map(teammate => 
                teammate.name || teammate.email || teammate.id
            ).join(', ');
        }
        
        // Contacts (users involved)
        if (conversation.contacts && conversation.contacts.contacts && conversation.contacts.contacts.length > 0) {
            const contacts = conversation.contacts.contacts.map(contact => {
                const parts = [];
                if (contact.name) parts.push(contact.name);
                if (contact.email) parts.push(contact.email);
                return parts.length > 0 ? parts.join(' - ') : contact.id;
            });
            attributes['Contacts'] = contacts.join(', ');
        }
        
        // Conversation Parts Summary
        if (conversation.conversation_parts && conversation.conversation_parts.conversation_parts) {
            const parts = conversation.conversation_parts.conversation_parts;
            attributes['Total Messages'] = parts.length;
            
            const userMessages = parts.filter(p => p.author && (p.author.type === 'user' || p.author.type === 'contact')).length;
            const adminMessages = parts.filter(p => p.author && (p.author.type === 'admin' || p.author.type === 'team')).length;
            
            if (userMessages > 0) attributes['User Messages'] = userMessages;
            if (adminMessages > 0) attributes['Admin Messages'] = adminMessages;
        }
        
        // Priority
        if (conversation.priority) {
            attributes['Priority'] = conversation.priority === 'priority' ? 'High' : conversation.priority;
        }
        
        // Custom Attributes (if any)
        if (conversation.custom_attributes) {
            Object.entries(conversation.custom_attributes).forEach(([key, value]) => {
                if (value !== null && value !== undefined) {
                    attributes[`Custom: ${formatLabelForAttribute(key)}`] = value;
                }
            });
        }
        
        // Links (store URL separately, will be handled in display)
        if (conversation.links) {
            if (conversation.links.conversation_web) {
                attributes['Web Link'] = conversation.links.conversation_web;
            }
        }
        
        // Conversation Rating (if available)
        if (conversation.conversation_rating) {
            attributes['Rating'] = conversation.conversation_rating.rating || 'N/A';
            if (conversation.conversation_rating.remark) {
                attributes['Rating Remark'] = conversation.conversation_rating.remark;
            }
        }
        
        return attributes;
    }
});

// ============================================================================
// Resizable Splitter Functionality (matching expert-audits.html)
// ============================================================================
document.addEventListener('DOMContentLoaded', function() {
    const splitter = document.getElementById('splitter');
    const leftColumn = document.getElementById('leftColumn');
    const rightColumn = document.getElementById('rightColumn');
    const auditContent = document.getElementById('auditContent');
    
    if (splitter && leftColumn && rightColumn && auditContent) {
        let isResizing = false;
        
        splitter.addEventListener('mousedown', function(e) {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            splitter.style.background = '#9ca3af';
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const containerRect = auditContent.getBoundingClientRect();
            const offsetX = e.clientX - containerRect.left;
            const containerWidth = containerRect.width;
            
            // Calculate percentage (with min/max constraints)
            // Min width: 13.6451rem (~13.625rem at 1.0rem base) - convert to percentage
            // Max width: 75% of container
            const minWidthPx = 13.6451 * 16; // Convert rem to pixels (assuming 1.0rem base)
            const minWidthPercent = Math.max(15, (minWidthPx / containerWidth) * 100); // At least 15%
            const maxWidthPercent = 75; // Maximum 75% of container
            
            let leftPercentage = (offsetX / containerWidth) * 100;
            leftPercentage = Math.max(minWidthPercent, Math.min(maxWidthPercent, leftPercentage));
            
            leftColumn.style.width = leftPercentage + '%';
            leftColumn.style.flex = '0 0 ' + leftPercentage + '%';
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                splitter.style.background = '#e5e7eb';
            }
        });
        
        // Hover effect
        splitter.addEventListener('mouseenter', function() {
            if (!isResizing) {
                splitter.style.background = '#d1d5db';
            }
        });
        
        splitter.addEventListener('mouseleave', function() {
            if (!isResizing) {
                splitter.style.background = '#e5e7eb';
            }
        });
    }
});

// ============================================================================
// Helper Function: Submit Dummy Audit Data (for testing)
// Usage: Call window.submitDummyAudit() in the browser console
// ============================================================================
window.submitDummyAudit = async function() {
    console.log('=== Starting Dummy Audit Submission ===');
    
    try {
        // Step 1: Open the manual audit form
        if (typeof window.createManualAudit === 'function') {
            await window.createManualAudit();
            console.log('✓ Opened audit form');
            await new Promise(resolve => setTimeout(resolve, 1500));
        } else {
            console.error('createManualAudit function not found');
            return;
        }
        
        // Step 2: Select first available scorecard
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (!scorecardSelect || scorecardSelect.options.length <= 1) {
            console.error('No scorecards available');
            return;
        }
        
        scorecardSelect.value = scorecardSelect.options[1].value;
        scorecardSelect.dispatchEvent(new Event('change', { bubbles: true }));
        console.log('✓ Selected scorecard:', scorecardSelect.options[1].text);
        
        // Wait for parameters to load
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Step 3: Fill employee information
        const employeeSelect = document.getElementById('employeeName');
        if (employeeSelect && employeeSelect.options.length > 1) {
            employeeSelect.value = employeeSelect.options[1].value;
            employeeSelect.dispatchEvent(new Event('change', { bubbles: true }));
            console.log('✓ Selected employee:', employeeSelect.options[1].text);
        } else {
            // Fill manually if dropdown not available
            const employeeName = document.getElementById('employeeName');
            const employeeEmail = document.getElementById('employeeEmail');
            const employeeType = document.getElementById('employeeType');
            const countryOfEmployee = document.getElementById('countryOfEmployee');
            
            if (employeeName && employeeName.tagName === 'INPUT') employeeName.value = 'John Doe';
            if (employeeEmail) employeeEmail.value = 'john.doe@example.com';
            if (employeeType) employeeType.value = 'Employee';
            if (countryOfEmployee) countryOfEmployee.value = 'Bangladesh';
            console.log('✓ Filled employee info (dummy)');
        }
        
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Step 4: Fill interaction details
        const interactionId = document.getElementById('interactionId');
        const interactionDate = document.getElementById('interactionDate');
        const channel = document.getElementById('channel');
        const clientEmail = document.getElementById('clientEmail');
        
        if (interactionId) {
            interactionId.value = 'INT-' + Date.now();
            console.log('✓ Filled interaction ID:', interactionId.value);
        }
        
        if (interactionDate) {
            const today = new Date();
            interactionDate.value = today.toISOString().split('T')[0];
            console.log('✓ Filled interaction date:', interactionDate.value);
        }
        
        if (channel) {
            if (channel.options && channel.options.length > 1) {
                channel.value = channel.options[1].value;
                channel.dispatchEvent(new Event('change', { bubbles: true }));
            } else {
                channel.value = 'FN Email';
            }
            console.log('✓ Selected channel:', channel.value);
        }
        
        if (clientEmail) {
            clientEmail.value = 'client@example.com';
            console.log('✓ Filled client email');
        }
        
        // Step 5: Fill transcript
        const transcript = document.getElementById('transcript');
        if (transcript) {
            transcript.value = `Customer: Hello, I need help with my account.
Agent: Hello! I'd be happy to help you with your account. Could you please provide me with your account number?
Customer: Sure, it's 123456789.
Agent: Thank you. I can see your account. How can I assist you today?
Customer: I want to update my email address.
Agent: I can help you with that. What is your new email address?
Customer: newemail@example.com
Agent: Perfect, I've updated your email address. Is there anything else I can help you with?
Customer: No, that's all. Thank you!
Agent: You're welcome! Have a great day!`;
            transcript.dispatchEvent(new Event('input', { bubbles: true }));
            console.log('✓ Filled transcript');
        }
        
        // Step 6: Fill audit type and validation status
        const auditType = document.getElementById('auditType');
        const validationStatus = document.getElementById('validationStatus');
        
        if (auditType) {
            auditType.value = 'Routine Audit (Recorded)';
            auditType.dispatchEvent(new Event('change', { bubbles: true }));
            console.log('✓ Selected audit type');
        }
        
        if (validationStatus) {
            validationStatus.value = 'Validated';
            console.log('✓ Selected validation status');
        }
        
        // Step 7: Fill error parameters
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const errorParametersContainer = document.getElementById('errorParametersContainer');
        if (errorParametersContainer) {
            const counterInputs = errorParametersContainer.querySelectorAll('input[type="number"]');
            const radioGroups = errorParametersContainer.querySelectorAll('input[type="radio"]');
            const feedbackInputs = errorParametersContainer.querySelectorAll('input[id^="feedback_"]');
            
            // Fill first 3 counters with random values (1-2)
            counterInputs.forEach((input, index) => {
                if (index < 3) {
                    input.value = Math.floor(Math.random() * 2) + 1;
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                    console.log(`✓ Filled counter ${input.id || input.name}: ${input.value}`);
                }
            });
            
            // Select some radio buttons
            let radioIndex = 0;
            radioGroups.forEach((radio) => {
                if (radioIndex < 2 && radio.value === '1') {
                    radio.checked = true;
                    radio.dispatchEvent(new Event('change', { bubbles: true }));
                    console.log(`✓ Selected radio ${radio.name}: ${radio.value}`);
                    radioIndex++;
                }
            });
            
            // Fill feedback fields
            feedbackInputs.forEach((input, index) => {
                if (index < 3 && (!input.value || input.value.trim() === '')) {
                    input.value = `Sample feedback for error parameter ${index + 1}. This is dummy data for testing purposes. Agent demonstrated good communication skills but needs improvement in handling customer requests.`;
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                    console.log(`✓ Filled feedback ${input.id || input.name}`);
                }
            });
        }
        
        // Wait for calculations to update
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // Step 9: Fill recommendations
        const recommendations = document.getElementById('recommendations');
        if (recommendations) {
            recommendations.value = `Recommendations for improvement:
1. Continue maintaining professional communication standards
2. Ensure all customer information is verified before making changes
3. Follow up with customers to ensure satisfaction

Next Steps:
- Review this audit with the employee
- Provide additional training if needed
- Schedule follow-up audit in next quarter`;
            recommendations.dispatchEvent(new Event('input', { bubbles: true }));
            console.log('✓ Filled recommendations');
        }
        
        // Step 10: Final wait and submit
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        console.log('=== Submitting form ===');
        const auditForm = document.getElementById('auditForm');
        if (auditForm) {
            // Trigger form validation and submission
            const submitBtn = auditForm.querySelector('button[type="submit"]');
            if (submitBtn) {
                submitBtn.click();
                console.log('✓ Form submission triggered!');
            } else {
                const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
                auditForm.dispatchEvent(submitEvent);
                console.log('✓ Form submitted via event!');
            }
            console.log('=== Dummy Audit Submission Complete ===');
        } else {
            console.error('Audit form not found');
        }
        
    } catch (error) {
        console.error('Error submitting dummy audit:', error);
        console.error('Stack:', error.stack);
    }
};

// ============================================================================
// URL Parameter Handling - Load assignment from URL
// ============================================================================
document.addEventListener('DOMContentLoaded', async function() {
    // Check for assignment parameter in URL
    const urlParams = new URLSearchParams(window.location.search);
    const assignmentId = urlParams.get('assignment');
    const fromConversation = urlParams.get('fromConversation');
    
    if (assignmentId) {
        // Load the assignment and start the audit
        await loadAssignmentFromURL(assignmentId);
    } else if (fromConversation === 'true') {
        // Load conversation data from sessionStorage
        const conversationDataStr = sessionStorage.getItem('pendingConversationData');
        if (conversationDataStr) {
            try {
                const conversationData = JSON.parse(conversationDataStr);
                sessionStorage.removeItem('pendingConversationData'); // Clean up
                
                // Pre-fill form with conversation data
                await loadConversationDataIntoForm(conversationData);
            } catch (error) {
                console.error('Error loading conversation data:', error);
            }
        }
    }
    
    // Show and start the timer when page loads
    const auditTimer = document.getElementById('auditTimer');
    if (auditTimer) {
        auditTimer.style.display = 'flex';
        // Attach event listeners when timer is shown
        if (window.attachTimerEventListeners) {
            window.attachTimerEventListeners();
        }
    }
    
    // Reset and start the timer
    if (window.resetTimer && window.startTimer) {
        window.resetTimer();
        window.startTimer();
    }
});

// Load conversation data into form (for starting audit from conversation)
// Store conversation ID globally for assignment linking
let pendingConversationId = null;

async function loadConversationDataIntoForm(conversationData) {
    const { conversation, adminInfo, adminEmail, conversation_id } = conversationData;
    
    // Store conversation ID for later use when creating/updating assignment
    pendingConversationId = conversation_id || conversation?.id || null;
    
    // Ensure employees are loaded
    await loadEmployees();
    
    // Pre-fill employee information
    const employeeSelect = document.getElementById('employeeName');
    let employeeFound = false;
    
    if (employeeSelect && adminEmail) {
        const normalizedEmail = adminEmail.toLowerCase().trim();
        for (let i = 0; i < employeeSelect.options.length; i++) {
            const optionEmail = (employeeSelect.options[i].dataset.email || '').toLowerCase().trim();
            if (optionEmail === normalizedEmail) {
                employeeSelect.selectedIndex = i;
                employeeSelect.dispatchEvent(new Event('change'));
                employeeFound = true;
                break;
            }
        }
    }
    
    if (!employeeFound && adminEmail) {
        await window.confirmationDialog.show({
            title: 'Employee Not Found',
            message: `Employee with email ${adminEmail} not found in the system. Please select the employee manually.`,
            confirmText: 'OK',
            type: 'warning'
        });
    }
    
    // Display Intercom alias if available
    const intercomAliasContainer = document.getElementById('intercomAliasContainer');
    const intercomAliasInput = document.getElementById('intercomAlias');
    if (adminInfo?.name && intercomAliasContainer && intercomAliasInput) {
        const selectedEmployeeName = employeeSelect?.options[employeeSelect.selectedIndex]?.textContent || '';
        if (adminInfo.name !== selectedEmployeeName) {
            intercomAliasInput.value = adminInfo.name;
            intercomAliasContainer.style.display = 'block';
        } else {
            intercomAliasContainer.style.display = 'none';
        }
    }
    
    // Pre-fill conversation ID
    const interactionIdField = document.getElementById('interactionId');
    if (interactionIdField && conversation.id) {
        interactionIdField.value = conversation.id;
        
        // Ensure chat view is shown
        const transcriptChatView = document.getElementById('transcriptChatView');
        const transcriptTextView = document.getElementById('transcriptTextView');
        if (transcriptChatView && transcriptTextView) {
            transcriptChatView.style.display = 'flex';
            transcriptTextView.style.display = 'none';
        }
        
        // Load the conversation
        setTimeout(async () => {
            if (window.loadConversationFromIntercom && typeof window.loadConversationFromIntercom === 'function') {
                await window.loadConversationFromIntercom(conversation.id);
            }
        }, 300);
    }
    
    // Pre-fill conversation date
    const interactionDateField = document.getElementById('interactionDate');
    if (interactionDateField && conversation.created_at) {
        const conversationDate = new Date(conversation.created_at * 1000);
        interactionDateField.value = conversationDate.toISOString().split('T')[0];
    }
    
    // Pre-fill client information
    const clientNameField = document.getElementById('clientName');
    const clientEmailField = document.getElementById('clientEmail');
    if (clientNameField && window.extractClientName) {
        clientNameField.value = window.extractClientName(conversation);
    }
    if (clientEmailField && window.extractClientEmail) {
        const clientEmail = window.extractClientEmail(conversation);
        if (clientEmail) {
            clientEmailField.value = clientEmail;
        }
    }
    
    // Auto-select scorecard based on channel (if channel was set from employee selection)
    const scorecardSelect = document.getElementById('scorecardSelect');
    const channelSelect = document.getElementById('channel');
    if (scorecardSelect) {
        // Wait a bit for employee change event to set the channel
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // If channel is selected, load scorecards filtered by channel (will auto-select default)
        if (channelSelect && channelSelect.value) {
            await autoSelectScorecardByChannel(channelSelect.value);
        } else {
            // Otherwise, just load all scorecards
            await loadScorecards();
        }
    }
}
</script>

    <!-- Image Viewer Modal -->
    <div id="imageViewerModal" tabindex="0" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 10000; align-items: center; justify-content: center; cursor: pointer;" onclick="if(event.target.id === 'imageViewerModal') window.closeImageViewer();" onkeydown="if(event.key === 'Escape') window.closeImageViewer(); if(event.key === 'ArrowLeft') window.navigateImage('prev'); if(event.key === 'ArrowRight') window.navigateImage('next');">
        <!-- Close Button -->
        <button id="imageViewerClose" onclick="window.closeImageViewer(); event.stopPropagation();" style="position: absolute; top: 1rem; right: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 2.5rem; height: 2.5rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Close (Esc)">
            ✕
        </button>
        
        <!-- Previous Button -->
        <button id="imageViewerPrev" onclick="window.navigateImage('prev'); event.stopPropagation();" style="position: absolute; left: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 3rem; height: 3rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Previous (â†)">
            â€¹
        </button>
        
        <!-- Next Button -->
        <button id="imageViewerNext" onclick="window.navigateImage('next'); event.stopPropagation();" style="position: absolute; right: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 3rem; height: 3rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Next (â†’)">
            â€º
        </button>
        
        <!-- Image Counter -->
        <div id="imageViewerCounter" style="position: absolute; bottom: 1rem; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); color: white; padding: 0.5rem 1rem; border-radius: 1.5rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; z-index: 10001;">
            1 / 1
        </div>
        
        <!-- Image Container -->
        <div style="max-width: 95%; max-height: 95%; display: flex; align-items: center; justify-content: center;" onclick="event.stopPropagation();">
            <img id="imageViewerImg" src="" alt="Conversation image" style="max-width: 100%; max-height: 90vh; object-fit: contain; border-radius: 0.5rem; box-shadow: 0 0.5rem 2rem rgba(0,0,0,0.5);">
        </div>
    </div>

</body>
</html>
</body></html>
