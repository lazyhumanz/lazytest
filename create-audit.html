<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Create Audit | QMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <style>
        /* Prevent horizontal overflow */
        .main-content {
            overflow-x: hidden;
            max-width: calc(100vw - var(--sidebar-collapsed)) !important;
            box-sizing: border-box;
            width: 100%;
        }
        
        .sidebar:not(.collapsed) ~ .main-content {
            max-width: calc(100vw - var(--sidebar-width)) !important;
        }
        
        .main-content > * {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        #pullConversationsSection {
            max-width: 100%;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        
        .copy-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.25rem;
            background: transparent;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            color: #6b7280;
            transition: all 0.2s;
        }
        .copy-button:hover {
            background-color: #f3f4f6;
            color: #374151;
        }
        .copy-button:active {
            transform: scale(0.95);
        }
        .copy-button svg {
            width: 0.875rem;
            height: 0.875rem;
        }
        .copy-success {
            color: #10b981 !important;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-1.25rem) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes modalSlideOut {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-1.25rem) scale(0.95);
            }
        }
        
        /* Shimmer effect for loading states */
        .shimmer-text {
            position: relative;
            overflow: hidden;
        }

        .shimmer-text::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.4),
                transparent
            );
            animation: shimmer 2s infinite;
        }

        .shimmer-overlay {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        /* Parts tooltip hover effect */
        .parts-tooltip-container:hover .parts-info-icon {
            background: #9ca3af !important;
        }

        /* Ensure tooltip positioning works correctly */
        .parts-tooltip-container,
        .column-tooltip-container {
            overflow: visible !important;
        }

        /* Column tooltip hover effect */
        .column-tooltip-container:hover .info-icon {
            background: #9ca3af !important;
        }

        .run-ai-audit-btn {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            color: #1A733E;
            border: 0.0304rem solid #1A733E;
            padding: 0.2425rem 0.4852rem;
            border-radius: 0.1617rem;
            font-size: 0.4447rem;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.2425rem;
            white-space: nowrap;
            box-shadow: 0 0.0405rem 0.0808rem rgba(26, 115, 62, 0.1);
        }

        .run-ai-audit-btn:hover {
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            border-color: #15582E;
            color: #15582E;
            box-shadow: 0 0.0808rem 0.1617rem rgba(26, 115, 62, 0.15);
            transform: translateY(-0.0203rem);
        }

        .run-ai-audit-btn:active {
            transform: translateY(0);
            box-shadow: 0 0.0203rem 0.0405rem rgba(26, 115, 62, 0.1);
        }

        /* Coming Soon Modal */
        #comingSoonModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        #comingSoonModalContent {
            background: white;
            border-radius: 0.6469rem;
            padding: 1.9406rem;
            max-width: 25.875rem;
            width: 90%;
            box-shadow: 0 0.8086rem 2.4258rem rgba(0, 0, 0, 0.15);
            animation: modalSlideIn 0.3s ease-out;
            text-align: center;
        }

    </style>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="access-control.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="load-sidebar.js"></script>
    <script src="search.js"></script>
    <script src="form-validation.js"></script>
    <script src="intercom-config.js"></script>
    <script src="audit-template.js"></script>
    <script src="keyboard-shortcuts.js"></script>
</head>

<body style="margin: 0; padding: 0;">
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
 <main class="main-content" role="main">
    <p class="page-heading" style="margin-bottom: 1.5rem;">Create Audit</p>
    <div style="margin-bottom: 0.9704rem; width: 100%;"></div>

<!-- Audit Timer Chip -->
<div id="auditTimer" style="position: fixed; top: 0.6469rem; right: 3.2344rem; background:var(--primary-color); padding: 0.1294rem 0.3234rem 0.1294rem 0.1294rem; border-radius: 2.0215rem; font-size: 0.6064rem; font-weight: 600; color: #ffffff; font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; letter-spacing: 0.0122rem; flex-shrink: 0; white-space: nowrap; font-variant-numeric: tabular-nums; min-width: 4.8516rem; display: none; align-items: center; gap: 0.3234rem; cursor: grab; user-select: none; z-index: 10001;">
    <button id="timerControlBtn" title="Play/Pause/Reset Timer" style="width: 1.1321rem; height: 1.1321rem; background: rgba(255, 255, 255, 0.2); border: none; border-radius: 50%; color: #ffffff; cursor: pointer; display: flex; align-items: center; justify-content: center; user-select: none; flex-shrink: 0; margin: 0; padding: 0;">
        <svg style="width: 0.5659rem; height: 0.5659rem;" viewBox="0 0 24 24" fill="currentColor">
            <path d="M8 5v14l11-7z"/>
        </svg>
    </button>
    <span style="flex: 1; text-align: center; font-size: 0.6064rem; font-weight: 600; font-variant-numeric: tabular-nums;">Time Keeper</span>
</div>
<!-- End of Audit Timer Chip -->

    <!-- Your Stats Section -->
    <div id="yourStatsSection" style="background: #ffffff; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0405rem solid #e5e7eb; margin-bottom: 0.9704rem; margin-top: 2rem; width: 100%;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.6469rem; padding-bottom: 0.3234rem; border-bottom: 0.0405rem solid #1A733E;">
            <h3 style="font-size: 0.5659rem; font-weight: 600; color: #1A733E; margin: 0; text-transform: uppercase; letter-spacing: 0.0122rem; display: flex; align-items: center; gap: 0.3234rem;">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
                </svg>
                Your Progress
            </h3>
        </div>
        
        <!-- Stats Cards -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(6.4687rem, 1fr)); gap: 0.6469rem; margin-bottom: 0.6469rem;">
            <div style="background-color: #1A733E; color: #ffffff; padding: 0.4852rem; border-radius: 0.3234rem; text-align: left; box-shadow: 0 0.0808rem 0.1617rem rgba(0, 0, 0, 0.1); min-height: 3.2344rem; display: flex; flex-direction: column; justify-content: center;">
                <div style="font-size: 0.4852rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0808rem; opacity: 0.9;">Assigned</div>
                <div id="statsAssignedCount" style="font-size: 1.6171rem; font-weight: 700; margin-bottom: 0.1617rem;">-</div>
            </div>
            <div style="background-color: #1A733E; color: #ffffff; padding: 0.4852rem; border-radius: 0.3234rem; text-align: left; box-shadow: 0 0.0808rem 0.1617rem rgba(0, 0, 0, 0.1); min-height: 3.2344rem; display: flex; flex-direction: column; justify-content: center;">
                <div style="font-size: 0.4852rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0808rem; opacity: 0.9;">Completed</div>
                <div id="statsCompletedCount" style="font-size: 1.6171rem; font-weight: 700; margin-bottom: 0.1617rem;">-</div>
                <div id="statsTargetAchieved" style="font-size: 0.4447rem; opacity: 0.9; margin-top: 0.0808rem;">-</div>
            </div>
            <div style="background-color: #1A733E; color: #ffffff; padding: 0.4852rem; border-radius: 0.3234rem; text-align: left; box-shadow: 0 0.0808rem 0.1617rem rgba(0, 0, 0, 0.1); min-height: 3.2344rem; display: flex; flex-direction: column; justify-content: center;">
                <div style="font-size: 0.4852rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0808rem; opacity: 0.9;">Remaining</div>
                <div id="statsRemainingCount" style="font-size: 1.6171rem; font-weight: 700; margin-bottom: 0.1617rem;">-</div>
            </div>
            <div style="background-color: #1A733E; color: #ffffff; padding: 0.4852rem; border-radius: 0.3234rem; text-align: left; box-shadow: 0 0.0808rem 0.1617rem rgba(0, 0, 0, 0.1); min-height: 3.2344rem; display: flex; flex-direction: column; justify-content: center;">
                <div style="font-size: 0.4852rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0808rem; opacity: 0.9;">In Progress</div>
                <div id="statsInProgressCount" style="font-size: 1.6171rem; font-weight: 700; margin-bottom: 0.1617rem;">-</div>
                <div id="statsDaysRemaining" style="font-size: 0.4447rem; opacity: 0.9; margin-top: 0.0808rem;">-</div>
            </div>
            <div style="background-color: #1A733E; color: #ffffff; padding: 0.4852rem; border-radius: 0.3234rem; text-align: left; box-shadow: 0 0.0808rem 0.1617rem rgba(0, 0, 0, 0.1); min-height: 3.2344rem; display: flex; flex-direction: column; justify-content: center;">
                <div style="font-size: 0.4852rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0808rem; opacity: 0.9;">Reversal Rate</div>
                <div id="statsReversalCount" style="font-size: 1.6171rem; font-weight: 700; margin-bottom: 0.1617rem;">-</div>
            </div>
            <div style="background-color: #1A733E; color: #ffffff; padding: 0.4852rem; border-radius: 0.3234rem; text-align: left; box-shadow: 0 0.0808rem 0.1617rem rgba(0, 0, 0, 0.1); min-height: 3.2344rem; display: flex; flex-direction: column; justify-content: center;">
                <div style="font-size: 0.4852rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0808rem; opacity: 0.9;">Avg Duration</div>
                <div id="statsAvgDuration" style="font-size: 1.2937rem; font-weight: 700; margin-bottom: 0.1617rem;">-</div>
                <div id="statsAvgDurationSubtitle" style="font-size: 0.4447rem; opacity: 0.9; margin-top: 0.0808rem;">per audit</div>
            </div>
        </div>
    </div>

    <!-- Pending Audits Section -->
    <div id="pendingAuditsSection" style="background: #ffffff; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0405rem solid #e5e7eb; margin-bottom: 0.6469rem; width: 100%; display: block;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.4852rem; padding-bottom: 0.3234rem; border-bottom: 0.0405rem solid #1A733E;">
            <h3 style="font-size: 0.5659rem; font-weight: 600; color: #1A733E; margin: 0; text-transform: uppercase; letter-spacing: 0.0122rem; display: flex; align-items: center; gap: 0.3234rem;">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 11l3 3L22 4"/>
                    <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
                </svg>
                <span id="auditsViewTitle">My Assigned Audits</span>
                <span id="pendingCount" style="background-color: #1A733E; color: white; padding: 0.0808rem 0.3234rem; border-radius: 0.1617rem; font-size: 0.4852rem; font-weight: 600; min-width: 0.9704rem; text-align: center;">0</span>
                <div style="display: flex; align-items: center; gap: 0.1617rem;">
                    <div style="position: relative; display: inline-block;">
                        <button id="sortIconBtn" onclick="toggleSortMenu()" style="background: none; border: none; padding: 0.1617rem; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #1A733E; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="Sort audits">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M7 12h10M11 18h2"/>
                            </svg>
                        </button>
                        <div id="sortMenu" style="display: none; position: absolute; top: 100%; left: 0; margin-top: 0.1617rem; background: white; border: 0.0405rem solid #e5e7eb; border-radius: 0.2425rem; box-shadow: 0 0.1617rem 0.3234rem rgba(0,0,0,0.1); z-index: 1000; min-width: 7.7625rem; padding: 0.3234rem 0;">
                            <select id="auditSortBy" onchange="sortPendingAudits(); toggleSortMenu();" style="width: 100%; padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem;">
                                <option value="name_asc">Name (A-Z)</option>
                                <option value="name_desc">Name (Z-A)</option>
                                <option value="status_asc">Status (Pending → In Progress)</option>
                                <option value="status_desc">Status (In Progress → Pending)</option>
                                <option value="priority_asc">Priority (Low → High)</option>
                                <option value="priority_desc">Priority (High → Low)</option>
                            </select>
                        </div>
                    </div>
                    <button id="showFiltersBtn" onclick="toggleFilters()" style="background: none; border: none; padding: 0.1617rem; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #1A733E; opacity: 0.7; transition: opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'" title="Show/Hide Filters">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"/>
                        </svg>
                    </button>
                </div>
            </h3>
            <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                <button id="createManualAuditBtn" onclick="createManualAudit()" style="padding: 0.2425rem 0.4852rem; background-color: #1A733E; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; display: flex; align-items: center; gap: 0.2425rem;" onmouseover="this.style.backgroundColor='#15582E'" onmouseout="this.style.backgroundColor='#1A733E'">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    <span>Create Manual Audit</span>
                </button>
                <button id="toggleAllAuditsBtn" onclick="toggleAllAuditsView()" style="padding: 0.2425rem 0.4852rem; background-color: #f9fafb; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; display: flex; align-items: center; gap: 0.2425rem;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span id="toggleBtnText">Show Completed audits</span>
                </button>
            </div>
        </div>
        
        <!-- Filters Section -->
        <div id="filtersSection" style="display: none; background: #f9fafb; border: 0.0405rem solid #e5e7eb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(10rem, 1fr)); gap: 0.6469rem; margin-bottom: 0.6469rem;">
                <!-- Date Range Filter -->
                <div class="filter-group" style="display: flex; flex-direction: column; gap: 0.2425rem;">
                    <label class="filter-label" style="font-size: 0.4852rem; font-weight: 600; color: #6b7280;">Start Date</label>
                    <input type="date" id="filterStartDate" class="filter-input" onchange="applyFilters()" style="padding: 0.2425rem 0.3234rem; border: 0.0405rem solid #e5e7eb; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background-color: white; color: #374151;">
                </div>
                <div class="filter-group" style="display: flex; flex-direction: column; gap: 0.2425rem;">
                    <label class="filter-label" style="font-size: 0.4852rem; font-weight: 600; color: #6b7280;">End Date</label>
                    <input type="date" id="filterEndDate" class="filter-input" onchange="applyFilters()" style="padding: 0.2425rem 0.3234rem; border: 0.0405rem solid #e5e7eb; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background-color: white; color: #374151;">
                </div>
                <!-- Status Filter -->
                <div class="filter-group" style="display: flex; flex-direction: column; gap: 0.2425rem;">
                    <label class="filter-label" style="font-size: 0.4852rem; font-weight: 600; color: #6b7280;">Status</label>
                    <select id="filterStatus" class="filter-select" onchange="applyFilters()" style="padding: 0.2425rem 0.3234rem; border: 0.0405rem solid #e5e7eb; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background-color: white; color: #374151; cursor: pointer;">
                        <option value="">All Statuses</option>
                        <option value="pending">Pending</option>
                        <option value="in_progress">In Progress</option>
                        <option value="completed">Completed</option>
                    </select>
                </div>
                <!-- Scorecard Filter -->
                <div class="filter-group" style="display: flex; flex-direction: column; gap: 0.2425rem;">
                    <label class="filter-label" style="font-size: 0.4852rem; font-weight: 600; color: #6b7280;">Scorecard</label>
                    <select id="filterScorecard" class="filter-select" onchange="applyFilters()" style="padding: 0.2425rem 0.3234rem; border: 0.0405rem solid #e5e7eb; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background-color: white; color: #374151; cursor: pointer;">
                        <option value="">All Scorecards</option>
                    </select>
                </div>
                <!-- Search Filter -->
                <div class="filter-group" style="display: flex; flex-direction: column; gap: 0.2425rem;">
                    <label class="filter-label" style="font-size: 0.4852rem; font-weight: 600; color: #6b7280;">Search</label>
                    <input type="text" id="filterSearch" class="filter-input" placeholder="Search by name..." style="padding: 0.2425rem 0.3234rem; border: 0.0405rem solid #e5e7eb; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background-color: white; color: #374151;">
                </div>
            </div>
            <div style="display: flex; gap: 0.3234rem; align-items: center; justify-content: flex-end;">
                <button onclick="clearFilters()" style="padding: 0.2425rem 0.4852rem; background-color: #f9fafb; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s ease;" onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='#f9fafb'">
                    Clear
                </button>
            </div>
        </div>
        
        <div id="pendingAuditsList" style="display: flex; flex-direction: column; gap: 0.3234rem;">
            <div style="text-align: center; padding: 1.9406rem 0.9704rem; color: #6b7280;">
                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin: 0 auto 0.6469rem; opacity: 0.4;">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="12" y1="18" x2="12" y2="12"/>
                    <line x1="9" y1="15" x2="15" y2="15"/>
                </svg>
                <p style="font-size: 0.5659rem; font-weight: 500; color: #374151; margin: 0 0 0.3234rem;">No audits have been assigned to you yet.</p>
                <p style="font-size: 0.4852rem; color: #9ca3af; margin: 0;">Audits will appear here once they are assigned to you.</p>
            </div>
        </div>
        
        <!-- Pagination Controls -->
        <div id="pendingAuditsPagination" style="display: none; margin-top: 0.6469rem; padding-top: 0.6469rem; border-top: 0.0405rem solid #e5e7eb;">
            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.6469rem;">
                <div style="display: flex; align-items: center; gap: 0.3234rem; font-size: 0.5659rem; color: #374151; font-family: 'Poppins', sans-serif;">
                    <span id="pendingPaginationInfo">Page 1 of 1</span>
                </div>
                <div style="display: flex; align-items: center; gap: 0.3234rem;">
                    <button id="pendingFirstPageBtn" onclick="goToPendingPage(1)" disabled style="padding: 0.3234rem 0.4852rem; background-color: #ffffff; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.1617rem;" title="First Page">
                        <svg style="width: 0.6469rem; height: 0.6469rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="11 17 6 12 11 7"></polyline>
                            <polyline points="18 17 13 12 18 7"></polyline>
                        </svg>
                    </button>
                    <button id="pendingPrevPageBtn" onclick="goToPendingPreviousPage()" disabled style="padding: 0.3234rem 0.4852rem; background-color: #ffffff; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.1617rem;" title="Previous Page">
                        <svg style="width: 0.6469rem; height: 0.6469rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="15 18 9 12 15 6"></polyline>
                        </svg>
                        <span>Previous</span>
                    </button>
                    <div id="pendingPageNumbers" style="display: flex; align-items: center; gap: 0.1617rem;">
                        <!-- Page numbers will be dynamically generated here -->
                    </div>
                    <button id="pendingNextPageBtn" onclick="goToPendingNextPage()" disabled style="padding: 0.3234rem 0.4852rem; background-color: #ffffff; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.1617rem;" title="Next Page">
                        <span>Next</span>
                        <svg style="width: 0.6469rem; height: 0.6469rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                    </button>
                    <button id="pendingLastPageBtn" onclick="goToPendingLastPage()" disabled style="padding: 0.3234rem 0.4852rem; background-color: #ffffff; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.1617rem;" title="Last Page">
                        <svg style="width: 0.6469rem; height: 0.6469rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="13 17 18 12 13 7"></polyline>
                            <polyline points="6 17 11 12 6 7"></polyline>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Pull Conversations from Intercom Section -->
    <div id="pullConversationsSection" style="display: none; background: #ffffff; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0405rem solid #d1fae5; margin-top: 0.6469rem; margin-bottom: 0.6469rem; width: 100%;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.6469rem; flex-wrap: wrap; gap: 0.6469rem;">
            <div style="display: flex; align-items: center; gap: 0.6469rem; flex-wrap: wrap; flex: 1;">
            <h3 id="pullConversationsHeader" style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
                <span>Conversations of</span>
                <span id="pullConversationsEmployeeName" style="color: #374151; font-weight: 500;"></span>
                <span id="pullConversationsAdminAliasChip" style="display: none;"></span>
            </h3>
                <div style="display: flex; align-items: center; gap: 0.3234rem;">
                    <button id="dateRangeBtnYesterday" data-is-active="true" onclick="selectDateRange('yesterday')" style="padding: 0.2425rem 0.4043rem; background: #1A733E; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s; white-space: nowrap;" onmouseover="if(this.dataset.isActive === 'true') this.style.backgroundColor='#15582E'; else this.style.backgroundColor='#e5e7eb'" onmouseout="if(this.dataset.isActive === 'true') this.style.backgroundColor='#1A733E'; else this.style.backgroundColor='#f3f4f6'" title="Yesterday (Default)">
                        Yesterday
                    </button>
                    <button id="dateRangeBtnLast3Days" data-is-active="false" onclick="selectDateRange('last3days')" style="padding: 0.2425rem 0.4043rem; background: #f3f4f6; color: #374151; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s; white-space: nowrap;" onmouseover="if(this.dataset.isActive === 'true') this.style.backgroundColor='#15582E'; else this.style.backgroundColor='#e5e7eb'" onmouseout="if(this.dataset.isActive === 'true') this.style.backgroundColor='#1A733E'; else this.style.backgroundColor='#f3f4f6'" title="Last 3 Days">
                        Last 3 days
                    </button>
                    <button id="dateRangeBtnThisWeek" data-is-active="false" onclick="selectDateRange('thisweek')" style="padding: 0.2425rem 0.4043rem; background: #f3f4f6; color: #374151; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s; white-space: nowrap;" onmouseover="if(this.dataset.isActive === 'true') this.style.backgroundColor='#15582E'; else this.style.backgroundColor='#e5e7eb'" onmouseout="if(this.dataset.isActive === 'true') this.style.backgroundColor='#1A733E'; else this.style.backgroundColor='#f3f4f6'" title="This Week">
                        This week
            </button>
                    </div>
                    <button onclick="openPullConversationsFilterDialog()" style="display: flex; align-items: center; gap: 0.2425rem; padding: 0.2425rem 0.4852rem; background: #1A733E; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#15582E'" onmouseout="this.style.backgroundColor='#1A733E'" title="Advanced Filters">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"/>
                        </svg>
                        <span>Filters</span>
                        <span id="pullConversationsActiveFiltersCount" style="background: rgba(255,255,255,0.3); padding: 0.0808rem 0.2425rem; border-radius: 0.0808rem; font-size: 0.4043rem; font-weight: 600; display: none;">0</span>
                    </button>
                </div>
            <div style="display: flex; align-items: center; gap: 0.6469rem; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 0.3234rem;">
                    <span style="font-size: 0.4852rem; color: #6b7280;">Conversations:</span>
                    <span id="pullConversationsCount" style="font-size: 0.5659rem; font-weight: 600; color: #1A733E;">0</span>
                    <span id="pullConversationsAdminName" style="font-size: 0.4852rem; color: #6b7280; margin-left: 0.3234rem; font-weight: 500;"></span>
                </div>
                <button onclick="closePullConversationsSection()" style="background: #f3f4f6; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; padding: 0.2425rem 0.4852rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; color: #374151; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                    Close
                </button>
            </div>
        </div>
        
        <!-- Active Filters Display -->
        <div id="pullConversationsActiveFilters" style="display: none; background: #eff6ff; border: 0.0304rem solid #bfdbfe; border-radius: 0.3234rem; padding: 0.4852rem 0.6469rem; margin-bottom: 0.6469rem;">
            <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                <span style="font-size: 0.4447rem; font-weight: 600; color: #1e40af;">Active Filters:</span>
                <div id="pullConversationsActiveFiltersTags" style="display: flex; gap: 0.2425rem; flex-wrap: wrap;"></div>
                <button onclick="clearPullConversationsFilters()" style="margin-left: auto; padding: 0.1617rem 0.3234rem; background: #dc2626; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4447rem; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#b91c1c'" onmouseout="this.style.backgroundColor='#dc2626'">Clear All</button>
            </div>
        </div>
        
        <!-- Loading State with Progress Indicator -->
        <div id="pullConversationsLoading" style="display: none; text-align: center; padding: 1.9406rem; color: #6b7280;">
            <div style="max-width: 28rem; margin: 0 auto;">
                <div class="shimmer-text" style="margin-bottom: 0.6469rem;">
                    <p id="pullConversationsStatus" style="font-size: 0.5659rem; margin: 0; color: #374151; font-weight: 500;">Pulling from Intercom...</p>
                </div>
                <div style="width: 100%; background: #e5e7eb; border-radius: 0.125rem; height: 0.4043rem; margin-bottom: 0.3234rem; overflow: hidden; position: relative;">
                    <div id="pullConversationsProgressBar" style="background: #1A733E; height: 0.4043rem; border-radius: 0.125rem; transition: width 0.3s ease-out; width: 0%; position: relative;">
                        <div class="shimmer-overlay"></div>
                    </div>
                </div>
                <div class="shimmer-text">
                    <p id="pullConversationsProgress" style="font-size: 0.4447rem; color: #6b7280; margin-top: 0.3234rem; margin: 0;"></p>
                </div>
            </div>
        </div>
        
        <!-- Error State -->
        <div id="pullConversationsError" style="display: none; background: #fee2e2; color: #991b1b; padding: 0.6469rem; border-radius: 0.3234rem; margin-bottom: 0.6469rem; font-size: 0.4852rem;">
            <strong>Error:</strong> <span id="pullConversationsErrorMessage"></span>
        </div>
        
        <!-- Conversations List -->
        <div id="pullConversationsList" style="display: none;">
            <div style="background: white; border-radius: 0 0 0.3234rem 0.3234rem; border: 0.0304rem solid #e5e7eb; border-top: none; max-height: 60vh; overflow-x: auto; overflow-y: auto; position: relative;">
                <table style="width: 100%; border-collapse: collapse; min-width: fit-content; font-size: 0.6069rem;">
                    <thead style="position: sticky; top: 0; z-index: 10; background: #f9fafb; overflow: visible;">
                        <tr style="background: #f9fafb; border-bottom: 0.0625rem solid #e5e7eb;">
                            <th style="padding: 0.25rem 0.375rem; text-align: center; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; width: 3rem;">
                                <input type="checkbox" id="selectAllPullConversations" style="cursor: pointer;" title="Select all conversations">
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; gap: 0.125rem; position: relative;">
                                    <span>Client</span>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">Client</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">The customer's name and email address who initiated the conversation.</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Example:</div>
                                                <p style="margin: 0; color: #9ca3af;">John Doe<br><span style="color: #9ca3af; font-size: 0.6875rem;">john.doe@example.com</span></p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; gap: 0.125rem; position: relative;">
                                    <span>ID</span>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">Conversation ID</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">Unique identifier for the conversation in Intercom. Click the copy icon to copy the full ID.</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Example:</div>
                                                <p style="margin: 0; color: #9ca3af; font-family: monospace; font-size: 0.6875rem;">215471675148327</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; gap: 0.125rem; position: relative;">
                                    <span>Subject</span>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">Subject</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">The subject line or first line of the conversation message from the customer.</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Example:</div>
                                                <p style="margin: 0; color: #9ca3af;">"CFD / Forex" or "Account balance issue"</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: center; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; justify-content: center; gap: 0.125rem; position: relative;">
                                    <span>Rating</span>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">Rating</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">Customer satisfaction rating given after the conversation (1-5 scale).</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Examples:</div>
                                                <p style="margin: 0; color: #9ca3af;"><span style="color: #10b981;">5/5</span> (Excellent), <span style="color: #f59e0b;">3/5</span> (Average), <span style="color: #ef4444;">1/5</span> (Poor)</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: center; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; justify-content: center; gap: 0.125rem; position: relative;">
                                    <span>CX Score</span>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">CX Score</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">Customer experience score rating from custom attributes (1-5 scale).</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Examples:</div>
                                                <p style="margin: 0; color: #9ca3af;"><span style="color: #10b981;">5</span> (Excellent), <span style="color: #f59e0b;">3</span> (Average), <span style="color: #ef4444;">1</span> (Poor)</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: center; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; justify-content: center; gap: 0.125rem; position: relative;">
                                    <span>Length</span>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">Conversation Length</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">Total number of conversation parts (messages) in the conversation.</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Example:</div>
                                                <p style="margin: 0; color: #9ca3af;">A conversation with 15 messages will show <span style="color: white; font-weight: 600;">15</span></p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: center; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; justify-content: center; gap: 0.125rem; position: relative;">
                                    <span>Status</span>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">Conversation Status</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">Current state of the conversation in Intercom.</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Examples:</div>
                                                <p style="margin: 0; color: #9ca3af;"><span style="color: #10b981;">closed</span> (Resolved), <span style="color: #f59e0b;">open</span> (Active), <span style="color: #6b7280;">snoozed</span> (Paused)</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: center; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; justify-content: center; gap: 0.125rem; position: relative;">
                                    <svg style="width: 0.75rem; height: 0.75rem; color: #dc2626;" fill="currentColor" viewBox="0 0 24 24">
                                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                                    </svg>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">Priority</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">Whether the conversation has been marked as high priority by the team.</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Example:</div>
                                                <p style="margin: 0; color: #9ca3af;">Priority icon shows when conversation is marked as <span style="color: white; font-weight: 600;">priority</span>, otherwise shows "-"</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; gap: 0.125rem; position: relative;">
                                    <span>Tags</span>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">Tags</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">Labels or categories applied to the conversation for organization and filtering. Shows first 2 tags, with count of additional tags.</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Example:</div>
                                                <p style="margin: 0; color: #9ca3af;">"GS CFD FIN Chats", "Lingpad" <span style="color: #6b7280;">+2</span> (shows 2 more tags on hover)</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: center; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; justify-content: center; gap: 0.125rem; position: relative;">
                                    <span>Created</span>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">Created Date</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">Date and time when the conversation was first created by the customer. Displayed in compact format (month day).</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Example:</div>
                                                <p style="margin: 0; color: #9ca3af;">"Nov 4" (hover to see full date: Nov 4, 2025, 10:30 AM)</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: center; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em; overflow: visible;">
                                <div class="column-tooltip-container" style="display: flex; align-items: center; justify-content: center; gap: 0.125rem; position: relative;">
                                    <span>Updated</span>
                                    <div class="info-icon" style="display: flex; align-items: center; justify-content: center; cursor: help; transition: opacity 0.2s;">
                                        <svg xmlns="http://www.w3.org/2000/svg" style="width: 0.5rem; height: 0.5rem; color: #4b5563;" viewBox="0 -960 960 960" fill="currentColor">
                                            <path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/>
                                        </svg>
                                    </div>
                                    <div class="column-tooltip" style="position: fixed; width: 20rem; background: #1f2937; color: white; font-size: 0.75rem; padding: 0.75rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 9999; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s; pointer-events: none; text-align: left; font-weight: normal; text-transform: none; letter-spacing: normal; white-space: normal; word-wrap: break-word; max-width: 20rem;">
                                        <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8125rem;">Updated Date</div>
                                        <div style="color: #d1d5db; line-height: 1.5;">
                                            <p style="margin: 0 0 0.5rem 0;">Date and time when the conversation was last updated (new message, status change, etc.). Displayed in compact format (month day).</p>
                                            <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #374151;">
                                                <div style="font-weight: 500; margin-bottom: 0.25rem;">Example:</div>
                                                <p style="margin: 0; color: #9ca3af;">"Nov 5" (hover to see full date: Nov 5, 2025, 3:45 PM)</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </th>
                            <th style="padding: 0.25rem 0.375rem; text-align: center; font-weight: 600; color: #374151; font-size: 0.6069rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">Action</th>
                        </tr>
                    </thead>
                    <tbody id="pullConversationsTableBody">
                        <!-- Rows will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Pull Conversations Filter Modal -->
    <div id="pullConversationsFilterModal" onclick="if(event.target === this) closePullConversationsFilterDialog();" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 10000; align-items: center; justify-content: center; padding: 1.2937rem;">
        <div onclick="event.stopPropagation();" style="background: white; border-radius: 0.6469rem; max-width: 48rem; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 0.8086rem 2.4258rem rgba(0, 0, 0, 0.15);">
            <div style="position: sticky; top: 0; background: white; border-bottom: 0.0625rem solid #e5e7eb; padding: 1.2937rem; display: flex; justify-content: space-between; align-items: center; z-index: 1;">
                <h2 style="font-size: 0.8086rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif;">Advanced Filters</h2>
                <button onclick="closePullConversationsFilterDialog()" style="background: #f3f4f6; border: none; border-radius: 50%; width: 1.9406rem; height: 1.9406rem; display: flex; align-items: center; justify-content: center; cursor: pointer; color: #6b7280; font-size: 1.2937rem; line-height: 1; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">×</button>
            </div>
            <form id="pullConversationsFilterForm" onsubmit="event.preventDefault(); applyPullConversationsFilters();" style="padding: 1.2937rem;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(12rem, 1fr)); gap: 1.2937rem;">
                    <!-- State Filter -->
                    <div>
                        <label style="display: block; font-size: 0.5659rem; font-weight: 600; color: #374151; margin-bottom: 0.3234rem;">State</label>
                        <select id="pullFilterState" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151; cursor: pointer;">
                            <option value="">All States</option>
                            <option value="open">Open</option>
                            <option value="closed">Closed</option>
                        </select>
                    </div>
                    
                    <!-- Priority Filter -->
                    <div>
                        <label style="display: block; font-size: 0.5659rem; font-weight: 600; color: #374151; margin-bottom: 0.3234rem;">Priority</label>
                        <select id="pullFilterPriority" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151; cursor: pointer;">
                            <option value="">All Priorities</option>
                            <option value="priority">Priority</option>
                            <option value="not_priority">Not Priority</option>
                        </select>
                    </div>
                    
                    <!-- Rating Filter -->
                    <div>
                        <label style="display: block; font-size: 0.5659rem; font-weight: 600; color: #374151; margin-bottom: 0.3234rem;">Rating</label>
                        <select id="pullFilterRatingType" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151; cursor: pointer; margin-bottom: 0.3234rem;">
                            <option value="">All Ratings</option>
                            <option value="hasRating">Has Rating (Any Star)</option>
                            <option value="unrated">Unrated</option>
                            <option value="exact">Exact Rating</option>
                            <option value="range">Rating Range</option>
                        </select>
                        
                        <!-- Exact Rating Input (shown when "exact" is selected) -->
                        <select id="pullFilterRatingExact" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151; cursor: pointer; display: none; margin-bottom: 0.3234rem;">
                            <option value="">Select Rating</option>
                            <option value="5">5 Stars</option>
                            <option value="4">4 Stars</option>
                            <option value="3">3 Stars</option>
                            <option value="2">2 Stars</option>
                            <option value="1">1 Star</option>
                        </select>
                        
                        <!-- Range Inputs (shown when "range" is selected) -->
                        <div id="pullFilterRatingRange" style="display: none; flex-direction: column; gap: 0.3234rem; margin-bottom: 0.3234rem;">
                            <div style="display: flex; gap: 0.3234rem; align-items: center;">
                                <label style="font-size: 0.4043rem; color: #6b7280; white-space: nowrap;">Min:</label>
                                <input type="number" id="pullFilterRatingMin" min="1" max="5" placeholder="1" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151;">
                    </div>
                            <div style="display: flex; gap: 0.3234rem; align-items: center;">
                                <label style="font-size: 0.4043rem; color: #6b7280; white-space: nowrap;">Max:</label>
                                <input type="number" id="pullFilterRatingMax" min="1" max="5" placeholder="5" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151;">
                    </div>
                    </div>
                        <div id="pullFilterRatingRangeError" style="display: none; color: #ef4444; font-size: 0.4043rem; margin-top: 0.1617rem;"></div>
                    </div>
                    
                    <!-- CX Score Filter -->
                    <div>
                        <label style="display: block; font-size: 0.5659rem; font-weight: 600; color: #374151; margin-bottom: 0.3234rem;">CX Score</label>
                        <select id="pullFilterCxScoreType" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151; cursor: pointer; margin-bottom: 0.3234rem;">
                            <option value="">All CX Scores</option>
                            <option value="hasScore">Has CX Score</option>
                            <option value="noScore">No CX Score</option>
                            <option value="exact">Exact Score</option>
                            <option value="range">Score Range</option>
                        </select>
                        
                        <!-- Exact CX Score Input (shown when "exact" is selected) -->
                        <select id="pullFilterCxScoreExact" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151; cursor: pointer; display: none; margin-bottom: 0.3234rem;">
                            <option value="">Select Score</option>
                            <option value="5">5</option>
                            <option value="4">4</option>
                            <option value="3">3</option>
                            <option value="2">2</option>
                            <option value="1">1</option>
                        </select>
                        
                        <!-- Range Inputs (shown when "range" is selected) -->
                        <div id="pullFilterCxScoreRange" style="display: none; flex-direction: column; gap: 0.3234rem; margin-bottom: 0.3234rem;">
                            <div style="display: flex; gap: 0.3234rem; align-items: center;">
                                <label style="font-size: 0.4043rem; color: #6b7280; white-space: nowrap;">Min:</label>
                                <input type="number" id="pullFilterCxScoreMin" min="1" max="5" placeholder="1" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151;">
                    </div>
                            <div style="display: flex; gap: 0.3234rem; align-items: center;">
                                <label style="font-size: 0.4043rem; color: #6b7280; white-space: nowrap;">Max:</label>
                                <input type="number" id="pullFilterCxScoreMax" min="1" max="5" placeholder="5" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151;">
                    </div>
                    </div>
                        <div id="pullFilterCxScoreRangeError" style="display: none; color: #ef4444; font-size: 0.4043rem; margin-top: 0.1617rem;"></div>
                    </div>
                    
                    <!-- Conversation Length Filter -->
                    <div>
                        <label style="display: block; font-size: 0.5659rem; font-weight: 600; color: #374151; margin-bottom: 0.3234rem;">Conversation Length</label>
                        <div style="display: flex; flex-direction: column; gap: 0.3234rem;">
                            <div style="display: flex; gap: 0.3234rem; align-items: center;">
                                <label style="font-size: 0.4043rem; color: #6b7280; white-space: nowrap;">Min:</label>
                                <input type="number" id="pullFilterLengthMin" min="0" placeholder="0" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151;">
                    </div>
                            <div style="display: flex; gap: 0.3234rem; align-items: center;">
                                <label style="font-size: 0.4043rem; color: #6b7280; white-space: nowrap;">Max:</label>
                                <input type="number" id="pullFilterLengthMax" min="0" placeholder="Any" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151;">
                    </div>
                    </div>
                        <div id="pullFilterLengthRangeError" style="display: none; color: #ef4444; font-size: 0.4043rem; margin-top: 0.1617rem;"></div>
                    </div>
                    
                    <!-- Client Email/Name Search -->
                    <div>
                        <label style="display: block; font-size: 0.5659rem; font-weight: 600; color: #374151; margin-bottom: 0.3234rem;">Search Client</label>
                        <input type="text" id="pullFilterClientSearch" placeholder="Name or email" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151;">
                    </div>
                    
                    <!-- Conversation ID Search -->
                    <div>
                        <label style="display: block; font-size: 0.5659rem; font-weight: 600; color: #374151; margin-bottom: 0.3234rem;">Conversation ID</label>
                        <input type="text" id="pullFilterConversationId" placeholder="Full or partial ID" style="width: 100%; padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151;">
                    </div>
                </div>
                
                <div style="margin-top: 1.9406rem; padding-top: 1.2937rem; border-top: 0.0625rem solid #e5e7eb; display: flex; gap: 0.6469rem; justify-content: flex-end;">
                    <button type="button" onclick="clearPullConversationsFilters()" style="padding: 0.4852rem 0.9704rem; background: #f3f4f6; color: #374151; border: 0.0304rem solid #d1d5db; border-radius: 0.3234rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">Clear All</button>
                    <button type="submit" style="padding: 0.4852rem 0.9704rem; background: #1A733E; color: white; border: none; border-radius: 0.3234rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#15582E'" onmouseout="this.style.backgroundColor='#1A733E'">Apply Filters</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Admin Search Modal (for when admin ID is not found) -->
    <div id="adminSearchModal" onclick="if(event.target === this) closeAdminSearchModal();" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 10001; align-items: center; justify-content: center; padding: 1.2937rem;">
        <div onclick="event.stopPropagation();" style="background: white; border-radius: 0.6469rem; max-width: 40rem; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 0.8086rem 2.4258rem rgba(0, 0, 0, 0.15);">
            <div style="position: sticky; top: 0; background: white; border-bottom: 0.0625rem solid #e5e7eb; padding: 1.2937rem; display: flex; justify-content: space-between; align-items: center; z-index: 1;">
                <h2 style="font-size: 0.8086rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif;">Admin Not Found - Search & Link</h2>
                <button onclick="closeAdminSearchModal()" style="background: #f3f4f6; border: none; border-radius: 50%; width: 1.9406rem; height: 1.9406rem; display: flex; align-items: center; justify-content: center; cursor: pointer; color: #6b7280; font-size: 1.2937rem; line-height: 1; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">×</button>
            </div>
            <div style="padding: 1.2937rem;">
                <div style="background: #eff6ff; border: 0.0304rem solid #bfdbfe; border-radius: 0.3234rem; padding: 0.8086rem; margin-bottom: 1.2937rem;">
                    <p style="font-size: 0.4852rem; color: #1e40af; margin: 0 0 0.3234rem 0; font-weight: 600;">Employee Information:</p>
                    <p style="font-size: 0.4852rem; color: #374151; margin: 0;"><strong>Email:</strong> <span id="adminSearchEmployeeEmail"></span></p>
                    <p style="font-size: 0.4852rem; color: #374151; margin: 0.1617rem 0 0 0;"><strong>Name:</strong> <span id="adminSearchEmployeeName"></span></p>
                </div>
                
                <div style="margin-bottom: 1.2937rem;">
                    <label for="adminSearchInput" style="display: block; font-size: 0.5659rem; font-weight: 600; color: #374151; margin-bottom: 0.3234rem;">Search by Admin Name or Alias:</label>
                    <div style="display: flex; gap: 0.3234rem;">
                        <input 
                            type="text" 
                            id="adminSearchInput" 
                            placeholder="Enter admin name or alias (e.g., 'John Ferguson', 'Selena Mercer')..." 
                            style="flex: 1; padding: 0.4852rem 0.6469rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; background: white; color: #374151;"
                            onkeypress="if(event.key === 'Enter') { event.preventDefault(); searchIntercomAdmins(); }"
                        >
                        <button 
                            onclick="searchIntercomAdmins()" 
                            id="adminSearchButton"
                            style="padding: 0.4852rem 0.9704rem; background: #1A733E; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s; white-space: nowrap;"
                            onmouseover="this.style.backgroundColor='#15582E'"
                            onmouseout="this.style.backgroundColor='#1A733E'"
                        >
                            Search
                        </button>
                    </div>
                    <p style="font-size: 0.4043rem; color: #6b7280; margin: 0.3234rem 0 0 0;">Search for the Intercom admin that corresponds to this employee</p>
                </div>

                <!-- Loading State -->
                <div id="adminSearchLoading" style="display: none; text-align: center; padding: 1.2937rem; color: #6b7280;">
                    <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.2021rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 0.8s linear infinite;"></div>
                    <p style="font-size: 0.4852rem; margin: 0.6469rem 0 0 0;">Searching Intercom admins...</p>
                </div>

                <!-- Error State -->
                <div id="adminSearchError" style="display: none; background: #fee2e2; color: #991b1b; padding: 0.6469rem; border-radius: 0.3234rem; margin-bottom: 1.2937rem; font-size: 0.4852rem;">
                    <strong>Error:</strong> <span id="adminSearchErrorMessage"></span>
                </div>

                <!-- Results -->
                <div id="adminSearchResults" style="display: none;">
                    <h3 style="font-size: 0.6064rem; font-weight: 600; color: #374151; margin: 0 0 0.6469rem 0; font-family: 'Poppins', sans-serif;">Select Admin:</h3>
                    <div id="adminResultsList" style="max-height: 20rem; overflow-y: auto; border: 0.0304rem solid #e5e7eb; border-radius: 0.3234rem;">
                        <!-- Admin results will appear here -->
                    </div>
                    <p id="adminSearchNoResults" style="display: none; text-align: center; padding: 1.2937rem; color: #6b7280; font-size: 0.4852rem; margin: 0;">No admins found. Try a different search term.</p>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 0.6469rem; justify-content: flex-end; margin-top: 1.2937rem; padding-top: 1.2937rem; border-top: 0.0304rem solid #e5e7eb;">
                    <button 
                        onclick="skipAdminSearch()" 
                        style="padding: 0.4852rem 0.9704rem; background: #f3f4f6; color: #374151; border: 0.0304rem solid #d1d5db; border-radius: 0.3234rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s;"
                        onmouseover="this.style.backgroundColor='#e5e7eb'"
                        onmouseout="this.style.backgroundColor='#f3f4f6'"
                    >
                        Skip (Continue without admin)
                    </button>
                    <button 
                        onclick="closeAdminSearchModal()" 
                        style="padding: 0.4852rem 0.9704rem; background: #6b7280; color: white; border: none; border-radius: 0.3234rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s;"
                        onmouseover="this.style.backgroundColor='#4b5563'"
                        onmouseout="this.style.backgroundColor='#6b7280'"
                    >
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Conversations Section (Hidden by default, shown when View conversations is clicked) -->
    <div id="conversationsSection" style="display: none; background: #ffffff; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0405rem solid #e5e7eb; margin-bottom: 0.6469rem; width: 100%;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.6469rem;">
            <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E">
                    <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 9h12v2H6V9zm8 5H6v-2h8v2zm4-6H6V6h12v2z"/>
                </svg>
                Conversations for <span id="conversationsEmployeeName"></span>
            </h3>
            <button onclick="closeConversationsSection()" style="background: #f3f4f6; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; padding: 0.2425rem 0.4852rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; color: #374151; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                Close
            </button>
        </div>
        
        <!-- Date Range Picker -->
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
            <div style="display: flex; align-items: center; gap: 0.6469rem; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 0.3234rem;">
                    <label for="conversationsStartDate" style="font-size: 0.4852rem; font-weight: 500; color: #6b7280; white-space: nowrap;">From Date:</label>
                    <input type="date" id="conversationsStartDate" style="padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif;">
                </div>
                <div style="display: flex; align-items: center; gap: 0.3234rem;">
                    <label for="conversationsEndDate" style="font-size: 0.4852rem; font-weight: 500; color: #6b7280; white-space: nowrap;">To Date:</label>
                    <input type="date" id="conversationsEndDate" style="padding: 0.3234rem 0.4852rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif;">
                </div>
                <button onclick="openConversationsFilterDialog()" style="padding: 0.375rem 0.75rem; background-color: #1A733E; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 0.5rem;" onmouseover="this.style.backgroundColor='#15582E'" onmouseout="this.style.backgroundColor='#1A733E'" title="Open filter options">
                    <svg style="width: 1rem; height: 1rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
                    </svg>
                    Filter
                    <span id="activeFiltersCount" style="display: none; background-color: rgba(255,255,255,0.3); border-radius: 0.75rem; padding: 0.125rem 0.375rem; font-size: 0.75rem; margin-left: 0.25rem;">0</span>
                </button>
                <button onclick="resetConversationsDateRange()" style="padding: 0.375rem 0.75rem; background-color: #f3f4f6; color: #374151; border: 0.0625rem solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'" title="Reset to default date range (previous day)">
                    Reset
                </button>
            </div>
        </div>
        
        <!-- Loading State -->
        <div id="conversationsLoading" style="display: none; text-align: center; padding: 1.9406rem; color: #6b7280;">
            <div style="display: inline-block; width: 1.9406rem; height: 1.9406rem; border: 0.1213rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversations...</p>
        </div>
        
        <!-- Error State -->
        <div id="conversationsError" style="display: none; background: #fee2e2; color: #991b1b; padding: 0.6469rem; border-radius: 0.3234rem; margin-bottom: 0.6469rem; font-size: 0.4852rem;">
            <strong>Error:</strong> <span id="conversationsErrorMessage"></span>
        </div>
        
        <!-- Conversations List -->
        <div id="conversationsList" style="display: none;">
            <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.4852rem; margin-bottom: 0.3234rem; border: 0.0304rem solid #e5e7eb;">
                <span style="font-size: 0.4852rem; color: #6b7280;">Total Conversations: </span>
                <span id="conversationsCount" style="font-size: 0.5659rem; font-weight: 600; color: #111827;">0</span>
                <span id="conversationsCountLoader" style="display: none; margin-left: 0.25rem;">
                    <svg style="width: 0.75rem; height: 0.75rem; animation: spin 1s linear infinite;" class="inline-block" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" style="color: #6b7280;"></path>
                    </svg>
                </span>
            </div>
            
            <div style="background: white; border-radius: 0.3234rem; overflow: hidden; border: 0.0304rem solid #e5e7eb; max-height: 60vh; overflow-y: auto; position: relative;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead style="position: sticky; top: 0; z-index: 10; background: #f9fafb;">
                        <tr style="background: #f9fafb; border-bottom: 0.0625rem solid #e5e7eb;">
                            <th style="padding: 0.5rem 0.75rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.75rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">Client</th>
                            <th style="padding: 0.5rem 0.75rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.75rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">Conversation ID</th>
                            <th style="padding: 0.5rem 0.75rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.75rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">Subject</th>
                            <th style="padding: 0.5rem 0.75rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.75rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">Product Type</th>
                            <th style="padding: 0.5rem 0.75rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.75rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">Rating</th>
                            <th style="padding: 0.5rem 0.75rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.75rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">CX Score</th>
                            <th style="padding: 0.5rem 0.75rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.75rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">Length</th>
                            <th style="padding: 0.5rem 0.75rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.75rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">State</th>
                            <th style="padding: 0.5rem 0.75rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.75rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">Created</th>
                            <th style="padding: 0.5rem 0.75rem; text-align: left; font-weight: 600; color: #374151; font-size: 0.75rem; white-space: nowrap; text-transform: uppercase; letter-spacing: 0.025em;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="conversationsTableBody">
                        <!-- Rows will be populated here -->
                    </tbody>
                </table>
            </div>
            
            <!-- Pagination -->
            <div id="conversationsPagination" style="display: none; padding: 0.6469rem; border-top: 0.0304rem solid #e5e7eb; background: #f9fafb; margin-top: 0.6469rem;">
                <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.6469rem;">
                    <div style="font-size: 0.4447rem; color: #6b7280;">
                        Showing <span id="conversationsPaginationStart" style="font-weight: 600; color: #111827;">0</span> to <span id="conversationsPaginationEnd" style="font-weight: 600; color: #111827;">0</span> of <span id="conversationsPaginationTotal" style="font-weight: 600; color: #111827;">0</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.1617rem;">
                        <button id="conversationsPaginationPrev" onclick="conversationsGoToPage(currentConversationsPage - 1)" disabled style="padding: 0.1617rem 0.3234rem; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4043rem; cursor: pointer; color: #6b7280; transition: all 0.2s;">Prev</button>
                        <div id="conversationsPaginationPages" style="display: flex; gap: 0.1617rem;">
                            <!-- Page numbers will be inserted here -->
                        </div>
                        <button id="conversationsPaginationNext" onclick="conversationsGoToPage(currentConversationsPage + 1)" style="padding: 0.1617rem 0.3234rem; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4043rem; cursor: pointer; color: #6b7280; transition: all 0.2s;">Next</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Coming Soon Modal -->
    <div id="comingSoonModal" onclick="if(event.target === this) closeComingSoonDialog();">
        <div id="comingSoonModalContent" onclick="event.stopPropagation();">
            <div style="margin-bottom: 1.2937rem;">
                <div style="width: 4.8516rem; height: 4.8516rem; margin: 0 auto 1.2937rem; background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%); border: 0.0808rem solid #1A733E; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 0.1617rem 0.3234rem rgba(26, 115, 62, 0.15);">
                    <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#1A733E" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2L13.09 8.26L20 9L13.09 9.74L12 16L10.91 9.74L4 9L10.91 8.26L12 2Z"/>
                        <path d="M19 19L20.09 21.26L23 22L20.09 22.74L19 25L17.91 22.74L15 22L17.91 21.26L19 19Z"/>
                        <path d="M5 19L6.09 21.26L9 22L6.09 22.74L5 25L3.91 22.74L1 22L3.91 21.26L5 19Z"/>
                    </svg>
                </div>
                <h2 style="font-size: 1.2937rem; font-weight: 700; color: #1f2937; margin: 0 0 0.6469rem 0; font-family: 'Poppins', sans-serif;">AI Audit Coming Soon!</h2>
                <p style="font-size: 0.8086rem; color: #6b7280; margin: 0; line-height: 1.6; font-family: 'Poppins', sans-serif;">
                    We're working on an AI-powered audit feature that will automatically analyze conversations and generate audit reports. Stay tuned!
                </p>
            </div>
            <button onclick="closeComingSoonDialog()" style="padding: 0.4852rem 1.2937rem; background: #1A733E; color: white; border: none; border-radius: 0.3234rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#15582E'" onmouseout="this.style.backgroundColor='#1A733E'">
                Got it!
            </button>
        </div>
    </div>

    <!-- Conversations Filter Dialog Modal -->
    <div id="conversationsFilterModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 1000; align-items: center; justify-content: center; font-family: 'Poppins', sans-serif;">
        <div id="conversationsFilterModalContent" onclick="event.stopPropagation();" style="background: white; border-radius: 0.5rem; padding: 1.5rem; max-width: 32rem; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 0.625rem 1.5625rem rgba(0, 0, 0, 0.2); animation: modalSlideIn 0.3s ease-out;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 0.0625rem solid #e5e7eb; padding-bottom: 1rem;">
                <h2 style="font-size: 1.25rem; font-weight: 600; color: #111827; margin: 0;">Filter Conversations</h2>
                <button onclick="closeConversationsFilterDialog()" style="background: transparent; border: none; cursor: pointer; padding: 0.25rem; color: #6b7280; transition: color 0.2s;" onmouseover="this.style.color='#374151'" onmouseout="this.style.color='#6b7280'" title="Close">
                    <svg style="width: 1.5rem; height: 1.5rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>

            <form id="conversationsFilterForm" onsubmit="event.preventDefault(); applyConversationsFilters();">
                <!-- Status Filter -->
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem;">Status</label>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.875rem; color: #6b7280;">
                            <input type="radio" name="conversationStatus" value="all" id="statusAll" checked style="width: 1rem; height: 1rem; cursor: pointer; accent-color: #1A733E;">
                            <span>All</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.875rem; color: #6b7280;">
                            <input type="radio" name="conversationStatus" value="open" id="statusOpen" style="width: 1rem; height: 1rem; cursor: pointer; accent-color: #1A733E;">
                            <span>Open</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.875rem; color: #6b7280;">
                            <input type="radio" name="conversationStatus" value="closed" id="statusClosed" style="width: 1rem; height: 1rem; cursor: pointer; accent-color: #1A733E;">
                            <span>Closed</span>
                        </label>
                    </div>
                </div>

                <!-- Read Status Filter -->
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem;">Read Status</label>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.875rem; color: #6b7280;">
                            <input type="radio" name="conversationReadStatus" value="all" id="readStatusAll" checked style="width: 1rem; height: 1rem; cursor: pointer; accent-color: #1A733E;">
                            <span>All</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.875rem; color: #6b7280;">
                            <input type="radio" name="conversationReadStatus" value="unread" id="readStatusUnread" style="width: 1rem; height: 1rem; cursor: pointer; accent-color: #1A733E;">
                            <span>Unread</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.875rem; color: #6b7280;">
                            <input type="radio" name="conversationReadStatus" value="read" id="readStatusRead" style="width: 1rem; height: 1rem; cursor: pointer; accent-color: #1A733E;">
                            <span>Read</span>
                        </label>
                    </div>
                </div>

                <!-- Sort By -->
                <div style="margin-bottom: 1.5rem;">
                    <label for="conversationSortBy" style="display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem;">Sort By</label>
                    <select id="conversationSortBy" style="width: 100%; padding: 0.5rem 0.75rem; border: 0.0625rem solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; color: #374151; background: white; cursor: pointer; transition: border-color 0.2s;" onfocus="this.style.borderColor='#1A733E'; this.style.outline='none';" onblur="this.style.borderColor='#d1d5db';">
                        <option value="updated_at">Updated At</option>
                        <option value="created_at">Created At</option>
                        <option value="waiting_since">Waiting Since</option>
                    </select>
                </div>

                <!-- Sort Order -->
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem;">Sort Order</label>
                    <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.875rem; color: #6b7280;">
                            <input type="radio" name="conversationSortOrder" value="desc" id="sortOrderDesc" checked style="width: 1rem; height: 1rem; cursor: pointer; accent-color: #1A733E;">
                            <span>Descending (Newest First)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.875rem; color: #6b7280;">
                            <input type="radio" name="conversationSortOrder" value="asc" id="sortOrderAsc" style="width: 1rem; height: 1rem; cursor: pointer; accent-color: #1A733E;">
                            <span>Ascending (Oldest First)</span>
                        </label>
                    </div>
                </div>

                <!-- Product Type Filter -->
                <div style="margin-bottom: 1.5rem;">
                    <label for="conversationProductType" style="display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem;">Product Type</label>
                    <select id="conversationProductType" style="width: 100%; padding: 0.5rem 0.75rem; border: 0.0625rem solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; color: #374151; background: white; cursor: pointer; transition: border-color 0.2s;" onfocus="this.style.borderColor='#1A733E'; this.style.outline='none';" onblur="this.style.borderColor='#d1d5db';">
                        <option value="all">All</option>
                        <option value="Futures">Futures</option>
                        <option value="CFD">CFD</option>
                        <option value="CFD / Forex">CFD / Forex</option>
                    </select>
                </div>

                <!-- Date Range Filter -->
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 0.5rem;">Date Range (Filter loaded conversations)</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                        <div>
                            <label for="filterDateStart" style="display: block; font-size: 0.75rem; color: #6b7280; margin-bottom: 0.25rem;">Start Date</label>
                            <input type="date" id="filterDateStart" style="width: 100%; padding: 0.5rem 0.75rem; border: 0.0625rem solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; color: #374151; background: white; cursor: pointer; transition: border-color 0.2s;" onfocus="this.style.borderColor='#1A733E'; this.style.outline='none';" onblur="this.style.borderColor='#d1d5db';">
                        </div>
                        <div>
                            <label for="filterDateEnd" style="display: block; font-size: 0.75rem; color: #6b7280; margin-bottom: 0.25rem;">End Date</label>
                            <input type="date" id="filterDateEnd" style="width: 100%; padding: 0.5rem 0.75rem; border: 0.0625rem solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; color: #374151; background: white; cursor: pointer; transition: border-color 0.2s;" onfocus="this.style.borderColor='#1A733E'; this.style.outline='none';" onblur="this.style.borderColor='#d1d5db';">
                        </div>
                    </div>
                    <p style="font-size: 0.75rem; color: #6b7280; margin-top: 0.5rem; margin-bottom: 0;">Note: This filters the already-loaded conversations by their date. Use the main date picker above to change the fetch range.</p>
                </div>

                <!-- Active Filters Display -->
                <div id="activeFiltersDisplay" style="margin-bottom: 1.5rem; padding: 0.75rem; background: #f9fafb; border-radius: 0.375rem; display: none;">
                    <div style="font-size: 0.75rem; font-weight: 500; color: #6b7280; margin-bottom: 0.5rem;">Active Filters:</div>
                    <div id="activeFiltersBadges" style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
                        <!-- Active filter badges will be inserted here -->
                    </div>
                </div>

                <!-- Action Buttons -->
                <div style="display: flex; gap: 0.75rem; justify-content: flex-end; border-top: 0.0625rem solid #e5e7eb; padding-top: 1rem;">
                    <button type="button" onclick="resetConversationsFilters()" style="padding: 0.5rem 1rem; background-color: #f3f4f6; color: #374151; border: 0.0625rem solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                        Reset All
                    </button>
                    <button type="button" onclick="closeConversationsFilterDialog()" style="padding: 0.5rem 1rem; background-color: #f3f4f6; color: #374151; border: 0.0625rem solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                        Cancel
                    </button>
                    <button type="submit" style="padding: 0.5rem 1rem; background-color: #1A733E; color: white; border: none; border-radius: 0.375rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor='#15582E'" onmouseout="this.style.backgroundColor='#1A733E'">
                        Apply Filters
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Audit Form Modal (Full Screen) -->
<div id="auditFormModal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); z-index: 1000; display: none; align-items: flex-start; justify-content: center; padding: 0; overflow-y: auto;">
    <form id="auditForm" method="POST" style="background: white; width: 100%; height: 100vh; display: flex; flex-direction: column; gap: 0; padding: 0; margin: 0; overflow-y: auto;">
    <!-- Hidden audit information fields - populated behind the scenes -->
    <input type="hidden" id="auditDuration" name="auditDuration">
    <input type="hidden" id="auditorEmail" name="auditorEmail">
    <input type="hidden" id="auditorName" name="auditorName">
    <input type="hidden" id="quarter" name="quarter">
    <input type="hidden" id="week" name="week">
    <input type="hidden" id="errorDescription" name="errorDescription">

    <!-- Beautiful Header Section (Report-Style) -->
    <div id="auditFormHeader" style="background: linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%); padding: 0.6469rem 0.9704rem; color: white; box-shadow: 0 0.1213rem 0.1819rem rgba(0,0,0,0.1); margin-bottom: 0.9704rem; transition: background 0.3s ease;">
        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.4852rem;">
            <div style="flex: 1;">
                <h2 style="font-size: 0.7278rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif;">Create New Audit</h2>
            </div>
            <div style="display: flex; align-items: center; gap: 0.3234rem;">
                <button type="button" onclick="closeAuditForm()" style="background: rgba(255,255,255,0.2); border: 0.0606rem solid white; border-radius: 0.2425rem; width: 1.2937rem; height: 1.2937rem; font-size: 0.8086rem; cursor: pointer; color: white; font-weight: bold; transition: all 0.2s; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">×</button>
            </div>
        </div>
        <div>
            
            <!-- Employee Information in Header -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(6.0644rem, 1fr)); gap: 0.3234rem; margin-bottom: 0.4852rem;">
                <div>
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Employee *</p>
                    <select id="employeeName" name="employeeName" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; background-color: transparent; color: white; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; width: 100%; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23ffffff\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem;">
                        <option value="" style="background-color: #ffffff; color: #374151;">Select Employee...</option>
                    </select>
                </div>
                <div>
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Email *</p>
                    <input type="email" id="employeeEmail" name="employeeEmail" required readonly style="padding: 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; background-color: transparent; color: white; width: 100%; word-break: break-all;">
                </div>
                <div>
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Type</p>
                    <input type="text" id="employeeType" name="employeeType" readonly style="padding: 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; background-color: transparent; color: white; width: 100%;">
                </div>
                <div>
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Department</p>
                    <input type="text" id="employeeDepartment" name="employeeDepartment" readonly style="padding: 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; background-color: transparent; color: white; width: 100%;">
                </div>
                <div>
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Country *</p>
                    <select id="countryOfEmployee" name="countryOfEmployee" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; background-color: transparent; color: white; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; width: 100%; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23ffffff\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem;">
                        <option value="" style="background-color: #ffffff; color: #374151;">Select Country</option>
                        <option value="Bangladesh" selected style="background-color: #ffffff; color: #374151;">Bangladesh</option>
                        <option value="Sri Lanka" style="background-color: #ffffff; color: #374151;">Sri Lanka</option>
                    </select>
                </div>
                <div id="intercomAliasContainer" style="display: none;">
                    <p style="font-size: 0.4043rem; color: rgba(255,255,255,0.7); margin: 0; font-family: 'Poppins', sans-serif; text-transform: uppercase;">Intercom Alias</p>
                    <input type="text" id="intercomAlias" name="intercomAlias" readonly style="padding: 0.3234rem; border: 0.0304rem solid rgba(255,255,255,0.3); border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; background-color: rgba(255,255,255,0.1); color: rgba(255,255,255,0.9); width: 100%;" placeholder="Intercom alias...">
                </div>
            </div>
        </div>
        
        <!-- Audit Metadata Cards -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(4.2451rem, 1fr)); gap: 0.3234rem;">
        </div>
    </div>

    <!-- Scorecard Info (moved to Error Details section, keeping scorecardInfo div here for backward compatibility) -->
    <div id="scorecardInfo" style="display: none; position: absolute; visibility: hidden;">
        <div style="display: flex; align-items: center; gap: 0.4852rem; font-size: 0.4447rem; color: #6b7280;">
            <span><strong id="scorecardScoringType" style="color: #1A733E;">--</strong></span>
            <span style="color: #d1d5db;">•</span>
            <span><strong id="scorecardParamsCount" style="color: #1A733E;">--</strong> params</span>
        </div>
    </div>

    <!-- Two Column Layout (matching expert-audits.html) -->
    <div id="auditContent" style="display: flex; padding: 0.9704rem; max-width: 100%; gap: 0; flex-wrap: nowrap; overflow-x: visible; align-items: stretch;">
        
        <!-- LEFT COLUMN: Interaction Details + Transcript -->
        <div id="leftColumn" style="display: flex; flex-direction: column; gap: 0.6469rem; flex: 0 0 33%; min-width: 13.6451rem; max-width: 75%; padding-right: 0.6469rem; overflow-x: visible; overflow-y: visible; box-sizing: border-box;">
            <!-- Transcript -->
            <div style="display: flex; flex-direction: column; gap: 0.6469rem; flex: 1; min-height: 0; max-height: calc(100vh - 15rem);">
                <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0; border: 0.0304rem solid #e5e7eb; display: flex; flex-direction: column; flex: 1; min-height: 0; transition: height 0.3s ease; overflow: hidden;">
                    <div style="background: #f9fafb; padding: 0.6469rem; border-bottom: 0.0304rem solid #e5e7eb; flex-shrink: 0; display: flex; flex-direction: column; gap: 0.4852rem;">
                        <!-- First Row: Transcript Title and Form Fields -->
                        <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap; justify-content: space-between;">
                            <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                                <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 9h12v2H6V9zm8 5H6v-2h8v2zm4-6H6V6h12v2z"/></svg>
                                    Transcript
                                </h3>
                                <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                    <span style="font-size: 0.4447rem; color: #6b7280; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0092rem; white-space: nowrap;">ID:</span>
                                    <input type="text" id="interactionId" name="interactionId" required placeholder="Enter..." style="padding: 0.1617rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600; min-width: 2.4258rem;">
                                    <button type="button" onclick="copyConversationId(); return false;" style="padding: 0.0808rem; background: transparent; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #6b7280; transition: all 0.2s;" title="Copy ID" onmouseover="this.style.color='#1A733E';" onmouseout="this.style.color='#6b7280';">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                        </svg>
                                    </button>
                                    <button type="button" id="viewChatBtn" disabled style="padding: 0.1617rem 0.3234rem; background-color: #9ca3af; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4447rem; font-family: 'Poppins', sans-serif; cursor: not-allowed; white-space: nowrap; transition: all 0.2s ease; font-weight: 500; opacity: 0.6;" title="Open in Intercom (load conversation first)">Open</button>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                                <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                    <span style="font-size: 0.4447rem; color: #6b7280; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0092rem; white-space: nowrap;">Date:</span>
                                    <input type="date" id="interactionDate" name="interactionDate" required style="padding: 0.1617rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600;">
                                </div>
                                <div style="width: 0.0304rem; height: 0.6469rem; background: #d1d5db;"></div>
                                <div style="display: flex; align-items: center; gap: 0.1617rem; min-width: 0;">
                                    <span style="font-size: 0.4447rem; color: #6b7280; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0092rem; white-space: nowrap; flex-shrink: 0;">Name:</span>
                                    <input type="text" id="clientName" name="clientName" readonly placeholder="Client name..." style="padding: 0.1617rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600; min-width: 3.6387rem; box-sizing: border-box; background-color: #f9fafb;">
                                </div>
                                <div style="width: 0.0304rem; height: 0.6469rem; background: #d1d5db;"></div>
                                <div style="display: flex; align-items: center; gap: 0.1617rem; min-width: 0;">
                                    <span style="font-size: 0.4447rem; color: #6b7280; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0092rem; white-space: nowrap; flex-shrink: 0;">Email:</span>
                                    <input type="email" id="clientEmail" name="clientEmail" placeholder="client@..." style="padding: 0.1617rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 600; min-width: 3.6387rem; box-sizing: border-box;">
                                    <button type="button" onclick="copyClientEmail(); return false;" style="padding: 0.0808rem; background: transparent; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #6b7280; transition: all 0.2s;" title="Copy Email" onmouseover="this.style.color='#1A733E';" onmouseout="this.style.color='#6b7280';">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <!-- Second Row: Quick Actions (Compact) -->
                        <div id="clientNameSection" style="display: none; align-items: center; justify-content: flex-end; gap: 0.3234rem; padding-top: 0.3234rem; border-top: 0.0304rem solid #e5e7eb;">
                            <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                <button type="button" id="translateChatBtn" onclick="translateChatMessages(); return false;" disabled style="padding: 0.2425rem 0.4043rem; background: #f3f4f6; border: 0.0304rem solid #d1d5db; border-radius: 0.2425rem; font-size: 0.4043rem; font-family: 'Poppins', sans-serif; font-weight: 500; color: #9ca3af; cursor: not-allowed; transition: all 0.2s; display: flex; align-items: center; gap: 0.1617rem; white-space: nowrap; opacity: 0.6;" title="Translation feature is currently disabled">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem;">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129"></path>
                                    </svg>
                                    <span>Translate</span>
                                </button>
                            </div>
                        </div>
                        <!-- Third Row: Collapsible Information Grid -->
                        <div id="conversationInfoGrid" style="display: none; padding-top: 0.3234rem; border-top: 0.0304rem solid #e5e7eb; margin-top: 0.3234rem;">
                            <button id="toggleInfoGridBtn" type="button" onclick="toggleConversationInfoGrid()" style="width: 100%; padding: 0.3234rem 0.4852rem; background: #f9fafb; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; font-family: 'Poppins', sans-serif; font-size: 0.4447rem; font-weight: 600; color: #1A733E; cursor: pointer; display: flex; align-items: center; justify-content: space-between; transition: all 0.2s; margin-bottom: 0.3234rem;" onmouseover="this.style.background='#f3f4f6'; this.style.borderColor='#1A733E';" onmouseout="this.style.background='#f9fafb'; this.style.borderColor='#e5e7eb';">
                                <span style="display: flex; align-items: center; gap: 0.2425rem;">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem;">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                    </svg>
                                    <span>Conversation Details</span>
                                </span>
                                <svg id="toggleInfoGridIcon" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem; transition: transform 0.2s; transform: rotate(0deg);">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </button>
                            <div id="conversationInfoGridContent" style="display: none; grid-template-columns: repeat(auto-fit, minmax(8rem, 1fr)); gap: 0.3234rem; font-family: 'Poppins', sans-serif;">
                                <!-- Information cards will be populated here -->
                            </div>
                        </div>
                    </div>
                    <!-- Chat Interface View -->
                    <div id="transcriptChatView" style="display: flex; padding: 0.4852rem; background: #f0f2f5; overflow-y: auto; overflow-x: hidden; flex: 1; flex-direction: column; scrollbar-width: thin; scrollbar-color: #9ca3af #f0f2f5; position: relative; min-height: 0;">
                        <!-- Chat messages will be dynamically inserted here -->
                        <div id="chatMessagesContainer" style="display: flex; flex-direction: column; min-height: 0; width: 100%; gap: 0.3234rem; padding: 0.2426rem 0;">
                            <div style="text-align: center; padding: 1.2937rem; color: #9ca3af; font-size: 0.5659rem;">
                                <p>Enter an Interaction ID to automatically load conversation from Intercom</p>
                            </div>
                        </div>
                    </div>
                    <!-- Text Area View (Fallback) -->
                    <div id="transcriptTextView" style="display: none; padding: 0.6469rem; background: white; overflow-y: auto; flex: 1; position: relative;">
                        <textarea id="transcript" name="transcript" placeholder="Paste the interaction transcript here..." style="width: 100%; height: 100%; padding: 0; border: none; font-size: 0.5257rem; line-height: 1.6; color: #374151; font-family: 'Poppins', sans-serif; background-color: transparent; resize: none; box-sizing: border-box; outline: none; transition: padding-top 0.3s ease;"></textarea>
                    </div>
                </div>
                <!-- Conversation Attributes Panel (Always visible by default) - Below transcript container -->
                <div id="conversationAttributesPanel" style="background: white; border-radius: 0.3234rem; padding: 0; border: 0.0304rem solid #e5e7eb; display: none; box-shadow: 0 0.0606rem 0.1213rem rgba(0,0,0,0.05); overflow-y: auto;">
                    <div id="conversationAttributesContent" style="padding: 0.3234rem; display: block;">
                        <div id="conversationAttributesGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(6.0644rem, 1fr)); gap: 0.3234rem;">
                            <!-- Attributes will be dynamically populated here -->
                        </div>
                    </div>
                </div>
                <!-- Conversation Attributes Panel for text view (Always visible by default) - Below transcript container -->
                <div id="conversationAttributesPanelTextView" style="background: white; border-radius: 0.3234rem; padding: 0.3234rem; border: 0.0304rem solid #e5e7eb; display: none; box-shadow: 0 0.0606rem 0.1213rem rgba(0,0,0,0.05); overflow-y: auto;">
                    <div id="conversationAttributesGridTextView" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(6.0644rem, 1fr)); gap: 0.3234rem;">
                        <!-- Attributes will be dynamically populated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- RESIZABLE SPLITTER -->
        <div id="splitter" style="width: 0.2425rem; background: #e5e7eb; cursor: col-resize; position: relative; flex-shrink: 0; transition: background 0.2s; z-index: 1;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 0.1213rem; height: 1.2128rem; background: #9ca3af; border-radius: 0.0606rem;"></div>
        </div>
        
        <!-- RIGHT COLUMN: Error Details, Post-Status & Recommendations -->
        <div id="rightColumn" style="flex: 1; min-width: 9.0967rem; padding-left: 0.3234rem; max-height: calc(100vh - 15rem); overflow-y: auto;">
            
            
            <!-- Error Details (Report-Style Table) -->
            <div id="errorParametersSection" style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4852rem; flex-wrap: wrap; gap: 0.4852rem;">
                    <div style="display: flex; align-items: center; gap: 0.4852rem; flex-wrap: wrap;">
                        <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                            <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
                            Error Details
                        </h3>
                        <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 0.3234rem;">
                                <label for="scorecardSelect" style="font-size: 0.4852rem; font-weight: 500; color: #6b7280; font-family: 'Poppins', sans-serif; white-space: nowrap;">Scorecard:</label>
                                <select id="scorecardSelect" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; min-width: 4.5482rem; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem;">
                                    <option value="">Loading scorecards...</option>
                                </select>
                            </div>
                            <div style="width: 0.0304rem; height: 0.6469rem; background: #d1d5db;"></div>
                            <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                <span style="font-size: 0.4852rem; font-weight: 500; color: #6b7280; font-family: 'Poppins', sans-serif; white-space: nowrap;">Channel:</span>
                                <select id="channel" name="channel" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; min-width: 3.6387rem; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem;">
                                    <option value="">Select...</option>
                                </select>
                            </div>
                        </div>
                        <div style="width: 0.0304rem; height: 0.6469rem; background: #d1d5db;"></div>
                        <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                <label style="font-size: 0.4852rem; font-weight: 500; color: #6b7280; font-family: 'Poppins', sans-serif; white-space: nowrap;">Pre-Status:</label>
                                <select id="agentPreStatus" name="agentPreStatus" style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem; min-width: 8rem;">
                                    <option value="">Select Status</option>
                                    <option value="No active quality concerns" selected>No active quality concerns</option>
                                    <option value="Pre-Quality">Pre-Quality</option>
                                    <option value="Quality Concern">Quality Concern</option>
                                    <option value="Performance Improvement Plan (PIP)">Performance Improvement Plan (PIP)</option>
                                    <option value="Performance Improvement Plan (PIP) - Alert">PIP - Alert</option>
                                    <option value="Performance Improvement Plan (PIP) - Priority">PIP - Priority</option>
                                </select>
                    </div>
                            <div style="width: 0.0304rem; height: 0.6469rem; background: #d1d5db;"></div>
                            <div style="display: flex; align-items: center; gap: 0.1617rem;">
                                <label style="font-size: 0.4852rem; font-weight: 500; color: #6b7280; font-family: 'Poppins', sans-serif; white-space: nowrap;">Audit Type:</label>
                                <select id="auditType" name="auditType" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem; min-width: 8rem;">
                                    <option value="">Select</option>
                                    <option value="Routine Audit (Recorded)" selected>Routine (Recorded)</option>
                                    <option value="Focused Audit (Recorded)">Focused (Recorded)</option>
                                    <option value="Focused Audit (Live)">Focused (Live)</option>
                                    <option value="Evaluation and Feedback">Evaluation</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="background: white; border-radius: 0.4852rem; box-shadow: 0 0.0405rem 0.1213rem 0 rgba(0, 0, 0, 0.1); overflow: hidden;">
                    <!-- Table Header -->
                    <div style="background-color: #f8f9fa; padding: 0.4852rem 0.6469rem; border-bottom: 0.0405rem solid #e5e7eb;">
                        <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 3fr; gap: 0.6469rem; align-items: center; font-weight: 700; font-size: 0.5659rem; color: #1f2937; text-transform: uppercase; letter-spacing: 0.05em;">
                            <div>Error Type</div>
                            <div style="text-align: center;">Points</div>
                            <div style="text-align: center;">Severity</div>
                            <div class="error-details-header-status" style="text-align: center;">Status</div>
                            <div>Feedback</div>
                        </div>
                    </div>
                    
                    <!-- Table Body -->
                    <div id="errorParametersContainer" style="padding: 0 0.6469rem 0.6469rem 0.6469rem; box-shadow: 0 -0.0606rem 0.1213rem rgba(0, 0, 0, 0.05);">
                        <!-- Error parameters will be dynamically loaded based on selected scorecard -->
                        <div style="padding: 1.2937rem; text-align: center; color: #6b7280; font-size: 0.5659rem;">
                            <p>Please select a scorecard above to load error parameters.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Avg Score, Passing Status & Post-Status -->
            <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Avg Score</p>
                        <input type="number" id="averageScore" name="averageScore" min="0" max="100" step="0.01" required readonly style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;">
                    </div>
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Status</p>
                        <input type="text" id="passingStatus" name="passingStatus" readonly style="font-size: 0.5659rem; font-weight: 600; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;">
                    </div>
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Post-Status</p>
                        <select id="agentPostStatus" name="agentPostStatus" style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; width: 100%; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem; text-align: center;">
                            <option value="">Select Status</option>
                            <option value="No active quality concerns" selected>No active quality concerns</option>
                            <option value="Pre-Quality">Pre-Quality</option>
                            <option value="Quality Concern">Quality Concern</option>
                            <option value="Performance Improvement Plan (PIP)">Performance Improvement Plan (PIP)</option>
                            <option value="Performance Improvement Plan (PIP) - Alert">PIP - Alert</option>
                            <option value="Performance Improvement Plan (PIP) - Priority">PIP - Priority</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Error Counts: Total Errors, Critical Fail, Critical, Significant -->
            <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Total Errors</p>
                        <input type="number" id="totalErrorsCount" name="totalErrorsCount" min="0" required readonly style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;">
                    </div>
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical Fail</p>
                        <input type="number" id="criticalFailErrorDisplay" name="criticalFailErrorDisplay" min="0" required readonly style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;" value="0">
                    </div>
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical</p>
                        <input type="number" id="criticalErrors" name="criticalErrors" min="0" required readonly style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;">
                    </div>
                    <div>
                        <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Significant Error</p>
                        <input type="number" id="significantError" name="significantError" min="0" required readonly style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; cursor: not-allowed; text-align: center;">
                    </div>
                </div>
            </div>

            <!-- Recommendations & Next Steps -->
            <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;">
                <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0 0 0.4852rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/></svg>
                    Recommendations / Next Steps
                </h3>
                <textarea id="recommendations" name="recommendations" rows="4" placeholder="Enter recommendations and next steps for the employee..." style="width: 100%; padding: 0.5659rem; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; font-size: 0.5257rem; line-height: 1.6; color: #374151; font-family: 'Poppins', sans-serif; background-color: white; resize: vertical; box-sizing: border-box;"></textarea>
            </div>
        </div>
    </div> <!-- End Two Column Layout -->

    <!-- Form Actions -->
    <div style="display: flex; justify-content: space-between; align-items: center; gap: 0.4852rem; padding: 0.6469rem 0.9704rem; border-top: 0.0405rem solid #e5e7eb; background-color: #f9fafb; margin-top: auto;">
        <div style="display: flex; align-items: center; gap: 0.4852rem;">
            <div>
                <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.1617rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Validation</p>
                <select id="validationStatus" name="validationStatus" required style="padding: 0.2425rem 0.3234rem; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; background-color: #ffffff; color: #374151; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.3234rem center; background-size: 0.5659rem; padding-right: 1.2937rem; min-width: 8rem;">
                    <option value="Validated" selected>Validated</option>
                    <option value="Pending">Pending</option>
                    <option value="Rejected">Rejected</option>
                </select>
            </div>
        </div>
        <div style="display: flex; gap: 0.4852rem;">
        <button type="button" id="cancelBtn" style="padding: 0.4852rem 1.2937rem; background-color: white; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">Cancel</button>
        <button type="submit" style="padding: 0.4852rem 1.2937rem; background: linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%); color: white; border: none; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 0.0606rem 0.1213rem rgba(26, 115, 62, 0.2);">✓ Submit Audit</button>
        </div>
    </div>
    </form>
</div> <!-- End auditFormModal -->







</main>

<script>
// ============================================================================
// Dynamic Scorecard System
// ============================================================================
let currentScorecard = null;
let currentParameters = [];

// Store all available scorecards for filtering
let allAvailableScorecards = [];

// Load available scorecards
async function loadScorecards(channelFilter = null) {
    const scorecardSelect = document.getElementById('scorecardSelect');
    
    try {
        let query = window.supabaseClient
            .from('scorecards')
            .select('*')
            .eq('is_active', true)
            .order('created_at', { ascending: false });
        
        const { data, error } = await query;
        
        if (error) throw error;
        
        // Store all scorecards for filtering
        allAvailableScorecards = data || [];
        
        // Filter by channel if provided
        let filteredScorecards = allAvailableScorecards;
        if (channelFilter) {
            filteredScorecards = allAvailableScorecards.filter(scorecard => {
                if (!scorecard.channels) return false;
                const channelsList = scorecard.channels.split(',').map(c => c.trim());
                return channelsList.includes(channelFilter);
            });
            
            // Sort scorecards: default ones first, then by created_at
            filteredScorecards.sort((a, b) => {
                const aIsDefault = a.default_for_channels && a.default_for_channels.split(',').map(c => c.trim()).includes(channelFilter);
                const bIsDefault = b.default_for_channels && b.default_for_channels.split(',').map(c => c.trim()).includes(channelFilter);
                
                if (aIsDefault && !bIsDefault) return -1;
                if (!aIsDefault && bIsDefault) return 1;
                
                // If both are default or neither, sort by created_at (newest first)
                const aDate = new Date(a.created_at || 0);
                const bDate = new Date(b.created_at || 0);
                return bDate - aDate;
            });
        }
        
        scorecardSelect.innerHTML = '<option value="">Select a scorecard...</option>';
        
        if (filteredScorecards && filteredScorecards.length > 0) {
            filteredScorecards.forEach(scorecard => {
                const option = document.createElement('option');
                option.value = scorecard.id;
                
                // Add "(Default)" indicator if this is the default scorecard for the channel
                let displayName = scorecard.name;
                if (channelFilter && scorecard.default_for_channels) {
                    const defaultChannels = scorecard.default_for_channels.split(',').map(c => c.trim());
                    if (defaultChannels.includes(channelFilter)) {
                        displayName += ' (Default)';
                    }
                }
                
                option.textContent = displayName;
                option.dataset.threshold = scorecard.passing_threshold;
                option.dataset.tableName = scorecard.table_name;
                option.dataset.channels = scorecard.channels || '';
                scorecardSelect.appendChild(option);
            });
            
            // Auto-select the first scorecard if available (whether one or multiple)
            // This will be the default one if it exists, otherwise the newest one
            if (filteredScorecards.length > 0) {
                scorecardSelect.value = filteredScorecards[0].id;
                await loadScorecardParameters(filteredScorecards[0].id);
                
                // Update default badge indicator
                updateDefaultScorecardBadge(filteredScorecards[0], channelFilter);
            }
            // If channel is selected but no matching scorecard, show message
            else if (channelFilter && filteredScorecards.length === 0) {
                scorecardSelect.innerHTML = '<option value="">No scorecard available for selected channel</option>';
            }
        } else {
            if (channelFilter) {
                scorecardSelect.innerHTML = '<option value="">No scorecard available for selected channel</option>';
        } else {
            scorecardSelect.innerHTML = '<option value="">No scorecards available</option>';
            }
        }
    } catch (error) {
        console.error('Error loading scorecards:', error);
        scorecardSelect.innerHTML = '<option value="">Error loading scorecards</option>';
    }
}

// Auto-select scorecard based on selected channel
async function autoSelectScorecardByChannel(channelName) {
    if (!channelName || !channelName.trim()) {
        // If channel is cleared, reload all scorecards and auto-select first
        await loadScorecards();
        return;
    }
    
    // Ensure scorecards are loaded first
    if (allAvailableScorecards.length === 0) {
        await loadScorecards();
    }
    
    // Reload scorecards filtered by channel (this will auto-select first matching scorecard)
    await loadScorecards(channelName.trim());
    
    // The loadScorecards function will already auto-select the first scorecard
    // No additional logic needed here
}

// Update default scorecard badge indicator
function updateDefaultScorecardBadge(scorecard, channelFilter) {
    // Remove any existing badge first
    removeDefaultScorecardBadge();
    
    // Check if this is a default scorecard for the current channel
    const isDefault = channelFilter && scorecard && scorecard.default_for_channels && 
                      typeof scorecard.default_for_channels === 'string' &&
                      scorecard.default_for_channels.split(',').map(c => c.trim()).includes(channelFilter);
    
    if (isDefault) {
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect && scorecardSelect.parentElement) {
            const badge = document.createElement('span');
            badge.id = 'defaultScorecardBadge';
            badge.textContent = '⭐ Default';
            badge.style.cssText = 'font-size: 0.4043rem; color: #1A733E; background: #d1fae5; padding: 0.1617rem 0.3234rem; border-radius: 0.1617rem; font-weight: 600; margin-left: 0.3234rem; white-space: nowrap; display: inline-flex; align-items: center;';
            badge.title = 'This is the default scorecard for the selected channel';
            scorecardSelect.parentElement.appendChild(badge);
        }
    }
}

// Remove default scorecard badge
function removeDefaultScorecardBadge() {
    const existingBadge = document.getElementById('defaultScorecardBadge');
    if (existingBadge) {
        existingBadge.remove();
    }
}

// Load parameters for selected scorecard
async function loadScorecardParameters(scorecardId) {
    // Handle empty, null, or "null" string values
    if (!scorecardId || scorecardId === 'null' || scorecardId === 'undefined' || scorecardId.trim() === '') {
        currentScorecard = null;
        currentParameters = [];
        document.getElementById('scorecardInfo').style.display = 'none';
        clearErrorParameters();
        return;
    }
    
    // Validate UUID format to prevent SQL errors
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(scorecardId)) {
        console.error('Invalid scorecard ID format:', scorecardId);
        currentScorecard = null;
        currentParameters = [];
        document.getElementById('scorecardInfo').style.display = 'none';
        clearErrorParameters();
        return;
    }
    
    try {
        // Load scorecard details
        const { data: scorecard, error: scorecardError } = await window.supabaseClient
            .from('scorecards')
            .select('*')
            .eq('id', scorecardId)
            .single();
        
        if (scorecardError) throw scorecardError;
        
        // Load parameters
        const { data: parameters, error: paramsError } = await window.supabaseClient
            .from('scorecard_parameters')
            .select('*')
            .eq('scorecard_id', scorecardId)
            .eq('is_active', true)
            .order('display_order', { ascending: true });
        
        if (paramsError) throw paramsError;
        
        currentScorecard = scorecard;
        currentParameters = parameters || [];
        
        // Update scorecard info display
        const scorecardScoringType = document.getElementById('scorecardScoringType');
        const scorecardParamsCount = document.getElementById('scorecardParamsCount');
        const scorecardInfo = document.getElementById('scorecardInfo');
        
        if (scorecardScoringType) {
            const scoringTypeText = scorecard.scoring_type 
                ? scorecard.scoring_type.charAt(0).toUpperCase() + scorecard.scoring_type.slice(1)
                : 'Deductive';
            scorecardScoringType.textContent = scoringTypeText;
        }
        if (scorecardParamsCount) scorecardParamsCount.textContent = currentParameters.length;
        if (scorecardInfo) scorecardInfo.style.display = 'flex';
        
        // Render error parameters
        renderErrorParameters();
        
        // Set initial average score based on scoring type
        setInitialAverageScore();
        
    } catch (error) {
        console.error('Error loading scorecard parameters:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to load scorecard parameters: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// ============================================================================
// Your Stats System
// ============================================================================

// Update your stats (assignment progress)
async function updateYourStats() {
    try {
        // Get current user info
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const currentUserEmail = (userInfo.email || '').toLowerCase().trim();
        const currentUserRole = userInfo.role || '';
        const isAgent = currentUserRole === 'Employee';
        
        if (!currentUserEmail) {
            return;
        }
        
        // Load assignments for current user
        // Filter by employee_email if agent, otherwise by auditor_email
        const filterField = isAgent ? 'employee_email' : 'auditor_email';
        const { data: assignments, error: assignmentsError } = await window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .eq(filterField, currentUserEmail)
            .order('created_at', { ascending: false });
        
        // Additional client-side filtering to ensure exact match (case-insensitive)
        const filteredAssignments = (assignments || []).filter(assignment => {
            const emailToCheck = isAgent ? assignment.employee_email : assignment.auditor_email;
            return emailToCheck && emailToCheck.toLowerCase().trim() === currentUserEmail;
        });
        
        if (assignmentsError) {
            console.error('Error loading assignments for stats:', assignmentsError);
            return;
        }
        
        const allAssignments = filteredAssignments;
        const totalAssigned = allAssignments.length;
        const completed = allAssignments.filter(a => a.status === 'completed').length;
        const inProgress = allAssignments.filter(a => a.status === 'in_progress').length;
        const pending = allAssignments.filter(a => a.status === 'pending').length;
        const remaining = pending + inProgress;
        
        // Calculate percentage
        const percentage = totalAssigned > 0 ? Math.round((completed / totalAssigned) * 100) : 0;
        
        // Calculate working days remaining (assuming 5 working days per week)
        const today = new Date();
        const endOfWeek = new Date(today);
        endOfWeek.setDate(today.getDate() + (5 - today.getDay())); // Friday
        const daysRemaining = Math.max(0, Math.ceil((endOfWeek - today) / (1000 * 60 * 60 * 24)));
        
        // Calculate average audit duration
        let avgDuration = 0;
        let avgDurationText = '-';
        
        try {
            // Get all scorecards to query audit tables
            const { data: scorecards, error: scError } = await window.supabaseClient
                .from('scorecards')
                .select('table_name')
                .eq('is_active', true);
            
            if (!scError && scorecards) {
                let totalDuration = 0;
                let auditCount = 0;
                
                // Query each scorecard table for audits by this user
                // Filter by employee_email if agent, otherwise by auditor_email
                const auditFilterField = isAgent ? 'employee_email' : 'auditor_email';
                for (const scorecard of scorecards) {
                    try {
                        const { data: audits, error } = await window.supabaseClient
                            .from(scorecard.table_name)
                            .select('audit_duration, ' + auditFilterField)
                            .not('audit_duration', 'is', null);
                        
                        if (!error && audits) {
                            // Filter by email (case-insensitive) on client side
                            const filteredAudits = audits.filter(audit => {
                                const emailToCheck = audit[auditFilterField];
                                return emailToCheck && emailToCheck.toLowerCase().trim() === currentUserEmail;
                            });
                            
                            filteredAudits.forEach(audit => {
                                // Handle duration conversion (new format: seconds, legacy format: minutes)
                                let durationInMinutes = 0;
                                if (typeof audit.audit_duration === 'number') {
                                    const value = audit.audit_duration;
                                    // If value is >= 1440 (24 hours in minutes), assume it's in seconds (new format)
                                    // Otherwise, assume it's already in minutes (legacy format)
                                    if (value >= 1440) {
                                        durationInMinutes = value / 60; // Convert seconds to minutes
                                    } else {
                                        durationInMinutes = value; // Already in minutes
                                    }
                                } else if (typeof audit.audit_duration === 'string') {
                                    // Try parsing as integer first
                                    const asInt = parseInt(audit.audit_duration);
                                    if (!isNaN(asInt)) {
                                        if (asInt >= 1440) {
                                            durationInMinutes = asInt / 60; // Convert seconds to minutes
                                        } else {
                                            durationInMinutes = asInt; // Already in minutes
                                        }
                                    } else {
                                        // Legacy format: time string (MM:SS or HH:MM:SS)
                                        const timeParts = audit.audit_duration.split(':');
                                        if (timeParts.length === 2) {
                                            // MM:SS format
                                            const minutes = parseInt(timeParts[0]) || 0;
                                            const seconds = parseInt(timeParts[1]) || 0;
                                            durationInMinutes = minutes + (seconds / 60);
                                        } else if (timeParts.length === 3) {
                                            // HH:MM:SS format
                                            const hours = parseInt(timeParts[0]) || 0;
                                            const minutes = parseInt(timeParts[1]) || 0;
                                            const seconds = parseInt(timeParts[2]) || 0;
                                            durationInMinutes = (hours * 60) + minutes + (seconds / 60);
                                        }
                                    }
                                }
                                
                                if (durationInMinutes > 0) {
                                    totalDuration += durationInMinutes; // Add minutes
                                    auditCount++;
                                }
                            });
                        }
                    } catch (err) {
                        console.warn(`Error getting duration from ${scorecard.table_name}:`, err);
                    }
                }
                
                if (auditCount > 0) {
                    avgDuration = totalDuration / auditCount; // Average in minutes
                    
                    // Format duration (avgDuration is in minutes)
                    if (avgDuration >= 60) {
                        const hours = Math.floor(avgDuration / 60);
                        const minutes = Math.round(avgDuration % 60);
                        avgDurationText = minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                    } else {
                        avgDurationText = `${Math.round(avgDuration)}m`;
                    }
                }
            }
        } catch (error) {
            console.error('Error calculating average duration:', error);
        }
        
        // Calculate reversal count for current user
        let reversalCount = 0;
        try {
            const { data: scorecards, error: scError } = await window.supabaseClient
                .from('scorecards')
                .select('table_name')
                .eq('is_active', true);
            
            if (!scError && scorecards) {
                // Filter by employee_email if agent, otherwise by auditor_email
                const reversalFilterField = isAgent ? 'employee_email' : 'auditor_email';
                for (const scorecard of scorecards) {
                    try {
                        const { data, error } = await window.supabaseClient
                            .from(scorecard.table_name)
                            .select('id, ' + reversalFilterField)
                            .not('reversal_requested_at', 'is', null);
                        
                        if (!error && data) {
                            // Filter by email (case-insensitive) on client side
                            const filteredReversals = data.filter(reversal => {
                                const emailToCheck = reversal[reversalFilterField];
                                return emailToCheck && emailToCheck.toLowerCase().trim() === currentUserEmail;
                            });
                            reversalCount += filteredReversals.length;
                        }
                    } catch (err) {
                        console.warn(`Error counting reversals in ${scorecard.table_name}:`, err);
                    }
                }
            }
        } catch (error) {
            console.error('Error calculating reversal count:', error);
        }
        
        // Update stat cards
        document.getElementById('statsAssignedCount').textContent = totalAssigned;
        document.getElementById('statsCompletedCount').textContent = completed;
        document.getElementById('statsTargetAchieved').textContent = `${percentage}% Target Achieved`;
        document.getElementById('statsRemainingCount').textContent = remaining;
        document.getElementById('statsInProgressCount').textContent = inProgress;
        document.getElementById('statsDaysRemaining').textContent = `${daysRemaining} working day${daysRemaining !== 1 ? 's' : ''} remaining`;
        document.getElementById('statsReversalCount').textContent = reversalCount;
        document.getElementById('statsAvgDuration').textContent = avgDurationText;
        document.getElementById('statsAvgDurationSubtitle').textContent = 'per audit';
        
    } catch (error) {
        console.error('Error updating your stats:', error);
    }
}

// ============================================================================
// Pending Audits System
// ============================================================================
let pendingAudits = [];
let isEditingPendingAudit = false;

// Pagination state for pending audits
let pendingCurrentPage = 1;
let pendingItemsPerPage = 5;
let pendingTotalPages = 1;
let currentEditingAuditId = null;
let currentAssignmentId = null; // Separate tracking for assignment vs audit editing
let showAllAudits = false; // Flag to track if showing all audits or just mine
let isEditingExistingAudit = false; // Flag for editing from audit reports
let currentEditingTableName = null; // Table name for the audit being edited
let currentSortOrder = 'name_asc'; // Current sort order for pending audits

// Filter state
let activeFilters = {
    startDate: null,
    endDate: null,
    status: '',
    scorecard: '',
    search: ''
};
let allPendingAudits = []; // Store all audits before filtering

// Toggle sort menu
function toggleSortMenu() {
    const sortMenu = document.getElementById('sortMenu');
    if (sortMenu) {
        const isVisible = sortMenu.style.display === 'block';
        sortMenu.style.display = isVisible ? 'none' : 'block';
        
        // Close menu when clicking outside
        if (!isVisible) {
            setTimeout(() => {
                document.addEventListener('click', function closeMenuOnOutsideClick(e) {
                    if (!sortMenu.contains(e.target) && e.target.id !== 'sortIconBtn') {
                        sortMenu.style.display = 'none';
                        document.removeEventListener('click', closeMenuOnOutsideClick);
                    }
                });
            }, 0);
        }
    }
}

// Make toggleSortMenu globally accessible
window.toggleSortMenu = toggleSortMenu;

// Toggle between pending/in_progress and completed audits for logged-in user
function toggleAllAuditsView() {
    showAllAudits = !showAllAudits;
    
    // Update button text and title
    const toggleBtn = document.getElementById('toggleBtnText');
    const title = document.getElementById('auditsViewTitle');
    
    if (showAllAudits) {
        toggleBtn.textContent = 'View Pending Only';
        title.textContent = 'My Completed Audits';
    } else {
        toggleBtn.textContent = 'Show Completed audits';
        title.textContent = 'My Assigned Audits';
    }
    
    // Reload audits with new view
    loadPendingAudits();
}

// Sort pending audits based on current sort order
function sortPendingAudits() {
    const sortBy = document.getElementById('auditSortBy');
    if (sortBy) {
        currentSortOrder = sortBy.value;
    }
    
    if (!pendingAudits || pendingAudits.length === 0) {
        return;
    }
    
    // Create a copy to avoid mutating the original array
    const sorted = [...pendingAudits];
    
    const [field, direction] = currentSortOrder.split('_');
    
    sorted.sort((a, b) => {
        let comparison = 0;
        
        switch(field) {
            case 'name':
                const nameA = (a.employee_name || '').toLowerCase();
                const nameB = (b.employee_name || '').toLowerCase();
                comparison = nameA.localeCompare(nameB);
                break;
                
            case 'status':
                // Status order: pending = 1, in_progress = 2
                const statusA = a.status === 'pending' ? 1 : (a.status === 'in_progress' ? 2 : 0);
                const statusB = b.status === 'pending' ? 1 : (b.status === 'in_progress' ? 2 : 0);
                comparison = statusA - statusB;
                break;
                
            case 'priority':
                // Priority: For now, we'll use a default priority of 0 if not defined
                // You can add a priority field to audit_assignments table later
                const priorityA = a.priority || 0;
                const priorityB = b.priority || 0;
                comparison = priorityA - priorityB;
                break;
                
            default:
                return 0;
        }
        
        // Apply direction (asc or desc)
        return direction === 'asc' ? comparison : -comparison;
    });
    
    // Update the pendingAudits array with sorted data
    pendingAudits = sorted;
    
    // Reset pagination to first page after sorting
    pendingCurrentPage = 1;
    
    // Re-display the sorted audits
    displayPendingAudits();
}

// Make sortPendingAudits accessible globally
window.sortPendingAudits = sortPendingAudits;

// View completed audit
window.viewCompletedAudit = function(auditId, scorecardId, tableName) {
    if (!auditId || !scorecardId || !tableName) {
        console.error('Missing required parameters for viewing audit:', { auditId, scorecardId, tableName });
        window.confirmationDialog.show({
            title: 'Error',
            message: 'Cannot view audit: Missing required information.',
            confirmText: 'OK',
            type: 'error'
        });
        return;
    }
    // Use same format as expert-audits.html for consistency
    window.location.href = `audit-view.html?id=${auditId}&scorecard=${scorecardId}&table=${tableName}`;
};

// ============================================================================
// ASSIGNED AUDITS DISPLAY CONFIGURATION
// ============================================================================
// Configure how assigned audits are displayed
const ASSIGNED_AUDITS_CONFIG = {
    // GROUPING SETTINGS
    // Set to true to group audits by employee (shows one row per employee with count)
    // Set to false to show individual audit rows (original behavior)
    groupByEmployee: true,
    
    // When grouped, show expandable/collapsible list of individual audits
    // Set to true to allow expanding to see individual audits
    // Set to false to show only summary (employee name + count)
    allowExpandCollapse: true,
    
    // CONVERSATION LINKING SETTINGS
    // Set to true to show conversation information and link
    // Set to false to hide conversation features
    showConversationLink: true,
    
    // When conversation_id exists, show a "View Conversation" button
    showViewConversationButton: true,
    
    // DISPLAY SETTINGS
    // Show count badge next to employee name when grouped
    showCountBadge: true,
    
    // Show status breakdown when grouped (e.g., "2 pending, 1 in progress")
    showStatusBreakdown: true,
    
    // DEFAULT EXPANDED STATE
    // When grouped, should groups be expanded by default?
    // true = all expanded, false = all collapsed, 'mixed' = remember user preference
    defaultExpandedState: false
};

// Storage key for expanded/collapsed state
const EXPANDED_STATE_STORAGE_KEY = 'assignedAuditsExpandedState';

// Track selected audit ID (single selection)
let selectedAuditId = null;

// ============================================================================
// ASSIGNED AUDITS HELPER FUNCTIONS
// ============================================================================

/**
 * Group audits by employee email
 * Returns an object with employee_email as key and grouped data as value
 */
async function groupAuditsByEmployee(audits) {
    const grouped = {};
    
    // First, collect all unique employee emails
    const employeeEmails = [...new Set(audits.map(audit => audit.employee_email).filter(Boolean))];
    
    // Fetch intercom_admin_alias for all employees in one query
    let aliasMap = {};
    if (employeeEmails.length > 0 && window.supabaseClient) {
        try {
            const { data: users, error } = await window.supabaseClient
                .from('users')
                .select('email, intercom_admin_alias')
                .in('email', employeeEmails.map(e => e.toLowerCase().trim()));
            
            if (!error && users) {
                users.forEach(user => {
                    const normalizedEmail = (user.email || '').toLowerCase().trim();
                    if (user.intercom_admin_alias) {
                        aliasMap[normalizedEmail] = user.intercom_admin_alias;
                    }
                });
            }
        } catch (error) {
            console.warn('⚠️ Error fetching admin aliases:', error);
        }
    }
    
    audits.forEach(audit => {
        // Use employee_email as the grouping key
        const key = (audit.employee_email || 'unknown').toLowerCase().trim();
        
        if (!grouped[key]) {
            const normalizedEmail = (audit.employee_email || '').toLowerCase().trim();
            grouped[key] = {
                employee_email: audit.employee_email,
                employee_name: audit.employee_name || audit.employee_email?.split('@')[0] || 'Unknown',
                intercom_admin_alias: aliasMap[normalizedEmail] || null,
                assignments: [],
                pending: 0,
                in_progress: 0,
                completed: 0,
                total: 0
            };
        }
        
        grouped[key].assignments.push(audit);
        grouped[key].total++;
        
        // Count by status
        if (audit.status === 'pending') {
            grouped[key].pending++;
        } else if (audit.status === 'in_progress') {
            grouped[key].in_progress++;
        } else if (audit.status === 'completed') {
            grouped[key].completed++;
        }
    });
    
    return grouped;
}

/**
 * Get expanded state for a specific employee
 */
function getExpandedState(employeeEmail) {
    try {
        const stored = localStorage.getItem(EXPANDED_STATE_STORAGE_KEY);
        if (!stored) return ASSIGNED_AUDITS_CONFIG.defaultExpandedState;
        
        const states = JSON.parse(stored);
        return states[employeeEmail] ?? ASSIGNED_AUDITS_CONFIG.defaultExpandedState;
    } catch (e) {
        return ASSIGNED_AUDITS_CONFIG.defaultExpandedState;
    }
}

/**
 * Set expanded state for a specific employee
 */
function setExpandedState(employeeEmail, isExpanded) {
    try {
        const stored = localStorage.getItem(EXPANDED_STATE_STORAGE_KEY);
        const states = stored ? JSON.parse(stored) : {};
        states[employeeEmail] = isExpanded;
        localStorage.setItem(EXPANDED_STATE_STORAGE_KEY, JSON.stringify(states));
    } catch (e) {
        console.warn('Failed to save expanded state:', e);
    }
}

/**
 * Build conversation link HTML if conversation_id exists
 */
function buildConversationLinkHTML(audit) {
    if (!ASSIGNED_AUDITS_CONFIG.showConversationLink) return '';
    
    // Show conversation ID or "No conversation" indicator
    if (audit.conversation_id) {
        const conversationId = String(audit.conversation_id).replace(/'/g, "\\'");
        const workspaceId = window.intercomConfig?.appId || 'aphmhtyj';
        const conversationUrl = `https://app.intercom.com/a/inbox/${workspaceId}/inbox/conversation/${conversationId}?view`;
        
        let html = '';
        
        if (ASSIGNED_AUDITS_CONFIG.showViewConversationButton) {
            html = `<span style="display: inline-flex; align-items: center; gap: 0.2425rem; margin-left: 0.3234rem;">
                <span style="font-size: 0.4043rem; color: #6b7280;">Conv:</span>
                <span style="font-family: 'Poppins', sans-serif; font-size: 0.4043rem; color: #2563eb; font-weight: 500;">${conversationId}</span>
                <button 
                    onclick="event.stopPropagation(); window.open('${conversationUrl}', '_blank', 'noopener,noreferrer')" 
                    style="padding: 0.1617rem 0.3234rem; background-color: #2563eb; color: white; border: none; border-radius: 0.1213rem; font-size: 0.3639rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s ease; white-space: nowrap;"
                    onmouseover="this.style.backgroundColor='#1d4ed8'"
                    onmouseout="this.style.backgroundColor='#2563eb'"
                    title="Open conversation in Intercom"
                >
                    View
                </button>
            </span>`;
        } else {
            // Just show conversation ID as text with copy button
            html = `<span style="display: inline-flex; align-items: center; gap: 0.2425rem; margin-left: 0.3234rem;">
                <span style="font-size: 0.4043rem; color: #6b7280;">Conv:</span>
                <span style="font-family: 'Poppins', sans-serif; font-size: 0.4043rem; color: #2563eb; font-weight: 500;">${conversationId}</span>
                <button 
                    onclick="event.stopPropagation(); copyToClipboard('${conversationId}', this);" 
                    style="padding: 0.0808rem; background: transparent; border: none; cursor: pointer; color: #6b7280; transition: all 0.2s; display: flex; align-items: center; justify-content: center;"
                    onmouseover="this.style.color='#2563eb'"
                    onmouseout="this.style.color='#6b7280'"
                    title="Copy conversation ID"
                >
                    <svg style="width: 0.75rem; height: 0.75rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                    </svg>
                </button>
            </span>`;
        }
        
        return html;
    } else {
        // Show "No conversation" indicator
        return `<span style="font-size: 0.4043rem; color: #9ca3af; margin-left: 0.3234rem; font-style: italic;">No conversation</span>`;
    }
}

/**
 * Build status breakdown text (e.g., "2 pending, 1 in progress")
 */
function buildStatusBreakdown(group) {
    if (!ASSIGNED_AUDITS_CONFIG.showStatusBreakdown) return '';
    
    const parts = [];
    if (group.pending > 0) parts.push(`${group.pending} pending`);
    if (group.in_progress > 0) parts.push(`${group.in_progress} in progress`);
    if (group.completed > 0) parts.push(`${group.completed} completed`);
    
    if (parts.length === 0) return '';
    return `<span style="font-size: 0.4043rem; color: #6b7280; margin-left: 0.3234rem;">(${parts.join(', ')})</span>`;
}

/**
 * Toggle expand/collapse for a grouped audit
 */
window.toggleAuditGroup = function(employeeEmail) {
    if (!ASSIGNED_AUDITS_CONFIG.allowExpandCollapse) return;
    
    const groupId = `auditGroup_${employeeEmail.replace(/[^a-zA-Z0-9]/g, '_')}`;
    const groupDiv = document.getElementById(groupId);
    
    if (!groupDiv) return;
    
    const isCurrentlyExpanded = groupDiv.style.display !== 'none';
    const newExpandedState = !isCurrentlyExpanded;
    
    groupDiv.style.display = newExpandedState ? 'block' : 'none';
    
    // Update expand button icon
    const expandButton = groupDiv.parentElement.querySelector('button[onclick*="toggleAuditGroup"]');
    if (expandButton) {
        expandButton.style.transform = newExpandedState ? 'rotate(90deg)' : 'rotate(0deg)';
        expandButton.title = newExpandedState ? 'Collapse' : 'Expand';
    }
    
    // Save state
    setExpandedState(employeeEmail, newExpandedState);
};

/**
 * Collapse all audit groups except the specified employee's group
 */
function collapseAllOtherGroups(activeEmployeeEmail) {
    if (!ASSIGNED_AUDITS_CONFIG.allowExpandCollapse) return;
    
    const normalizedActiveEmail = (activeEmployeeEmail || '').toLowerCase().trim();
    const pendingAuditsList = document.getElementById('pendingAuditsList');
    if (!pendingAuditsList) return;
    
    // Find all group cards
    const allGroupCards = pendingAuditsList.querySelectorAll('div[style*="background: #f9fafb"]');
    
    allGroupCards.forEach(card => {
        // Try to find the employee email associated with this card
        const cardText = card.textContent || '';
        const emailInCard = card.querySelector(`[data-email]`);
        const cardEmail = emailInCard ? (emailInCard.getAttribute('data-email') || '').toLowerCase().trim() : '';
        
        // Check if this card's text contains an email that matches
        let cardEmployeeEmail = null;
        if (cardEmail) {
            cardEmployeeEmail = cardEmail;
        } else {
            // Try to extract email from card content
            const emailPattern = /[\w\.-]+@[\w\.-]+\.\w+/gi;
            const matches = cardText.match(emailPattern);
            if (matches && matches.length > 0) {
                cardEmployeeEmail = matches[0].toLowerCase().trim();
            }
        }
        
        // Skip if this is the active employee's card
        if (cardEmployeeEmail && cardEmployeeEmail === normalizedActiveEmail) {
            return;
        }
        
        // Find the nested group div (the expandable content)
        const groupId = cardEmployeeEmail ? `auditGroup_${cardEmployeeEmail.replace(/[^a-zA-Z0-9]/g, '_')}` : null;
        if (groupId) {
            const groupDiv = document.getElementById(groupId);
            if (groupDiv) {
                // Collapse the group
                groupDiv.style.display = 'none';
                
                // Update expand button icon
                const expandButton = card.querySelector('button[onclick*="toggleAuditGroup"]');
                if (expandButton) {
                    expandButton.style.transform = 'rotate(0deg)';
                    expandButton.title = 'Expand';
                }
                
                // Save collapsed state
                if (cardEmployeeEmail) {
                    setExpandedState(cardEmployeeEmail, false);
                }
            }
        }
    });
}

/**
 * Expand the audit group for the specified employee
 */
function expandGroupForEmployee(employeeEmail) {
    if (!ASSIGNED_AUDITS_CONFIG.allowExpandCollapse) return;
    
    const normalizedEmail = (employeeEmail || '').toLowerCase().trim();
    const groupId = `auditGroup_${normalizedEmail.replace(/[^a-zA-Z0-9]/g, '_')}`;
    const groupDiv = document.getElementById(groupId);
    
    if (!groupDiv) return;
    
    // Expand the group
    groupDiv.style.display = 'block';
    
    // Update expand button icon
    const pendingAuditsList = document.getElementById('pendingAuditsList');
    if (pendingAuditsList) {
        // Find the card that contains this group
        const card = groupDiv.closest('div[style*="background: #f9fafb"]');
        if (card) {
            const expandButton = card.querySelector('button[onclick*="toggleAuditGroup"]');
            if (expandButton) {
                expandButton.style.transform = 'rotate(90deg)';
                expandButton.title = 'Collapse';
            }
        }
    }
    
    // Save expanded state
    setExpandedState(employeeEmail, true);
}

/**
 * Highlight the group card for the specified employee with green border
 */
function highlightGroupCardForEmployee(employeeEmail) {
    const normalizedEmail = (employeeEmail || '').toLowerCase().trim();
    const pendingAuditsList = document.getElementById('pendingAuditsList');
    if (!pendingAuditsList) return;
    
    // Find all group cards
    const allGroupCards = pendingAuditsList.querySelectorAll('div[style*="background: #f9fafb"]');
    
    allGroupCards.forEach(card => {
        // Try to find the employee email associated with this card
        const emailInCard = card.querySelector(`[data-email]`);
        const cardEmail = emailInCard ? (emailInCard.getAttribute('data-email') || '').toLowerCase().trim() : '';
        
        // Check if this card's text contains an email that matches
        let cardEmployeeEmail = null;
        if (cardEmail) {
            cardEmployeeEmail = cardEmail;
        } else {
            const cardText = card.textContent || '';
            const emailPattern = /[\w\.-]+@[\w\.-]+\.\w+/gi;
            const matches = cardText.match(emailPattern);
            if (matches && matches.length > 0) {
                cardEmployeeEmail = matches[0].toLowerCase().trim();
            }
        }
        
        // Apply green highlighting if this is the active employee's card
        if (cardEmployeeEmail && cardEmployeeEmail === normalizedEmail) {
            // Store original border color if not already stored
            if (!card.dataset.originalBorder) {
                const currentStyle = card.getAttribute('style') || '';
                const borderMatch = currentStyle.match(/border:\s*([^;]+)/);
                if (borderMatch) {
                    card.dataset.originalBorder = borderMatch[1];
                } else {
                    card.dataset.originalBorder = '0.0405rem solid #e5e7eb';
                }
            }
            
            // Apply green border
            const currentStyle = card.getAttribute('style') || '';
            const updatedStyle = currentStyle.replace(
                /border:\s*[^;]+/,
                'border: 0.0405rem solid #1A733E'
            );
            if (!updatedStyle.includes('border:')) {
                card.setAttribute('style', currentStyle + '; border: 0.0405rem solid #1A733E;');
            } else {
                card.setAttribute('style', updatedStyle);
            }
            
            // Also add a subtle green background tint
            const bgStyle = card.getAttribute('style') || '';
            if (!bgStyle.includes('background:')) {
                card.setAttribute('style', bgStyle + '; background: #f0fdf4;');
            } else {
                card.setAttribute('style', bgStyle.replace(
                    /background:\s*[^;]+/,
                    'background: #f0fdf4'
                ));
            }
        } else {
            // Remove green highlighting from other cards
            if (card.dataset.originalBorder) {
                const currentStyle = card.getAttribute('style') || '';
                card.setAttribute('style', currentStyle.replace(
                    /border:\s*[^;]+/,
                    `border: ${card.dataset.originalBorder}`
                ));
            }
            
            // Restore original background
            const currentStyle = card.getAttribute('style') || '';
            if (currentStyle.includes('background: #f0fdf4')) {
                card.setAttribute('style', currentStyle.replace(
                    /background:\s*#f0fdf4/,
                    'background: #f9fafb'
                ));
            }
        }
    });
}

/**
 * Remove green highlighting from all group cards
 */
function removeHighlightFromAllGroupCards() {
    const pendingAuditsList = document.getElementById('pendingAuditsList');
    if (!pendingAuditsList) return;
    
    const allGroupCards = pendingAuditsList.querySelectorAll('div[style*="background: #f9fafb"], div[style*="background: #f0fdf4"]');
    
    allGroupCards.forEach(card => {
        // Restore original border if stored
        if (card.dataset.originalBorder) {
            const currentStyle = card.getAttribute('style') || '';
            card.setAttribute('style', currentStyle.replace(
                /border:\s*[^;]+/,
                `border: ${card.dataset.originalBorder}`
            ));
            delete card.dataset.originalBorder;
        }
        
        // Restore original background
        const currentStyle = card.getAttribute('style') || '';
        if (currentStyle.includes('background: #f0fdf4')) {
            card.setAttribute('style', currentStyle.replace(
                /background:\s*#f0fdf4/,
                'background: #f9fafb'
            ));
        }
    });
}

/**
 * Select a nested audit (single selection)
 */
window.selectNestedAudit = function(auditId) {
    // If clicking the same audit, deselect it
    if (selectedAuditId === auditId) {
        selectedAuditId = null;
    } else {
        selectedAuditId = auditId;
    }
    
    // Update all nested audit cards to reflect selection state
    const allNestedCards = document.querySelectorAll('.nested-audit-card');
    allNestedCards.forEach(card => {
        const cardAuditId = card.getAttribute('data-audit-id');
        const radioButton = card.querySelector(`input[type="radio"][value="${cardAuditId}"]`);
        const isSelected = selectedAuditId === cardAuditId;
        
        if (isSelected) {
            // Selected state
            card.style.background = '#eff6ff';
            card.style.border = '0.0405rem solid #2563eb';
            card.style.boxShadow = '0 0 0 0.0808rem rgba(37, 99, 235, 0.1)';
            if (radioButton) radioButton.checked = true;
        } else {
            // Unselected state
            card.style.background = '#ffffff';
            card.style.border = '0.0304rem solid #e5e7eb';
            card.style.boxShadow = 'none';
            if (radioButton) radioButton.checked = false;
        }
    });
    
    console.log('Selected audit ID:', selectedAuditId);
    
    // Update all audit buttons in the pulled conversations list
    updateAuditButtonsState();
};

/**
 * Update the state of all audit buttons in the pulled conversations list
 * based on whether an audit is selected
 */
function updateAuditButtonsState() {
    const auditButtons = document.querySelectorAll('.start-audit-from-conversation-btn');
    auditButtons.forEach(button => {
        if (selectedAuditId) {
            // Enable button
            button.disabled = false;
            button.style.color = '#1A733E';
            button.style.background = '#d1fae5';
            button.style.cursor = 'pointer';
            button.style.opacity = '1';
            button.title = 'Start audit from conversation';
            // Re-attach hover handlers
            button.onmouseover = function() {
                this.style.background = '#a7f3d0';
            };
            button.onmouseout = function() {
                this.style.background = '#d1fae5';
            };
        } else {
            // Disable button
            button.disabled = true;
            button.style.color = '#9ca3af';
            button.style.background = '#f3f4f6';
            button.style.cursor = 'not-allowed';
            button.style.opacity = '0.6';
            button.title = 'Please select an assigned audit first';
            // Remove hover handlers
            button.onmouseover = null;
            button.onmouseout = null;
        }
    });
}

// Load pending audits for current user from audit_assignments table
async function loadPendingAudits() {
    try {
        // Get current user info
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const currentUserEmail = (userInfo.email || '').toLowerCase().trim();
        const currentUserRole = userInfo.role || '';
        const isAgent = currentUserRole === 'Employee';
        
        if (!currentUserEmail) {
            return;
        }
        
        // Determine status filter
        const statusFilter = showAllAudits ? ['completed'] : ['pending', 'in_progress'];
        
        // Load assigned audits from audit_assignments table with scorecard info
        // Filter by employee_email if agent, otherwise by auditor_email
        // showAllAudits controls whether to show completed or pending/in_progress
        const filterField = isAgent ? 'employee_email' : 'auditor_email';
        let query = window.supabaseClient
            .from('audit_assignments')
            .select(`
                *,
                scorecards:scorecard_id (
                    id,
                    name,
                    table_name
                )
            `)
            .eq(filterField, currentUserEmail)
            .order('created_at', { ascending: false });
        
        
        // If showing completed audits, filter by status
        if (showAllAudits) {
            query = query.eq('status', 'completed');
        } else {
            query = query.in('status', statusFilter);
        }
        
        const { data, error } = await query;
        
        if (error) {
            console.error('Error loading assignments:', error);
            throw error;
        }
        
        // Normalize and filter client-side for exact match (case-insensitive)
        // This ensures we match emails correctly regardless of case differences
        const normalizedCurrentEmail = currentUserEmail.toLowerCase().trim();
        const finalFiltered = (data || []).filter(assignment => {
            const emailToCheck = isAgent ? assignment.employee_email : assignment.auditor_email;
            if (!emailToCheck) return false;
            return emailToCheck.toLowerCase().trim() === normalizedCurrentEmail;
        });
        
        allPendingAudits = finalFiltered; // Store all audits
        
        // Apply filters
        applyFiltersToAudits();
        
        // Apply sorting
        sortPendingAudits();
        
        // Reset pagination to first page when audits reload
        pendingCurrentPage = 1;
        
        // Clear selection when audits reload
        selectedAuditId = null;
        
        // Display pending audits
        displayPendingAudits();
        
        // Update your stats
        await updateYourStats();
        
    } catch (error) {
        console.error('Error loading pending audits:', error);
    }
}

// Display pending audits in the UI
async function displayPendingAudits() {
    const section = document.getElementById('pendingAuditsSection');
    const list = document.getElementById('pendingAuditsList');
    const countBadge = document.getElementById('pendingCount');
    const paginationContainer = document.getElementById('pendingAuditsPagination');
    
    // Don't show the section if we're currently editing an audit
    if (!isEditingPendingAudit) {
        section.style.display = 'block';
    }
    
    // Update count badge - show total audits or total employees based on grouping
    if (ASSIGNED_AUDITS_CONFIG.groupByEmployee) {
        const grouped = groupAuditsByEmployee(pendingAudits);
        countBadge.textContent = Object.keys(grouped).length; // Count of unique employees
    } else {
        countBadge.textContent = pendingAudits.length; // Count of total audits
    }
    
    // Show empty state if no audits
    if (pendingAudits.length === 0) {
        const emptyStateMessage = showAllAudits 
            ? 'No completed audits found.'
            : 'No audits have been assigned to you yet.';
        
        list.innerHTML = `
            <div style="text-align: center; padding: 1.9406rem 0.9704rem; color: #6b7280;">
                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin: 0 auto 0.6469rem; opacity: 0.4;">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="12" y1="18" x2="12" y2="12"/>
                    <line x1="9" y1="15" x2="15" y2="15"/>
                </svg>
                <p style="font-size: 0.5659rem; font-weight: 500; color: #374151; margin: 0 0 0.3234rem;">${emptyStateMessage}</p>
                <p style="font-size: 0.4852rem; color: #9ca3af; margin: 0;">Audits will appear here once they are assigned to you.</p>
            </div>
        `;
        if (paginationContainer) paginationContainer.style.display = 'none';
        return;
    }
    
    // Get current user info to check if agent
    const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
    const userRole = userInfo.role || '';
    const isAgent = userRole === 'Employee';
    
    // Check if we should group by employee
    if (ASSIGNED_AUDITS_CONFIG.groupByEmployee) {
        // GROUPED VIEW
        const grouped = await groupAuditsByEmployee(pendingAudits);
        const groupedArray = Object.values(grouped);
        
        // Calculate pagination for groups
        pendingTotalPages = Math.ceil(groupedArray.length / pendingItemsPerPage);
        if (pendingCurrentPage > pendingTotalPages && pendingTotalPages > 0) {
            pendingCurrentPage = pendingTotalPages;
        }
        if (pendingCurrentPage < 1) {
            pendingCurrentPage = 1;
        }
        
        // Get paginated groups
        const startIndex = (pendingCurrentPage - 1) * pendingItemsPerPage;
        const endIndex = startIndex + pendingItemsPerPage;
        const paginatedGroups = groupedArray.slice(startIndex, endIndex);
        
        list.innerHTML = '';
        
        paginatedGroups.forEach(group => {
            const isExpanded = getExpandedState(group.employee_email);
            const groupCard = createGroupedAuditCard(group, isAgent, isExpanded);
            list.appendChild(groupCard);
        });
        
        // Store original conversation ID values for inputs and add event listeners
        setTimeout(() => {
            const conversationInputs = list.querySelectorAll('input[id^="conversationIdInput_"]');
            conversationInputs.forEach(input => {
                // Store original value
                input.setAttribute('data-original-value', input.value || '');
                
                // Add Enter key support
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur(); // This will trigger onchange
                    }
                });
            });
        }, 50);
        
        // Add drag-and-drop event listeners to nested audit cards
        setTimeout(() => {
            const nestedCards = list.querySelectorAll('.nested-audit-card[data-drop-target="true"]');
            nestedCards.forEach(card => {
                // Prevent default drag behavior on the card itself
                card.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    e.dataTransfer.dropEffect = 'move';
                    // Add visual feedback
                    if (!card.classList.contains('drag-over')) {
                        card.classList.add('drag-over');
                        card.style.backgroundColor = '#eff6ff';
                        card.style.borderColor = '#2563eb';
                    }
                });
                
                card.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    // Remove visual feedback
                    card.classList.remove('drag-over');
                    const isSelected = selectedAuditId === card.getAttribute('data-audit-id');
                    if (!isSelected) {
                        card.style.backgroundColor = '';
                        card.style.borderColor = '';
                    }
                });
                
                card.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Remove visual feedback
                    card.classList.remove('drag-over');
                    const isSelected = selectedAuditId === card.getAttribute('data-audit-id');
                    if (!isSelected) {
                        card.style.backgroundColor = '';
                        card.style.borderColor = '';
                    }
                    
                    const auditId = card.getAttribute('data-audit-id');
                    const conversationData = e.dataTransfer.getData('application/json');
                    
                    if (conversationData && auditId) {
                        try {
                            const conversation = JSON.parse(conversationData);
                            await linkConversationToAudit(conversation, auditId);
                        } catch (error) {
                            console.error('Error parsing conversation data:', error);
                            await window.confirmationDialog.show({
                                title: 'Error',
                                message: 'Failed to link conversation: ' + error.message,
                                confirmText: 'OK',
                                type: 'error'
                            });
                        }
                    }
                });
            });
        }, 100);
        
        // Add event listeners for pull conversations buttons in group headers AND nested cards
        setTimeout(() => {
            const pullBtns = list.querySelectorAll('.pull-conversations-btn, .pull-conversations-btn-group');
            pullBtns.forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const email = this.getAttribute('data-email');
                    const name = this.getAttribute('data-name');
                    if (window.pullConversationsForEmployee && typeof window.pullConversationsForEmployee === 'function') {
                        window.pullConversationsForEmployee(email, name);
                    } else {
                        console.error('❌ pullConversationsForEmployee function not found on window');
                        alert('Function not loaded. Please refresh the page.');
                    }
                });
            });
        }, 0);
        
    } else {
        // INDIVIDUAL VIEW (Original behavior)
    // Calculate pagination
    pendingTotalPages = Math.ceil(pendingAudits.length / pendingItemsPerPage);
    if (pendingCurrentPage > pendingTotalPages && pendingTotalPages > 0) {
        pendingCurrentPage = pendingTotalPages;
    }
    if (pendingCurrentPage < 1) {
        pendingCurrentPage = 1;
    }
    
    // Get paginated audits
    const startIndex = (pendingCurrentPage - 1) * pendingItemsPerPage;
    const endIndex = startIndex + pendingItemsPerPage;
    const paginatedAudits = pendingAudits.slice(startIndex, endIndex);
    
    // Fetch admin aliases for individual cards
    const employeeEmails = [...new Set(paginatedAudits.map(audit => audit.employee_email).filter(Boolean))];
    let aliasMap = {};
    if (employeeEmails.length > 0 && window.supabaseClient) {
        try {
            const { data: users, error } = await window.supabaseClient
                .from('users')
                .select('email, intercom_admin_alias')
                .in('email', employeeEmails.map(e => e.toLowerCase().trim()));
            
            if (!error && users) {
                users.forEach(user => {
                    const normalizedEmail = (user.email || '').toLowerCase().trim();
                    if (user.intercom_admin_alias) {
                        aliasMap[normalizedEmail] = user.intercom_admin_alias;
                    }
                });
            }
        } catch (error) {
            console.warn('⚠️ Error fetching admin aliases for individual cards:', error);
        }
    }
    
    list.innerHTML = '';
    
        paginatedAudits.forEach(audit => {
            // Add alias to audit object for display
            const normalizedEmail = (audit.employee_email || '').toLowerCase().trim();
            audit.intercom_admin_alias = aliasMap[normalizedEmail] || null;
            const auditCard = createIndividualAuditCard(audit, isAgent);
            
            // Add hover effects
            auditCard.onmouseenter = () => {
                auditCard.style.borderColor = '#1A733E';
                auditCard.style.backgroundColor = '#ffffff';
            };
            
            auditCard.onmouseleave = () => {
                auditCard.style.borderColor = '#e5e7eb';
                auditCard.style.backgroundColor = '#f9fafb';
            };
            
            // Add event listener to pull conversations button
            const displayEmail = isAgent ? (audit.auditor_email || 'No email') : (audit.employee_email || 'No email');
            if (displayEmail && displayEmail !== 'No email') {
                const pullBtn = auditCard.querySelector('.pull-conversations-btn');
                if (pullBtn) {
                    pullBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const email = this.getAttribute('data-email');
                        const name = this.getAttribute('data-name');
                        if (window.pullConversationsForEmployee && typeof window.pullConversationsForEmployee === 'function') {
                            window.pullConversationsForEmployee(email, name);
                        } else {
                            console.error('❌ pullConversationsForEmployee function not found on window');
                            alert('Function not loaded. Please refresh the page.');
                        }
                    });
                }
            }
            
            list.appendChild(auditCard);
        });
    }
    
    // Update pagination UI
    updatePendingPaginationUI();
}

/**
 * Create a grouped audit card (one employee with multiple audits)
 */
function createGroupedAuditCard(group, isAgent, isExpanded) {
    const card = document.createElement('div');
    const displayName = group.employee_name || 'Unknown Employee';
    const displayEmail = group.employee_email || 'No email';
    const adminAlias = group.intercom_admin_alias || null;
    
    // Count badge HTML
    const countBadgeHTML = ASSIGNED_AUDITS_CONFIG.showCountBadge 
        ? `<span style="background-color: #1A733E; color: white; padding: 0.0808rem 0.2425rem; border-radius: 0.1617rem; font-size: 0.4043rem; font-weight: 600; margin-left: 0.3234rem;">${group.total}</span>`
        : '';
    
    // Status breakdown HTML
    const statusBreakdownHTML = buildStatusBreakdown(group);
    
    // Expand/collapse button
    const expandButtonHTML = ASSIGNED_AUDITS_CONFIG.allowExpandCollapse
        ? `<button 
            onclick="event.stopPropagation(); toggleAuditGroup('${escapeHtml(displayEmail).replace(/'/g, "\\'")}')" 
            style="background: none; border: none; padding: 0.1617rem; cursor: pointer; color: #6b7280; transition: transform 0.2s; transform: rotate(${isExpanded ? '90deg' : '0deg'});"
            title="${isExpanded ? 'Collapse' : 'Expand'}"
        >
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
        </button>`
        : '';
    
    card.innerHTML = `
        <div style="background: #f9fafb; border: 0.0405rem solid #e5e7eb; border-radius: 0.1617rem; padding: 0.4852rem; margin-bottom: 0.3234rem;">
            <!-- Group Header -->
            <div style="display: flex; align-items: center; justify-content: space-between; gap: 0.4852rem;">
                <div style="display: flex; align-items: center; gap: 0.4852rem; flex: 1; cursor: pointer;" onclick="toggleAuditGroup('${escapeHtml(displayEmail).replace(/'/g, "\\'")}')">
                    ${expandButtonHTML}
                    <div style="width: 1.6171rem; height: 1.6171rem; border-radius: 0.1617rem; background: #1A733E; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.5659rem; flex-shrink: 0;">
                        ${getInitials(displayName)}
                    </div>
                    <div style="flex: 1; min-width: 0;">
                        <div style="display: flex; align-items: center; gap: 0.3234rem; flex-wrap: wrap;">
                            <h4 style="margin: 0; font-size: 0.5659rem; font-weight: 600; color: #1f2937;">
                                ${escapeHtml(displayName)}
                            </h4>
                            ${adminAlias ? `<span style="font-size: 0.4852rem; color: #1A733E; font-weight: 500; background: #f0fdf4; padding: 0.0808rem 0.2425rem; border-radius: 0.1617rem; border: 0.0304rem solid #86efac; white-space: nowrap;" title="Intercom Admin Alias">${escapeHtml(adminAlias)}</span>` : ''}
                            ${countBadgeHTML}
                            ${statusBreakdownHTML}
                        </div>
                        <p style="margin: 0.1617rem 0 0 0; font-size: 0.4852rem; color: #6b7280;">
                            ${escapeHtml(displayEmail)}
                        </p>
                    </div>
                </div>
                ${displayEmail && displayEmail !== 'No email' ? `
                    <div style="flex-shrink: 0; display: flex; gap: 0.2425rem;">
                        <button 
                            class="pull-conversations-btn-group"
                            data-email="${escapeHtml(displayEmail)}"
                            data-name="${escapeHtml(displayName)}"
                            onclick="event.stopPropagation();"
                            style="padding: 0.2425rem 0.4852rem; background-color: #f0fdf4; color: #1A733E; border: 0.0304rem solid #1A733E; border-radius: 0.1617rem; font-size: 0.4447rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; display: flex; align-items: center; gap: 0.2425rem;"
                            onmouseover="this.style.backgroundColor='#dcfce7'; this.style.borderColor='#15582E'; this.style.color='#15582E';"
                            onmouseout="this.style.backgroundColor='#f0fdf4'; this.style.borderColor='#1A733E'; this.style.color='#1A733E';"
                            title="Pull conversations for ${escapeHtml(displayName)}"
                        >
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                <polyline points="7 10 12 15 17 10"/>
                                <line x1="12" y1="15" x2="12" y2="3"/>
                            </svg>
                            <span>Pull Conversations</span>
                        </button>
                        <button 
                            class="run-ai-audit-btn-group run-ai-audit-btn"
                            data-email="${escapeHtml(displayEmail)}"
                            data-name="${escapeHtml(displayName)}"
                            onclick="event.stopPropagation(); showComingSoonDialog('${escapeHtml(displayName)}');"
                            title="Run AI Audit for ${escapeHtml(displayName)}"
                        >
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 2L13.09 8.26L20 9L13.09 9.74L12 16L10.91 9.74L4 9L10.91 8.26L12 2Z"/>
                                <path d="M19 19L20.09 21.26L23 22L20.09 22.74L19 25L17.91 22.74L15 22L17.91 21.26L19 19Z"/>
                                <path d="M5 19L6.09 21.26L9 22L6.09 22.74L5 25L3.91 22.74L1 22L3.91 21.26L5 19Z"/>
                            </svg>
                            <span>Run AI Audit</span>
                        </button>
                    </div>
                ` : ''}
            </div>
            
            <!-- Individual Audits (shown when expanded) -->
            <div id="auditGroup_${escapeHtml(displayEmail).replace(/[^a-zA-Z0-9]/g, '_')}" style="display: ${isExpanded ? 'block' : 'none'}; margin-top: 0.4852rem; padding-top: 0.4852rem; border-top: 0.0405rem solid #e5e7eb;">
                ${group.assignments.map(audit => {
    const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
    const userRole = userInfo.role || '';
    const isAgent = userRole === 'Employee';
                    // Add alias to audit object for nested cards
                    if (!isAgent && adminAlias && !audit.intercom_admin_alias) {
                        audit.intercom_admin_alias = adminAlias;
                    }
                    return createIndividualAuditCardHTML(audit, isAgent, true); // true = is nested
                }).join('')}
            </div>
        </div>
    `;
    
    return card;
}

/**
 * Create an individual audit card
 */
function createIndividualAuditCard(audit, isAgent) {
    const card = document.createElement('div');
    card.innerHTML = createIndividualAuditCardHTML(audit, isAgent, false);
    return card;
}

/**
 * Generate HTML for individual audit card
 * @param {Object} audit - The audit assignment object
 * @param {boolean} isAgent - Whether current user is an agent
 * @param {boolean} isNested - Whether this card is nested inside a group
 */
function createIndividualAuditCardHTML(audit, isAgent, isNested) {
        const displayName = isAgent ? (audit.auditor_email || 'Unknown Auditor') : (audit.employee_name || 'Unknown Employee');
        const displayEmail = isAgent ? (audit.auditor_email || 'No email') : (audit.employee_email || 'No email');
        const adminAlias = isAgent ? null : (audit.intercom_admin_alias || null);
        
        // Get conversation ID early to check if buttons should be shown
        const conversationId = audit.conversation_id ? String(audit.conversation_id) : null;
        
    // Status badge - larger for nested cards for better visibility
        let statusBadge = '';
        let actionButton = '';
        const canEdit = !isAgent;
        const badgeSize = isNested ? '0.4852rem' : '0.4447rem';
        const badgePadding = isNested ? '0.1617rem 0.4043rem' : '0.0808rem 0.3234rem';
        
        if (audit.status === 'completed') {
            // Status chip - very light greenish indicator for completed (pill-shaped)
            statusBadge = `<span style="background-color: #d1fae5; color: #047857; padding: ${isNested ? '0.1617rem 0.4852rem' : badgePadding}; border-radius: 9999px; font-size: ${isNested ? '0.4852rem' : badgeSize}; font-weight: 500; white-space: nowrap; display: inline-flex; align-items: center; justify-content: center; height: 1.2935rem;">Completed</span>`;
            const auditId = audit.audit_id ? String(audit.audit_id).replace(/'/g, "\\'") : '';
            const scorecardId = audit.scorecard_id ? String(audit.scorecard_id).replace(/'/g, "\\'") : '';
            const tableName = audit.scorecards?.table_name ? String(audit.scorecards.table_name).replace(/'/g, "\\'") : '';
            
            if (auditId && scorecardId && tableName) {
                actionButton = `<button 
                    onclick="event.stopPropagation(); viewCompletedAudit('${auditId}', '${scorecardId}', '${tableName}')" 
                    style="padding: ${isNested ? '0.2425rem 0.4043rem' : '0.3234rem 0.6469rem'}; background-color: #1A733E; color: white; border: none; border-radius: ${isNested ? '0.2425rem' : '0.1617rem'}; font-size: ${isNested ? '0.4447rem' : '0.4852rem'}; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; height: ${isNested ? '1.6169rem' : 'auto'}; display: flex; align-items: center;"
                    onmouseover="this.style.backgroundColor='#15582E'"
                    onmouseout="this.style.backgroundColor='#1A733E'"
                >
                    View Details
                </button>`;
            }
        } else if (audit.status === 'in_progress') {
            // Status chip - very light purple indicator for in progress (pill-shaped)
            statusBadge = `<span style="background-color: #e9d5ff; color: #6b21a8; padding: ${isNested ? '0.1617rem 0.4852rem' : badgePadding}; border-radius: 9999px; font-size: ${isNested ? '0.4852rem' : badgeSize}; font-weight: 500; white-space: nowrap; display: inline-flex; align-items: center; justify-content: center; height: 1.2935rem;">In Progress</span>`;
            if (canEdit && conversationId) {
                actionButton = `<button 
                    onclick="event.stopPropagation(); navigateToAssignment('${audit.id}')" 
                    style="padding: ${isNested ? '0.2425rem 0.4043rem' : '0.3234rem 0.6469rem'}; background-color: #1A733E; color: white; border: none; border-radius: ${isNested ? '0.2425rem' : '0.1617rem'}; font-size: ${isNested ? '0.4447rem' : '0.4852rem'}; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; height: ${isNested ? '1.6169rem' : 'auto'}; display: flex; align-items: center;"
                    onmouseover="this.style.backgroundColor='#15582E'"
                    onmouseout="this.style.backgroundColor='#1A733E'"
                >
                    Continue
                </button>`;
            }
        } else {
            // Status chip - very light red indicator for pending (pill-shaped)
            statusBadge = `<span style="background-color: #fee2e2; color: #991b1b; padding: ${isNested ? '0.1617rem 0.4852rem' : badgePadding}; border-radius: 9999px; font-size: ${isNested ? '0.4852rem' : badgeSize}; font-weight: 500; white-space: nowrap; display: inline-flex; align-items: center; justify-content: center; height: 1.2935rem;">Pending</span>`;
            if (canEdit && conversationId) {
                // Check if conversations section is visible for this employee - if so, hide Start Audit button in nested cards
                const pullConversationsSection = document.getElementById('pullConversationsSection');
                const isConversationsVisible = pullConversationsSection && pullConversationsSection.style.display !== 'none';
                const isEmployeeConversationsVisible = isConversationsVisible && pullConversationsAdminEmail && 
                    (audit.employee_email || '').toLowerCase().trim() === (pullConversationsAdminEmail || '').toLowerCase().trim();
                
                // Hide Start Audit button in nested cards when conversations are visible for this employee
                const shouldHideStartButton = isNested && isEmployeeConversationsVisible;
                
                actionButton = `<button 
                    class="nested-start-audit-btn"
                    data-audit-id="${audit.id}"
                    onclick="event.stopPropagation(); navigateToAssignment('${audit.id}')" 
                    style="padding: ${isNested ? '0.2425rem 0.4043rem' : '0.3234rem 0.6469rem'}; background-color: #1A733E; color: white; border: none; border-radius: ${isNested ? '0.2425rem' : '0.1617rem'}; font-size: ${isNested ? '0.4447rem' : '0.4852rem'}; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; height: ${isNested ? '1.6169rem' : 'auto'}; display: ${shouldHideStartButton ? 'none' : 'flex'}; align-items: center;"
                    onmouseover="this.style.backgroundColor='#15582E'"
                    onmouseout="this.style.backgroundColor='#1A733E'"
                >
                    Start Audit
                </button>`;
            }
        }
        
    // Conversation link
    const conversationLinkHTML = buildConversationLinkHTML(audit);
    
    // Click handler
        const clickHandler = audit.status === 'completed' && audit.audit_id 
            ? `onclick="event.stopPropagation(); viewCompletedAudit('${audit.audit_id}', '${audit.scorecard_id}', '${audit.scorecards?.table_name || ''}')"`
            : canEdit ? `onclick="navigateToAssignment('${audit.id}')"` : '';
        
    // Check if this audit is selected
    const isSelected = selectedAuditId === audit.id;
    
    // Nested styling - professional card design matching reference
    // Add selected state styling for nested cards
    let cardStyle = '';
    if (isNested) {
        if (isSelected) {
            cardStyle = 'background: #ffffff; border: 0.0405rem solid #2563eb; border-radius: 0.3234rem; margin-bottom: 0.4043rem; box-shadow: 0 0.0808rem 0.2425rem rgba(37, 99, 235, 0.15), 0 0 0 0.0808rem rgba(37, 99, 235, 0.1);';
        } else {
            cardStyle = 'background: #ffffff; border: 0.0304rem solid #e5e7eb; border-radius: 0.3234rem; margin-bottom: 0.4043rem; box-shadow: 0 0.0405rem 0.1213rem rgba(0, 0, 0, 0.05);';
        }
    } else {
        cardStyle = 'background: #f9fafb; border: 0.0405rem solid #e5e7eb; border-radius: 0.1617rem; padding: 0.4852rem; transition: all 0.2s ease;';
    }
    
    // Radio button for nested cards (single selection) - compact inline version
    const radioButtonHTML = isNested ? `
        <input 
            type="radio" 
            name="selectedAudit" 
            id="auditRadio_${audit.id}"
            value="${audit.id}"
            ${isSelected ? 'checked' : ''}
            onclick="event.stopPropagation(); selectNestedAudit('${audit.id}');"
            style="width: 0.8086rem; height: 0.8086rem; cursor: pointer; accent-color: #2563eb; flex-shrink: 0;"
        />
    ` : '';
    
    // For nested cards, create a professional card layout matching the reference design
    if (isNested) {
        // conversationId is already defined at the top of the function
        const workspaceId = window.intercomConfig?.appId || 'aphmhtyj';
        const conversationUrl = conversationId ? `https://app.intercom.com/a/inbox/${workspaceId}/inbox/conversation/${conversationId}?view` : '';
        
        // Format assignment ID (show first 8 chars for display)
        const assignmentIdDisplay = audit.id ? `#${String(audit.id).substring(0, 8).toUpperCase()}` : '#N/A';
        
        // Get date to display (completed date if available, otherwise created date)
        const displayDate = audit.completed_at ? audit.completed_at : audit.created_at;
        let dateFormatted = 'N/A';
        if (displayDate) {
            const dateObj = typeof displayDate === 'string' ? new Date(displayDate) : displayDate;
            // Format as "DD MMM YYYY" (e.g., "23 Nov 2022")
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const day = dateObj.getDate();
            const month = months[dateObj.getMonth()];
            const year = dateObj.getFullYear();
            dateFormatted = `${day} ${month} ${year}`;
        }
        
        // Get employee name
        const employeeName = audit.employee_name || audit.employee_email?.split('@')[0] || 'Unknown';
        
        return `
            <div class="nested-audit-card" data-audit-id="${audit.id}" data-drop-target="true" style="${cardStyle} display: flex; align-items: center; gap: 0.8086rem; padding: 0.4043rem 0.8086rem; height: 2.5rem; max-height: 2.5rem; ${isNested ? 'cursor: pointer;' : ''}" ${isNested ? `onclick="selectNestedAudit('${audit.id}')"` : clickHandler}>
                <!-- Left: Basic Info (Radio + Scorecard Name) -->
                <div style="display: flex; align-items: center; gap: 0.4852rem; flex-shrink: 0; min-width: 0;">
                    ${radioButtonHTML}
                    <span style="font-size: 0.6069rem; font-weight: 600; color: #111827; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 10rem;">${escapeHtml(audit.scorecards?.name || 'Unknown Scorecard')}</span>
                </div>
                
                <!-- Middle: Crucial Info (Status Chip, Employee, Date) -->
                <div style="display: flex; align-items: center; gap: 0.4852rem; flex: 1; min-width: 0; overflow: hidden;">
                    ${statusBadge}
                    <span style="font-size: 0.5252rem; color: #6b7280; white-space: nowrap; margin: 0 0.1617rem;">•</span>
                    <span style="font-size: 0.5252rem; color: #374151; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 7rem;">${escapeHtml(employeeName)}</span>
                    ${adminAlias ? `<span style="font-size: 0.4447rem; color: #1A733E; font-weight: 500; background: #f0fdf4; padding: 0.0404rem 0.1213rem; border-radius: 0.0808rem; border: 0.0202rem solid #86efac; white-space: nowrap; margin: 0 0.1617rem;" title="Intercom Admin Alias">${escapeHtml(adminAlias)}</span>` : ''}
                    <span style="font-size: 0.5252rem; color: #6b7280; white-space: nowrap; margin: 0 0.1617rem;">•</span>
                    <span style="font-size: 0.5252rem; color: #6b7280; white-space: nowrap;">${dateFormatted}</span>
                </div>
                
                <!-- Right: Conversation ID Input and Actions -->
                <div style="display: flex; align-items: center; gap: 0.4852rem; flex-shrink: 0;">
                        <div style="display: flex; align-items: center; gap: 0.2425rem; flex-shrink: 0;">
                        <svg style="width: 0.8886rem; height: 0.8886rem; color: ${conversationId ? '#2563eb' : '#9ca3af'}; flex-shrink: 0;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
                            </svg>
                        <input 
                            type="text" 
                            id="conversationIdInput_${audit.id}"
                            value="${conversationId || ''}"
                            placeholder="Enter conversation ID"
                            data-audit-id="${audit.id}"
                            ${conversationId ? 'readonly' : ''}
                            onchange="updateConversationIdForAudit('${String(audit.id).replace(/'/g, "\\'")}', this.value)"
                            onclick="event.stopPropagation();"
                            onkeydown="if(event.target.readOnly && event.key !== 'Delete' && event.key !== 'Backspace' && !event.ctrlKey && !event.metaKey && !event.altKey) { event.preventDefault(); }"
                            oninput="if(!this.value.trim()) { this.readOnly = false; this.style.color = '#6b7280'; this.style.fontWeight = '400'; this.style.borderColor = '#d1d5db'; this.style.background = 'white'; this.style.cursor = 'text'; this.title = 'Enter conversation ID'; }"
                            style="padding: 0.1213rem 0.2425rem; font-size: 0.5252rem; font-family: 'Poppins', sans-serif; color: ${conversationId ? '#1e40af' : '#6b7280'}; font-weight: ${conversationId ? '600' : '400'}; border: 0.0304rem solid ${conversationId ? '#2563eb' : '#d1d5db'}; border-radius: 0.1617rem; background: ${conversationId ? '#f9fafb' : 'white'}; width: 8rem; min-width: 6rem; max-width: 10rem; white-space: nowrap; transition: all 0.2s; cursor: ${conversationId ? 'default' : 'text'};"
                            onfocus="if(!this.readOnly) { this.style.borderColor='#2563eb'; this.style.outline='none'; }"
                            onblur="this.style.borderColor='${conversationId ? '#2563eb' : '#d1d5db'}';"
                            title="${conversationId ? 'Delete to edit or replace' : 'Enter conversation ID'}"
                        />
                        ${conversationId ? `
                            <button 
                                onclick="event.stopPropagation(); navigator.clipboard.writeText('${conversationId}').then(() => { const btn = event.target.closest('button'); const originalHTML = btn.innerHTML; btn.innerHTML = '<svg style=\\'width: 0.7273rem; height: 0.7273rem;\\' fill=\\'none\\' stroke=\\'currentColor\\' viewBox=\\'0 0 24 24\\'><path stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\' stroke-width=\\'2\\' d=\\'M5 13l4 4L19 7\\'></path></svg>'; setTimeout(() => { btn.innerHTML = originalHTML; }, 1000); }).catch(err => console.error('Failed to copy:', err));"
                                style="padding: 0.1617rem; background-color: transparent; border: none; border-radius: 0.1617rem; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #6b7280; transition: all 0.2s; flex-shrink: 0;"
                                onmouseover="this.style.backgroundColor='#f3f4f6'; this.style.color='#374151';"
                                onmouseout="this.style.backgroundColor='transparent'; this.style.color='#6b7280';"
                                title="Copy conversation ID"
                            >
                                <svg style="width: 0.7273rem; height: 0.7273rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                </svg>
                            </button>
                            <button 
                                class="remove-conversation-btn"
                                data-audit-id="${audit.id}"
                                data-conversation-id="${conversationId}"
                                onclick="event.stopPropagation(); window.removeConversationFromAudit('${String(audit.id).replace(/'/g, "\\'")}', '${String(conversationId).replace(/'/g, "\\'")}')"
                                style="padding: 0.1617rem; background-color: transparent; border: none; border-radius: 0.1617rem; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #dc2626; transition: all 0.2s; flex-shrink: 0;"
                                onmouseover="this.style.backgroundColor='#fee2e2'; this.style.color='#991b1b';"
                                onmouseout="this.style.backgroundColor='transparent'; this.style.color='#dc2626';"
                                title="Remove conversation link"
                            >
                                <svg style="width: 0.7273rem; height: 0.7273rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                            </button>
                        ` : ''}
                        </div>
                    ${conversationId && conversationUrl ? `
                        <button 
                            onclick="event.stopPropagation(); window.open('${conversationUrl}', '_blank', 'noopener,noreferrer')" 
                            style="padding: 0.2425rem 0.4043rem; background-color: #f3f4f6; color: #374151; border: none; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap; display: flex; align-items: center; gap: 0.1617rem; height: 1.6169rem;"
                            onmouseover="this.style.backgroundColor='#e5e7eb'"
                            onmouseout="this.style.backgroundColor='#f3f4f6'"
                            title="Open conversation in Intercom"
                        >
                            <svg style="width: 0.8886rem; height: 0.8886rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                            </svg>
                            <span>View</span>
                        </button>
                    ` : ''}
                    ${actionButton}
                </div>
            </div>
        `;
    }
    
    // For non-nested cards, use the original layout
    return `
        <div class="nested-audit-card" data-audit-id="${audit.id}" style="${cardStyle} display: flex; justify-content: space-between; align-items: center; gap: 0.4852rem; ${clickHandler ? 'cursor: pointer;' : ''}" ${clickHandler}>
            <div style="flex: 1; display: flex; align-items: center; gap: 0.4852rem;">
                <div style="width: 1.6171rem; height: 1.6171rem; border-radius: 0.1617rem; background: #1A733E; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.5659rem; flex-shrink: 0;">
                    ${getInitials(displayName)}
                </div>
                <div style="flex: 1; min-width: 0;">
                    <div style="display: flex; align-items: center; gap: 0.3234rem; margin-bottom: 0.1617rem; flex-wrap: wrap;">
                        <h4 style="margin: 0; font-size: 0.5659rem; font-weight: 600; color: #1f2937;">
                            ${escapeHtml(displayName)}
                        </h4>
                        ${adminAlias ? `<span style="font-size: 0.4447rem; color: #1A733E; font-weight: 500; background: #f0fdf4; padding: 0.0808rem 0.2021rem; border-radius: 0.1213rem; border: 0.0304rem solid #86efac; white-space: nowrap;" title="Intercom Admin Alias">${escapeHtml(adminAlias)}</span>` : ''}
                        ${statusBadge}
                        ${conversationLinkHTML}
                    </div>
                    <p style="margin: 0; font-size: 0.4852rem; color: #6b7280; display: flex; align-items: center; gap: 0.2425rem; flex-wrap: wrap;">
                        <span>${escapeHtml(displayEmail)}</span>
                        ${audit.scorecards?.name ? `<span style="color: #9ca3af;">•</span><span>${escapeHtml(audit.scorecards.name)}</span>` : ''}
                        ${audit.completed_at ? `<span style="color: #9ca3af;">•</span><span style="font-size: 0.4447rem; color: #6b7280;">Completed ${formatDate(audit.completed_at)}</span>` : ''}
                    </p>
                </div>
            </div>
            ${actionButton ? `<div style="flex-shrink: 0;">${actionButton}</div>` : ''}
            ${displayEmail && displayEmail !== 'No email' ? `
                <div style="flex-shrink: 0; display: flex; gap: 0.2425rem;">
                    <button 
                        class="pull-conversations-btn"
                        data-email="${escapeHtml(displayEmail)}"
                        data-name="${escapeHtml(displayName)}"
                        style="padding: 0.2425rem 0.4852rem; background-color: #f0fdf4; color: #1A733E; border: 0.0304rem solid #1A733E; border-radius: 0.1617rem; font-size: 0.4447rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; white-space: nowrap; display: flex; align-items: center; gap: 0.2425rem;"
                        onmouseover="this.style.backgroundColor='#dcfce7'; this.style.borderColor='#15582E'; this.style.color='#15582E';"
                        onmouseout="this.style.backgroundColor='#f0fdf4'; this.style.borderColor='#1A733E'; this.style.color='#1A733E';"
                        title="Pull conversations for ${escapeHtml(displayName)}"
                    >
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                        <span>Pull Conversations</span>
                    </button>
                    <button 
                        class="run-ai-audit-btn"
                        data-email="${escapeHtml(displayEmail)}"
                        data-name="${escapeHtml(displayName)}"
                        onclick="event.stopPropagation(); showComingSoonDialog('${escapeHtml(displayName)}');"
                        title="Run AI Audit for ${escapeHtml(displayName)}"
                    >
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 2L13.09 8.26L20 9L13.09 9.74L12 16L10.91 9.74L4 9L10.91 8.26L12 2Z"/>
                            <path d="M19 19L20.09 21.26L23 22L20.09 22.74L19 25L17.91 22.74L15 22L17.91 21.26L19 19Z"/>
                            <path d="M5 19L6.09 21.26L9 22L6.09 22.74L5 25L3.91 22.74L1 22L3.91 21.26L5 19Z"/>
                        </svg>
                        <span>Run AI Audit</span>
                    </button>
                </div>
            ` : ''}
        </div>
    `;
}

// Calculate pagination for pending audits
function calculatePendingPagination() {
    pendingTotalPages = Math.ceil(pendingAudits.length / pendingItemsPerPage);
    if (pendingCurrentPage > pendingTotalPages && pendingTotalPages > 0) {
        pendingCurrentPage = pendingTotalPages;
    }
    if (pendingCurrentPage < 1) {
        pendingCurrentPage = 1;
    }
}

// Get paginated pending audits
function getPaginatedPendingAudits() {
    const startIndex = (pendingCurrentPage - 1) * pendingItemsPerPage;
    const endIndex = startIndex + pendingItemsPerPage;
    return pendingAudits.slice(startIndex, endIndex);
}

// ============================================================================
// Filter Functions
// ============================================================================

// Apply filters to audits
function applyFiltersToAudits() {
    let filtered = [...allPendingAudits];
    
    // Date range filter
    if (activeFilters.startDate) {
        const startDate = new Date(activeFilters.startDate);
        startDate.setHours(0, 0, 0, 0);
        filtered = filtered.filter(audit => {
            const auditDate = new Date(audit.created_at);
            auditDate.setHours(0, 0, 0, 0);
            return auditDate >= startDate;
        });
    }
    
    if (activeFilters.endDate) {
        const endDate = new Date(activeFilters.endDate);
        endDate.setHours(23, 59, 59, 999);
        filtered = filtered.filter(audit => {
            const auditDate = new Date(audit.created_at);
            return auditDate <= endDate;
        });
    }
    
    // Status filter
    if (activeFilters.status) {
        filtered = filtered.filter(audit => audit.status === activeFilters.status);
    }
    
    // Scorecard filter
    if (activeFilters.scorecard) {
        filtered = filtered.filter(audit => audit.scorecard_id === activeFilters.scorecard);
    }
    
    // Search filter
    if (activeFilters.search) {
        const searchTerm = activeFilters.search.toLowerCase().trim();
        filtered = filtered.filter(audit => {
            const employeeName = (audit.employee_name || '').toLowerCase();
            const employeeEmail = (audit.employee_email || '').toLowerCase();
            const auditorEmail = (audit.auditor_email || '').toLowerCase();
            const scorecardName = (audit.scorecards?.name || '').toLowerCase();
            return employeeName.includes(searchTerm) || 
                   employeeEmail.includes(searchTerm) || 
                   auditorEmail.includes(searchTerm) ||
                   scorecardName.includes(searchTerm);
        });
    }
    
    pendingAudits = filtered;
}

// Apply filters from UI
function applyFilters() {
    const startDateInput = document.getElementById('filterStartDate');
    const endDateInput = document.getElementById('filterEndDate');
    const statusSelect = document.getElementById('filterStatus');
    const scorecardSelect = document.getElementById('filterScorecard');
    const searchInput = document.getElementById('filterSearch');
    
    // Update active filters
    activeFilters.startDate = startDateInput?.value || null;
    activeFilters.endDate = endDateInput?.value || null;
    activeFilters.status = statusSelect?.value || '';
    activeFilters.scorecard = scorecardSelect?.value || '';
    activeFilters.search = searchInput?.value || '';
    
    // Apply filters
    applyFiltersToAudits();
    
    // Reset pagination
    pendingCurrentPage = 1;
    
    // Apply sorting and display
    sortPendingAudits();
    displayPendingAudits();
}

// Clear all filters
function clearFilters() {
    const startDateInput = document.getElementById('filterStartDate');
    const endDateInput = document.getElementById('filterEndDate');
    const statusSelect = document.getElementById('filterStatus');
    const scorecardSelect = document.getElementById('filterScorecard');
    const searchInput = document.getElementById('filterSearch');
    
    // Clear filter inputs
    if (startDateInput) startDateInput.value = '';
    if (endDateInput) endDateInput.value = '';
    if (statusSelect) statusSelect.value = '';
    if (scorecardSelect) scorecardSelect.value = '';
    if (searchInput) searchInput.value = '';
    
    // Reset active filters
    activeFilters = {
        startDate: null,
        endDate: null,
        status: '',
        scorecard: '',
        search: ''
    };
    
    // Apply filters (will reset to all audits)
    applyFiltersToAudits();
    
    // Reset pagination
    pendingCurrentPage = 1;
    
    // Apply sorting and display
    sortPendingAudits();
    displayPendingAudits();
}

// Toggle filters visibility
function toggleFilters() {
    const filtersSection = document.getElementById('filtersSection');
    const showFiltersBtn = document.getElementById('showFiltersBtn');
    
    if (filtersSection && showFiltersBtn) {
        const isCurrentlyHidden = filtersSection.style.display === 'none';
        filtersSection.style.display = isCurrentlyHidden ? 'block' : 'none';
        
        // Update button opacity to indicate active state
        if (isCurrentlyHidden) {
            showFiltersBtn.style.opacity = '1';
            showFiltersBtn.title = 'Hide Filters';
        } else {
            showFiltersBtn.style.opacity = '0.7';
            showFiltersBtn.title = 'Show Filters';
        }
    }
}

// Populate scorecard filter dropdown
async function populateScorecardFilter() {
    const scorecardSelect = document.getElementById('filterScorecard');
    if (!scorecardSelect) return;
    
    try {
        const { data: scorecards, error } = await window.supabaseClient
            .from('scorecards')
            .select('id, name')
            .eq('is_active', true)
            .order('name', { ascending: true });
        
        if (error) {
            console.error('Error loading scorecards for filter:', error);
            return;
        }
        
        // Clear existing options except "All Scorecards"
        scorecardSelect.innerHTML = '<option value="">All Scorecards</option>';
        
        // Add scorecard options
        if (scorecards && scorecards.length > 0) {
            scorecards.forEach(scorecard => {
                const option = document.createElement('option');
                option.value = scorecard.id;
                option.textContent = scorecard.name;
                scorecardSelect.appendChild(option);
            });
        }
    } catch (error) {
        console.error('Error populating scorecard filter:', error);
    }
}

// Make filter functions globally accessible
window.applyFilters = applyFilters;
window.clearFilters = clearFilters;
window.toggleFilters = toggleFilters;

// Update pagination UI for pending audits
function updatePendingPaginationUI() {
    const paginationContainer = document.getElementById('pendingAuditsPagination');
    const paginationInfo = document.getElementById('pendingPaginationInfo');
    const pageNumbers = document.getElementById('pendingPageNumbers');
    const firstPageBtn = document.getElementById('pendingFirstPageBtn');
    const prevPageBtn = document.getElementById('pendingPrevPageBtn');
    const nextPageBtn = document.getElementById('pendingNextPageBtn');
    const lastPageBtn = document.getElementById('pendingLastPageBtn');
    
    if (pendingAudits.length === 0 || pendingTotalPages <= 1) {
        if (paginationContainer) paginationContainer.style.display = 'none';
        return;
    }
    
    if (paginationContainer) {
        paginationContainer.style.display = 'block';
    }
    
    // Update pagination info
    const startIndex = (pendingCurrentPage - 1) * pendingItemsPerPage + 1;
    const endIndex = Math.min(pendingCurrentPage * pendingItemsPerPage, pendingAudits.length);
    if (paginationInfo) {
        paginationInfo.textContent = `Page ${pendingCurrentPage} of ${pendingTotalPages} (Showing ${startIndex}-${endIndex} of ${pendingAudits.length})`;
    }
    
    // Update button states
    if (firstPageBtn) {
        firstPageBtn.disabled = pendingCurrentPage === 1;
        firstPageBtn.style.opacity = pendingCurrentPage === 1 ? '0.5' : '1';
        firstPageBtn.style.cursor = pendingCurrentPage === 1 ? 'not-allowed' : 'pointer';
    }
    if (prevPageBtn) {
        prevPageBtn.disabled = pendingCurrentPage === 1;
        prevPageBtn.style.opacity = pendingCurrentPage === 1 ? '0.5' : '1';
        prevPageBtn.style.cursor = pendingCurrentPage === 1 ? 'not-allowed' : 'pointer';
    }
    if (nextPageBtn) {
        nextPageBtn.disabled = pendingCurrentPage === pendingTotalPages;
        nextPageBtn.style.opacity = pendingCurrentPage === pendingTotalPages ? '0.5' : '1';
        nextPageBtn.style.cursor = pendingCurrentPage === pendingTotalPages ? 'not-allowed' : 'pointer';
    }
    if (lastPageBtn) {
        lastPageBtn.disabled = pendingCurrentPage === pendingTotalPages;
        lastPageBtn.style.opacity = pendingCurrentPage === pendingTotalPages ? '0.5' : '1';
        lastPageBtn.style.cursor = pendingCurrentPage === pendingTotalPages ? 'not-allowed' : 'pointer';
    }
    
    // Generate page numbers
    if (pageNumbers) {
        pageNumbers.innerHTML = '';
        const maxVisiblePages = 5;
        let startPage = Math.max(1, pendingCurrentPage - Math.floor(maxVisiblePages / 2));
        let endPage = Math.min(pendingTotalPages, startPage + maxVisiblePages - 1);
        
        // Adjust start page if we're near the end
        if (endPage - startPage < maxVisiblePages - 1) {
            startPage = Math.max(1, endPage - maxVisiblePages + 1);
        }
        
        // First page
        if (startPage > 1) {
            const firstBtn = document.createElement('button');
            firstBtn.textContent = '1';
            firstBtn.onclick = () => goToPendingPage(1);
            firstBtn.style.cssText = 'padding: 0.3234rem 0.4852rem; background-color: #ffffff; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: \'Poppins\', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;';
            pageNumbers.appendChild(firstBtn);
            
            if (startPage > 2) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = '...';
                ellipsis.style.cssText = 'padding: 0.3234rem 0.1617rem; color: #6b7280; font-size: 0.5659rem;';
                pageNumbers.appendChild(ellipsis);
            }
        }
        
        // Page numbers
        for (let i = startPage; i <= endPage; i++) {
            const pageBtn = document.createElement('button');
            pageBtn.textContent = i.toString();
            pageBtn.onclick = () => goToPendingPage(i);
            if (i === pendingCurrentPage) {
                pageBtn.style.cssText = 'padding: 0.3234rem 0.4852rem; background-color: #1A733E; color: #ffffff; border: 0.0405rem solid #1A733E; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: \'Poppins\', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;';
            } else {
                pageBtn.style.cssText = 'padding: 0.3234rem 0.4852rem; background-color: #ffffff; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: \'Poppins\', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;';
            }
            pageBtn.onmouseover = function() {
                if (i !== pendingCurrentPage) {
                    this.style.backgroundColor = '#f3f4f6';
                }
            };
            pageBtn.onmouseout = function() {
                if (i !== pendingCurrentPage) {
                    this.style.backgroundColor = '#ffffff';
                }
            };
            pageNumbers.appendChild(pageBtn);
        }
        
        // Last page
        if (endPage < pendingTotalPages) {
            if (endPage < pendingTotalPages - 1) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = '...';
                ellipsis.style.cssText = 'padding: 0.3234rem 0.1617rem; color: #6b7280; font-size: 0.5659rem;';
                pageNumbers.appendChild(ellipsis);
            }
            
            const lastBtn = document.createElement('button');
            lastBtn.textContent = pendingTotalPages.toString();
            lastBtn.onclick = () => goToPendingPage(pendingTotalPages);
            lastBtn.style.cssText = 'padding: 0.3234rem 0.4852rem; background-color: #ffffff; color: #374151; border: 0.0405rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: \'Poppins\', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;';
            pageNumbers.appendChild(lastBtn);
        }
    }
}

// Pagination navigation functions for pending audits
window.goToPendingPage = function(page) {
    if (page >= 1 && page <= pendingTotalPages && page !== pendingCurrentPage) {
        pendingCurrentPage = page;
        displayPendingAudits();
        // Scroll to top of pending audits section
        const pendingSection = document.getElementById('pendingAuditsSection');
        if (pendingSection) {
            pendingSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }
};

window.goToPendingPreviousPage = function() {
    if (pendingCurrentPage > 1) {
        goToPendingPage(pendingCurrentPage - 1);
    }
};

window.goToPendingNextPage = function() {
    if (pendingCurrentPage < pendingTotalPages) {
        goToPendingPage(pendingCurrentPage + 1);
    }
};

window.goToPendingLastPage = function() {
    if (pendingTotalPages > 0) {
        goToPendingPage(pendingTotalPages);
    }
};

// Load pending audit data into the form
window.loadPendingAuditIntoForm = async function(auditId) {
    const audit = pendingAudits.find(a => a.id === auditId);
    
    if (!audit) {
        console.error('Audit not found:', auditId);
        return;
    }
    
    // Set editing mode
    isEditingPendingAudit = true;
    currentEditingAuditId = auditId;
    
    // Pre-fill employee information
    const employeeSelect = document.getElementById('employeeName');
    const employeeEmail = document.getElementById('employeeEmail');
    const employeeType = document.getElementById('employeeType');
    const employeeDepartment = document.getElementById('employeeDepartment');
    const countryOfEmployee = document.getElementById('countryOfEmployee');
    
    // Find and select the employee in dropdown
    if (employeeSelect && audit.employee_email) {
        for (let i = 0; i < employeeSelect.options.length; i++) {
            if (employeeSelect.options[i].dataset.email === audit.employee_email) {
                employeeSelect.selectedIndex = i;
                // Trigger change event to populate other fields
                employeeSelect.dispatchEvent(new Event('change'));
                break;
            }
        }
    }
    
    if (employeeEmail) employeeEmail.value = audit.employee_email || '';
    if (employeeType) employeeType.value = audit.employee_type || '';
    if (employeeDepartment) employeeDepartment.value = audit.employee_department || '';
    if (countryOfEmployee) countryOfEmployee.value = audit.country_of_employee || '';
    
    // Pre-fill any other existing data
    if (audit.channel) {
        const channelField = document.getElementById('channel');
        if (channelField) channelField.value = audit.channel;
    }
    if (audit.agent_pre_status) {
        const agentPreStatusField = document.getElementById('agentPreStatus');
        if (agentPreStatusField) agentPreStatusField.value = audit.agent_pre_status;
    }
    
    // Scroll to form
    document.getElementById('auditForm').scrollIntoView({ behavior: 'smooth', block: 'start' });
    
    // Show notification
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 2.4258rem;
        right: 0.6064rem;
        background: #1A733E;
        color: white;
        padding: 0.3639rem 0.6064rem;
        border-radius: 0.1819rem;
        font-family: 'Poppins', sans-serif;
        font-size: 0.4245rem;
        z-index: 10000;
        box-shadow: 0 0.1213rem 0.3639rem rgba(0,0,0,0.15);
    `;
    notification.textContent = `Editing pending audit for ${audit.employee_name}`;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 3000);
}

// ============================================================================
// Create Manual Audit Function
// ============================================================================

// Create a manual audit - open blank form for manual audit creation
window.createManualAudit = async function() {
    // Reset all editing and assignment tracking flags
    isEditingPendingAudit = false;
    currentEditingAuditId = null;
    currentAssignmentId = null;
    isEditingExistingAudit = false;
    currentEditingTableName = null;
    
    // Reset the form
    const auditForm = document.getElementById('auditForm');
    if (auditForm) {
        auditForm.reset();
    }
    
    // Reset header back to green (passing state)
    const headerElement = document.getElementById('auditFormHeader');
    if (headerElement) {
        headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
    }
    
    // Reset form header title
    const scorecardDisplay = document.getElementById('formScorecardDisplay');
    if (scorecardDisplay) {
        scorecardDisplay.innerHTML = '<svg style="width: 0.5659rem; height: 0.5659rem; display: inline-block; vertical-align: middle; margin-right: 0.2425rem;" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg> Select a scorecard';
    }
    
    // Clear scorecard parameters container
    const parametersContainer = document.getElementById('scorecardParameters');
    if (parametersContainer) {
        parametersContainer.innerHTML = '';
    }
    
    // Reset scorecard select
    const scorecardSelect = document.getElementById('scorecardSelect');
    if (scorecardSelect) {
        scorecardSelect.value = '';
    }
    
    // Remove default badge
    removeDefaultScorecardBadge();
    
    // Reset employee select
    const employeeSelect = document.getElementById('employeeName');
    if (employeeSelect) {
        employeeSelect.selectedIndex = 0;
        // Trigger change event to clear employee-related fields
        employeeSelect.dispatchEvent(new Event('change'));
    }
    
    // Hide Intercom alias field
    const intercomAliasContainer = document.getElementById('intercomAliasContainer');
    if (intercomAliasContainer) {
        intercomAliasContainer.style.display = 'none';
    }
    
    // Navigate to audit-form.html for manual audit creation
    window.location.href = 'audit-form.html';
}

// ============================================================================
// Start Assigned Audit Function
// ============================================================================

// Start an assigned audit - update status and pre-fill form
// Navigate to assignment URL (creates unique URL for each audit)
// Conversations state
let currentEmployeeEmail = null;
let currentEmployeeName = null;
let currentAdminId = null;
let allEmployeeConversations = []; // Filtered conversations for display
let rawEmployeeConversations = []; // All unfiltered conversations (persistent)
let currentConversationsPage = 1;
const conversationsItemsPerPage = 20; // Display 20 conversations per page
const maxConversationsToFetch = 150; // Maximum conversations to fetch from API
let isLoadingEmployeeConversations = false;

/**
 * Cache an admin to Supabase cache table (async, non-blocking)
 * This is called when an admin is found via Intercom API fallback
 */
async function cacheAdminAsync(supabaseClient, admin) {
    try {
        const adminId = admin.id;
        const adminEmail = admin.email || '';
        const adminName = admin.name || '';
        
        if (!adminId) {
            return; // Skip if no ID
        }
        
        const cacheData = {
            id: adminId,
            email: adminEmail.toLowerCase().trim(), // Normalize email
            name: adminName,
            admin_data: admin, // Store all admin fields as JSON
            last_synced_at: new Date().toISOString()
        };
        
        // Upsert (insert or update if exists)
        const { error: upsertError } = await supabaseClient
            .from('intercom_admin_cache')
            .upsert(cacheData, {
                onConflict: 'id',
                ignoreDuplicates: false
            });
        
        if (upsertError) {
            console.warn('Failed to cache admin:', upsertError);
        }
    } catch (error) {
        console.warn('Error caching admin:', error);
        // Non-critical, so we don't throw
    }
}

// View employee conversations - show conversations on the same page
window.viewEmployeeConversations = async function(employeeEmail, employeeName) {
    if (!employeeEmail || !employeeEmail.trim()) {
        alert('Employee email is required to view conversations.');
        return;
    }
    
    try {
        // Get Supabase configuration
        const supabaseUrl = window.SupabaseConfig?.url || '';
        const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
        
        if (!supabaseUrl || !supabaseAnonKey) {
            alert('Configuration error: Supabase credentials not found.');
            return;
        }
        
        // Store current employee info
        currentEmployeeEmail = employeeEmail.trim();
        currentEmployeeName = employeeName || employeeEmail;
        
        // Show conversations section
        const conversationsSection = document.getElementById('conversationsSection');
        const conversationsEmployeeName = document.getElementById('conversationsEmployeeName');
        if (conversationsSection) {
            conversationsSection.style.display = 'block';
            if (conversationsEmployeeName) {
                conversationsEmployeeName.textContent = currentEmployeeName;
            }
            
            // Scroll to conversations section
            conversationsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Set default dates immediately after showing section (use requestAnimationFrame to ensure DOM is ready)
            requestAnimationFrame(() => {
                setDefaultConversationsDateRange();
            });
        }
        
        // Normalize email for lookup (case-insensitive)
        const normalizedEmail = currentEmployeeEmail.toLowerCase().trim();
        
        let adminId = null;
        let adminFound = false;
        
        // First, try to find admin in Supabase cache
        const supabaseClient = window.SupabaseConfig?.getClient?.();
        if (supabaseClient) {
            try {
                const { data: cachedAdmins, error: queryError } = await supabaseClient
                    .from('intercom_admin_cache')
                    .select('id, email, name, admin_data')
                    .eq('email', normalizedEmail)
                    .limit(1);
                
                if (!queryError && cachedAdmins && cachedAdmins.length > 0) {
                    const cachedAdmin = cachedAdmins[0];
                    adminId = cachedAdmin.id || cachedAdmin.admin_data?.id;
                    if (adminId) {
                        adminFound = true;
                    }
                } else if (queryError) {
                    console.warn('⚠️ Error querying admin cache:', queryError);
                    // Continue to fallback
                }
            } catch (cacheError) {
                console.warn('⚠️ Error accessing Supabase cache:', cacheError);
                // Continue to fallback
            }
        }
        
        // Fallback: If not found in cache, fetch from Intercom API
        if (!adminFound) {
            try {
                // Fetch admins from Intercom API via Supabase Edge Function
                const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=admins`;
                
                const response = await fetch(edgeFunctionUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${supabaseAnonKey}`,
                        'apikey': supabaseAnonKey,
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const admins = data.admins || data || [];
                
                // Find admin with matching email (case-insensitive)
                const admin = admins.find(a => a.email && a.email.toLowerCase() === normalizedEmail);
                
                if (!admin || !admin.id) {
                    showConversationsError(`Admin not found for email: ${employeeEmail}`);
                    return;
                }
                
                adminId = admin.id;
                
                // Optionally cache this admin for future use (async, don't wait)
                if (supabaseClient && admin) {
                    cacheAdminAsync(supabaseClient, admin).catch(err => {
                        console.warn('⚠️ Failed to cache admin (non-critical):', err);
                    });
                }
                
            } catch (error) {
                console.error('❌ Error fetching admin from Intercom API:', error);
                showConversationsError(`Failed to find admin: ${error.message}`);
                return;
            }
        }
        
        if (!adminId) {
            showConversationsError(`Admin ID not found for email: ${employeeEmail}`);
            return;
        }
        
        // Store admin ID
        currentAdminId = adminId;
        
        // Initialize active filters count
        updateActiveFiltersCount();
        
        // Ensure dates are set - wait a bit for DOM to be ready, then verify
        await new Promise(resolve => setTimeout(resolve, 150));
        
        // Verify dates are set, if not set them again
        const startDateInput = document.getElementById('conversationsStartDate');
        const endDateInput = document.getElementById('conversationsEndDate');
        if (startDateInput && endDateInput && (!startDateInput.value || !endDateInput.value)) {
            setDefaultConversationsDateRange();
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        
        // Load conversations
        await loadConversationsForEmployee();
        
    } catch (error) {
        console.error('Error finding admin for conversations:', error);
        showConversationsError('Failed to load conversations. Please try again later.');
    }
};

// Close conversations section
window.closeConversationsSection = function() {
    const conversationsSection = document.getElementById('conversationsSection');
    if (conversationsSection) {
        conversationsSection.style.display = 'none';
    }
    // Reset state
    currentEmployeeEmail = null;
    currentEmployeeName = null;
    currentAdminId = null;
    allEmployeeConversations = [];
    rawEmployeeConversations = []; // Clear raw conversations too
    currentConversationsPage = 1;
};

// ============================================================================
// Pull Conversations from Intercom Functions
// ============================================================================

let pullConversationsAdminId = null;
let pullConversationsAdminName = null;
let pullConversationsAdminEmail = null;
let pullConversationsAdminAlias = null;
let pullConversationsDateRange = 'yesterday'; // Default: 'yesterday', 'last3days', 'thisweek'
let pullConversationsList = []; // Original unfiltered list from cache/API
let pullConversationsFilteredList = []; // Filtered list for display
let pullConversationsFilters = {
    state: null,
    priority: null,
    rating: null,
    cxScore: null,
    conversationLength: null,
    clientSearch: null,
    conversationId: null
};

// Select date range and update button styles
async function selectDateRange(range) {
    pullConversationsDateRange = range;
    
    // Reset all buttons to default style
    const yesterdayBtn = document.getElementById('dateRangeBtnYesterday');
    const last3DaysBtn = document.getElementById('dateRangeBtnLast3Days');
    const thisWeekBtn = document.getElementById('dateRangeBtnThisWeek');
    
    const activeStyle = {
        background: '#1A733E',
        color: 'white',
        border: 'none'
    };
    
    const inactiveStyle = {
        background: '#f3f4f6',
        color: '#374151',
        border: '0.0304rem solid #d1d5db'
    };
    
    // Apply styles based on selection
    if (yesterdayBtn) {
        if (range === 'yesterday') {
            Object.assign(yesterdayBtn.style, activeStyle);
            yesterdayBtn.dataset.isActive = 'true';
        } else {
            Object.assign(yesterdayBtn.style, inactiveStyle);
            yesterdayBtn.dataset.isActive = 'false';
        }
    }
    
    if (last3DaysBtn) {
        if (range === 'last3days') {
            Object.assign(last3DaysBtn.style, activeStyle);
            last3DaysBtn.dataset.isActive = 'true';
        } else {
            Object.assign(last3DaysBtn.style, inactiveStyle);
            last3DaysBtn.dataset.isActive = 'false';
        }
    }
    
    if (thisWeekBtn) {
        if (range === 'thisweek') {
            Object.assign(thisWeekBtn.style, activeStyle);
            thisWeekBtn.dataset.isActive = 'true';
        } else {
            Object.assign(thisWeekBtn.style, inactiveStyle);
            thisWeekBtn.dataset.isActive = 'false';
        }
    }
    
    // Fetch conversations with new date range
    if (pullConversationsAdminId) {
        const dateRange = getDateRangeForSelection(range);
        await fetchConversationsForDateRange(dateRange.startDate, dateRange.endDate);
    }
}

// Get date range based on selection
function getDateRangeForSelection(range) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    let startDate, endDate;
    
    switch (range) {
        case 'yesterday':
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            startDate = yesterday.toISOString().split('T')[0];
            endDate = yesterday.toISOString().split('T')[0];
            break;
        case 'last3days':
            const threeDaysAgo = new Date(today);
            threeDaysAgo.setDate(today.getDate() - 3);
            startDate = threeDaysAgo.toISOString().split('T')[0];
            endDate = today.toISOString().split('T')[0];
            break;
        case 'thisweek':
            // Get Monday of current week
            const monday = new Date(today);
            const day = monday.getDay();
            const diff = monday.getDate() - day + (day === 0 ? -6 : 1); // Adjust when day is Sunday
            monday.setDate(diff);
            startDate = monday.toISOString().split('T')[0];
            endDate = today.toISOString().split('T')[0];
            break;
        default:
            // Default to yesterday
            const defaultYesterday = new Date(today);
            defaultYesterday.setDate(today.getDate() - 1);
            startDate = defaultYesterday.toISOString().split('T')[0];
            endDate = defaultYesterday.toISOString().split('T')[0];
    }
    
    return { startDate, endDate };
}

// Update pull conversations header with employee name and alias
function updatePullConversationsHeader() {
    const headerElement = document.getElementById('pullConversationsHeader');
    const employeeNameElement = document.getElementById('pullConversationsEmployeeName');
    const aliasChipElement = document.getElementById('pullConversationsAdminAliasChip');
    
    if (!headerElement || !employeeNameElement || !aliasChipElement) {
        return;
    }
    
    // Update employee name
    if (pullConversationsAdminName) {
        employeeNameElement.textContent = pullConversationsAdminName;
    } else {
        employeeNameElement.textContent = '';
    }
    
    // Update alias chip
    if (pullConversationsAdminAlias) {
        aliasChipElement.style.display = 'inline-flex';
        aliasChipElement.innerHTML = `<span style="font-size: 0.4852rem; color: #1A733E; font-weight: 500; background: #f0fdf4; padding: 0.0808rem 0.2425rem; border-radius: 0.1617rem; border: 0.0304rem solid #86efac; white-space: nowrap; margin-left: 0.3234rem;" title="Intercom Admin Alias">${escapeHtml(pullConversationsAdminAlias)}</span>`;
    } else {
        aliasChipElement.style.display = 'none';
        aliasChipElement.innerHTML = '';
    }
}

// Pull conversations from Intercom - main function (for current user)
window.pullConversationsFromIntercom = async function() {
    try {
        // Get current user's email from localStorage
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const currentUserEmail = (userInfo.email || '').toLowerCase().trim();
        const currentUserName = userInfo.name || currentUserEmail.split('@')[0] || 'Unknown';
        
        if (!currentUserEmail) {
            showPullConversationsError('User email not found. Please log in again.');
            return;
        }
        
        // Reset admin info
        pullConversationsAdminId = null;
        pullConversationsAdminName = currentUserName;
        pullConversationsAdminEmail = currentUserEmail;
        pullConversationsAdminAlias = null;
        
        // Fetch admin alias from Supabase
        if (window.supabaseClient) {
            try {
                const { data: userData, error: aliasError } = await window.supabaseClient
                    .from('users')
                    .select('intercom_admin_alias')
                    .eq('email', currentUserEmail)
                    .single();
                
                if (!aliasError && userData && userData.intercom_admin_alias) {
                    pullConversationsAdminAlias = userData.intercom_admin_alias;
                    console.log('✅ Found admin alias:', pullConversationsAdminAlias);
                }
            } catch (error) {
                console.warn('⚠️ Could not fetch admin alias:', error);
            }
        }
        
        // Update header with employee name and alias
        updatePullConversationsHeader();
        
        // Show the section
        const section = document.getElementById('pullConversationsSection');
        if (section) {
            // Ensure the section appears right after the pending audits section
            const pendingAuditsSection = document.getElementById('pendingAuditsSection');
            if (pendingAuditsSection && section.parentNode) {
                // Move the section to appear right after pendingAuditsSection
                pendingAuditsSection.parentNode.insertBefore(section, pendingAuditsSection.nextSibling);
            }
            section.style.display = 'block';
            section.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // Hide "Start Audit" buttons in nested cards for this employee when conversations are visible
            if (pullConversationsAdminEmail) {
                hideNestedStartButtonsForEmployee(pullConversationsAdminEmail);
            }
        }
        
        // Set default date to yesterday
        const dateInput = document.getElementById('pullConversationsDate');
        if (dateInput && !dateInput.value) {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            const yesterdayStr = yesterday.toISOString().split('T')[0];
            dateInput.value = yesterdayStr;
        }
        
        // Find admin ID for current user
        await findAdminIdForCurrentUser(currentUserEmail);
        
        // If admin ID found, load conversations
        if (pullConversationsAdminId) {
            // Initialize date range buttons (set Yesterday as default)
            selectDateRange('yesterday');
            const dateRange = getDateRangeForSelection('yesterday');
            await fetchConversationsForDateRange(dateRange.startDate, dateRange.endDate);
        }
        
    } catch (error) {
        console.error('Error pulling conversations:', error);
        showPullConversationsError(`Failed to pull conversations: ${error.message}`);
    }
};

// Pull conversations for a specific employee (from audit card)
window.pullConversationsForEmployee = async function(employeeEmail, employeeName) {
    try {
        if (!employeeEmail || !employeeEmail.trim()) {
            console.error('❌ Employee email is required');
            showPullConversationsError('Employee email is required.');
            return;
        }
        
        // Show the section immediately
        const section = document.getElementById('pullConversationsSection');
        if (!section) {
            console.error('❌ pullConversationsSection element not found!');
            alert('Error: Conversations section not found. Please refresh the page.');
            return;
        }
        
        // Find the specific audit card for this employee and insert the section right after it
        const normalizedEmployeeEmail = (employeeEmail || '').toLowerCase().trim();
        let targetCard = null;
        
        // Find the pull conversations button that was clicked (or find any button for this employee)
        const pullButtons = document.querySelectorAll('.pull-conversations-btn-group, .pull-conversations-btn');
        for (const btn of pullButtons) {
            const btnEmail = (btn.getAttribute('data-email') || '').toLowerCase().trim();
            if (btnEmail === normalizedEmployeeEmail) {
                // Found the button, now find its parent card container
                // For grouped view: the card is the parent div with background #f9fafb
                // For individual view: similar structure
                let parent = btn.parentElement;
                while (parent && parent !== document.body) {
                    // Check if this is a card container (has the audit card styling)
                    const style = parent.getAttribute('style') || '';
                    if (style.includes('background: #f9fafb') || style.includes('border:') || parent.id === 'pendingAuditsList') {
                        // If we're at the list level, go back to find the actual card
                        if (parent.id === 'pendingAuditsList') {
                            // We've gone too far, the card should be the previous parent
                            break;
                        }
                        // Check if this looks like a card (has margin-bottom or is a direct child of pendingAuditsList)
                        if (style.includes('margin-bottom') || parent.parentElement?.id === 'pendingAuditsList') {
                            targetCard = parent;
                            break;
                        }
                    }
                    parent = parent.parentElement;
                }
                if (targetCard) break;
            }
        }
        
        // Alternative: Search all cards in pendingAuditsList and match by email in the card content
        if (!targetCard) {
            const pendingAuditsList = document.getElementById('pendingAuditsList');
            if (pendingAuditsList) {
                const allCards = pendingAuditsList.querySelectorAll('div[style*="background: #f9fafb"], div[style*="border"]');
                for (const card of allCards) {
                    // Check if this card contains the employee email
                    const cardText = card.textContent || '';
                    const emailInCard = card.querySelector(`[data-email="${escapeHtml(employeeEmail)}"]`);
                    if (emailInCard || cardText.toLowerCase().includes(normalizedEmployeeEmail)) {
                        // Make sure this is a top-level card (direct child or has margin-bottom)
                        const style = card.getAttribute('style') || '';
                        if (card.parentElement === pendingAuditsList || style.includes('margin-bottom')) {
                            targetCard = card;
                            break;
                        }
                    }
                }
            }
        }
        
        // Collapse all other groups and expand current agent's group first
        collapseAllOtherGroups(employeeEmail);
        expandGroupForEmployee(employeeEmail);
        highlightGroupCardForEmployee(employeeEmail);
        
        // Find the expanded group content area (auditGroup_${email}) inside the target card
        const normalizedEmailForId = normalizedEmployeeEmail.replace(/[^a-zA-Z0-9]/g, '_');
        const groupContentDiv = document.getElementById(`auditGroup_${normalizedEmailForId}`);
        
        // Insert the section inside the expanded group content area
        if (groupContentDiv) {
            // Remove section from its current parent if it exists
            if (section.parentNode) {
                section.parentNode.removeChild(section);
            }
            // Append to the group content div (after all nested audit cards)
            groupContentDiv.appendChild(section);
            console.log('✅ Inserted conversations section inside employee group container');
        } else if (targetCard && targetCard.parentNode) {
            // Fallback: insert right after the target card if group div not found
            targetCard.parentNode.insertBefore(section, targetCard.nextSibling);
            console.log('⚠️ Group content div not found, inserted after employee card');
        } else {
            // Final fallback: insert after pendingAuditsSection
            const pendingAuditsSection = document.getElementById('pendingAuditsSection');
            if (pendingAuditsSection && section.parentNode) {
                pendingAuditsSection.parentNode.insertBefore(section, pendingAuditsSection.nextSibling);
                console.log('⚠️ Could not find employee card, inserted after pendingAuditsSection');
            }
        }
        
        console.log('✅ Showing conversations section');
        section.style.display = 'block';
        
        // Hide "Start Audit" buttons in nested cards for this employee when conversations are visible
        hideNestedStartButtonsForEmployee(employeeEmail);
        
        // Hide error and list initially
        const errorDiv = document.getElementById('pullConversationsError');
        const listDiv = document.getElementById('pullConversationsList');
        if (errorDiv) errorDiv.style.display = 'none';
        if (listDiv) listDiv.style.display = 'none';
        
        // Show loading immediately
        const loadingDiv = document.getElementById('pullConversationsLoading');
        if (loadingDiv) {
            loadingDiv.style.display = 'block';
            updateProgressIndicator(10, 'Initializing...');
        }
        
        // Scroll to section
        setTimeout(() => {
            section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);
        
        // Set default date to yesterday
        const dateInput = document.getElementById('pullConversationsDate');
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        const yesterdayStr = yesterday.toISOString().split('T')[0];
        if (dateInput) {
            dateInput.value = yesterdayStr;
            console.log('✅ Date set to:', yesterdayStr);
        }
        
        // Reset admin ID and info
        pullConversationsAdminId = null;
        pullConversationsAdminName = employeeName || null;
        pullConversationsAdminEmail = employeeEmail || null;
        pullConversationsAdminAlias = null;
        
        // Fetch admin alias from Supabase
        if (employeeEmail && window.supabaseClient) {
            try {
                const normalizedEmail = (employeeEmail || '').toLowerCase().trim();
                const { data: userData, error: aliasError } = await window.supabaseClient
                    .from('users')
                    .select('intercom_admin_alias')
                    .eq('email', normalizedEmail)
                    .single();
                
                if (!aliasError && userData && userData.intercom_admin_alias) {
                    pullConversationsAdminAlias = userData.intercom_admin_alias;
                    console.log('✅ Found admin alias:', pullConversationsAdminAlias);
                }
            } catch (error) {
                console.warn('⚠️ Could not fetch admin alias:', error);
            }
        }
        
        // Update header with employee name and alias
        updatePullConversationsHeader();
        
        // Find admin ID for the employee email (optimized lookup: users table → cache → API → search modal)
        console.log('🔍 Looking up admin ID for email:', employeeEmail);
        const adminFound = await findAdminIdForEmployee(employeeEmail);
        
        // If admin ID found, load conversations
        if (adminFound && pullConversationsAdminId) {
            let selectedDate;
            if (dateInput && dateInput.value) {
                selectedDate = dateInput.value;
            } else {
                // Fallback to yesterday if date input is not available
                selectedDate = yesterdayStr;
            }
            console.log('✅ Admin ID found:', pullConversationsAdminId);
            console.log('📅 Fetching conversations for date:', selectedDate);
            await fetchConversationsForCurrentUser(selectedDate);
        } else {
            console.error('❌ Admin ID not found for email:', employeeEmail);
            if (loadingDiv) loadingDiv.style.display = 'none';
            // Error message will be shown by findAdminIdForEmployee or modal
        }
        
    } catch (error) {
        console.error('❌ Error pulling conversations for employee:', error);
        console.error('Error stack:', error.stack);
        const loadingDiv = document.getElementById('pullConversationsLoading');
        if (loadingDiv) loadingDiv.style.display = 'none';
        showPullConversationsError(`Failed to pull conversations: ${error.message}`);
    }
};

// Find admin ID for a specific employee email (looks in Supabase cache first)
// Send email notification to employee when audit is submitted
async function sendAuditEmailNotification(auditData, scorecard) {
    try {
        // Get Supabase configuration
        const supabaseUrl = window.env?.SUPABASE_URL || window.SUPABASE_URL;
        const supabaseAnonKey = window.env?.SUPABASE_ANON_KEY || window.SUPABASE_ANON_KEY;
        
        if (!supabaseUrl || !supabaseAnonKey) {
            console.warn('Supabase configuration not found. Email notification skipped.');
            return;
        }
        
        // Prepare email notification data
        const emailData = {
            employee_email: auditData.employee_email || null,
            employee_name: auditData.employee_name || null,
            auditor_name: auditData.auditor_name || null,
            auditor_email: auditData.auditor_email || null,
            audit_id: auditData.id || null,
            audit_type: auditData.audit_type || null,
            passing_status: auditData.passing_status || null,
            average_score: auditData.average_score || null,
            submitted_at: auditData.submitted_at || null,
            scorecard_name: scorecard?.name || null
        };
        
        // Only send if employee email is available
        if (!emailData.employee_email) {
            console.warn('Employee email not found. Email notification skipped.');
            return;
        }
        
        // Call Supabase Edge Function to send email
        const edgeFunctionUrl = `${supabaseUrl}/functions/v1/send-audit-email`;
        console.log('Sending email notification to:', emailData.employee_email);
        
        const response = await fetch(edgeFunctionUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${supabaseAnonKey}`,
                'apikey': supabaseAnonKey,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(emailData)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Email notification API error:', response.status, response.statusText, errorText);
            // Don't throw - we don't want to fail audit submission if email fails
            return;
        }
        
        const result = await response.json();
        if (result.success) {
            console.log('Email notification sent successfully:', result);
        } else {
            console.warn('Email notification not sent:', result.message || result.warning);
        }
    } catch (error) {
        // Log error but don't throw - we don't want to fail audit submission if email fails
        console.error('Error sending email notification:', error);
    }
}

async function findAdminIdForEmployee(employeeEmail) {
    const normalizedEmail = employeeEmail.toLowerCase().trim();
    let adminId = null;
    let adminFound = false;
    
    // Get Supabase configuration
    const supabaseUrl = window.SupabaseConfig?.url || '';
    const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
    
    if (!supabaseUrl || !supabaseAnonKey) {
        showPullConversationsError('Configuration error: Supabase credentials not found.');
        return false;
    }
    
    const supabaseClient = window.SupabaseConfig?.getClient?.();
    if (!supabaseClient) {
        showPullConversationsError('Supabase client not available.');
        return false;
    }
    
    // ============================================
    // OPTIMIZATION: Check users table FIRST (fastest lookup)
    // ============================================
    try {
        console.log('🔍 Looking up admin ID in users table for email:', normalizedEmail);
        const { data: user, error: userError } = await supabaseClient
            .from('users')
            .select('intercom_admin_id, intercom_admin_alias, email')
            .eq('email', normalizedEmail)
            .limit(1)
            .maybeSingle();
        
        if (!userError && user && user.intercom_admin_id) {
            adminId = user.intercom_admin_id;
            adminFound = true;
            console.log('✅ Admin ID found in users table:', adminId);
            
            // Store admin alias from users table if available
            if (user.intercom_admin_alias && !pullConversationsAdminName) {
                pullConversationsAdminName = user.intercom_admin_alias;
            }
        } else if (userError) {
            console.warn('⚠️ Error querying users table:', userError);
        }
    } catch (userTableError) {
        console.warn('⚠️ Error accessing users table:', userTableError);
    }
    
    // ============================================
    // FALLBACK 1: Check intercom_admin_cache
    // ============================================
    if (!adminFound) {
        try {
            console.log('🔍 Looking up admin in intercom_admin_cache for email:', normalizedEmail);
            const { data: cachedAdmins, error: queryError } = await supabaseClient
                .from('intercom_admin_cache')
                .select('id, email, name, admin_data')
                .eq('email', normalizedEmail)
                .limit(1);
            
            if (!queryError && cachedAdmins && cachedAdmins.length > 0) {
                const cachedAdmin = cachedAdmins[0];
                adminId = cachedAdmin.id || cachedAdmin.admin_data?.id;
                if (adminId) {
                    console.log('✅ Admin found in intercom_admin_cache:', adminId);
                    adminFound = true;
                    // Store admin name from cache if available
                    if (cachedAdmin.name && !pullConversationsAdminName) {
                        pullConversationsAdminName = cachedAdmin.name;
                    }
                }
            } else if (queryError) {
                console.warn('⚠️ Error querying admin cache:', queryError);
            }
        } catch (cacheError) {
            console.warn('⚠️ Error accessing intercom_admin_cache:', cacheError);
        }
    }
    
    // ============================================
    // FALLBACK 2: Fetch from Intercom API (exact email match)
    // ============================================
    if (!adminFound) {
        console.log('🔄 Admin not in database, fetching from Intercom API...');
        try {
            const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=admins`;
            
            const response = await fetch(edgeFunctionUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${supabaseAnonKey}`,
                    'apikey': supabaseAnonKey,
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            const admins = data.admins || data || [];
            
            // Find admin with matching email (case-insensitive)
            const admin = admins.find(a => a.email && a.email.toLowerCase() === normalizedEmail);
            
            if (admin && admin.id) {
                adminId = admin.id;
                console.log('✅ Admin found via Intercom API:', adminId);
                
                // Store admin name from API if available
                if (admin.name && !pullConversationsAdminName) {
                    pullConversationsAdminName = admin.name;
                }
                
                // Cache this admin for future use (async, don't wait)
                if (supabaseClient && admin) {
                    cacheAdminAsync(supabaseClient, admin).catch(err => {
                        console.warn('⚠️ Failed to cache admin (non-critical):', err);
                    });
                }
                
                adminFound = true;
            }
            
        } catch (error) {
            console.error('❌ Error fetching admin from Intercom API:', error);
            // Don't show error here - we'll show the search modal instead
        }
    }
    
    // ============================================
    // FALLBACK 3: Show admin search modal if still not found
    // ============================================
    if (!adminFound || !adminId) {
        console.log('⚠️ Admin ID not found, showing search modal');
        // Show modal and wait for user to search/select
        const selectedAdmin = await showAdminSearchModal(employeeEmail, pullConversationsAdminName || null);
        
        if (selectedAdmin && selectedAdmin.id) {
            adminId = selectedAdmin.id;
            if (selectedAdmin.name && !pullConversationsAdminName) {
                pullConversationsAdminName = selectedAdmin.name;
            }
            console.log('✅ Admin selected from search modal:', adminId);
        } else {
            // User cancelled or skipped
            console.log('⚠️ Admin search cancelled or skipped');
            return false;
        }
    }
    
    if (!adminId) {
        return false;
    }
    
    pullConversationsAdminId = adminId;
    return true;
}

// ============================================================================
// Admin Search Modal Functions (Production-Ready)
// ============================================================================

// Global variables for admin search modal
let adminSearchModalPromise = null;
let adminSearchModalResolve = null;
let adminSearchCurrentEmployeeEmail = null;
let adminSearchCurrentEmployeeName = null;

/**
 * Show admin search modal and return a promise that resolves when admin is selected
 * @param {string} employeeEmail - Employee email
 * @param {string} employeeName - Employee name (optional)
 * @returns {Promise<Object|null>} - Promise that resolves with selected admin {id, name, email} or null if cancelled/skipped
 */
async function showAdminSearchModal(employeeEmail, employeeName = null) {
    adminSearchCurrentEmployeeEmail = employeeEmail;
    adminSearchCurrentEmployeeName = employeeName;
    
    // Reset modal state
    const modal = document.getElementById('adminSearchModal');
    const searchInput = document.getElementById('adminSearchInput');
    const employeeEmailSpan = document.getElementById('adminSearchEmployeeEmail');
    const employeeNameSpan = document.getElementById('adminSearchEmployeeName');
    const loadingDiv = document.getElementById('adminSearchLoading');
    const errorDiv = document.getElementById('adminSearchError');
    const resultsDiv = document.getElementById('adminSearchResults');
    const resultsList = document.getElementById('adminResultsList');
    const noResultsMsg = document.getElementById('adminSearchNoResults');
    
    if (!modal || !searchInput || !employeeEmailSpan) {
        console.error('❌ Admin search modal elements not found');
        return null;
    }
    
    // Set employee info
    employeeEmailSpan.textContent = employeeEmail;
    employeeNameSpan.textContent = employeeName || 'N/A';
    
    // Reset UI
    searchInput.value = '';
    loadingDiv.style.display = 'none';
    errorDiv.style.display = 'none';
    resultsDiv.style.display = 'none';
    resultsList.innerHTML = '';
    noResultsMsg.style.display = 'none';
    
    // Show modal
    modal.style.display = 'flex';
    
    // Focus search input after a short delay
    setTimeout(() => {
        searchInput.focus();
    }, 100);
    
    // Return promise that resolves when admin is selected or modal is closed
    return new Promise((resolve) => {
        adminSearchModalResolve = resolve;
    });
}

/**
 * Close admin search modal
 */
function closeAdminSearchModal() {
    const modal = document.getElementById('adminSearchModal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    // Resolve promise with null (cancelled)
    if (adminSearchModalResolve) {
        adminSearchModalResolve(null);
        adminSearchModalResolve = null;
    }
    
    adminSearchCurrentEmployeeEmail = null;
    adminSearchCurrentEmployeeName = null;
}

/**
 * Skip admin search and continue without admin
 */
async function skipAdminSearch() {
    console.log('⚠️ User skipped admin search');
    closeAdminSearchModal();
    
    // Resolve with null to indicate skip
    if (adminSearchModalResolve) {
        adminSearchModalResolve(null);
        adminSearchModalResolve = null;
    }
}

/**
 * Search Intercom admins by name/alias
 */
window.searchIntercomAdmins = async function() {
    const searchInput = document.getElementById('adminSearchInput');
    const searchButton = document.getElementById('adminSearchButton');
    const loadingDiv = document.getElementById('adminSearchLoading');
    const errorDiv = document.getElementById('adminSearchError');
    const resultsDiv = document.getElementById('adminSearchResults');
    const resultsList = document.getElementById('adminResultsList');
    const noResultsMsg = document.getElementById('adminSearchNoResults');
    
    if (!searchInput || !loadingDiv || !resultsDiv || !resultsList) {
        console.error('❌ Admin search elements not found');
        return;
    }
    
    const searchTerm = (searchInput.value || '').trim();
    
    // Validate input
    if (!searchTerm || searchTerm.length < 2) {
        errorDiv.style.display = 'block';
        document.getElementById('adminSearchErrorMessage').textContent = 'Please enter at least 2 characters to search.';
        resultsDiv.style.display = 'none';
        return;
    }
    
    // Get Supabase configuration
    const supabaseUrl = window.SupabaseConfig?.url || '';
    const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
    
    if (!supabaseUrl || !supabaseAnonKey) {
        errorDiv.style.display = 'block';
        document.getElementById('adminSearchErrorMessage').textContent = 'Configuration error: Supabase credentials not found.';
        return;
    }
    
    // Show loading, hide error and results
    loadingDiv.style.display = 'block';
    errorDiv.style.display = 'none';
    resultsDiv.style.display = 'none';
    resultsList.innerHTML = '';
    noResultsMsg.style.display = 'none';
    
    // Disable search button
    if (searchButton) {
        searchButton.disabled = true;
        searchButton.style.opacity = '0.6';
        searchButton.style.cursor = 'not-allowed';
    }
    
    try {
        console.log('🔍 Searching Intercom admins for:', searchTerm);
        
        // Fetch all admins from Intercom API
        const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=admins`;
        
        const response = await fetch(edgeFunctionUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${supabaseAnonKey}`,
                'apikey': supabaseAnonKey,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        const allAdmins = data.admins || data || [];
        
        // Filter admins by search term (case-insensitive, matches name or email)
        const searchLower = searchTerm.toLowerCase();
        const matchingAdmins = allAdmins.filter(admin => {
            if (!admin) return false;
            const name = (admin.name || '').toLowerCase();
            const email = (admin.email || '').toLowerCase();
            return name.includes(searchLower) || email.includes(searchLower);
        });
        
        // Hide loading
        loadingDiv.style.display = 'none';
        
        // Show results
        if (matchingAdmins.length === 0) {
            noResultsMsg.style.display = 'block';
            resultsDiv.style.display = 'block';
        } else {
            noResultsMsg.style.display = 'none';
            resultsDiv.style.display = 'block';
            
            // Display results
            resultsList.innerHTML = '';
            matchingAdmins.forEach((admin, index) => {
                const adminItem = document.createElement('div');
                adminItem.style.cssText = 'padding: 0.8086rem; border-bottom: 0.0304rem solid #e5e7eb; cursor: pointer; transition: background 0.2s;';
                adminItem.style.borderBottom = index === matchingAdmins.length - 1 ? 'none' : '0.0304rem solid #e5e7eb';
                
                adminItem.onmouseover = function() {
                    this.style.backgroundColor = '#f9fafb';
                };
                adminItem.onmouseout = function() {
                    this.style.backgroundColor = 'white';
                };
                
                adminItem.onclick = function() {
                    selectAdminFromSearch(admin);
                };
                
                const adminName = admin.name || 'Unknown';
                const adminEmail = admin.email || 'No email';
                const adminId = admin.id || 'N/A';
                
                adminItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <div style="font-size: 0.4852rem; font-weight: 600; color: #374151; margin-bottom: 0.1617rem;">${escapeHtml(adminName)}</div>
                            <div style="font-size: 0.4043rem; color: #6b7280;">${escapeHtml(adminEmail)}</div>
                            <div style="font-size: 0.4043rem; color: #9ca3af; margin-top: 0.1617rem;">ID: ${adminId}</div>
                        </div>
                        <div style="color: #1A733E; font-size: 0.4043rem; font-weight: 500;">Select →</div>
                    </div>
                `;
                
                resultsList.appendChild(adminItem);
            });
        }
        
    } catch (error) {
        console.error('❌ Error searching Intercom admins:', error);
        loadingDiv.style.display = 'none';
        errorDiv.style.display = 'block';
        document.getElementById('adminSearchErrorMessage').textContent = `Failed to search admins: ${error.message}`;
    } finally {
        // Re-enable search button
        if (searchButton) {
            searchButton.disabled = false;
            searchButton.style.opacity = '1';
            searchButton.style.cursor = 'pointer';
        }
    }
};

/**
 * Select admin from search results and update users table
 * @param {Object} admin - Admin object from Intercom API
 */
async function selectAdminFromSearch(admin) {
    if (!admin || !admin.id) {
        console.error('❌ Invalid admin object');
        return;
    }
    
    const adminId = admin.id;
    const adminName = admin.name || '';
    const adminEmail = admin.email || '';
    const employeeEmail = adminSearchCurrentEmployeeEmail;
    
    if (!employeeEmail) {
        console.error('❌ Employee email not found');
        showAdminSearchError('Employee email not found. Please try again.');
        return;
    }
    
    // Get Supabase client
    const supabaseClient = window.SupabaseConfig?.getClient?.();
    if (!supabaseClient) {
        showAdminSearchError('Supabase client not available.');
        return;
    }
    
    // Show updating state
    const searchButton = document.getElementById('adminSearchButton');
    const originalButtonText = searchButton ? searchButton.textContent : 'Search';
    if (searchButton) {
        searchButton.disabled = true;
        searchButton.textContent = 'Updating...';
        searchButton.style.opacity = '0.6';
    }
    
    try {
        console.log('💾 Updating users table with admin info:', { employeeEmail, adminId, adminName });
        
        // Update users table
        const { data: updatedUser, error: updateError } = await supabaseClient
            .from('users')
            .update({
                intercom_admin_id: String(adminId),
                intercom_admin_alias: adminName || null
            })
            .eq('email', employeeEmail.toLowerCase().trim())
            .select('email, intercom_admin_id, intercom_admin_alias')
            .maybeSingle();
        
        if (updateError) {
            console.error('❌ Error updating users table:', updateError);
            throw new Error(`Failed to update user: ${updateError.message}`);
        }
        
        if (!updatedUser) {
            throw new Error('User not found in database');
        }
        
        console.log('✅ Successfully updated users table:', updatedUser);
        
        // Also cache the admin in intercom_admin_cache (async, don't wait)
        if (admin) {
            cacheAdminAsync(supabaseClient, admin).catch(err => {
                console.warn('⚠️ Failed to cache admin (non-critical):', err);
            });
        }
        
        // Set global admin variables
        pullConversationsAdminId = String(adminId);
        if (adminName && !pullConversationsAdminName) {
            pullConversationsAdminName = adminName;
        }
        
        // Close modal and resolve promise
        closeAdminSearchModal();
        
        // Resolve with selected admin
        if (adminSearchModalResolve) {
            adminSearchModalResolve({
                id: String(adminId),
                name: adminName,
                email: adminEmail
            });
            adminSearchModalResolve = null;
        }
        
        // Show success message and continue with conversation fetch
        const loadingDiv = document.getElementById('pullConversationsLoading');
        const statusElement = document.getElementById('pullConversationsStatus');
        if (statusElement) {
            statusElement.textContent = `✅ Admin linked successfully! Loading conversations...`;
        }
        if (loadingDiv) {
            loadingDiv.style.display = 'block';
        }
        
        // Continue with conversation fetch
        const dateInput = document.getElementById('pullConversationsDate');
        let selectedDate;
        if (dateInput && dateInput.value) {
            selectedDate = dateInput.value;
        } else {
            // Fallback to yesterday
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            selectedDate = yesterday.toISOString().split('T')[0];
        }
        
        // Fetch conversations for the selected admin
        setTimeout(async () => {
            try {
                await fetchConversationsForCurrentUser(selectedDate);
            } catch (error) {
                console.error('❌ Error fetching conversations after admin selection:', error);
                showPullConversationsError(`Failed to fetch conversations: ${error.message}`);
            }
        }, 500); // Small delay to ensure UI updates
        
    } catch (error) {
        console.error('❌ Error selecting admin:', error);
        showAdminSearchError(`Failed to update user: ${error.message}`);
        
        // Re-enable button
        if (searchButton) {
            searchButton.disabled = false;
            searchButton.textContent = originalButtonText;
            searchButton.style.opacity = '1';
        }
    }
}

/**
 * Show error in admin search modal
 */
function showAdminSearchError(message) {
    const errorDiv = document.getElementById('adminSearchError');
    const errorMessage = document.getElementById('adminSearchErrorMessage');
    if (errorDiv && errorMessage) {
        errorMessage.textContent = message;
        errorDiv.style.display = 'block';
    }
}

// Find admin ID for current user
async function findAdminIdForCurrentUser(userEmail) {
    const normalizedEmail = userEmail.toLowerCase().trim();
    let adminId = null;
    let adminFound = false;
    
    // Get Supabase configuration
    const supabaseUrl = window.SupabaseConfig?.url || '';
    const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
    
    if (!supabaseUrl || !supabaseAnonKey) {
        showPullConversationsError('Configuration error: Supabase credentials not found.');
        return;
    }
    
    // First, try to find admin in Supabase cache
    const supabaseClient = window.SupabaseConfig?.getClient?.();
    if (supabaseClient) {
        try {
            console.log('🔍 Looking up admin in Supabase cache...');
            const { data: cachedAdmins, error: queryError } = await supabaseClient
                .from('intercom_admin_cache')
                .select('id, email, name, admin_data')
                .eq('email', normalizedEmail)
                .limit(1);
            
            if (!queryError && cachedAdmins && cachedAdmins.length > 0) {
                const cachedAdmin = cachedAdmins[0];
                adminId = cachedAdmin.id || cachedAdmin.admin_data?.id;
                if (adminId) {
                    console.log('✅ Admin found in Supabase cache');
                    adminFound = true;
                }
            }
        } catch (cacheError) {
            console.warn('⚠️ Error accessing Supabase cache:', cacheError);
        }
    }
    
    // Fallback: If not found in cache, fetch from Intercom API
    if (!adminFound) {
        console.log('🔄 Admin not in cache, fetching from Intercom API...');
        try {
            const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=admins`;
            
            const response = await fetch(edgeFunctionUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${supabaseAnonKey}`,
                    'apikey': supabaseAnonKey,
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            const admins = data.admins || data || [];
            
            // Find admin with matching email (case-insensitive)
            const admin = admins.find(a => a.email && a.email.toLowerCase() === normalizedEmail);
            
            if (!admin || !admin.id) {
                showPullConversationsError(`Admin not found for email: ${userEmail}`);
                return;
            }
            
            adminId = admin.id;
            console.log('✅ Admin found via Intercom API fallback:', adminId);
            
            // Store admin name from API if available
            if (admin.name && !pullConversationsAdminName) {
                pullConversationsAdminName = admin.name;
            }
            
            // Cache this admin for future use (async, don't wait)
            if (supabaseClient && admin) {
                cacheAdminAsync(supabaseClient, admin).catch(err => {
                    console.warn('⚠️ Failed to cache admin (non-critical):', err);
                });
            }
            
        } catch (error) {
            console.error('❌ Error fetching admin from Intercom API:', error);
            showPullConversationsError(`Failed to find admin: ${error.message}`);
            return;
        }
    }
    
    if (!adminId) {
        showPullConversationsError(`Admin ID not found for email: ${userEmail}`);
        return;
    }
    
    pullConversationsAdminId = adminId;
    if (!pullConversationsAdminEmail) {
        pullConversationsAdminEmail = userEmail;
    }
    console.log('✅ Admin ID set:', pullConversationsAdminId);
};

// ============================================================================
// Local Caching Utilities for Conversations (IndexedDB)
// ============================================================================

const CONVERSATION_CACHE_PREFIX = 'conversations_cache_';
const CACHE_EXPIRY_HOURS = 24; // Cache expires after 24 hours
const INDEXEDDB_DB_NAME = 'QMSConversationCache';
const INDEXEDDB_STORE_NAME = 'conversations';
const INDEXEDDB_VERSION = 1;

// Check if IndexedDB is available
const INDEXEDDB_AVAILABLE = typeof indexedDB !== 'undefined';

// Generate cache key from admin ID and date
function getConversationCacheKey(adminId, date) {
    // Normalize adminId to string to ensure consistency
    const normalizedAdminId = String(adminId || '').trim();
    // Normalize date to YYYY-MM-DD format
    let normalizedDate = '';
    if (date) {
        if (typeof date === 'string') {
            normalizedDate = date.trim();
            // If date is in a different format, try to normalize it
            if (normalizedDate.includes('T')) {
                normalizedDate = normalizedDate.split('T')[0];
            }
        } else if (date instanceof Date) {
            normalizedDate = date.toISOString().split('T')[0];
        }
    }
    return `${normalizedAdminId}_${normalizedDate}`;
}

// Initialize IndexedDB database
function initConversationCacheDB() {
    return new Promise((resolve, reject) => {
        if (!INDEXEDDB_AVAILABLE) {
            console.warn('⚠️ IndexedDB not available, will use localStorage fallback');
            resolve(null);
            return;
        }

        const request = indexedDB.open(INDEXEDDB_DB_NAME, INDEXEDDB_VERSION);

        request.onerror = () => {
            console.error('❌ IndexedDB open error:', request.error);
            reject(request.error);
        };

        request.onsuccess = () => {
            console.log('✅ IndexedDB database opened successfully');
            resolve(request.result);
        };

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            
            // Create object store if it doesn't exist
            if (!db.objectStoreNames.contains(INDEXEDDB_STORE_NAME)) {
                const objectStore = db.createObjectStore(INDEXEDDB_STORE_NAME, { keyPath: 'cacheKey' });
                
                // Create indexes
                objectStore.createIndex('adminId', 'adminId', { unique: false });
                objectStore.createIndex('date', 'date', { unique: false });
                objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                objectStore.createIndex('expiresAt', 'expiresAt', { unique: false });
                
                console.log('✅ IndexedDB object store and indexes created');
            }
        };
    });
}

// Get database instance (with initialization)
let dbInstance = null;
async function getConversationCacheDB() {
    if (!INDEXEDDB_AVAILABLE) {
        return null;
    }
    
    if (dbInstance) {
        return dbInstance;
    }
    
    try {
        dbInstance = await initConversationCacheDB();
        return dbInstance;
    } catch (error) {
        console.error('❌ Failed to initialize IndexedDB:', error);
        return null;
    }
}

// Get cached conversations from IndexedDB (with localStorage fallback)
async function getCachedConversations(adminId, date) {
    const cacheKey = getConversationCacheKey(adminId, date);
    console.log('🔍 Checking cache with key:', cacheKey, 'for adminId:', adminId, 'date:', date);
    
    // Try IndexedDB first
    const db = await getConversationCacheDB();
    if (db) {
        try {
            return new Promise((resolve) => {
                const transaction = db.transaction([INDEXEDDB_STORE_NAME], 'readonly');
                const store = transaction.objectStore(INDEXEDDB_STORE_NAME);
                const request = store.get(cacheKey);
                
                request.onsuccess = () => {
                    const cachedData = request.result;
                    
                    if (!cachedData) {
                        console.log('📦 No cache found in IndexedDB for:', cacheKey);
                        resolve(null);
                        return;
                    }
                    
                    const now = Date.now();
                    
                    // Check if cache is expired
                    if (cachedData.expiresAt && now > cachedData.expiresAt) {
                        console.log('⏰ Cache expired for:', cacheKey, 'Expired at:', new Date(cachedData.expiresAt).toISOString());
                        // Delete expired cache
                        deleteCachedConversation(cacheKey);
                        resolve(null);
                        return;
                    }
                    
                    // Validate cache data structure
                    if (!cachedData.data) {
                        console.warn('⚠️ Cache data structure invalid, missing data field:', cacheKey);
                        deleteCachedConversation(cacheKey);
                        resolve(null);
                        return;
                    }
                    
                    const conversationCount = cachedData.data.conversations?.length || 0;
                    console.log('✅ Cache hit in IndexedDB for:', cacheKey, `(${conversationCount} conversations)`, 'Cached at:', new Date(cachedData.timestamp).toISOString());
                    resolve(cachedData.data);
                };
                
                request.onerror = () => {
                    console.warn('⚠️ Error reading from IndexedDB:', request.error);
                    resolve(null);
                };
            });
        } catch (error) {
            console.warn('⚠️ Error accessing IndexedDB:', error);
            // Fall through to localStorage fallback
        }
    }
    
    // Fallback to localStorage
    try {
        const localStorageKey = CONVERSATION_CACHE_PREFIX + cacheKey;
        const cachedData = localStorage.getItem(localStorageKey);
        
        if (!cachedData) {
            console.log('📦 No cache found in localStorage for:', localStorageKey);
            return null;
        }
        
        const parsed = JSON.parse(cachedData);
        const now = Date.now();
        
        // Check if cache is expired
        if (parsed.expiresAt && now > parsed.expiresAt) {
            console.log('⏰ Cache expired for:', localStorageKey, 'Expired at:', new Date(parsed.expiresAt).toISOString());
            localStorage.removeItem(localStorageKey);
            return null;
        }
        
        // Validate cache data structure
        if (!parsed.data) {
            console.warn('⚠️ Cache data structure invalid, missing data field:', localStorageKey);
            localStorage.removeItem(localStorageKey);
            return null;
        }
        
        const conversationCount = parsed.data.conversations?.length || 0;
        console.log('✅ Cache hit in localStorage for:', localStorageKey, `(${conversationCount} conversations)`, 'Cached at:', new Date(parsed.timestamp).toISOString());
        return parsed.data;
        
    } catch (error) {
        console.warn('⚠️ Error reading from localStorage:', error);
        return null;
    }
}

// Delete a cached conversation
async function deleteCachedConversation(cacheKey) {
    const db = await getConversationCacheDB();
    if (db) {
        try {
            const transaction = db.transaction([INDEXEDDB_STORE_NAME], 'readwrite');
            const store = transaction.objectStore(INDEXEDDB_STORE_NAME);
            store.delete(cacheKey);
        } catch (error) {
            console.warn('⚠️ Error deleting from IndexedDB:', error);
        }
    }
    
    // Also try localStorage
    try {
        localStorage.removeItem(CONVERSATION_CACHE_PREFIX + cacheKey);
    } catch (error) {
        // Ignore
    }
}

// Store conversations in cache (IndexedDB with localStorage fallback)
async function cacheConversations(adminId, date, data) {
    // Validate inputs
    if (!adminId || !date || !data) {
        console.warn('⚠️ Cannot cache: missing required parameters', { adminId, date, hasData: !!data });
        return false;
    }
    
    const cacheKey = getConversationCacheKey(adminId, date);
    console.log('💾 Cache save attempt - Key:', cacheKey, 'AdminId:', adminId, 'Date:', date);
    
    const expiresAt = Date.now() + (CACHE_EXPIRY_HOURS * 60 * 60 * 1000); // 24 hours from now
    
    const cacheData = {
        cacheKey: cacheKey,
        adminId: String(adminId), // Normalize to string
        date: String(date), // Normalize to string
        data: data,
        timestamp: Date.now(),
        expiresAt: expiresAt,
        conversationCount: data.conversations?.length || 0
    };
    
    // Try IndexedDB first
    const db = await getConversationCacheDB();
    if (db) {
        try {
            return new Promise((resolve) => {
                const transaction = db.transaction([INDEXEDDB_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INDEXEDDB_STORE_NAME);
                const request = store.put(cacheData);
                
                request.onsuccess = () => {
                    const sizeInMB = (JSON.stringify(cacheData).length / (1024 * 1024)).toFixed(2);
                    console.log('✅ Successfully cached conversations in IndexedDB for:', cacheKey, `(${cacheData.conversationCount} conversations, ${sizeInMB}MB)`, 'Expires:', new Date(expiresAt).toISOString());
                    resolve(true);
                };
                
                request.onerror = async () => {
                    console.warn('⚠️ Error saving to IndexedDB:', request.error);
                    // Fall through to localStorage fallback
                    const result = await cacheToLocalStorage(cacheKey, cacheData);
                    resolve(result);
                };
            });
        } catch (error) {
            console.warn('⚠️ Error accessing IndexedDB:', error);
            // Fall through to localStorage fallback
            return await cacheToLocalStorage(cacheKey, cacheData);
        }
    }
    
    // Fallback to localStorage
    return await cacheToLocalStorage(cacheKey, cacheData);
}

// Helper function to cache to localStorage (fallback)
async function cacheToLocalStorage(cacheKey, cacheData) {
    try {
        const localStorageKey = CONVERSATION_CACHE_PREFIX + cacheKey;
        const cacheString = JSON.stringify(cacheData);
        const sizeInMB = (cacheString.length / (1024 * 1024)).toFixed(2);
        
        // Check if data is too large for localStorage (limit is ~5-10MB, but be conservative)
        if (cacheString.length > 2 * 1024 * 1024) { // 2MB limit per entry (more conservative)
            console.warn('⚠️ Cache data too large for localStorage (' + sizeInMB + 'MB), skipping cache storage.');
            return false;
        }
        
        localStorage.setItem(localStorageKey, cacheString);
        
        // Verify it was saved
        const verifyCache = localStorage.getItem(localStorageKey);
        if (!verifyCache) {
            console.error('❌ Cache save failed: Item not found after save attempt');
            return false;
        }
        
        console.log('✅ Successfully cached conversations in localStorage for:', localStorageKey, `(${cacheData.conversationCount} conversations, ${sizeInMB}MB)`, 'Expires:', new Date(cacheData.expiresAt).toISOString());
        return true;
        
    } catch (error) {
        // Handle quota exceeded error
        if (error.name === 'QuotaExceededError' || error.code === 22) {
            console.warn('⚠️ localStorage quota exceeded, clearing old cache entries...');
            await clearOldCacheEntries();
            
            // Try once more after clearing
            try {
                const localStorageKey = CONVERSATION_CACHE_PREFIX + cacheKey;
                localStorage.setItem(localStorageKey, JSON.stringify(cacheData));
                const verifyCache = localStorage.getItem(localStorageKey);
                if (verifyCache) {
                    console.log('✅ Cached to localStorage after clearing old entries');
                    return true;
                }
            } catch (retryError) {
                console.warn('⚠️ Still unable to cache to localStorage after clearing:', retryError);
            }
        }
        console.warn('⚠️ Error caching to localStorage:', error);
        return false;
    }
}

// Clear old cache entries (keep only last 50 entries for IndexedDB, or last 5 for localStorage)
async function clearOldCacheEntries() {
    const db = await getConversationCacheDB();
    
    if (db) {
        // Use IndexedDB cleanup
        try {
            return new Promise((resolve) => {
                const transaction = db.transaction([INDEXEDDB_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(INDEXEDDB_STORE_NAME);
                const index = store.index('timestamp');
                const request = index.openCursor(null, 'prev'); // Descending order (newest first)
                
                const entries = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        entries.push(cursor.value);
                        cursor.continue();
                    } else {
                        // All entries loaded, now process
                        if (entries.length === 0) {
                            console.log('📦 No cache entries to clear in IndexedDB');
                            resolve();
                            return;
                        }
                        
                        // Calculate total size
                        const totalSize = entries.reduce((sum, entry) => {
                            return sum + (JSON.stringify(entry).length || 0);
                        }, 0);
                        const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
                        console.log(`📊 IndexedDB cache stats: ${entries.length} entries, ${totalSizeMB}MB total`);
                        
                        // Keep last 50 entries (IndexedDB can handle much more)
                        const maxEntries = 50;
                        if (entries.length > maxEntries) {
                            const toRemove = entries.slice(maxEntries);
                            const deleteTransaction = db.transaction([INDEXEDDB_STORE_NAME], 'readwrite');
                            const deleteStore = deleteTransaction.objectStore(INDEXEDDB_STORE_NAME);
                            
                            let deletedCount = 0;
                            toRemove.forEach(entry => {
                                deleteStore.delete(entry.cacheKey);
                                deletedCount++;
                                console.log(`🗑️ Removed old cache from IndexedDB: ${entry.cacheKey} (${entry.conversationCount || 0} conversations)`);
                            });
                            
                            console.log(`🗑️ Removed ${deletedCount} old cache entries from IndexedDB`);
                        }
                        
                        // If still too large (more than 500MB), be more aggressive - keep only last 30
                        if (totalSize > 500 * 1024 * 1024 && entries.length > 30) {
                            console.warn('⚠️ IndexedDB cache still too large, keeping only last 30 entries');
                            const toRemove = entries.slice(30);
                            const deleteTransaction = db.transaction([INDEXEDDB_STORE_NAME], 'readwrite');
                            const deleteStore = deleteTransaction.objectStore(INDEXEDDB_STORE_NAME);
                            
                            toRemove.forEach(entry => {
                                deleteStore.delete(entry.cacheKey);
                            });
                        }
                        
                        resolve();
                    }
                };
                
                request.onerror = () => {
                    console.warn('⚠️ Error reading from IndexedDB for cleanup:', request.error);
                    resolve();
                };
            });
        } catch (error) {
            console.warn('⚠️ Error clearing IndexedDB cache:', error);
        }
    }
    
    // Fallback to localStorage cleanup
    try {
        const cacheKeys = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(CONVERSATION_CACHE_PREFIX)) {
                cacheKeys.push(key);
            }
        }
        
        if (cacheKeys.length === 0) {
            console.log('📦 No cache entries to clear in localStorage');
            return;
        }
        
        // Sort by timestamp (newest first) and calculate sizes
        const cacheEntries = cacheKeys.map(key => {
            try {
                const data = localStorage.getItem(key);
                const parsed = JSON.parse(data);
                const size = new Blob([data]).size;
                return { 
                    key, 
                    timestamp: parsed.timestamp || 0,
                    size: size,
                    conversationCount: parsed.data?.conversations?.length || 0
                };
            } catch {
                return { key, timestamp: 0, size: 0, conversationCount: 0 };
            }
        }).sort((a, b) => b.timestamp - a.timestamp);
        
        // Calculate total cache size
        const totalSize = cacheEntries.reduce((sum, entry) => sum + entry.size, 0);
        const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
        console.log(`📊 localStorage cache stats: ${cacheEntries.length} entries, ${totalSizeMB}MB total`);
        
        // If we have more than 5 entries, remove oldest ones
        if (cacheEntries.length > 5) {
            const toRemove = cacheEntries.slice(5);
            const removedSize = toRemove.reduce((sum, entry) => sum + entry.size, 0);
            toRemove.forEach(entry => {
                localStorage.removeItem(entry.key);
                console.log(`🗑️ Removed old cache from localStorage: ${entry.key} (${entry.conversationCount} conversations, ${(entry.size / 1024).toFixed(1)}KB)`);
            });
            console.log(`🗑️ Removed ${toRemove.length} old cache entries from localStorage, freed ${(removedSize / (1024 * 1024)).toFixed(2)}MB`);
        }
    } catch (error) {
        console.warn('⚠️ Error clearing localStorage cache:', error);
    }
}

// Clear all conversation caches
function clearAllConversationCaches() {
    try {
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(CONVERSATION_CACHE_PREFIX)) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
        console.log(`🗑️ Cleared ${keysToRemove.length} cache entries`);
        return keysToRemove.length;
    } catch (error) {
        console.warn('⚠️ Error clearing caches:', error);
        return 0;
    }
}

// Fetch conversations for date range
async function fetchConversationsForDateRange(startDate, endDate) {
    if (!pullConversationsAdminId) {
        showPullConversationsError('Admin ID not found. Please try again.');
        return;
    }
    
    // Hide elements during loading
    hideElementsDuringLoading();
    
    // Show loading state
    const loadingDiv = document.getElementById('pullConversationsLoading');
    const errorDiv = document.getElementById('pullConversationsError');
    const listDiv = document.getElementById('pullConversationsList');
    
    if (loadingDiv) loadingDiv.style.display = 'block';
    if (errorDiv) errorDiv.style.display = 'none';
    if (listDiv) listDiv.style.display = 'none';
    
    // Get Supabase configuration
    const supabaseUrl = window.SupabaseConfig?.url || '';
    const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
    
    // Normalize adminId and dates
    const normalizedAdminId = String(pullConversationsAdminId || '').trim();
    const normalizedStartDate = startDate ? String(startDate).trim().split('T')[0] : '';
    const normalizedEndDate = endDate ? String(endDate).trim().split('T')[0] : '';
    
    if (!normalizedAdminId || !normalizedStartDate || !normalizedEndDate) {
        console.warn('⚠️ Cannot fetch: missing adminId or dates', { 
            adminId: normalizedAdminId, 
            startDate: normalizedStartDate,
            endDate: normalizedEndDate
        });
        if (!normalizedAdminId) {
            showPullConversationsError('Admin ID is missing. Please pull conversations again.');
            if (loadingDiv) loadingDiv.style.display = 'none';
            return;
        }
        if (!normalizedStartDate || !normalizedEndDate) {
            showPullConversationsError('Please select a date range.');
            if (loadingDiv) loadingDiv.style.display = 'none';
            return;
        }
    }
    
    // Format dates for API (add time component)
    const updatedSince = `${normalizedStartDate} 00:00:00`;
    const updatedBefore = `${normalizedEndDate} 23:59:59`;
    
    // No cache for date ranges - always fetch from API
    console.log('🌐 Fetching from API for date range:', normalizedStartDate, 'to', normalizedEndDate);
    
    // Update progress: Initial
    updateProgressIndicator(10, 'Pulling from Intercom...');
    
    try {
        // Build edge function URL with date range
        const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=conversations&admin_id=${encodeURIComponent(pullConversationsAdminId)}&updated_since=${encodeURIComponent(updatedSince)}&updated_before=${encodeURIComponent(updatedBefore)}`;
        
        console.log('📡 Calling:', edgeFunctionUrl);
        
        // Update progress: Searching
        updateProgressIndicator(20, 'Searching conversations in Intercom...');
        
        // Create AbortController for timeout handling
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 120000); // 120 seconds timeout
        
        let response;
        try {
            response = await fetch(edgeFunctionUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${supabaseAnonKey}`,
                    'apikey': supabaseAnonKey,
                    'Accept': 'application/json'
                },
                signal: controller.signal
            });
        } catch (fetchError) {
            clearTimeout(timeoutId);
            
            // Handle timeout and network errors
            if (fetchError.name === 'AbortError') {
                throw new Error('Request timed out. The Intercom API is taking too long to respond. Please try again or check your internet connection.');
            } else if (fetchError.message.includes('Failed to fetch') || fetchError.message.includes('ERR_CONNECTION')) {
                throw new Error('Connection failed. Please check your internet connection and try again. If the problem persists, the Intercom service may be temporarily unavailable.');
            } else {
                throw new Error(`Network error: ${fetchError.message}`);
            }
        }
        
        clearTimeout(timeoutId);

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            const errorMsg = errorData.error || `HTTP ${response.status}: ${response.statusText}`;
            throw new Error(errorMsg);
        }

        // Update progress: Processing
        updateProgressIndicator(70, 'Processing participation data...');
        
        const data = await response.json();
        
        // Extract conversations from response
        let conversations = [];
        if (data && Array.isArray(data.conversations)) {
            conversations = data.conversations;
        } else if (data && data.type === 'conversation.list' && Array.isArray(data.conversations)) {
            conversations = data.conversations;
        }
        
        const participationCount = data.participation_count || 0;
        
        console.log(`✅ Fetched ${conversations.length} conversations from API`);
        console.log('📋 First conversation sample:', conversations[0] ? Object.keys(conversations[0]) : 'No conversations');
        
        // Update progress: Complete
        updateProgressIndicator(100, 'Complete');
        
        // Small delay to show completion
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Store conversations (original unfiltered list)
        pullConversationsList = conversations;
        
        // Initialize filtered list with all conversations
        pullConversationsFilteredList = [...conversations];
        
        // Only apply filters if any are actually set
        const hasActiveFilters = Object.values(pullConversationsFilters).some(value => value !== null && value !== '');
        if (hasActiveFilters) {
            await filterPullConversations();
        } else {
            // No filters, just display all conversations
            await displayPullConversationsList(conversations);
            updatePullConversationsCountAndAdmin(conversations.length);
        }
        
        // Hide loading and show results
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (listDiv) listDiv.style.display = 'block';
        
        // Show elements after loading
        showElementsAfterLoading();
        
        // Update active filters display
        updatePullConversationsActiveFilters();
        
    } catch (error) {
        console.error('❌ Error fetching conversations:', error);
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (errorDiv) {
            errorDiv.style.display = 'block';
            errorDiv.textContent = `Error: ${error.message}`;
        }
        showElementsAfterLoading();
    }
}

// Fetch conversations for current user (legacy function - kept for compatibility)
async function fetchConversationsForCurrentUser(selectedDate) {
    if (!pullConversationsAdminId) {
        showPullConversationsError('Admin ID not found. Please try again.');
        return;
    }
    
    // Hide elements during loading
    hideElementsDuringLoading();
    
    // Show loading state
    const loadingDiv = document.getElementById('pullConversationsLoading');
    const errorDiv = document.getElementById('pullConversationsError');
    const listDiv = document.getElementById('pullConversationsList');
    
    if (loadingDiv) loadingDiv.style.display = 'block';
    if (errorDiv) errorDiv.style.display = 'none';
    if (listDiv) listDiv.style.display = 'none';
    
    // Get Supabase configuration
    const supabaseUrl = window.SupabaseConfig?.url || '';
    const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
    
    // Normalize adminId and date for cache lookup
    const normalizedAdminId = String(pullConversationsAdminId || '').trim();
    const normalizedDate = selectedDate ? String(selectedDate).trim().split('T')[0] : '';
    
    if (!normalizedAdminId || !normalizedDate) {
        console.warn('⚠️ Cannot check cache: missing adminId or date', { 
            adminId: normalizedAdminId, 
            date: normalizedDate,
            pullConversationsAdminId: pullConversationsAdminId,
            selectedDate: selectedDate
        });
        // Don't proceed if we don't have required info
        if (!normalizedAdminId) {
            showPullConversationsError('Admin ID is missing. Please pull conversations again.');
            if (loadingDiv) loadingDiv.style.display = 'none';
            return;
        }
        if (!normalizedDate) {
            showPullConversationsError('Please select a date.');
            if (loadingDiv) loadingDiv.style.display = 'none';
            return;
        }
    }
    
    // Check cache first
    console.log('🔍 Cache check - AdminId:', normalizedAdminId, 'Date:', normalizedDate, 'Raw adminId:', pullConversationsAdminId, 'Raw date:', selectedDate);
    const cachedData = await getCachedConversations(normalizedAdminId, normalizedDate);
    if (cachedData) {
        console.log('✅ Using cached data, skipping API call');
        console.log('📦 Using cached data');
        updateProgressIndicator(10, 'Loading from cache...');
        
        // Small delay to show cache loading
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Extract conversations from cached data
        let conversations = [];
        if (cachedData && Array.isArray(cachedData.conversations)) {
            conversations = cachedData.conversations;
        } else if (cachedData && cachedData.type === 'conversation.list' && Array.isArray(cachedData.conversations)) {
            conversations = cachedData.conversations;
        }
        
        const participationCount = cachedData.participation_count || 0;
        
        console.log(`✅ Loaded ${conversations.length} conversations from cache`);
        console.log('📋 First conversation sample:', conversations[0] ? Object.keys(conversations[0]) : 'No conversations');
        
        // Update progress: Complete
        updateProgressIndicator(100, 'Loaded from cache');
        
        // Small delay to show completion
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Store conversations (original unfiltered list)
        pullConversationsList = conversations;
        
        // Initialize filtered list with all conversations
        pullConversationsFilteredList = [...conversations];
        
        // Only apply filters if any are actually set
        const hasActiveFilters = Object.values(pullConversationsFilters).some(value => value !== null && value !== '');
        if (hasActiveFilters) {
            await filterPullConversations();
        } else {
            // No filters, just display all conversations
            await displayPullConversationsList(conversations);
            updatePullConversationsCountAndAdmin(conversations.length);
        }
        
        // Hide loading and show results
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (listDiv) listDiv.style.display = 'block';
        
        // Show elements after loading
        showElementsAfterLoading();
        
        // Update active filters display
        updatePullConversationsActiveFilters();
        return;
    }
    
    // No cache found, fetch from API
    console.log('🌐 Fetching from API (no cache found)');
    
    // Update progress: Initial
    updateProgressIndicator(10, 'Pulling from Intercom...');
    
    try {
        // Build edge function URL
        const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=conversations&admin_id=${encodeURIComponent(pullConversationsAdminId)}&updated_date=${encodeURIComponent(selectedDate)}`;
        
        console.log('📡 Calling:', edgeFunctionUrl);
        
        // Update progress: Searching
        updateProgressIndicator(20, 'Searching conversations in Intercom...');
        
        // Create AbortController for timeout handling
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 120000); // 120 seconds timeout
        
        let response;
        try {
            response = await fetch(edgeFunctionUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${supabaseAnonKey}`,
                    'apikey': supabaseAnonKey,
                    'Accept': 'application/json'
                },
                signal: controller.signal
            });
        } catch (fetchError) {
            clearTimeout(timeoutId);
            
            // Handle timeout and network errors
            if (fetchError.name === 'AbortError') {
                throw new Error('Request timed out. The Intercom API is taking too long to respond. Please try again or check your internet connection.');
            } else if (fetchError.message.includes('Failed to fetch') || fetchError.message.includes('ERR_CONNECTION')) {
                throw new Error('Connection failed. Please check your internet connection and try again. If the problem persists, the Intercom service may be temporarily unavailable.');
            } else {
                throw new Error(`Network error: ${fetchError.message}`);
            }
        }
        
        clearTimeout(timeoutId);

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            const errorMsg = errorData.error || `HTTP ${response.status}: ${response.statusText}`;
            throw new Error(errorMsg);
        }

        // Update progress: Processing
        updateProgressIndicator(70, 'Processing participation data...');
        
        const data = await response.json();
        
        // Extract conversations from response first to validate
        let conversations = [];
        if (data && Array.isArray(data.conversations)) {
            conversations = data.conversations;
        } else if (data && data.type === 'conversation.list' && Array.isArray(data.conversations)) {
            conversations = data.conversations;
        }
        
        const participationCount = data.participation_count || 0;
        
        // Only cache if we have valid data
        if (data && conversations.length >= 0) {
            console.log('💾 Attempting to cache data...', { adminId: normalizedAdminId, date: normalizedDate, conversationCount: conversations.length });
            const cacheResult = await cacheConversations(normalizedAdminId, normalizedDate, data);
            if (cacheResult) {
                console.log('✅ Cache saved successfully');
            } else {
                console.warn('⚠️ Cache save failed or was skipped');
            }
        } else {
            console.warn('⚠️ Not caching: invalid or empty data', data);
        }
        
        console.log(`✅ Fetched ${conversations.length} participated conversations`);
        
        // Update progress: Complete
        updateProgressIndicator(100, 'Almost done...');
        
        // Small delay to show completion
        await new Promise(resolve => setTimeout(resolve, 200));
        
        // Store conversations (original unfiltered list)
        pullConversationsList = conversations;
        
        // Initialize filtered list with all conversations
        pullConversationsFilteredList = [...conversations];
        
        // Only apply filters if any are actually set
        const hasActiveFilters = Object.values(pullConversationsFilters).some(value => value !== null && value !== '');
        if (hasActiveFilters) {
            await filterPullConversations();
        } else {
            // No filters, just display all conversations
            await displayPullConversationsList(conversations);
            updatePullConversationsCountAndAdmin(conversations.length);
        }
        
        // Hide loading and show results
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (listDiv) listDiv.style.display = 'block';
        
        // Show elements after loading
        showElementsAfterLoading();
        
        // Update active filters display
        updatePullConversationsActiveFilters();
        
    } catch (error) {
        console.error('❌ Error fetching conversations:', error);
        
        // Provide more helpful error messages
        let errorMessage = error.message || 'An unknown error occurred';
        
        // Check for specific error types
        if (error.message.includes('timed out') || error.message.includes('timeout')) {
            errorMessage = 'Request timed out. The Intercom API is taking longer than expected. This might happen if there are many conversations to process. Please try again in a moment.';
        } else if (error.message.includes('Connection failed') || error.message.includes('ERR_CONNECTION')) {
            errorMessage = 'Connection failed. Please check your internet connection. If the problem persists, the service may be temporarily unavailable.';
        } else if (error.message.includes('Failed to fetch')) {
            errorMessage = 'Unable to reach the server. Please check your internet connection and try again.';
        }
        
        showPullConversationsError(`Failed to fetch conversations: ${errorMessage}`);
        if (loadingDiv) loadingDiv.style.display = 'none';
        
        // Update progress indicator to show error state
        updateProgressIndicator(0, 'Error occurred. Please try again.');
    }
}

// Update progress indicator
function updateProgressIndicator(percentage, message) {
    const statusElement = document.getElementById('pullConversationsStatus');
    const progressBar = document.getElementById('pullConversationsProgressBar');
    const progressText = document.getElementById('pullConversationsProgress');
    
    if (statusElement) {
        statusElement.textContent = message || 'Pulling from Intercom...';
    }
    
    if (progressBar) {
        progressBar.style.width = `${percentage}%`;
    }
    
    if (progressText && percentage === 100) {
        progressText.textContent = `✅ Loaded ${pullConversationsList.length} conversations`;
        setTimeout(() => {
            if (progressText) {
                progressText.textContent = '';
            }
        }, 3000);
    }
}

// Hide elements during loading
function hideElementsDuringLoading() {
    const dateSelector = document.getElementById('pullConversationsDate');
    const countDisplay = document.querySelector('#pullConversationsSection > div:nth-child(2)');
    
    if (dateSelector) {
        dateSelector.style.opacity = '0.5';
        dateSelector.disabled = true;
    }
    if (countDisplay) {
        countDisplay.style.opacity = '0.5';
    }
}

// Show elements after loading
function showElementsAfterLoading() {
    const dateSelector = document.getElementById('pullConversationsDate');
    const countDisplay = document.querySelector('#pullConversationsSection > div:nth-child(2)');
    
    if (dateSelector) {
        dateSelector.style.opacity = '1';
        dateSelector.disabled = false;
    }
    if (countDisplay) {
        countDisplay.style.opacity = '1';
    }
}

// Update count and admin name display
function updatePullConversationsCountAndAdmin(count) {
    const countElement = document.getElementById('pullConversationsCount');
    if (countElement) {
        countElement.textContent = count;
    }
    
    const adminNameElement = document.getElementById('pullConversationsAdminName');
    if (adminNameElement) {
        if (pullConversationsAdminName) {
            adminNameElement.textContent = `- ${pullConversationsAdminName}`;
            adminNameElement.style.display = 'inline';
        } else {
            adminNameElement.textContent = '';
            adminNameElement.style.display = 'none';
        }
    }
}

// Get list of already-audited conversation IDs
async function getAlreadyAuditedConversationIds() {
    const supabaseClient = window.SupabaseConfig?.getClient?.();
    if (!supabaseClient) {
        console.warn('Supabase client not available');
        return new Set();
    }
    
    try {
        const { data: assignments, error } = await supabaseClient
            .from('audit_assignments')
            .select('conversation_id')
            .not('conversation_id', 'is', null);
        
        if (error) {
            console.error('Error fetching already-audited conversations:', error);
            return new Set();
        }
        
        // Create a Set of conversation IDs (as strings for comparison)
        const auditedIds = new Set(
            (assignments || [])
                .map(a => String(a.conversation_id))
                .filter(id => id && id !== 'null' && id !== 'undefined')
        );
        
        console.log('✅ Loaded', auditedIds.size, 'already-audited conversation IDs');
        return auditedIds;
    } catch (error) {
        console.error('Error in getAlreadyAuditedConversationIds:', error);
        return new Set();
    }
}

// Display conversations list
async function displayPullConversationsList(conversations) {
    const tableBody = document.getElementById('pullConversationsTableBody');
    if (!tableBody) return;
    
        tableBody.innerHTML = '';
    
    if (conversations.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="12" style="text-align: center; padding: 1.9406rem; color: #9ca3af;">No conversations found for the selected date.</td></tr>';
        return;
    }
    
    // Get already-audited conversation IDs
    const alreadyAuditedIds = await getAlreadyAuditedConversationIds();
    
    // Sort conversations by: Lowest Rating, Lowest CX Score, Longest Length
    const sortedConversations = [...conversations].sort((a, b) => {
        // Extract rating (treat '-' or missing as high value for sorting)
        const ratingA = a.conversation_rating?.rating;
        const ratingB = b.conversation_rating?.rating;
        const ratingAValue = (ratingA && ratingA !== '-') ? parseFloat(ratingA) : 999;
        const ratingBValue = (ratingB && ratingB !== '-') ? parseFloat(ratingB) : 999;
        
        // Extract CX Score (treat null/undefined as high value for sorting)
        const cxScoreA = a.custom_attributes?.["CX Score rating"];
        const cxScoreB = b.custom_attributes?.["CX Score rating"];
        const cxScoreAValue = (cxScoreA !== null && cxScoreA !== undefined) ? parseInt(cxScoreA) : 999;
        const cxScoreBValue = (cxScoreB !== null && cxScoreB !== undefined) ? parseInt(cxScoreB) : 999;
        
        // Extract conversation length
        const lengthA = a.conversation_parts?.conversation_parts?.length || 0;
        const lengthB = b.conversation_parts?.conversation_parts?.length || 0;
        
        // Primary sort: Lowest Rating (ascending)
        if (ratingAValue !== ratingBValue) {
            return ratingAValue - ratingBValue;
        }
        
        // Secondary sort: Lowest CX Score (ascending)
        if (cxScoreAValue !== cxScoreBValue) {
            return cxScoreAValue - cxScoreBValue;
        }
        
        // Tertiary sort: Longest Length (descending - more messages first)
        return lengthB - lengthA;
    });
    
    // Get number of assigned audits for the specific employee whose conversations are being pulled
    // Use frontend pendingAudits array (already filtered to current user) instead of querying database
    let assignedAuditsCount = 0;
    let employeeAudits = [];
    if (pullConversationsAdminEmail && pendingAudits && pendingAudits.length > 0) {
        // Normalize email for comparison (lowercase, trim)
        const normalizedEmail = (pullConversationsAdminEmail || '').toLowerCase().trim();
        
        // Filter pendingAudits for this specific employee (already filtered to current user)
        employeeAudits = pendingAudits.filter(audit => {
            const auditEmployeeEmail = (audit.employee_email || '').toLowerCase().trim();
            return auditEmployeeEmail === normalizedEmail && 
                   (audit.status === 'pending' || audit.status === 'in_progress');
        });
        
        assignedAuditsCount = employeeAudits.length;
        
        // Debug logging
        console.log('🔍 Employee audit count (from frontend):', {
            employeeEmail: pullConversationsAdminEmail,
            normalizedEmail: normalizedEmail,
            totalPendingAuditsForUser: pendingAudits.length,
            auditsForThisEmployee: assignedAuditsCount,
            matchedAuditIds: employeeAudits.map(a => a.id)
        });
    }
    const highlightCount = Math.min(assignedAuditsCount, sortedConversations.length);
    
    console.log('🔍 Employee email:', pullConversationsAdminEmail, 'Assigned audits count:', assignedAuditsCount, 'Highlight count:', highlightCount);
    
    sortedConversations.forEach((conversation, index) => {
        const row = document.createElement('tr');
        
        // Make row draggable
        row.draggable = true;
        row.setAttribute('data-conversation-id', conversation.id);
        row.setAttribute('data-conversation-data', JSON.stringify(conversation));
        row.style.cursor = 'grab'; // Show grab cursor on hover
        
        // Extract data
        const clientName = extractClientName(conversation) || 'Unknown';
        const clientEmail = extractClientEmail(conversation) || '';
        const conversationId = (conversation.id || 'N/A').toString();
        
        // Check if this conversation is already audited
        const isAlreadyAudited = alreadyAuditedIds.has(conversationId);
        
        // Highlight top conversations based on number of assigned audits for the employee
        // But prioritize "already audited" styling if applicable
        const shouldHighlight = index < highlightCount && !isAlreadyAudited;
        if (shouldHighlight) {
            row.style.backgroundColor = '#fef3c7'; // Light yellow background
            row.style.borderLeft = '0.2rem solid #f59e0b'; // Orange left border
        }
        
        // Add visual indicator for already-audited conversations
        if (isAlreadyAudited) {
            row.style.backgroundColor = '#f3f4f6'; // Light gray background
            row.style.opacity = '0.7'; // Slightly faded
            row.style.borderLeft = '0.2rem solid #6b7280'; // Gray left border
        }
        
        // Store the default opacity for dragend handler
        const defaultOpacity = isAlreadyAudited ? '0.7' : '1';
        
        // Add drag event handlers
        row.addEventListener('dragstart', (e) => {
            // Don't start drag if clicking on buttons or interactive elements
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.closest('button') || e.target.closest('input')) {
                e.preventDefault();
                return;
            }
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', conversation.id);
            e.dataTransfer.setData('application/json', JSON.stringify(conversation));
            row.style.opacity = '0.5';
            row.style.cursor = 'grabbing';
        });
        
        row.addEventListener('dragend', (e) => {
            row.style.opacity = defaultOpacity;
            row.style.cursor = 'grab';
        });
        
        // Extract subject and strip HTML tags
        let subject = conversation.source?.subject || (conversation.source?.body ? conversation.source.body.substring(0, 50) : '') || 'No subject';
        // Strip HTML tags from subject
        if (subject && typeof subject === 'string') {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = subject;
            subject = tempDiv.textContent || tempDiv.innerText || subject;
        }
        const rating = conversation.conversation_rating?.rating || '-';
        const state = conversation.state || 'unknown';
        const createdDate = conversation.created_at_iso || (conversation.created_at ? new Date(conversation.created_at * 1000).toLocaleDateString() : '-');
        const updatedDate = conversation.updated_at_iso || (conversation.updated_at ? new Date(conversation.updated_at * 1000).toLocaleDateString() : '-');
        
        // Extract additional attributes
        const priority = conversation.priority || 'not_priority';
        const tags = conversation.tags?.tags || [];
        
        // Extract CX Score
        const cxScore = conversation.custom_attributes?.["CX Score rating"] ?? null;
        let cxScoreHtml = '-';
        if (cxScore !== null && cxScore !== undefined) {
            const cxScoreNum = parseInt(cxScore);
            if (!isNaN(cxScoreNum)) {
                const cxScoreColor = cxScoreNum >= 4 ? '#10b981' : cxScoreNum >= 3 ? '#f59e0b' : '#ef4444';
                cxScoreHtml = `<span style="color: ${cxScoreColor}; font-weight: 600; font-size: 0.6069rem;">${cxScoreNum}</span>`;
            }
        }
        
        // Calculate conversation length
        const conversationLength = conversation.conversation_parts?.conversation_parts?.length || 0;
        const lengthDisplay = conversationLength > 0 
            ? `<span style="font-size: 0.6069rem; color: #374151; font-weight: 500;">${conversationLength}</span>`
            : '<span style="color: #9ca3af; font-size: 0.5252rem;">-</span>';
        
        // Format rating (compact)
        let ratingHtml = '-';
        if (rating && rating !== '-') {
            const ratingColor = rating >= 4 ? '#10b981' : rating >= 3 ? '#f59e0b' : '#ef4444';
            ratingHtml = `<span style="color: ${ratingColor}; font-weight: 600; font-size: 0.6069rem;">${rating}/5</span>`;
        }
        
        // Format state (compact badge)
        const stateColor = state === 'closed' ? '#10b981' : state === 'open' ? '#f59e0b' : '#6b7280';
        const stateBadge = `<span style="background: ${stateColor === '#10b981' ? '#d1fae5' : stateColor === '#f59e0b' ? '#fef3c7' : '#f3f4f6'}; color: ${stateColor}; padding: 0.08rem 0.25rem; border-radius: 0.16rem; font-size: 0.4852rem; font-weight: 500;">${state}</span>`;
        
        // Format priority (icon only)
        const priorityBadge = priority === 'priority' 
            ? `<svg style="width: 0.75rem; height: 0.75rem; color: #dc2626; vertical-align: middle;" fill="currentColor" viewBox="0 0 24 24" title="Priority">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
            </svg>`
            : `<span style="color: #9ca3af; font-size: 0.5252rem;">-</span>`;
        
        // Format tags (show all with full names)
        let tagsHtml = '-';
        if (tags && tags.length > 0) {
            const displayTags = tags.map(tag => {
                const tagName = (tag.name || tag || '').toString();
                return tagName;
            }).filter(tag => tag);
            if (displayTags.length > 0) {
                tagsHtml = `<div style="display: flex; flex-wrap: wrap; gap: 0.08rem; max-width: 15rem;">
                    ${displayTags.map(tag => `<span style="background: #e0e7ff; color: #4338ca; padding: 0.04rem 0.16rem; border-radius: 0.08rem; font-size: 0.4447rem; font-weight: 500;">${escapeHtml(tag)}</span>`).join('')}
                </div>`;
            }
        }
        
        // Format dates (compact)
        const createdDateShort = createdDate !== '-' ? new Date(createdDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : '-';
        const updatedDateShort = updatedDate !== '-' ? new Date(updatedDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : '-';
        
        row.innerHTML = `
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle; text-align: center;">
                <input type="checkbox" class="conversation-checkbox" data-conversation-id="${conversation.id}" style="cursor: pointer;" onclick="event.stopPropagation(); updatePullConversationsSelection();">
            </td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle;">
                <div style="font-weight: 500; color: #111827; font-size: 0.6069rem; line-height: 1.2;">${escapeHtml(clientName)}</div>
                <div style="font-size: 0.5252rem; color: #6b7280; line-height: 1.2;">${clientEmail ? escapeHtml(clientEmail.substring(0, 20)) + (clientEmail.length > 20 ? '...' : '') : '-'}</div>
            </td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle;">
                <div style="display: flex; align-items: center; gap: 0.25rem;">
                    <span style="font-family: 'Poppins', sans-serif; font-size: 0.5252rem; color: #6b7280;">${conversationId && conversationId !== 'N/A' ? conversationId : 'N/A'}</span>
                    ${conversationId && conversationId !== 'N/A' ? `<button onclick="event.stopPropagation(); copyToClipboard('${conversationId}', this);" style="padding: 0.08rem; background: transparent; border: none; cursor: pointer; color: #6b7280; transition: all 0.2s;" onmouseover="this.style.color='#1A733E';" onmouseout="this.style.color='#6b7280';" title="Copy ID">
                        <svg style="width: 0.65rem; height: 0.65rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                    </button>` : ''}
                    ${isAlreadyAudited ? `<span style="background: #6b7280; color: white; padding: 0.08rem 0.25rem; border-radius: 0.16rem; font-size: 0.4447rem; font-weight: 600; white-space: nowrap; margin-left: 0.25rem;" title="This conversation has already been audited">Audited</span>` : ''}
                </div>
            </td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle;">
                <div style="max-width: 10rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 0.6069rem; color: #374151;" title="${escapeHtml(subject)}">${escapeHtml(subject)}</div>
            </td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle; text-align: center;">${ratingHtml}</td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle; text-align: center;">${cxScoreHtml}</td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle; text-align: center;">${lengthDisplay}</td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle; text-align: center;">${stateBadge}</td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle; text-align: center;">${priorityBadge}</td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle; max-width: 15rem;">${tagsHtml}</td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle; font-size: 0.5252rem; color: #6b7280; white-space: nowrap; text-align: center;" title="${createdDate}">${createdDateShort}</td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle; font-size: 0.5252rem; color: #6b7280; white-space: nowrap; text-align: center;" title="${updatedDate}">${updatedDateShort}</td>
            <td style="padding: 0.25rem 0.375rem; vertical-align: middle; text-align: center;">
                <div style="display: flex; gap: 0.25rem; justify-content: center; align-items: center;">
                    <button 
                        class="open-in-intercom-btn"
                        data-conversation-id="${conversation.id}"
                        style="padding: 0.16rem 0.32rem; font-size: 0.4852rem; font-weight: 500; color: #2563eb; background: #dbeafe; border: none; border-radius: 0.16rem; cursor: pointer; transition: all 0.2s; white-space: nowrap;"
                        onmouseover="this.style.background='#bfdbfe'" 
                        onmouseout="this.style.background='#dbeafe'"
                        title="Open in Intercom"
                    >
                        Open
                    </button>
                ${shouldHighlight && employeeAudits.length > 0 ? `
                    <button 
                        class="quick-start-audit-btn"
                        data-conversation-id="${conversation.id}"
                        data-audit-index="${index % assignedAuditsCount}"
                        data-audit-id="${employeeAudits[index % assignedAuditsCount]?.id || ''}"
                        style="padding: 0.2425rem 0.4852rem; background-color: #1A733E; color: white; border: none; border-radius: 0.1617rem; font-size: 0.4852rem; font-family: 'Poppins', sans-serif; font-weight: 500; cursor: pointer; transition: all 0.2s ease; white-space: nowrap;"
                        onmouseover="this.style.backgroundColor='#15582E'"
                        onmouseout="this.style.backgroundColor='#1A733E'"
                        title="Start audit #${(index % assignedAuditsCount) + 1} for this conversation"
                    >
                        Start Audit #${(index % assignedAuditsCount) + 1}
                    </button>
                ` : `
                <button 
                    class="start-audit-from-conversation-btn"
                    data-conversation-id="${conversation.id}"
                        ${selectedAuditId ? '' : 'disabled'}
                        style="padding: 0.16rem 0.32rem; font-size: 0.4852rem; font-weight: 500; color: ${selectedAuditId ? '#1A733E' : '#9ca3af'}; background: ${selectedAuditId ? '#d1fae5' : '#f3f4f6'}; border: none; border-radius: 0.16rem; cursor: ${selectedAuditId ? 'pointer' : 'not-allowed'}; transition: all 0.2s; white-space: nowrap; opacity: ${selectedAuditId ? '1' : '0.6'};"
                        onmouseover="${selectedAuditId ? "this.style.background='#a7f3d0'" : ''}"
                        onmouseout="${selectedAuditId ? "this.style.background='#d1fae5'" : ''}"
                        title="${selectedAuditId ? 'Start audit from conversation' : 'Please select an assigned audit first'}"
                >
                    Audit
                </button>
                `}
                </div>
            </td>
        `;
        
        // Attach click handler to the "Open in Intercom" button
        const openInIntercomBtn = row.querySelector('.open-in-intercom-btn');
        if (openInIntercomBtn) {
            openInIntercomBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                openConversationInIntercom(conversation.id);
            });
        }
        
        // Attach click handler to the Audit button using the conversation from closure
        const auditButton = row.querySelector('.start-audit-from-conversation-btn');
        if (auditButton) {
            auditButton.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!selectedAuditId) {
                    return; // Button is disabled, do nothing
                }
                window.startAuditFromConversation(conversation);
            });
        }
        
        // Attach click handler to the Quick Start Audit button (for highlighted rows)
        const quickStartButton = row.querySelector('.quick-start-audit-btn');
        if (quickStartButton) {
            quickStartButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const auditId = quickStartButton.getAttribute('data-audit-id');
                if (auditId) {
                    window.quickStartAuditFromConversation(conversation, auditId);
                }
            });
        }
        
        tableBody.appendChild(row);
    });
    
    // Update all audit buttons after rendering
    updateAuditButtonsState();
}

// Track open Intercom tabs
let openIntercomTabs = [];
const MAX_INTERCOM_TABS = 10;

// Update selection state
window.updatePullConversationsSelection = function() {
    const checkboxes = document.querySelectorAll('.conversation-checkbox');
    const selectAllCheckbox = document.getElementById('selectAllPullConversations');
    const bulkActionsBar = document.getElementById('pullConversationsBulkActions');
    const selectedCountSpan = document.getElementById('pullConversationsSelectedCount');
    
    if (!checkboxes || checkboxes.length === 0) {
        if (bulkActionsBar) bulkActionsBar.style.display = 'none';
        return;
    }
    
    const checkedBoxes = Array.from(checkboxes).filter(cb => cb.checked);
    const selectedCount = checkedBoxes.length;
    
    // Update select all checkbox
    if (selectAllCheckbox) {
        selectAllCheckbox.checked = checkboxes.length > 0 && checkedBoxes.length === checkboxes.length;
        selectAllCheckbox.indeterminate = checkedBoxes.length > 0 && checkedBoxes.length < checkboxes.length;
    }
    
    // Bulk actions bar removed - no longer needed
    if (bulkActionsBar) {
        bulkActionsBar.style.display = 'none';
    }
};

// Select all conversations
window.selectAllPullConversations = function(checked) {
    const checkboxes = document.querySelectorAll('.conversation-checkbox');
    checkboxes.forEach(cb => {
        cb.checked = checked;
    });
    updatePullConversationsSelection();
};

// Build Intercom URL
function buildIntercomUrl(conversationId) {
    const workspaceId = window.intercomConfig?.appId || 'aphmhtyj';
    return `https://app.intercom.com/a/inbox/${workspaceId}/inbox/conversation/${conversationId}?view`;
}

// Open single conversation in Intercom
window.openConversationInIntercom = async function(conversationId) {
    if (!conversationId) {
        console.warn('No conversation ID provided');
        return;
    }
    
    // Clean up closed tabs
    openIntercomTabs = openIntercomTabs.filter(tabInfo => {
        if (!tabInfo.tab) return false;
        try {
            return !tabInfo.tab.closed;
        } catch (e) {
            // Tab reference is invalid
            return false;
        }
    });
    
    // Check limit
    if (openIntercomTabs.length >= MAX_INTERCOM_TABS) {
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Tab Limit Reached',
                message: `You can only have ${MAX_INTERCOM_TABS} Intercom tabs open at once. Please close some tabs first.`,
                confirmText: 'OK',
                type: 'warning'
            });
        } else {
            alert(`You can only have ${MAX_INTERCOM_TABS} Intercom tabs open at once. Please close some tabs first.`);
        }
        return;
    }
    
    const conversationUrl = buildIntercomUrl(conversationId);
    const newTab = window.open(conversationUrl, '_blank', 'noopener,noreferrer');
    
    if (!newTab || newTab.closed || typeof newTab.closed === 'undefined') {
        // Check if user has chosen to not show this warning
        const doNotShowKey = 'intercom_popup_blocked_warning_dismissed';
        if (localStorage.getItem(doNotShowKey) === 'true') {
            // User chose not to see this warning, just return silently
            return;
        }
        
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Popup Blocked',
                message: 'Please allow popups for this site to open Intercom conversations.',
                confirmText: 'OK',
                type: 'warning',
                doNotShowAgain: true,
                doNotShowAgainKey: doNotShowKey
            });
        } else {
            alert('Please allow popups for this site to open Intercom conversations.');
        }
        return;
    }
    
    // Track the tab
    openIntercomTabs.push({
        tab: newTab,
        conversationId: conversationId,
        openedAt: Date.now()
    });
    
    console.log(`✅ Opened conversation ${conversationId} in Intercom. Total open tabs: ${openIntercomTabs.length}`);
};

// Open selected conversations in Intercom
window.openSelectedConversationsInIntercom = async function() {
    const checkboxes = document.querySelectorAll('.conversation-checkbox:checked');
    const selectedIds = Array.from(checkboxes).map(cb => cb.dataset.conversationId).filter(id => id);
    
    if (selectedIds.length === 0) {
        return;
    }
    
    // Clean up closed tabs
    openIntercomTabs = openIntercomTabs.filter(tabInfo => {
        if (!tabInfo.tab) return false;
        try {
            return !tabInfo.tab.closed;
        } catch (e) {
            return false;
        }
    });
    
    // Check if we can open all selected
    const currentOpenCount = openIntercomTabs.length;
    const willExceedLimit = currentOpenCount + selectedIds.length > MAX_INTERCOM_TABS;
    
    if (willExceedLimit) {
        const canOpen = MAX_INTERCOM_TABS - currentOpenCount;
        
        if (canOpen === 0) {
            if (window.confirmationDialog) {
                await window.confirmationDialog.show({
                    title: 'Tab Limit Reached',
                    message: `You've reached the limit of ${MAX_INTERCOM_TABS} open tabs. Please close some tabs first.`,
                    confirmText: 'OK',
                    type: 'warning'
                });
            } else {
                alert(`You've reached the limit of ${MAX_INTERCOM_TABS} open tabs. Please close some tabs first.`);
            }
            return;
        }
        
        // Limit to what we can open
        selectedIds.splice(canOpen);
    }
    
    // Open all tabs immediately - browsers allow multiple popups from single user gesture
    // This maintains the user gesture chain, so popup blocker won't interfere
    // We'll open them directly here to avoid individual limit checks interfering
    for (let i = 0; i < selectedIds.length; i++) {
        const conversationId = selectedIds[i];
        const conversationUrl = buildIntercomUrl(conversationId);
        const newTab = window.open(conversationUrl, '_blank', 'noopener,noreferrer');
        
        if (newTab && !newTab.closed && typeof newTab.closed !== 'undefined') {
            // Track the tab
            openIntercomTabs.push({
                tab: newTab,
                conversationId: conversationId,
                openedAt: Date.now()
            });
            console.log(`✅ Opened conversation ${conversationId} in Intercom. Total open tabs: ${openIntercomTabs.length}`);
        } else {
            // Popup was blocked for this one, but continue with others
            console.warn(`⚠️ Popup blocked for conversation ${conversationId}`);
        }
    }
    
    // Clear selection after opening
    checkboxes.forEach(cb => cb.checked = false);
    updatePullConversationsSelection();
};

// Show error message
function showPullConversationsError(message) {
    const errorDiv = document.getElementById('pullConversationsError');
    const errorMessage = document.getElementById('pullConversationsErrorMessage');
    const loadingDiv = document.getElementById('pullConversationsLoading');
    const listDiv = document.getElementById('pullConversationsList');
    
    if (errorDiv && errorMessage) {
        errorMessage.textContent = message;
        errorDiv.style.display = 'block';
    }
    if (loadingDiv) loadingDiv.style.display = 'none';
    if (listDiv) listDiv.style.display = 'none';
}

// Close pull conversations section
// Hide "Start Audit" buttons in nested cards for a specific employee
function hideNestedStartButtonsForEmployee(employeeEmail) {
    if (!employeeEmail) return;
    
    const normalizedEmail = (employeeEmail || '').toLowerCase().trim();
    
    // Find all nested cards and check if they belong to this employee
    // Method 1: Find by audit data (if we have pendingAudits)
    if (pendingAudits && pendingAudits.length > 0) {
        const employeeAuditIds = pendingAudits
            .filter(audit => {
                const auditEmail = (audit.employee_email || '').toLowerCase().trim();
                return auditEmail === normalizedEmail && 
                       (audit.status === 'pending' || audit.status === 'in_progress');
            })
            .map(audit => audit.id);
        
        employeeAuditIds.forEach(auditId => {
            const card = document.querySelector(`.nested-audit-card[data-audit-id="${auditId}"]`);
            if (card) {
                const startButton = card.querySelector('.nested-start-audit-btn');
                if (startButton) {
                    startButton.style.display = 'none';
                }
            }
        });
    }
    
    // Method 2: Find by group card and hide all nested cards within it
    const groupCards = document.querySelectorAll('#pendingAuditsList > div');
    groupCards.forEach(groupCard => {
        const pullButton = groupCard.querySelector('.pull-conversations-btn-group[data-email]');
        if (pullButton) {
            const groupEmail = (pullButton.getAttribute('data-email') || '').toLowerCase().trim();
            if (groupEmail === normalizedEmail) {
                // This is the group for this employee, hide all Start Audit buttons in nested cards
                const nestedCards = groupCard.querySelectorAll('.nested-audit-card');
                nestedCards.forEach(card => {
                    const startButton = card.querySelector('.nested-start-audit-btn');
                    if (startButton) {
                        startButton.style.display = 'none';
                    }
                });
            }
        }
    });
}

// Show "Start Audit" buttons in nested cards for a specific employee
function showNestedStartButtonsForEmployee(employeeEmail) {
    if (!employeeEmail) return;
    
    const normalizedEmail = (employeeEmail || '').toLowerCase().trim();
    
    // Find all nested cards and check if they belong to this employee
    // Method 1: Find by audit data (if we have pendingAudits)
    if (pendingAudits && pendingAudits.length > 0) {
        const employeeAuditIds = pendingAudits
            .filter(audit => {
                const auditEmail = (audit.employee_email || '').toLowerCase().trim();
                return auditEmail === normalizedEmail && 
                       (audit.status === 'pending' || audit.status === 'in_progress');
            })
            .map(audit => audit.id);
        
        employeeAuditIds.forEach(auditId => {
            const card = document.querySelector(`.nested-audit-card[data-audit-id="${auditId}"]`);
            if (card) {
                const startButton = card.querySelector('.nested-start-audit-btn');
                if (startButton) {
                    startButton.style.display = 'flex';
                }
            }
        });
    }
    
    // Method 2: Find by group card and show all nested cards within it
    const groupCards = document.querySelectorAll('#pendingAuditsList > div');
    groupCards.forEach(groupCard => {
        const pullButton = groupCard.querySelector('.pull-conversations-btn-group[data-email]');
        if (pullButton) {
            const groupEmail = (pullButton.getAttribute('data-email') || '').toLowerCase().trim();
            if (groupEmail === normalizedEmail) {
                // This is the group for this employee, show all Start Audit buttons in nested cards
                const nestedCards = groupCard.querySelectorAll('.nested-audit-card');
                nestedCards.forEach(card => {
                    const startButton = card.querySelector('.nested-start-audit-btn');
                    if (startButton) {
                        startButton.style.display = 'flex';
                    }
                });
            }
        }
    });
}

window.closePullConversationsSection = function() {
    const section = document.getElementById('pullConversationsSection');
    if (section) {
        section.style.display = 'none';
        
        // Remove green highlighting from all group cards
        removeHighlightFromAllGroupCards();
        
        // Show "Start Audit" buttons in nested cards again when conversations section is closed
        if (pullConversationsAdminEmail) {
            showNestedStartButtonsForEmployee(pullConversationsAdminEmail);
        }
    }
    // Reset state
    pullConversationsAdminId = null;
    pullConversationsList = [];
    pullConversationsFilteredList = [];
    pullConversationsFilters = {
        state: null,
        priority: null,
        rating: null,
        sourceType: null,
        productType: null,
        language: null,
        slaStatus: null,
        minParts: null,
        minReopens: null,
        maxTimeToReply: null,
        clientSearch: null,
        conversationId: null
    };
};

// ============================================================================
// Pull Conversations Filtering Functions
// ============================================================================

// Handle rating type change to show/hide conditional inputs
function handleRatingTypeChange() {
    const ratingType = document.getElementById('pullFilterRatingType')?.value || '';
    const exactSelect = document.getElementById('pullFilterRatingExact');
    const rangeDiv = document.getElementById('pullFilterRatingRange');
    const errorDiv = document.getElementById('pullFilterRatingRangeError');
    
    // Hide all conditional inputs first
    if (exactSelect) exactSelect.style.display = 'none';
    if (rangeDiv) rangeDiv.style.display = 'none';
    if (errorDiv) {
        errorDiv.style.display = 'none';
        errorDiv.textContent = '';
    }
    
    // Show appropriate input based on selection
    if (ratingType === 'exact') {
        if (exactSelect) exactSelect.style.display = 'block';
    } else if (ratingType === 'range') {
        if (rangeDiv) rangeDiv.style.display = 'flex';
        
        // Add validation for range inputs
        const minInput = document.getElementById('pullFilterRatingMin');
        const maxInput = document.getElementById('pullFilterRatingMax');
        
        if (minInput && maxInput && !minInput.hasAttribute('data-listener-attached')) {
            // Add validation listeners
            const validateRange = () => {
                const min = parseInt(minInput.value, 10);
                const max = parseInt(maxInput.value, 10);
                
                if (minInput.value && maxInput.value) {
                    if (isNaN(min) || isNaN(max) || min < 1 || min > 5 || max < 1 || max > 5) {
                        if (errorDiv) {
                            errorDiv.textContent = 'Rating must be between 1 and 5.';
                            errorDiv.style.display = 'block';
                        }
                        return false;
                    } else if (min > max) {
                        if (errorDiv) {
                            errorDiv.textContent = 'Minimum cannot be greater than maximum.';
                            errorDiv.style.display = 'block';
                        }
                        return false;
                    } else {
                        if (errorDiv) {
                            errorDiv.style.display = 'none';
                            errorDiv.textContent = '';
                        }
                        return true;
                    }
                } else {
                    if (errorDiv) {
                        errorDiv.style.display = 'none';
                        errorDiv.textContent = '';
                    }
                    return true;
                }
            };
            
            minInput.addEventListener('input', validateRange);
            maxInput.addEventListener('input', validateRange);
            minInput.addEventListener('blur', validateRange);
            maxInput.addEventListener('blur', validateRange);
            
            minInput.setAttribute('data-listener-attached', 'true');
            maxInput.setAttribute('data-listener-attached', 'true');
        }
    }
}

// Open filter dialog
window.openPullConversationsFilterDialog = function() {
    const modal = document.getElementById('pullConversationsFilterModal');
    if (!modal) return;
    
    // Set current filter values in the form
    document.getElementById('pullFilterState').value = pullConversationsFilters.state || '';
    document.getElementById('pullFilterPriority').value = pullConversationsFilters.priority || '';
    // Handle rating filter (support both old string format and new object format)
    const ratingFilter = pullConversationsFilters.rating;
    if (ratingFilter) {
        if (typeof ratingFilter === 'string') {
            // Old format: migrate to new format
            if (ratingFilter === 'unrated') {
                document.getElementById('pullFilterRatingType').value = 'unrated';
            } else if (ratingFilter) {
                document.getElementById('pullFilterRatingType').value = 'exact';
                document.getElementById('pullFilterRatingExact').value = ratingFilter;
            }
        } else if (typeof ratingFilter === 'object') {
            // New format
            document.getElementById('pullFilterRatingType').value = ratingFilter.type || '';
            if (ratingFilter.type === 'exact' && ratingFilter.value) {
                document.getElementById('pullFilterRatingExact').value = ratingFilter.value;
            } else if (ratingFilter.type === 'range') {
                if (ratingFilter.min) document.getElementById('pullFilterRatingMin').value = ratingFilter.min;
                if (ratingFilter.max) document.getElementById('pullFilterRatingMax').value = ratingFilter.max;
            }
        }
    }
    // Trigger change to show/hide conditional inputs
    const ratingTypeSelect = document.getElementById('pullFilterRatingType');
    if (ratingTypeSelect) {
        // Set up event listener if not already set
        if (!ratingTypeSelect.hasAttribute('data-listener-attached')) {
            ratingTypeSelect.addEventListener('change', handleRatingTypeChange);
            ratingTypeSelect.setAttribute('data-listener-attached', 'true');
        }
        ratingTypeSelect.dispatchEvent(new Event('change'));
    }
    
    // Handle CX Score filter
    const cxScoreFilter = pullConversationsFilters.cxScore;
    if (cxScoreFilter) {
        document.getElementById('pullFilterCxScoreType').value = cxScoreFilter.type || '';
        if (cxScoreFilter.type === 'exact' && cxScoreFilter.value) {
            document.getElementById('pullFilterCxScoreExact').value = cxScoreFilter.value;
        } else if (cxScoreFilter.type === 'range') {
            if (cxScoreFilter.min) document.getElementById('pullFilterCxScoreMin').value = cxScoreFilter.min;
            if (cxScoreFilter.max) document.getElementById('pullFilterCxScoreMax').value = cxScoreFilter.max;
        }
    }
    // Trigger change to show/hide conditional inputs for CX Score
    const cxScoreTypeSelect = document.getElementById('pullFilterCxScoreType');
    if (cxScoreTypeSelect) {
        if (!cxScoreTypeSelect.hasAttribute('data-listener-attached')) {
            cxScoreTypeSelect.addEventListener('change', function() {
                const type = this.value;
                const exactSelect = document.getElementById('pullFilterCxScoreExact');
                const rangeDiv = document.getElementById('pullFilterCxScoreRange');
                const errorDiv = document.getElementById('pullFilterCxScoreRangeError');
                
                if (exactSelect) exactSelect.style.display = type === 'exact' ? 'block' : 'none';
                if (rangeDiv) rangeDiv.style.display = type === 'range' ? 'flex' : 'none';
                if (errorDiv) errorDiv.style.display = 'none';
            });
            cxScoreTypeSelect.setAttribute('data-listener-attached', 'true');
        }
        cxScoreTypeSelect.dispatchEvent(new Event('change'));
    }
    
    // Handle Conversation Length filter
    if (pullConversationsFilters.conversationLength) {
        const lengthFilter = pullConversationsFilters.conversationLength;
        if (lengthFilter.min !== undefined) document.getElementById('pullFilterLengthMin').value = lengthFilter.min;
        if (lengthFilter.max !== undefined) document.getElementById('pullFilterLengthMax').value = lengthFilter.max;
    }
    
    document.getElementById('pullFilterClientSearch').value = pullConversationsFilters.clientSearch || '';
    document.getElementById('pullFilterConversationId').value = pullConversationsFilters.conversationId || '';
    
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden';
    
    // Close on Escape key
    const escapeHandler = (e) => {
        if (e.key === 'Escape') {
            closePullConversationsFilterDialog();
            document.removeEventListener('keydown', escapeHandler);
        }
    };
    document.addEventListener('keydown', escapeHandler);
};

// Close filter dialog
window.closePullConversationsFilterDialog = function() {
    const modal = document.getElementById('pullConversationsFilterModal');
    if (modal) {
        modal.style.display = 'none';
    }
    document.body.style.overflow = '';
};

// Show Coming Soon Dialog
window.showComingSoonDialog = function(employeeName) {
    const modal = document.getElementById('comingSoonModal');
    if (modal) {
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        
        // Optionally update the message to include employee name
        if (employeeName) {
            const message = modal.querySelector('p');
            if (message) {
                message.textContent = `We're working on an AI-powered audit feature for ${employeeName} that will automatically analyze conversations and generate audit reports. Stay tuned!`;
            }
        } else {
            // Reset to default message if no employee name
            const message = modal.querySelector('p');
            if (message) {
                message.textContent = `We're working on an AI-powered audit feature that will automatically analyze conversations and generate audit reports. Stay tuned!`;
            }
        }
        
        // Close on Escape key
        const escapeHandler = (e) => {
            if (e.key === 'Escape') {
                closeComingSoonDialog();
                document.removeEventListener('keydown', escapeHandler);
            }
        };
        document.addEventListener('keydown', escapeHandler);
    }
};

// Close Coming Soon Dialog
window.closeComingSoonDialog = function() {
    const modal = document.getElementById('comingSoonModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = '';
    }
};

// Apply filters to conversations
window.applyPullConversationsFilters = async function() {
    // Get filter values from form - normalize empty strings to null
    const getValue = (id) => {
        const el = document.getElementById(id);
        const val = el ? el.value : '';
        return val && val.trim() ? val.trim() : null;
    };
    
    pullConversationsFilters.state = getValue('pullFilterState');
    pullConversationsFilters.priority = getValue('pullFilterPriority');
    
    // Handle rating filter with new structure
    const ratingType = getValue('pullFilterRatingType');
    if (ratingType) {
        if (ratingType === 'exact') {
            const exactValue = getValue('pullFilterRatingExact');
            if (exactValue) {
                pullConversationsFilters.rating = {
                    type: 'exact',
                    value: exactValue
                };
            } else {
                pullConversationsFilters.rating = null;
            }
        } else if (ratingType === 'range') {
            const minEl = document.getElementById('pullFilterRatingMin');
            const maxEl = document.getElementById('pullFilterRatingMax');
            const min = minEl && minEl.value ? parseInt(minEl.value, 10) : null;
            const max = maxEl && maxEl.value ? parseInt(maxEl.value, 10) : null;
            
            // Validate range
            if (min !== null && max !== null) {
                if (min < 1 || min > 5 || max < 1 || max > 5) {
                    alert('Rating range must be between 1 and 5.');
                    return;
                }
                if (min > max) {
                    alert('Minimum rating cannot be greater than maximum rating.');
                    return;
                }
                pullConversationsFilters.rating = {
                    type: 'range',
                    min: min,
                    max: max
                };
            } else {
                alert('Please enter both minimum and maximum ratings for range filter.');
                return;
            }
        } else if (ratingType === 'hasRating' || ratingType === 'unrated') {
            pullConversationsFilters.rating = {
                type: ratingType
            };
        } else {
            pullConversationsFilters.rating = null;
        }
    } else {
        pullConversationsFilters.rating = null;
    }
    
    // Handle CX Score filter
    const cxScoreType = getValue('pullFilterCxScoreType');
    if (cxScoreType) {
        if (cxScoreType === 'exact') {
            const exactValue = getValue('pullFilterCxScoreExact');
            if (exactValue) {
                pullConversationsFilters.cxScore = {
                    type: 'exact',
                    value: exactValue
                };
            } else {
                pullConversationsFilters.cxScore = null;
            }
        } else if (cxScoreType === 'range') {
            const minEl = document.getElementById('pullFilterCxScoreMin');
            const maxEl = document.getElementById('pullFilterCxScoreMax');
            const min = minEl && minEl.value ? parseInt(minEl.value, 10) : null;
            const max = maxEl && maxEl.value ? parseInt(maxEl.value, 10) : null;
            
            // Validate range
            if (min !== null && max !== null) {
                if (min < 1 || min > 5 || max < 1 || max > 5) {
                    alert('CX Score range must be between 1 and 5.');
                    return;
                }
                if (min > max) {
                    alert('Minimum CX Score cannot be greater than maximum score.');
                    return;
                }
                pullConversationsFilters.cxScore = {
                    type: 'range',
                    min: min,
                    max: max
                };
            } else {
                alert('Please enter both minimum and maximum scores for range filter.');
                return;
            }
        } else if (cxScoreType === 'hasScore' || cxScoreType === 'noScore') {
            pullConversationsFilters.cxScore = {
                type: cxScoreType
            };
        } else {
            pullConversationsFilters.cxScore = null;
        }
    } else {
        pullConversationsFilters.cxScore = null;
    }
    
    // Handle Conversation Length filter
    const lengthMinEl = document.getElementById('pullFilterLengthMin');
    const lengthMaxEl = document.getElementById('pullFilterLengthMax');
    const lengthMin = lengthMinEl && lengthMinEl.value ? parseInt(lengthMinEl.value, 10) : null;
    const lengthMax = lengthMaxEl && lengthMaxEl.value ? parseInt(lengthMaxEl.value, 10) : null;
    
    if (lengthMin !== null || lengthMax !== null) {
        if (lengthMin !== null && lengthMin < 0) {
            alert('Minimum conversation length cannot be negative.');
            return;
        }
        if (lengthMax !== null && lengthMax < 0) {
            alert('Maximum conversation length cannot be negative.');
            return;
        }
        if (lengthMin !== null && lengthMax !== null && lengthMin > lengthMax) {
            alert('Minimum conversation length cannot be greater than maximum length.');
            return;
        }
        pullConversationsFilters.conversationLength = {
            min: lengthMin !== null ? lengthMin : undefined,
            max: lengthMax !== null ? lengthMax : undefined
        };
    } else {
        pullConversationsFilters.conversationLength = null;
    }
    
    pullConversationsFilters.clientSearch = getValue('pullFilterClientSearch');
    pullConversationsFilters.conversationId = getValue('pullFilterConversationId');
    
    console.log('🎯 Applied filters:', pullConversationsFilters);
    
    // Apply filters
    await filterPullConversations();
    
    // Close modal
    closePullConversationsFilterDialog();
    
    // Update active filters display
    updatePullConversationsActiveFilters();
};

// Filter conversations based on current filters
async function filterPullConversations() {
    console.log('🔍 Filtering conversations...');
    console.log('📊 Original list length:', pullConversationsList?.length || 0);
    console.log('🎯 Active filters:', pullConversationsFilters);
    
    if (!pullConversationsList || pullConversationsList.length === 0) {
        console.log('⚠️ No conversations to filter');
        pullConversationsFilteredList = [];
        await displayPullConversationsList([]);
        return;
    }
    
    let filtered = [...pullConversationsList]; // Create a copy
    const initialCount = filtered.length;
    
    // Filter by state
    if (pullConversationsFilters.state) {
        const beforeCount = filtered.length;
        filtered = filtered.filter(conv => {
            const matches = conv.state === pullConversationsFilters.state;
            if (!matches && beforeCount <= 5) {
                console.log(`❌ State filter: conv.state=${conv.state}, filter=${pullConversationsFilters.state}`);
            }
            return matches;
        });
        console.log(`🔍 State filter (${pullConversationsFilters.state}): ${beforeCount} → ${filtered.length}`);
    }
    
    // Filter by priority
    if (pullConversationsFilters.priority) {
        const beforeCount = filtered.length;
        filtered = filtered.filter(conv => {
            const matches = conv.priority === pullConversationsFilters.priority;
            if (!matches && beforeCount <= 5) {
                console.log(`❌ Priority filter: conv.priority=${conv.priority}, filter=${pullConversationsFilters.priority}`);
            }
            return matches;
        });
        console.log(`🔍 Priority filter (${pullConversationsFilters.priority}): ${beforeCount} → ${filtered.length}`);
    }
    
    // Filter by rating (support both old string format and new object format)
    if (pullConversationsFilters.rating) {
        const beforeCount = filtered.length;
        const ratingFilter = pullConversationsFilters.rating;
        
        // Handle old string format for backward compatibility
        if (typeof ratingFilter === 'string') {
            if (ratingFilter === 'unrated') {
            filtered = filtered.filter(conv => !conv.conversation_rating || !conv.conversation_rating.rating);
        } else {
                const ratingNum = parseInt(ratingFilter);
            filtered = filtered.filter(conv => {
                const convRating = conv.conversation_rating?.rating;
                    return convRating === ratingNum;
                });
            }
        } else if (typeof ratingFilter === 'object' && ratingFilter.type) {
            // New object format
            if (ratingFilter.type === 'hasRating') {
                // Filter: has any rating (1-5)
        filtered = filtered.filter(conv => {
                    const rating = conv.conversation_rating?.rating;
                    return rating && rating >= 1 && rating <= 5;
                });
            } else if (ratingFilter.type === 'unrated') {
                // Filter: no rating
                filtered = filtered.filter(conv => !conv.conversation_rating || !conv.conversation_rating.rating);
            } else if (ratingFilter.type === 'exact' && ratingFilter.value) {
                // Filter: exact rating match
                const ratingNum = parseInt(ratingFilter.value);
        filtered = filtered.filter(conv => {
                    const convRating = conv.conversation_rating?.rating;
                    return convRating === ratingNum;
                });
            } else if (ratingFilter.type === 'range' && ratingFilter.min !== undefined && ratingFilter.max !== undefined) {
                // Filter: rating range
        filtered = filtered.filter(conv => {
                    const rating = conv.conversation_rating?.rating;
                    return rating && rating >= ratingFilter.min && rating <= ratingFilter.max;
                });
            }
        }
        console.log(`🔍 Rating filter (${JSON.stringify(ratingFilter)}): ${beforeCount} → ${filtered.length}`);
    }
    
    // Filter by client search (name or email)
    if (pullConversationsFilters.clientSearch) {
        const searchLower = pullConversationsFilters.clientSearch.toLowerCase();
        filtered = filtered.filter(conv => {
            const clientName = extractClientName(conv).toLowerCase();
            const clientEmail = extractClientEmail(conv)?.toLowerCase() || '';
            return clientName.includes(searchLower) || clientEmail.includes(searchLower);
        });
    }
    
    // Filter by conversation ID
    if (pullConversationsFilters.conversationId) {
        const idSearch = pullConversationsFilters.conversationId.toLowerCase();
        filtered = filtered.filter(conv => {
            const convId = (conv.id || '').toString().toLowerCase();
            return convId.includes(idSearch);
        });
    }
    
    // Filter by CX Score
    if (pullConversationsFilters.cxScore) {
        const cxFilter = pullConversationsFilters.cxScore;
        if (cxFilter.type === 'hasScore') {
            filtered = filtered.filter(conv => {
                const cxScore = conv.custom_attributes?.["CX Score rating"];
                return cxScore !== null && cxScore !== undefined;
            });
        } else if (cxFilter.type === 'noScore') {
            filtered = filtered.filter(conv => {
                const cxScore = conv.custom_attributes?.["CX Score rating"];
                return cxScore === null || cxScore === undefined;
            });
        } else if (cxFilter.type === 'exact' && cxFilter.value !== undefined) {
            filtered = filtered.filter(conv => {
                const cxScore = conv.custom_attributes?.["CX Score rating"];
                return cxScore !== null && cxScore !== undefined && parseInt(cxScore) === parseInt(cxFilter.value);
            });
        } else if (cxFilter.type === 'range' && cxFilter.min !== undefined && cxFilter.max !== undefined) {
            filtered = filtered.filter(conv => {
                const cxScore = conv.custom_attributes?.["CX Score rating"];
                if (cxScore === null || cxScore === undefined) return false;
                const scoreNum = parseInt(cxScore);
                return !isNaN(scoreNum) && scoreNum >= cxFilter.min && scoreNum <= cxFilter.max;
            });
        }
    }
    
    // Filter by Conversation Length
    if (pullConversationsFilters.conversationLength) {
        const lengthFilter = pullConversationsFilters.conversationLength;
        filtered = filtered.filter(conv => {
            const length = conv.conversation_parts?.conversation_parts?.length || 0;
            const min = lengthFilter.min !== undefined ? lengthFilter.min : 0;
            const max = lengthFilter.max !== undefined ? lengthFilter.max : Infinity;
            return length >= min && length <= max;
        });
    }
    
    console.log(`✅ Filtered from ${initialCount} to ${filtered.length} conversations`);
    
    pullConversationsFilteredList = filtered;
    await displayPullConversationsList(filtered);
    
    // Update count and admin name
    updatePullConversationsCountAndAdmin(filtered.length);
}

// Clear all filters
window.clearPullConversationsFilters = async function() {
    pullConversationsFilters = {
        state: null,
        priority: null,
        rating: null,
        cxScore: null,
        conversationLength: null,
        clientSearch: null,
        conversationId: null
    };
    
    // Clear form
    const form = document.getElementById('pullConversationsFilterForm');
    if (form) {
        form.reset();
    }
    
    // Reset filtered list to original
    pullConversationsFilteredList = [...pullConversationsList];
    await displayPullConversationsList(pullConversationsFilteredList);
    
    // Update count and admin name
    updatePullConversationsCountAndAdmin(pullConversationsFilteredList.length);
    
    // Update active filters display
    updatePullConversationsActiveFilters();
    
    // Close modal if open
    closePullConversationsFilterDialog();
};

// Update active filters display
function updatePullConversationsActiveFilters() {
    const activeFiltersDiv = document.getElementById('pullConversationsActiveFilters');
    const activeFiltersTags = document.getElementById('pullConversationsActiveFiltersTags');
    const activeFiltersCount = document.getElementById('pullConversationsActiveFiltersCount');
    
    if (!activeFiltersDiv || !activeFiltersTags) return;
    
    const activeFilters = [];
    
    if (pullConversationsFilters.state) activeFilters.push({ label: `State: ${pullConversationsFilters.state}`, key: 'state' });
    if (pullConversationsFilters.priority) activeFilters.push({ label: `Priority: ${pullConversationsFilters.priority}`, key: 'priority' });
    // Handle rating filter display (support both old and new format)
    if (pullConversationsFilters.rating) {
        const ratingFilter = pullConversationsFilters.rating;
        let ratingLabel = '';
        
        if (typeof ratingFilter === 'string') {
            // Old format
            ratingLabel = ratingFilter === 'unrated' ? 'Unrated' : ratingFilter + ' Stars';
        } else if (typeof ratingFilter === 'object' && ratingFilter.type) {
            // New format
            if (ratingFilter.type === 'hasRating') {
                ratingLabel = 'Has Rating (Any Star)';
            } else if (ratingFilter.type === 'unrated') {
                ratingLabel = 'Unrated';
            } else if (ratingFilter.type === 'exact' && ratingFilter.value) {
                ratingLabel = ratingFilter.value + ' Stars';
            } else if (ratingFilter.type === 'range' && ratingFilter.min !== undefined && ratingFilter.max !== undefined) {
                ratingLabel = `${ratingFilter.min}-${ratingFilter.max} Stars`;
            }
        }
        
        if (ratingLabel) {
            activeFilters.push({ label: `Rating: ${ratingLabel}`, key: 'rating' });
        }
    }
    // Handle CX Score filter display
    if (pullConversationsFilters.cxScore) {
        const cxFilter = pullConversationsFilters.cxScore;
        let cxLabel = '';
        if (cxFilter.type === 'hasScore') {
            cxLabel = 'Has CX Score';
        } else if (cxFilter.type === 'noScore') {
            cxLabel = 'No CX Score';
        } else if (cxFilter.type === 'exact' && cxFilter.value) {
            cxLabel = `CX Score: ${cxFilter.value}`;
        } else if (cxFilter.type === 'range' && cxFilter.min !== undefined && cxFilter.max !== undefined) {
            cxLabel = `CX Score: ${cxFilter.min}-${cxFilter.max}`;
        }
        if (cxLabel) {
            activeFilters.push({ label: cxLabel, key: 'cxScore' });
        }
    }
    
    // Handle Conversation Length filter display
    if (pullConversationsFilters.conversationLength) {
        const lengthFilter = pullConversationsFilters.conversationLength;
        let lengthLabel = 'Length: ';
        if (lengthFilter.min !== undefined && lengthFilter.max !== undefined) {
            lengthLabel += `${lengthFilter.min}-${lengthFilter.max}`;
        } else if (lengthFilter.min !== undefined) {
            lengthLabel += `≥${lengthFilter.min}`;
        } else if (lengthFilter.max !== undefined) {
            lengthLabel += `≤${lengthFilter.max}`;
        }
        activeFilters.push({ label: lengthLabel, key: 'conversationLength' });
    }
    
    if (pullConversationsFilters.clientSearch) activeFilters.push({ label: `Client: ${pullConversationsFilters.clientSearch}`, key: 'clientSearch' });
    if (pullConversationsFilters.conversationId) activeFilters.push({ label: `ID: ${pullConversationsFilters.conversationId}`, key: 'conversationId' });
    
    if (activeFilters.length === 0) {
        activeFiltersDiv.style.display = 'none';
        if (activeFiltersCount) {
            activeFiltersCount.style.display = 'none';
        }
    } else {
        activeFiltersDiv.style.display = 'block';
        if (activeFiltersCount) {
            activeFiltersCount.textContent = activeFilters.length;
            activeFiltersCount.style.display = 'inline-block';
        }
        
        activeFiltersTags.innerHTML = activeFilters.map(filter => `
            <span style="background: #dbeafe; color: #1e40af; padding: 0.1617rem 0.3234rem; border-radius: 0.1617rem; font-size: 0.4447rem; font-weight: 500; display: flex; align-items: center; gap: 0.1617rem;">
                ${escapeHtml(filter.label)}
                <button onclick="removePullConversationFilter('${filter.key}')" style="background: none; border: none; color: #1e40af; cursor: pointer; padding: 0; margin-left: 0.1617rem; font-size: 0.5659rem; line-height: 1; font-weight: bold;" title="Remove filter">×</button>
            </span>
        `).join('');
    }
}

// Remove a specific filter
window.removePullConversationFilter = async function(filterKey) {
    if (pullConversationsFilters.hasOwnProperty(filterKey)) {
        pullConversationsFilters[filterKey] = null;
    }
    
    // Update form
    const form = document.getElementById('pullConversationsFilterForm');
    if (form) {
        const inputMap = {
            'state': 'pullFilterState',
            'priority': 'pullFilterPriority',
            'rating': 'pullFilterRatingType', // Use rating type selector
            'clientSearch': 'pullFilterClientSearch',
            'conversationId': 'pullFilterConversationId'
        };
        
        const inputId = inputMap[filterKey];
        if (inputId) {
            const input = document.getElementById(inputId);
            if (input) {
                input.value = '';
            }
            
            // If clearing rating, also clear related inputs
            if (filterKey === 'rating') {
                const exactInput = document.getElementById('pullFilterRatingExact');
                const minInput = document.getElementById('pullFilterRatingMin');
                const maxInput = document.getElementById('pullFilterRatingMax');
                if (exactInput) exactInput.value = '';
                if (minInput) minInput.value = '';
                if (maxInput) maxInput.value = '';
                // Hide conditional inputs
                if (exactInput) exactInput.style.display = 'none';
                const rangeDiv = document.getElementById('pullFilterRatingRange');
                if (rangeDiv) rangeDiv.style.display = 'none';
                const errorDiv = document.getElementById('pullFilterRatingRangeError');
                if (errorDiv) {
                    errorDiv.style.display = 'none';
                    errorDiv.textContent = '';
                }
            }
        }
    }
    
    // Re-apply filters
    await filterPullConversations();
    
    // Update active filters display
    updatePullConversationsActiveFilters();
};

// Copy to clipboard helper
function copyToClipboard(text, buttonElement) {
    navigator.clipboard.writeText(text).then(() => {
        const originalHTML = buttonElement.innerHTML;
        buttonElement.innerHTML = '<svg style="width: 0.875rem; height: 0.875rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>';
        buttonElement.style.color = '#10b981';
        setTimeout(() => {
            buttonElement.innerHTML = originalHTML;
            buttonElement.style.color = '';
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy:', err);
    });
}

// Escape HTML helper
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Set default date range (previous day - one day)
function setDefaultConversationsDateRange() {
    const today = new Date();
    // Set end date to yesterday (previous day)
    const endDate = new Date(today);
    endDate.setDate(today.getDate() - 1);
    endDate.setHours(23, 59, 59, 999); // End of day
    // Set start date to yesterday (same as end date for one day range)
    const startDate = new Date(endDate);
    startDate.setHours(0, 0, 0, 0); // Start of day

    const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    };

    const formattedStartDate = formatDate(startDate);
    const formattedEndDate = formatDate(endDate);

    const startDateInput = document.getElementById('conversationsStartDate');
    const endDateInput = document.getElementById('conversationsEndDate');
    
    if (!startDateInput || !endDateInput) {
        console.warn('⚠️ Date inputs not found, will retry...');
        // Retry after a short delay
        setTimeout(() => {
            setDefaultConversationsDateRange();
        }, 200);
        return;
    }
    
    // Set the values directly
    startDateInput.value = formattedStartDate;
    endDateInput.value = formattedEndDate;
    
    // Trigger input event to ensure any listeners are notified
    startDateInput.dispatchEvent(new Event('input', { bubbles: true }));
    endDateInput.dispatchEvent(new Event('input', { bubbles: true }));
    startDateInput.dispatchEvent(new Event('change', { bubbles: true }));
    endDateInput.dispatchEvent(new Event('change', { bubbles: true }));
    
    console.log('✅ Set default date range:', formattedStartDate, 'to', formattedEndDate);
    
    // Verify they were set, if not retry
    if (startDateInput.value !== formattedStartDate || endDateInput.value !== formattedEndDate) {
        console.warn('⚠️ Date values not set correctly, retrying...');
        setTimeout(() => {
            if (startDateInput) {
                startDateInput.value = formattedStartDate;
                startDateInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            if (endDateInput) {
                endDateInput.value = formattedEndDate;
                endDateInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            console.log('🔄 Retry: Set default dates:', formattedStartDate, 'to', formattedEndDate);
        }, 200);
    }
}

// Reset date range to default
window.resetConversationsDateRange = function() {
    setDefaultConversationsDateRange();
    resetConversationsFilters();
    if (currentAdminId) {
        loadConversationsForEmployee();
    }
};

// Filter state management
let currentConversationFilters = {
    open: null,
    unread: null,
    sort: 'updated_at',
    order: 'desc',
    productType: null, // 'Futures', 'CFD', 'CFD / Forex', or null for all
    dateStart: null, // Date string (YYYY-MM-DD) or null
    dateEnd: null // Date string (YYYY-MM-DD) or null
};

// Open conversations filter dialog
window.openConversationsFilterDialog = function() {
    const modal = document.getElementById('conversationsFilterModal');
    if (!modal) return;
    
    // Set current filter values in the form
    const statusRadio = document.querySelector(`input[name="conversationStatus"][value="${currentConversationFilters.open === null ? 'all' : (currentConversationFilters.open ? 'open' : 'closed')}"]`);
    if (statusRadio) statusRadio.checked = true;
    
    const readStatusRadio = document.querySelector(`input[name="conversationReadStatus"][value="${currentConversationFilters.unread === null ? 'all' : (currentConversationFilters.unread ? 'unread' : 'read')}"]`);
    if (readStatusRadio) readStatusRadio.checked = true;
    
    const sortSelect = document.getElementById('conversationSortBy');
    if (sortSelect) sortSelect.value = currentConversationFilters.sort || 'updated_at';
    
    const sortOrderRadio = document.querySelector(`input[name="conversationSortOrder"][value="${currentConversationFilters.order || 'desc'}"]`);
    if (sortOrderRadio) sortOrderRadio.checked = true;
    
    const productTypeSelect = document.getElementById('conversationProductType');
    if (productTypeSelect) {
        productTypeSelect.value = currentConversationFilters.productType || 'all';
    }
    
    const filterDateStart = document.getElementById('filterDateStart');
    if (filterDateStart) {
        filterDateStart.value = currentConversationFilters.dateStart || '';
    }
    
    const filterDateEnd = document.getElementById('filterDateEnd');
    if (filterDateEnd) {
        filterDateEnd.value = currentConversationFilters.dateEnd || '';
    }
    
    // Update active filters display
    updateActiveFiltersDisplay();
    
    // Show modal
    modal.style.display = 'flex';
    document.body.style.overflow = 'hidden'; // Prevent background scrolling
    
    // Close on Escape key
    let escapeHandler = null;
    escapeHandler = (e) => {
        if (e.key === 'Escape') {
            closeConversationsFilterDialog();
            if (escapeHandler) {
                document.removeEventListener('keydown', escapeHandler);
            }
        }
    };
    document.addEventListener('keydown', escapeHandler);
    
    // Close on backdrop click (prevent event propagation)
    const backdropClickHandler = (e) => {
        if (e.target === modal) {
            closeConversationsFilterDialog();
            modal.removeEventListener('click', backdropClickHandler);
        }
    };
    modal.addEventListener('click', backdropClickHandler);
};

// Close conversations filter dialog
window.closeConversationsFilterDialog = function() {
    const modal = document.getElementById('conversationsFilterModal');
    if (!modal) return;
    
    const modalContent = document.getElementById('conversationsFilterModalContent');
    if (modalContent) {
        modalContent.style.animation = 'modalSlideOut 0.3s ease-out';
        setTimeout(() => {
            modal.style.display = 'none';
            document.body.style.overflow = ''; // Restore scrolling
            if (modalContent) {
                modalContent.style.animation = 'modalSlideIn 0.3s ease-out';
            }
        }, 300);
    } else {
        modal.style.display = 'none';
        document.body.style.overflow = '';
    }
};

// Re-apply filters to already-loaded raw conversations (no re-fetch)
function reapplyFilters() {
    if (rawEmployeeConversations.length === 0) {
        console.warn('⚠️ No raw conversations to filter. Please load conversations first.');
        return;
    }
    
    // Apply filters to raw conversations
    const filteredConversations = applyClientSideFilters(rawEmployeeConversations, currentConversationFilters);
    allEmployeeConversations = filteredConversations;
    
    // Reset to first page
    currentConversationsPage = 1;
    
    // Update count
    const countSpan = document.getElementById('conversationsCount');
    if (countSpan) {
        countSpan.textContent = filteredConversations.length;
    }
    
    // Update display
    displayEmployeeConversations();
    
    console.log(`🔍 Filters reapplied: ${rawEmployeeConversations.length} raw conversations → ${filteredConversations.length} filtered conversations`);
}

// Apply conversations filters
window.applyConversationsFilters = function() {
    // Get filter values from form
    const statusRadio = document.querySelector('input[name="conversationStatus"]:checked');
    const readStatusRadio = document.querySelector('input[name="conversationReadStatus"]:checked');
    const sortSelect = document.getElementById('conversationSortBy');
    const sortOrderRadio = document.querySelector('input[name="conversationSortOrder"]:checked');
    const productTypeSelect = document.getElementById('conversationProductType');
    const filterDateStart = document.getElementById('filterDateStart');
    const filterDateEnd = document.getElementById('filterDateEnd');
    
    // Update filter state
    if (statusRadio) {
        if (statusRadio.value === 'all') {
            currentConversationFilters.open = null;
        } else {
            currentConversationFilters.open = statusRadio.value === 'open';
        }
    }
    
    if (readStatusRadio) {
        if (readStatusRadio.value === 'all') {
            currentConversationFilters.unread = null;
        } else {
            currentConversationFilters.unread = readStatusRadio.value === 'unread';
        }
    }
    
    if (sortSelect) {
        currentConversationFilters.sort = sortSelect.value;
    }
    
    if (sortOrderRadio) {
        currentConversationFilters.order = sortOrderRadio.value;
    }
    
    // Product type filter
    if (productTypeSelect) {
        if (productTypeSelect.value === 'all') {
            currentConversationFilters.productType = null;
        } else {
            currentConversationFilters.productType = productTypeSelect.value;
        }
    }
    
    // Date range filters
    if (filterDateStart) {
        currentConversationFilters.dateStart = filterDateStart.value || null;
    }
    if (filterDateEnd) {
        currentConversationFilters.dateEnd = filterDateEnd.value || null;
    }
    
    // Update active filters display
    updateActiveFiltersDisplay();
    updateActiveFiltersCount();
    
    // Close dialog
    closeConversationsFilterDialog();
    
    // Re-apply filters to already-loaded data (no re-fetch)
    reapplyFilters();
};

// Reset all conversations filters
window.resetConversationsFilters = function() {
    // Reset filter state to defaults
    currentConversationFilters = {
        open: null,
        unread: null,
        sort: 'updated_at',
        order: 'desc',
        productType: null,
        dateStart: null,
        dateEnd: null
    };
    
    // Reset form values
    const statusAll = document.getElementById('statusAll');
    if (statusAll) statusAll.checked = true;
    
    const readStatusAll = document.getElementById('readStatusAll');
    if (readStatusAll) readStatusAll.checked = true;
    
    const sortSelect = document.getElementById('conversationSortBy');
    if (sortSelect) sortSelect.value = 'updated_at';
    
    const sortOrderDesc = document.getElementById('sortOrderDesc');
    if (sortOrderDesc) sortOrderDesc.checked = true;
    
    const productTypeSelect = document.getElementById('conversationProductType');
    if (productTypeSelect) productTypeSelect.value = 'all';
    
    const filterDateStart = document.getElementById('filterDateStart');
    if (filterDateStart) filterDateStart.value = '';
    
    const filterDateEnd = document.getElementById('filterDateEnd');
    if (filterDateEnd) filterDateEnd.value = '';
    
    // Re-apply filters (will show all conversations)
    reapplyFilters();
    
    // Update displays
    updateActiveFiltersDisplay();
    updateActiveFiltersCount();
};

// Update active filters display in dialog
function updateActiveFiltersDisplay() {
    const activeFiltersDisplay = document.getElementById('activeFiltersDisplay');
    const activeFiltersBadges = document.getElementById('activeFiltersBadges');
    
    if (!activeFiltersDisplay || !activeFiltersBadges) return;
    
    const badges = [];
    
    if (currentConversationFilters.open !== null) {
        badges.push({
            label: currentConversationFilters.open ? 'Open' : 'Closed',
            value: currentConversationFilters.open
        });
    }
    
    if (currentConversationFilters.unread !== null) {
        badges.push({
            label: currentConversationFilters.unread ? 'Unread' : 'Read',
            value: currentConversationFilters.unread
        });
    }
    
    if (currentConversationFilters.sort && currentConversationFilters.sort !== 'updated_at') {
        const sortLabels = {
            'created_at': 'Created At',
            'waiting_since': 'Waiting Since'
        };
        badges.push({
            label: `Sort: ${sortLabels[currentConversationFilters.sort] || currentConversationFilters.sort}`,
            value: currentConversationFilters.sort
        });
    }
    
    if (currentConversationFilters.order && currentConversationFilters.order !== 'desc') {
        badges.push({
            label: 'Order: Ascending',
            value: currentConversationFilters.order
        });
    }
    
    if (currentConversationFilters.productType) {
        badges.push({
            label: `Product: ${currentConversationFilters.productType}`,
            value: currentConversationFilters.productType
        });
    }
    
    if (currentConversationFilters.dateStart || currentConversationFilters.dateEnd) {
        const dateRange = [];
        if (currentConversationFilters.dateStart) dateRange.push(currentConversationFilters.dateStart);
        if (currentConversationFilters.dateEnd) dateRange.push(currentConversationFilters.dateEnd);
        badges.push({
            label: `Date: ${dateRange.join(' to ')}`,
            value: dateRange.join(' to ')
        });
    }
    
    if (badges.length > 0) {
        activeFiltersBadges.innerHTML = badges.map(badge => 
            `<span style="background-color: #dbeafe; color: #1e40af; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 500;">${escapeHtml(badge.label)}</span>`
        ).join('');
        activeFiltersDisplay.style.display = 'block';
    } else {
        activeFiltersBadges.innerHTML = '';
        activeFiltersDisplay.style.display = 'none';
    }
}

// Update active filters count badge on filter button
function updateActiveFiltersCount() {
    const activeFiltersCount = document.getElementById('activeFiltersCount');
    if (!activeFiltersCount) return;
    
    let count = 0;
    if (currentConversationFilters.open !== null) count++;
    if (currentConversationFilters.unread !== null) count++;
    if (currentConversationFilters.sort && currentConversationFilters.sort !== 'updated_at') count++;
    if (currentConversationFilters.order && currentConversationFilters.order !== 'desc') count++;
    if (currentConversationFilters.productType) count++;
    if (currentConversationFilters.dateStart || currentConversationFilters.dateEnd) count++;
    
    if (count > 0) {
        activeFiltersCount.textContent = count;
        activeFiltersCount.style.display = 'inline-block';
    } else {
        activeFiltersCount.style.display = 'none';
    }
}

// Apply client-side filters and sorting to conversations
function applyClientSideFilters(conversations, filters) {
    if (!conversations || !Array.isArray(conversations)) {
        return [];
    }
    
    let filtered = [...conversations]; // Create a copy to avoid mutating original
    
    // Filter by open/closed status
    if (filters.open !== null && filters.open !== undefined) {
        filtered = filtered.filter(conv => {
            // Check both 'open' property and 'state' property
            const isOpen = conv.open === true || conv.state === 'open';
            return filters.open ? isOpen : !isOpen;
        });
    }
    
    // Filter by read/unread status
    if (filters.unread !== null && filters.unread !== undefined) {
        filtered = filtered.filter(conv => {
            const isUnread = conv.read === false;
            return filters.unread ? isUnread : !isUnread;
        });
    }
    
    // Filter by product type
    if (filters.productType && filters.productType !== 'all') {
        filtered = filtered.filter(conv => {
            const productType = extractProductType(conv);
            if (!productType) return false;
            
            const productTypeLower = productType.toLowerCase();
            const filterLower = filters.productType.toLowerCase();
            
            // Handle different variations
            if (filterLower === 'cfd') {
                return productTypeLower.includes('cfd');
            } else if (filterLower === 'futures') {
                return productTypeLower.includes('futures') && !productTypeLower.includes('cfd');
            } else if (filterLower === 'cfd / forex' || filterLower === 'cfd/forex') {
                return productTypeLower.includes('cfd') && (productTypeLower.includes('forex') || productTypeLower.includes('/'));
            }
            
            return productTypeLower === filterLower;
        });
    }
    
    // Filter by date range (filter conversations by their created_at or updated_at)
    if (filters.dateStart || filters.dateEnd) {
        filtered = filtered.filter(conv => {
            // Use updated_at as primary, fallback to created_at
            const convDate = conv.updated_at || conv.created_at;
            if (!convDate) return false;
            
            // Convert to timestamp (handle both seconds and milliseconds)
            let timestamp = typeof convDate === 'number' ? convDate : new Date(convDate).getTime();
            if (timestamp < 10000000000) timestamp = timestamp * 1000;
            
            const convDateObj = new Date(timestamp);
            const convDateStr = convDateObj.toISOString().split('T')[0]; // YYYY-MM-DD
            
            if (filters.dateStart && convDateStr < filters.dateStart) {
                return false;
            }
            if (filters.dateEnd && convDateStr > filters.dateEnd) {
                return false;
            }
            
            return true;
        });
    }
    
    // Sort conversations
    const sortField = filters.sort || 'updated_at';
    const sortOrder = filters.order || 'desc';
    
    filtered.sort((a, b) => {
        let aValue, bValue;
        
        switch (sortField) {
            case 'created_at':
                aValue = a.created_at || 0;
                bValue = b.created_at || 0;
                break;
            case 'waiting_since':
                aValue = a.waiting_since || 0;
                bValue = b.waiting_since || 0;
                break;
            case 'updated_at':
            default:
                aValue = a.updated_at || 0;
                bValue = b.updated_at || 0;
                break;
        }
        
        // Ensure we're comparing numbers
        aValue = typeof aValue === 'number' ? aValue : (aValue ? new Date(aValue).getTime() : 0);
        bValue = typeof bValue === 'number' ? bValue : (bValue ? new Date(bValue).getTime() : 0);
        
        // Handle Unix timestamps (seconds vs milliseconds)
        if (aValue < 10000000000) aValue = aValue * 1000;
        if (bValue < 10000000000) bValue = bValue * 1000;
        
        if (sortOrder === 'asc') {
            return aValue - bValue;
        } else {
            return bValue - aValue;
        }
    });
    
    return filtered;
}

// Format date for API
function formatDateForAPI(dateStr) {
    return `${dateStr} 00:00:00`;
}

// Format date for API end date
function formatEndDateForAPI(dateStr) {
    return `${dateStr} 23:59:59`;
}

// Format date for display (DD/MM/YYYY HH:MM)
function formatConversationDateForDisplay(timestamp) {
    if (!timestamp) return 'N/A';
    const date = typeof timestamp === 'number' 
        ? new Date(timestamp < 10000000000 ? timestamp * 1000 : timestamp)
        : new Date(timestamp);
    if (isNaN(date.getTime())) return 'N/A';
    
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${day}/${month}/${year} ${hours}:${minutes}`;
}

// Show error message
function showConversationsError(message) {
    const errorDiv = document.getElementById('conversationsError');
    const errorMessage = document.getElementById('conversationsErrorMessage');
    const loadingDiv = document.getElementById('conversationsLoading');
    const listDiv = document.getElementById('conversationsList');
    
    if (errorDiv && errorMessage) {
        errorMessage.textContent = message;
        errorDiv.style.display = 'block';
    }
    if (loadingDiv) loadingDiv.style.display = 'none';
    if (listDiv) listDiv.style.display = 'none';
}

// Fetch conversations progressively: fast initial load + complete data fetching
// Helper function to fetch with retry logic
async function fetchWithRetry(url, options, maxRetries = 3, retryDelay = 1000, timeoutMs = 60000) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const controller = new AbortController();
            // Increase timeout on retries (exponential backoff for timeout too)
            const currentTimeout = timeoutMs * (1 + (attempt - 1) * 0.5); // 60s, 90s, 120s
            const timeoutId = setTimeout(() => controller.abort(), currentTimeout);
            
            console.log(`🔄 Fetch attempt ${attempt}/${maxRetries} (timeout: ${currentTimeout/1000}s)...`);
            
            const response = await fetch(url, {
                ...options,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            // Check if response is ok
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const errorMsg = errorData.error || `HTTP ${response.status}: ${response.statusText}`;
                throw new Error(errorMsg);
            }
            
            return response;
        } catch (error) {
            const isTimeout = error.name === 'AbortError' || error.message.includes('timeout');
            const isLastAttempt = attempt === maxRetries;
            
            if (isLastAttempt) {
                if (isTimeout) {
                    throw new Error(`Request timeout after ${maxRetries} attempts. The server may be processing a large dataset. Please try a smaller date range or try again later.`);
                }
                throw error;
            }
            
            // Wait before retrying with exponential backoff
            const delay = retryDelay * Math.pow(2, attempt - 1);
            if (isTimeout) {
                console.warn(`⚠️ Request timeout on attempt ${attempt}, retrying in ${delay}ms with longer timeout...`);
            } else {
                console.warn(`⚠️ Fetch attempt ${attempt} failed, retrying in ${delay}ms...`, error.message);
            }
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

async function fetchEmployeeConversationsProgressively(adminId, updatedSince, updatedBefore, filters = null) {
    isLoadingEmployeeConversations = true;
    allEmployeeConversations = [];
    rawEmployeeConversations = []; // Clear and store fresh raw data

    // Use provided filters or current filter state (always use currentConversationFilters as fallback)
    const activeFilters = filters !== null ? filters : currentConversationFilters;
    
    console.log('📊 Using filters for client-side filtering:', activeFilters);

    // Show loading indicator next to count
    const countLoader = document.getElementById('conversationsCountLoader');
    if (countLoader) {
        countLoader.style.display = 'inline-block';
    }

    try {
        // Step 1: Fast initial load - fetch first 150 conversations immediately
        let startingAfter = null;
        let hasMore = true;
        let pageCount = 0;
        const maxPages = 100; // Safety limit

        while (hasMore && pageCount < maxPages) {
            pageCount++;
            
            // Build API URL - only include date range and per_page limit (no filters - done client-side)
            let edgeFunctionUrl = `${window.SupabaseConfig?.url || ''}/functions/v1/intercom-proxy?endpoint=conversations&admin_id=${encodeURIComponent(adminId)}&updated_since=${encodeURIComponent(updatedSince)}&updated_before=${encodeURIComponent(updatedBefore)}&per_page=${maxConversationsToFetch}`;
            
            // Add pagination cursor if we have one (validate and encode properly)
            if (startingAfter) {
                // Ensure cursor is a valid string and properly encoded
                const cursorValue = String(startingAfter).trim();
                if (cursorValue && cursorValue.length > 0) {
                    edgeFunctionUrl += `&starting_after=${encodeURIComponent(cursorValue)}`;
                } else {
                    console.warn('⚠️ Invalid cursor value, skipping pagination');
                    hasMore = false;
                    break;
                }
            }

            if (pageCount === 1) {
                console.log('═══════════════════════════════════════════════════════');
                console.log('🚀 FETCHING CONVERSATIONS (Client-side filtering)');
                console.log('═══════════════════════════════════════════════════════');
                console.log('📋 Active filters (will apply after fetch):', JSON.stringify(activeFilters, null, 2));
                console.log('🔗 API URL:', edgeFunctionUrl);
                console.log('📅 Date range:', updatedSince, 'to', updatedBefore);
                console.log('👤 Admin ID:', adminId);
                console.log('═══════════════════════════════════════════════════════');
            } else {
                console.log(`🔄 Background fetch: Loading page ${pageCount}...`);
            }

            let response;
            try {
                // Use longer timeout for conversation fetching (60 seconds, with retries up to 120s)
                response = await fetchWithRetry(edgeFunctionUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${window.SupabaseConfig?.anonKey || ''}`,
                        'apikey': window.SupabaseConfig?.anonKey || '',
                        'Accept': 'application/json'
                    }
                }, 3, 2000, 60000); // maxRetries=3, retryDelay=2s, timeout=60s
            } catch (fetchError) {
                // If it's a network error on subsequent pages, log but don't fail completely
                if (pageCount > 1) {
                    console.warn(`⚠️ Failed to fetch page ${pageCount}, but continuing with ${allEmployeeConversations.length} conversations already loaded:`, fetchError.message);
                    hasMore = false;
                    break;
                }
                throw fetchError;
            }

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const errorMsg = errorData.error || `HTTP ${response.status}: ${response.statusText}`;
                
                // If it's a 400/404 on subsequent pages, might be invalid cursor - stop pagination
                if (pageCount > 1 && (response.status === 400 || response.status === 404)) {
                    console.warn(`⚠️ Invalid cursor on page ${pageCount}, stopping pagination. Loaded ${allEmployeeConversations.length} conversations.`);
                    hasMore = false;
                    break;
                }
                
                throw new Error(errorMsg);
            }

            const data = await response.json();
            
            // Extract conversations from response
            let pageConversations = [];
            if (data && Array.isArray(data.conversations)) {
                pageConversations = data.conversations;
            } else if (data && data.type === 'conversation.list' && Array.isArray(data.conversations)) {
                pageConversations = data.conversations;
            } else if (data && data.conversations && Array.isArray(data.conversations)) {
                pageConversations = data.conversations;
            }

            if (pageConversations.length > 0) {
                // Add conversations to raw array (unfiltered) - store in global variable
                rawEmployeeConversations = rawEmployeeConversations.concat(pageConversations);
                
                // Update count to show progress (raw count during loading)
                const countSpan = document.getElementById('conversationsCount');
                if (countSpan) {
                    countSpan.textContent = rawEmployeeConversations.length;
                }
                
                // Don't display during progressive loading - wait until all data is fetched
                console.log(`📥 Page ${pageCount} loaded: ${pageConversations.length} conversations (Total fetched: ${rawEmployeeConversations.length})`);
            }

            // Check if there are more pages to fetch
            hasMore = false;
            startingAfter = null;

            if (data.pages && data.pages.next) {
                const next = data.pages.next;
                if (typeof next === 'string') {
                    try {
                        if (next.includes('?')) {
                            const urlParts = next.split('?');
                            const urlParams = new URLSearchParams(urlParts[1]);
                            startingAfter = urlParams.get('starting_after');
                        } else {
                            // If it's just a cursor string, use it directly
                            startingAfter = next;
                        }
                        
                        // Validate cursor value
                        if (startingAfter && typeof startingAfter === 'string' && startingAfter.trim().length > 0) {
                            startingAfter = startingAfter.trim();
                        } else {
                            startingAfter = null;
                        }
                    } catch (e) {
                        console.warn('⚠️ Error parsing next URL:', e);
                        startingAfter = null;
                    }
                } else if (next && typeof next === 'object') {
                    startingAfter = next.starting_after || next.cursor || null;
                    // Validate cursor value
                    if (startingAfter && typeof startingAfter === 'string' && startingAfter.trim().length > 0) {
                        startingAfter = startingAfter.trim();
                    } else {
                        startingAfter = null;
                    }
                }
                hasMore = !!startingAfter;
            }

            // Stop if no more conversations or invalid cursor
            if (pageConversations.length === 0 || !startingAfter) {
                hasMore = false;
                break;
            }
        }

        console.log(`✅ All conversations loaded: ${rawEmployeeConversations.length} total conversations fetched`);
        
        // Apply final client-side filtering and sorting to all raw conversations
        const filteredConversations = applyClientSideFilters(rawEmployeeConversations, activeFilters);
        allEmployeeConversations = filteredConversations;
        console.log(`🔍 After filtering: ${filteredConversations.length} conversations`);
        
        // Update count with final filtered count
        const countSpan = document.getElementById('conversationsCount');
        if (countSpan) {
            countSpan.textContent = filteredConversations.length;
        }
        
        // Hide loading and show results
        const loadingDiv = document.getElementById('conversationsLoading');
        const listDiv = document.getElementById('conversationsList');
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (listDiv) listDiv.style.display = 'block';
        
        displayEmployeeConversations();
        
    } catch (error) {
        console.error('❌ Error fetching conversations:', error);
        throw error;
    } finally {
        isLoadingEmployeeConversations = false;
        
        // Hide loading indicator when done
        const countLoader = document.getElementById('conversationsCountLoader');
        if (countLoader) {
            countLoader.style.display = 'none';
        }
    }
}

// Load conversations for employee
window.loadConversationsForEmployee = async function() {
    if (!currentAdminId) {
        showConversationsError('Admin ID is missing.');
        return;
    }

    const startDateInput = document.getElementById('conversationsStartDate');
    const endDateInput = document.getElementById('conversationsEndDate');
    
    // If dates are not set, set default dates first
    if (!startDateInput || !endDateInput) {
        showConversationsError('Date inputs not found. Please refresh the page.');
        return;
    }
    
    // If dates are empty, set default dates
    if (!startDateInput.value || !endDateInput.value) {
        console.log('⚠️ Date inputs are empty, setting default dates...');
        setDefaultConversationsDateRange();
        // Wait a bit for dates to be set
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Check again after setting defaults
        if (!startDateInput.value || !endDateInput.value) {
            showConversationsError('Please select both start and end dates.');
            return;
        }
    }

    const startDate = startDateInput.value;
    const endDate = endDateInput.value;

    if (new Date(startDate) > new Date(endDate)) {
        showConversationsError('Start date must be before end date.');
        return;
    }

    const loadingDiv = document.getElementById('conversationsLoading');
    const errorDiv = document.getElementById('conversationsError');
    const listDiv = document.getElementById('conversationsList');
    
    if (loadingDiv) loadingDiv.style.display = 'block';
    if (errorDiv) errorDiv.style.display = 'none';
    if (listDiv) listDiv.style.display = 'none';

    const updatedSince = formatDateForAPI(startDate);
    const updatedBefore = formatEndDateForAPI(endDate);

    try {
        allEmployeeConversations = [];
        currentConversationsPage = 1;
        
        // Pass current filters for client-side filtering
        await fetchEmployeeConversationsProgressively(currentAdminId, updatedSince, updatedBefore, currentConversationFilters);
    } catch (error) {
        console.error('Error loading conversations:', error);
        
        // Provide more helpful error messages
        let errorMessage = 'Failed to fetch conversations.';
        if (error.message) {
            if (error.message.includes('timeout')) {
                errorMessage = 'Request timed out. The server may be processing a large dataset. Please try:\n\n' +
                              '• Selecting a smaller date range\n' +
                              '• Waiting a few moments and trying again\n' +
                              '• Checking your internet connection';
            } else if (error.message.includes('Failed to fetch') || error.message.includes('ERR_QUIC') || error.message.includes('ERR_')) {
                errorMessage = 'Network error. Please check your internet connection and try again.';
            } else {
                errorMessage = error.message;
            }
        }
        
        showConversationsError(errorMessage);
    } finally {
        if (loadingDiv) loadingDiv.style.display = 'none';
    }
};

// Extract client name from conversation
function extractClientName(conversation) {
    if (conversation.source?.author?.name) {
        return conversation.source.author.name;
    }
    if (conversation.source?.author?.email) {
        return conversation.source.author.email;
    }
    if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
        const contact = conversation.contacts.contacts[0];
        return contact.name || contact.email || 'Unknown';
    }
    return 'Unknown';
}

// Extract client email from conversation
function extractClientEmail(conversation) {
    if (conversation.source?.author?.email) {
        return conversation.source.author.email;
    }
    if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
        const contact = conversation.contacts.contacts[0];
        return contact.email || null;
    }
    return null;
}

// Extract admin information from conversation (Intercom admin who participated)
function extractAdminFromConversation(conversation) {
    // Check teammates.admins array first
    if (conversation.teammates?.admins && Array.isArray(conversation.teammates.admins) && conversation.teammates.admins.length > 0) {
        const admin = conversation.teammates.admins[0];
        return {
            id: admin.id || conversation.admin_assignee_id,
            name: admin.name || null, // This is the Intercom alias
            email: admin.email || null
        };
    }
    
    // Check admin_assignee_id
    if (conversation.admin_assignee_id) {
        return {
            id: conversation.admin_assignee_id,
            name: null, // Will need to look up
            email: null // Will need to look up
        };
    }
    
    return null;
}

// Get rating from conversation
function getConversationRating(conversation) {
    if (conversation.conversation_rating?.rating) {
        const rating = parseInt(conversation.conversation_rating.rating, 10);
        if (!isNaN(rating) && rating >= 1 && rating <= 5) {
            return rating;
        }
    }
    return null;
}

// Extract product type from conversation
function extractProductType(conversation) {
    // Priority 1: Check ticket custom_attributes for Product Type
    if (conversation.ticket?.custom_attributes?.["Product Type"]) {
        const productType = conversation.ticket.custom_attributes["Product Type"];
        // Handle object with value property
        if (productType && typeof productType === 'object' && productType.value) {
            return productType.value;
        }
        // Sometimes it's a direct string value
        if (typeof productType === 'string' && productType.trim()) {
            return productType;
        }
    }
    
    // Priority 2: Check tags for product type indicators
    if (conversation.tags?.tags && Array.isArray(conversation.tags.tags)) {
        for (const tag of conversation.tags.tags) {
            const tagName = tag.name || '';
            // Check for CFD indicators
            if (tagName.includes('CFD') || tagName === 'CFD Conversation' || tagName.includes('CFD FIN')) {
                return 'CFD';
            }
            // Check for Futures indicators
            if (tagName.includes('Futures') || tagName === 'Future Conversations' || tagName.includes('Futures FIN')) {
                return 'Futures';
            }
        }
    }
    
    // Priority 3: Check source body for user-selected product type
    if (conversation.source?.body) {
        const body = conversation.source.body.toLowerCase();
        // Check for CFD / Forex (handle HTML tags)
        if (body.includes('cfd / forex') || body.includes('cfd/forex') || body.includes('<p>cfd / forex</p>')) {
            return 'CFD / Forex';
        }
        // Check for Futures (handle HTML tags)
        if (body.includes('<p>futures</p>') || (body.includes('futures') && !body.includes('cfd'))) {
            return 'Futures';
        }
    }
    
    // Priority 4: Check topics for product type indicators
    if (conversation.topics?.topics && Array.isArray(conversation.topics.topics)) {
        for (const topic of conversation.topics.topics) {
            const topicName = topic.name || '';
            if (topicName.includes('Futures')) {
                return 'Futures';
            }
            if (topicName.includes('CFD')) {
                return 'CFD';
            }
        }
    }
    
    // Priority 5: Check team names in statistics
    if (conversation.statistics?.assigned_team_first_response_time && Array.isArray(conversation.statistics.assigned_team_first_response_time)) {
        for (const team of conversation.statistics.assigned_team_first_response_time) {
            const teamName = team.team_name || '';
            if (teamName.includes('(CFD)')) {
                return 'CFD';
            }
            if (teamName.includes('(FUT)')) {
                return 'Futures';
            }
        }
    }
    
    return null;
}

// Generate star rating HTML
function generateStarRating(rating) {
    const maxStars = 5;
    const filledStars = rating || 0;
    const emptyStars = maxStars - filledStars;
    
    let starsHtml = '<div style="display: flex; align-items: center; gap: 0.125rem;">';
    
    for (let i = 0; i < filledStars; i++) {
        starsHtml += `
            <svg aria-hidden="true" style="width: 1rem; height: 1rem; color: #fbbf24;" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
            </svg>
        `;
    }
    
    for (let i = 0; i < emptyStars; i++) {
        starsHtml += `
            <svg aria-hidden="true" style="width: 1rem; height: 1rem; color: #d1d5db;" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
            </svg>
        `;
    }
    
    starsHtml += '</div>';
    return starsHtml;
}

// Copy conversation ID to clipboard
window.copyConversationId = function(conversationId, buttonElement) {
    if (!conversationId || conversationId === 'N/A') {
        return;
    }

    // Copy to clipboard
    navigator.clipboard.writeText(conversationId).then(() => {
        // Visual feedback
        const originalHTML = buttonElement.innerHTML;
        buttonElement.classList.add('copy-success');
        buttonElement.innerHTML = `
            <svg aria-hidden="true" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
        `;
        buttonElement.title = 'Copied!';

        // Reset after 2 seconds
        setTimeout(() => {
            buttonElement.classList.remove('copy-success');
            buttonElement.innerHTML = originalHTML;
            buttonElement.title = 'Copy conversation ID';
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy conversation ID:', err);
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = conversationId;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            const originalHTML = buttonElement.innerHTML;
            buttonElement.innerHTML = '✓';
            setTimeout(() => {
                buttonElement.innerHTML = originalHTML;
            }, 2000);
        } catch (fallbackErr) {
            console.error('Fallback copy failed:', fallbackErr);
        }
        document.body.removeChild(textArea);
    });
};

// Display conversations in table
function displayEmployeeConversations() {
    const tableBody = document.getElementById('conversationsTableBody');
    if (!tableBody) return;
    
    tableBody.innerHTML = '';

    if (allEmployeeConversations.length === 0) {
        const listDiv = document.getElementById('conversationsList');
        if (listDiv) listDiv.style.display = 'block';
        const paginationDiv = document.getElementById('conversationsPagination');
        if (paginationDiv) paginationDiv.style.display = 'none';
        tableBody.innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 1.9406rem; color: #9ca3af;">No conversations found for this date range.</td></tr>';
        return;
    }

    const totalPages = Math.ceil(allEmployeeConversations.length / conversationsItemsPerPage);
    const startIndex = (currentConversationsPage - 1) * conversationsItemsPerPage;
    const endIndex = Math.min(startIndex + conversationsItemsPerPage, allEmployeeConversations.length);
    const pageConversations = allEmployeeConversations.slice(startIndex, endIndex);

    const paginationStart = document.getElementById('conversationsPaginationStart');
    const paginationEnd = document.getElementById('conversationsPaginationEnd');
    const paginationTotal = document.getElementById('conversationsPaginationTotal');
    
    if (paginationStart) paginationStart.textContent = allEmployeeConversations.length > 0 ? startIndex + 1 : 0;
    if (paginationEnd) paginationEnd.textContent = endIndex;
    if (paginationTotal) {
        paginationTotal.textContent = allEmployeeConversations.length;
        if (isLoadingEmployeeConversations) {
            paginationTotal.textContent = `${allEmployeeConversations.length}+`;
        }
    }

    pageConversations.forEach(conversation => {
        const row = document.createElement('tr');
        row.style.borderBottom = '0.0625rem solid #e5e7eb';
        row.style.cursor = 'pointer';
        row.onmouseenter = () => {
            row.style.backgroundColor = '#f9fafb';
        };
        row.onmouseleave = () => {
            row.style.backgroundColor = 'transparent';
        };
        
        const clientName = extractClientName(conversation);
        const clientEmail = extractClientEmail(conversation);
        const createdDate = formatConversationDateForDisplay(conversation.created_at || conversation.created_at_time);
        const subject = conversation.source?.subject || 
                       conversation.conversation_parts?.[0]?.body?.substring(0, 100) || 
                       'No subject';
        const subjectDisplay = subject.length > 50 ? subject.substring(0, 50) + '...' : subject;
        const state = conversation.state || 'unknown';
        const stateBadge = state === 'open' 
            ? '<span style="background-color: #fef3c7; color: #92400e; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">Open</span>'
            : state === 'closed'
            ? '<span style="background-color: #dcfce7; color: #166534; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">Closed</span>'
            : '<span style="background-color: #fee2e2; color: #991b1b; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">' + escapeHtml(state) + '</span>';
        const rating = getConversationRating(conversation);
        const ratingHtml = generateStarRating(rating);
        const conversationId = conversation.id || 'N/A';
        
        // Extract CX Score
        const cxScore = conversation.custom_attributes?.["CX Score rating"] ?? null;
        let cxScoreHtml = '-';
        if (cxScore !== null && cxScore !== undefined) {
            const cxScoreNum = parseInt(cxScore);
            if (!isNaN(cxScoreNum)) {
                const cxScoreColor = cxScoreNum >= 4 ? '#10b981' : cxScoreNum >= 3 ? '#f59e0b' : '#ef4444';
                cxScoreHtml = `<span style="color: ${cxScoreColor}; font-weight: 600; font-size: 0.75rem;">${cxScoreNum}</span>`;
            }
        }
        
        // Calculate conversation length
        const conversationLength = conversation.conversation_parts?.conversation_parts?.length || 0;
        const lengthDisplay = conversationLength > 0 
            ? `<span style="font-size: 0.75rem; color: #374151; font-weight: 500;">${conversationLength}</span>`
            : '<span style="color: #9ca3af;">-</span>';
        
        // Extract product type
        const productType = extractProductType(conversation);
        let productTypeBadge = '';
        if (productType) {
            const isCFD = productType.toLowerCase().includes('cfd') || productType === 'CFD / Forex';
            const isFutures = productType.toLowerCase().includes('futures');
            const bgColor = isCFD ? '#dbeafe' : isFutures ? '#fef3c7' : '#f3f4f6';
            const textColor = isCFD ? '#1e40af' : isFutures ? '#92400e' : '#374151';
            productTypeBadge = `<span style="background-color: ${bgColor}; color: ${textColor}; padding: 0.25rem 0.5rem; border-radius: 0.375rem; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">${escapeHtml(productType)}</span>`;
        } else {
            productTypeBadge = '<span style="color: #9ca3af; font-size: 0.75rem;">—</span>';
        }

        row.innerHTML = `
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">
                <div style="font-weight: 500; color: #111827; font-size: 0.875rem; line-height: 1.4;">${escapeHtml(clientName)}</div>
                ${clientEmail ? `<div style="font-size: 0.75rem; color: #6b7280; margin-top: 0.125rem;">${escapeHtml(clientEmail)}</div>` : ''}
            </td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <div style="font-family: 'Poppins', sans-serif; font-size: 0.8125rem; color: #4b5563; font-weight: 500;">${conversationId}</div>
                    <button 
                        class="copy-button"
                        onclick="event.stopPropagation(); copyConversationId('${conversationId}', this);"
                        title="Copy conversation ID"
                        style="display: inline-flex; align-items: center; justify-content: center; padding: 0.25rem; background: transparent; border: none; border-radius: 0.25rem; cursor: pointer; color: #6b7280; transition: all 0.2s;"
                        onmouseover="this.style.backgroundColor='#f3f4f6'; this.style.color='#374151'"
                        onmouseout="this.style.backgroundColor='transparent'; this.style.color='#6b7280'"
                    >
                        <svg aria-hidden="true" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" style="width: 1rem; height: 1rem;">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                    </button>
                </div>
            </td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">
                <div style="max-width: 16rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 0.875rem; color: #374151; line-height: 1.4;" title="${escapeHtml(subject)}">${escapeHtml(subjectDisplay)}</div>
            </td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">${productTypeBadge}</td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">${ratingHtml}</td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle; text-align: center;">${cxScoreHtml}</td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle; text-align: center;">${lengthDisplay}</td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">${stateBadge}</td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle; font-size: 0.875rem; color: #6b7280; white-space: nowrap;">${createdDate}</td>
            <td style="padding: 0.625rem 0.75rem; vertical-align: middle;">
                <button 
                    onclick="event.stopPropagation(); window.open('audit-view.html?conversation_id=${conversation.id}', '_blank');"
                    style="padding: 0.375rem 0.75rem; font-size: 0.8125rem; font-weight: 500; color: #1A733E; background: #d1fae5; border: none; border-radius: 0.375rem; cursor: pointer; transition: all 0.2s; white-space: nowrap;"
                    onmouseover="this.style.background='#a7f3d0'"
                    onmouseout="this.style.background='#d1fae5'"
                >
                    Audit
                </button>
            </td>
        `;

        tableBody.appendChild(row);
    });

    updateConversationsPaginationControls(totalPages);
    const paginationDiv = document.getElementById('conversationsPagination');
    if (paginationDiv) paginationDiv.style.display = totalPages > 1 ? 'block' : 'none';
}

// Update pagination controls
function updateConversationsPaginationControls(totalPages) {
    const paginationPages = document.getElementById('conversationsPaginationPages');
    const paginationPrev = document.getElementById('conversationsPaginationPrev');
    const paginationNext = document.getElementById('conversationsPaginationNext');
    
    if (!paginationPages || !paginationPrev || !paginationNext) return;
    
    paginationPages.innerHTML = '';
    
    if (totalPages <= 1) {
        paginationPrev.disabled = true;
        paginationNext.disabled = true;
        return;
    }
    
    paginationPrev.disabled = currentConversationsPage === 1;
    paginationNext.disabled = currentConversationsPage === totalPages;
    
    const maxVisiblePages = 5;
    let startPage = Math.max(1, currentConversationsPage - Math.floor(maxVisiblePages / 2));
    let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
    
    if (endPage - startPage < maxVisiblePages - 1) {
        startPage = Math.max(1, endPage - maxVisiblePages + 1);
    }
    
    for (let i = startPage; i <= endPage; i++) {
        const pageBtn = document.createElement('button');
        pageBtn.type = 'button';
        pageBtn.style.cssText = 'padding: 0.1617rem 0.3234rem; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.4043rem; cursor: pointer; color: #6b7280; transition: all 0.2s;';
        if (i === currentConversationsPage) {
            pageBtn.style.background = '#1A733E';
            pageBtn.style.color = 'white';
            pageBtn.style.borderColor = '#1A733E';
        }
        pageBtn.textContent = i;
        pageBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            conversationsGoToPage(i);
        };
        paginationPages.appendChild(pageBtn);
    }
}

// Go to specific page
window.conversationsGoToPage = function(page) {
    const totalPages = Math.ceil(allEmployeeConversations.length / conversationsItemsPerPage);
    if (page < 1 || page > totalPages) return;
    
    currentConversationsPage = page;
    displayEmployeeConversations();
};

window.navigateToAssignment = function(assignmentId) {
    // Navigate to audit-form.html with assignment parameter
    window.location.href = `audit-form.html?assignment=${assignmentId}`;
};

// Remove conversation link from audit
async function removeConversationFromAudit(auditId, conversationId) {
    try {
        console.log('🗑️ Removing conversation link from audit:', { conversationId, auditId });
        
        // Show confirmation dialog
        const proceed = await window.confirmationDialog.show({
            title: 'Remove Conversation Link',
            message: `Are you sure you want to remove the conversation link (ID: ${conversationId}) from this audit assignment?`,
            confirmText: 'Remove',
            cancelText: 'Cancel',
            type: 'warning'
        });
        
        if (!proceed) {
            return;
        }
        
        // Get Supabase client
        const supabaseClient = window.SupabaseConfig?.getClient?.();
        if (!supabaseClient) {
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Database connection not available',
                confirmText: 'OK',
                type: 'error'
            });
            return;
        }
        
        // Update assignment to remove conversation_id (set to null)
        const { error: updateError } = await supabaseClient
            .from('audit_assignments')
            .update({ 
                conversation_id: null
            })
            .eq('id', auditId);
        
        if (updateError) {
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Failed to remove conversation link: ' + updateError.message,
                confirmText: 'OK',
                type: 'error'
            });
            return;
        }
        
        console.log('✅ Successfully removed conversation link from audit');
        
        // Show success message
        await window.confirmationDialog.show({
            title: 'Success',
            message: `Conversation link has been removed from the audit assignment.`,
            confirmText: 'OK',
            type: 'success'
        });
        
        // Update input field to make it editable
        const input = document.getElementById(`conversationIdInput_${auditId}`);
        if (input) {
            input.value = '';
            input.readOnly = false;
            input.style.color = '#6b7280';
            input.style.fontWeight = '400';
            input.style.borderColor = '#d1d5db';
            input.style.background = 'white';
            input.style.cursor = 'text';
            input.title = 'Enter conversation ID';
        }
        
        // Refresh the pending audits display
        await displayPendingAudits();
        
    } catch (error) {
        console.error('Error removing conversation link:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to remove conversation link: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// Make function available globally
window.removeConversationFromAudit = removeConversationFromAudit;

// Update conversation ID for audit (from input field)
async function updateConversationIdForAudit(auditId, conversationIdValue) {
    try {
        // Trim and validate the input
        const conversationId = conversationIdValue ? conversationIdValue.trim() : null;
        
        // If empty, remove the conversation link and make input editable
        if (!conversationId || conversationId === '') {
            const input = document.getElementById(`conversationIdInput_${auditId}`);
            if (input) {
                input.readOnly = false;
                input.style.background = 'white';
                input.style.cursor = 'text';
                input.title = 'Enter conversation ID';
            }
            await removeConversationFromAudit(auditId, '');
            return;
        }
        
        console.log('📝 Updating conversation ID for audit:', { conversationId, auditId });
        
        // Get Supabase client
        const supabaseClient = window.SupabaseConfig?.getClient?.();
        if (!supabaseClient) {
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Database connection not available',
                confirmText: 'OK',
                type: 'error'
            });
            // Reset input to original value
            const input = document.getElementById(`conversationIdInput_${auditId}`);
            if (input) {
                const originalValue = input.getAttribute('data-original-value') || '';
                input.value = originalValue;
            }
            return;
        }
        
        // Get the current assignment to check if it already has a conversation_id
        const { data: currentAssignment, error: fetchError } = await supabaseClient
            .from('audit_assignments')
            .select('id, conversation_id, employee_email, employee_name, auditor_email, status')
            .eq('id', auditId)
            .single();
        
        if (fetchError || !currentAssignment) {
            console.error('Error fetching assignment:', fetchError);
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Failed to load assignment details: ' + (fetchError?.message || 'Assignment not found'),
                confirmText: 'OK',
                type: 'error'
            });
            // Reset input
            const input = document.getElementById(`conversationIdInput_${auditId}`);
            if (input) {
                const originalValue = input.getAttribute('data-original-value') || '';
                input.value = originalValue;
            }
            return;
        }
        
        // Check if assignment already has a different conversation_id
        if (currentAssignment.conversation_id) {
            const existingConvId = String(currentAssignment.conversation_id);
            const newConvId = String(conversationId);
            
            // If it's the same conversation, no need to update
            if (existingConvId === newConvId) {
                return;
            }
            
            // Different conversation - show warning
            const proceed = await window.confirmationDialog.show({
                title: 'Warning: Conversation Already Linked',
                message: `This assignment already has a conversation linked (ID: ${existingConvId}).\n\n` +
                        `You are trying to link a different conversation (ID: ${newConvId}).\n\n` +
                        `Do you want to replace the existing conversation?`,
                confirmText: 'Replace',
                cancelText: 'Cancel',
                type: 'warning'
            });
            
            if (!proceed) {
                // Reset input to original value and make it readonly again
                const input = document.getElementById(`conversationIdInput_${auditId}`);
                if (input) {
                    input.value = existingConvId;
                    input.readOnly = true;
                    input.style.color = '#1e40af';
                    input.style.fontWeight = '600';
                    input.style.borderColor = '#2563eb';
                    input.style.background = '#f9fafb';
                    input.style.cursor = 'default';
                    input.title = 'Delete to edit or replace';
                }
                return;
            }
        }
        
        // Update assignment with conversation_id
        const { error: updateError } = await supabaseClient
            .from('audit_assignments')
            .update({ 
                conversation_id: conversationId
            })
            .eq('id', auditId);
        
        if (updateError) {
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Failed to update conversation ID: ' + updateError.message,
                confirmText: 'OK',
                type: 'error'
            });
            // Reset input to original value and restore readonly state
            const input = document.getElementById(`conversationIdInput_${auditId}`);
            if (input) {
                const originalValue = input.getAttribute('data-original-value') || '';
                input.value = originalValue;
                if (originalValue) {
                    input.readOnly = true;
                    input.style.color = '#1e40af';
                    input.style.fontWeight = '600';
                    input.style.borderColor = '#2563eb';
                    input.style.background = '#f9fafb';
                    input.style.cursor = 'default';
                    input.title = 'Delete to edit or replace';
                } else {
                    input.readOnly = false;
                    input.style.color = '#6b7280';
                    input.style.fontWeight = '400';
                    input.style.borderColor = '#d1d5db';
                    input.style.background = 'white';
                    input.style.cursor = 'text';
                    input.title = 'Enter conversation ID';
                }
            }
            return;
        }
        
        console.log('✅ Successfully updated conversation ID for audit');
        
        // Update the input's original value
        const input = document.getElementById(`conversationIdInput_${auditId}`);
        if (input) {
            input.setAttribute('data-original-value', conversationId);
            input.readOnly = true;
            input.style.color = '#1e40af';
            input.style.fontWeight = '600';
            input.style.borderColor = '#2563eb';
            input.style.background = '#f9fafb';
            input.style.cursor = 'default';
            input.title = 'Delete to edit or replace';
        }
        
        // Refresh the pending audits display to show the linked conversation
        await displayPendingAudits();
        
    } catch (error) {
        console.error('Error updating conversation ID:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to update conversation ID: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
        // Reset input to original value and restore readonly state
        const input = document.getElementById(`conversationIdInput_${auditId}`);
        if (input) {
            const originalValue = input.getAttribute('data-original-value') || '';
            input.value = originalValue;
            if (originalValue) {
                input.readOnly = true;
                input.style.color = '#1e40af';
                input.style.fontWeight = '600';
                input.style.borderColor = '#2563eb';
                input.style.background = '#f9fafb';
                input.style.cursor = 'default';
                input.title = 'Delete to edit or replace';
            } else {
                input.readOnly = false;
                input.style.color = '#6b7280';
                input.style.fontWeight = '400';
                input.style.borderColor = '#d1d5db';
                input.style.background = 'white';
                input.style.cursor = 'text';
                input.title = 'Enter conversation ID';
            }
        }
    }
}

// Make function available globally
window.updateConversationIdForAudit = updateConversationIdForAudit;

// Link conversation to audit via drag-and-drop
async function linkConversationToAudit(conversation, auditId) {
    try {
        console.log('🔗 Linking conversation to audit via drag-and-drop:', { conversationId: conversation.id, auditId });
        
        const conversationId = conversation.id || null;
        if (!conversationId) {
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Invalid conversation: No conversation ID found',
                confirmText: 'OK',
                type: 'error'
            });
            return;
        }
        
        // Get Supabase client
        const supabaseClient = window.SupabaseConfig?.getClient?.();
        if (!supabaseClient) {
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Database connection not available',
                confirmText: 'OK',
                type: 'error'
            });
            return;
        }
        
        // Get the current assignment to check if it already has a conversation_id
        const { data: currentAssignment, error: fetchError } = await supabaseClient
            .from('audit_assignments')
            .select('id, conversation_id, employee_email, employee_name, auditor_email, status')
            .eq('id', auditId)
            .single();
        
        if (fetchError || !currentAssignment) {
            console.error('Error fetching assignment:', fetchError);
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Failed to load assignment details: ' + (fetchError?.message || 'Assignment not found'),
                confirmText: 'OK',
                type: 'error'
            });
            return;
        }
        
        // Check if assignment already has a conversation_id
        if (currentAssignment.conversation_id) {
            const existingConvId = String(currentAssignment.conversation_id);
            const newConvId = String(conversationId);
            
            // If it's the same conversation, just show success message
            if (existingConvId === newConvId) {
                await window.confirmationDialog.show({
                    title: 'Already Linked',
                    message: `This conversation (ID: ${newConvId}) is already linked to this audit.`,
                    confirmText: 'OK',
                    type: 'info'
                });
                return;
            }
            
            // Different conversation - show warning
            const proceed = await window.confirmationDialog.show({
                title: 'Warning: Conversation Already Linked',
                message: `This assignment already has a conversation linked (ID: ${existingConvId}).\n\n` +
                        `You are trying to link a different conversation (ID: ${newConvId}).\n\n` +
                        `Do you want to replace the existing conversation?`,
                confirmText: 'Replace',
                cancelText: 'Cancel',
                type: 'warning'
            });
            
            if (!proceed) {
                return;
            }
        }
        
        // Update assignment with conversation_id
        const { error: updateError } = await supabaseClient
            .from('audit_assignments')
            .update({ 
                conversation_id: conversationId
            })
            .eq('id', auditId);
        
        if (updateError) {
            await window.confirmationDialog.show({
                title: 'Error',
                message: 'Failed to link conversation to assignment: ' + updateError.message,
                confirmText: 'OK',
                type: 'error'
            });
            return;
        }
        
        console.log('✅ Successfully linked conversation to assignment via drag-and-drop');
        
        // Update the input field value immediately (before refresh)
        const input = document.getElementById(`conversationIdInput_${auditId}`);
        if (input) {
            input.value = conversationId;
            input.setAttribute('data-original-value', conversationId);
            input.style.color = '#1e40af';
            input.style.fontWeight = '600';
            input.style.borderColor = '#2563eb';
        }
        
        // Update the audit card in the pendingAudits array immediately
        const auditIndex = pendingAudits.findIndex(a => a.id === auditId);
        if (auditIndex !== -1) {
            pendingAudits[auditIndex].conversation_id = conversationId;
        }
        
        // Update the card UI immediately without full refresh
        const auditCard = document.querySelector(`.nested-audit-card[data-audit-id="${auditId}"]`);
        if (auditCard) {
            // Find conversation ID input and its container
            const cardInput = auditCard.querySelector(`#conversationIdInput_${auditId}`);
            const conversationContainer = cardInput ? cardInput.parentElement : null;
            
            if (cardInput) {
                // Update conversation ID input
                cardInput.value = conversationId;
                cardInput.setAttribute('data-original-value', conversationId);
                cardInput.readOnly = true;
                cardInput.style.color = '#1e40af';
                cardInput.style.fontWeight = '600';
                cardInput.style.borderColor = '#2563eb';
                cardInput.style.background = '#f9fafb';
                cardInput.style.cursor = 'default';
                cardInput.title = 'Delete to edit or replace';
            }
            
            if (conversationContainer && cardInput) {
                // Check if copy and remove buttons exist, if not create them
                let copyBtn = conversationContainer.querySelector('button[title="Copy conversation ID"]');
                let removeBtn = conversationContainer.querySelector('.remove-conversation-btn');
                
                if (!copyBtn) {
                    // Create copy button
                    copyBtn = document.createElement('button');
                    copyBtn.onclick = (e) => {
                        e.stopPropagation();
                        navigator.clipboard.writeText(conversationId).then(() => {
                            const originalHTML = copyBtn.innerHTML;
                            copyBtn.innerHTML = '<svg style="width: 0.7273rem; height: 0.7273rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>';
                            setTimeout(() => { copyBtn.innerHTML = originalHTML; }, 1000);
                        }).catch(err => console.error('Failed to copy:', err));
                    };
                    copyBtn.style.cssText = 'padding: 0.1617rem; background-color: transparent; border: none; border-radius: 0.1617rem; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #6b7280; transition: all 0.2s; flex-shrink: 0;';
                    copyBtn.onmouseover = () => { copyBtn.style.backgroundColor = '#f3f4f6'; copyBtn.style.color = '#374151'; };
                    copyBtn.onmouseout = () => { copyBtn.style.backgroundColor = 'transparent'; copyBtn.style.color = '#6b7280'; };
                    copyBtn.title = 'Copy conversation ID';
                    copyBtn.innerHTML = '<svg style="width: 0.7273rem; height: 0.7273rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>';
                    conversationContainer.appendChild(copyBtn);
                } else {
                    copyBtn.style.display = 'flex';
                }
                
                if (!removeBtn) {
                    // Create remove button
                    removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-conversation-btn';
                    removeBtn.setAttribute('data-audit-id', auditId);
                    removeBtn.setAttribute('data-conversation-id', conversationId);
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        window.removeConversationFromAudit(auditId, conversationId);
                    };
                    removeBtn.style.cssText = 'padding: 0.1617rem; background-color: transparent; border: none; border-radius: 0.1617rem; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #dc2626; transition: all 0.2s; flex-shrink: 0;';
                    removeBtn.onmouseover = () => { removeBtn.style.backgroundColor = '#fee2e2'; removeBtn.style.color = '#991b1b'; };
                    removeBtn.onmouseout = () => { removeBtn.style.backgroundColor = 'transparent'; removeBtn.style.color = '#dc2626'; };
                    removeBtn.title = 'Remove conversation link';
                    removeBtn.innerHTML = '<svg style="width: 0.7273rem; height: 0.7273rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';
                    conversationContainer.appendChild(removeBtn);
                } else {
                    removeBtn.style.display = 'flex';
                    removeBtn.setAttribute('data-conversation-id', conversationId);
                }
                
                // Update chat icon color
                const chatIcon = conversationContainer.querySelector('svg');
                if (chatIcon) {
                    chatIcon.style.color = '#2563eb';
                }
            }
            
            // Update View button - check if it exists in the right section
            const workspaceId = window.intercomConfig?.appId || 'aphmhtyj';
            const conversationUrl = `https://app.intercom.com/a/inbox/${workspaceId}/inbox/conversation/${conversationId}?view`;
            const rightSection = auditCard.querySelector('div[style*="flex-shrink: 0"]:last-child');
            if (rightSection) {
                let viewBtn = rightSection.querySelector('button[onclick*="window.open"]');
                if (!viewBtn || !viewBtn.textContent.includes('View')) {
                    // Create or update View button
                    if (viewBtn) {
                        viewBtn.remove();
                    }
                    viewBtn = document.createElement('button');
                    viewBtn.onclick = (e) => {
                        e.stopPropagation();
                        window.open(conversationUrl, '_blank', 'noopener,noreferrer');
                    };
                    viewBtn.style.cssText = 'padding: 0.2425rem 0.4043rem; background-color: #f3f4f6; color: #374151; border: none; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap; display: flex; align-items: center; gap: 0.1617rem; height: 1.6169rem;';
                    viewBtn.onmouseover = () => viewBtn.style.backgroundColor = '#e5e7eb';
                    viewBtn.onmouseout = () => viewBtn.style.backgroundColor = '#f3f4f6';
                    viewBtn.title = 'Open conversation in Intercom';
                    viewBtn.innerHTML = '<svg style="width: 0.8886rem; height: 0.8886rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg><span>View</span>';
                    rightSection.insertBefore(viewBtn, rightSection.firstChild);
                }
            }
            
            // Show Start/Continue button if it exists and conversationId is now available
            const startBtn = auditCard.querySelector('.nested-start-audit-btn');
            if (startBtn && conversationId) {
                startBtn.style.display = 'flex';
            }
        }
        
        // Show success message
        await window.confirmationDialog.show({
            title: 'Success',
            message: `Conversation (ID: ${conversationId}) has been linked to the audit assignment.`,
            confirmText: 'OK',
            type: 'success'
        });
        
        // Refresh the pending audits display to ensure everything is in sync
        await displayPendingAudits();
        
    } catch (error) {
        console.error('Error linking conversation to audit:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to link conversation: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// Quick start audit from conversation - auto-selects the audit and starts immediately
window.quickStartAuditFromConversation = async function(conversation, auditId) {
    try {
        console.log('⚡ Quick Start Audit:', { conversationId: conversation.id, auditId });
        
        // Set the selected audit ID
        selectedAuditId = auditId;
        
        // Update UI to reflect selection
        const allNestedCards = document.querySelectorAll('.nested-audit-card');
        allNestedCards.forEach(card => {
            const cardAuditId = card.getAttribute('data-audit-id');
            const radioButton = card.querySelector(`input[type="radio"][value="${cardAuditId}"]`);
            const isSelected = selectedAuditId === cardAuditId;
            
            if (isSelected) {
                card.style.background = '#eff6ff';
                card.style.border = '0.0405rem solid #2563eb';
                card.style.boxShadow = '0 0 0 0.0808rem rgba(37, 99, 235, 0.1)';
                if (radioButton) radioButton.checked = true;
            } else {
                card.style.background = '#ffffff';
                card.style.border = '0.0304rem solid #e5e7eb';
                card.style.boxShadow = 'none';
                if (radioButton) radioButton.checked = false;
            }
        });
        
        // Update audit buttons state
        updateAuditButtonsState();
        
        // Start the audit immediately
        await window.startAuditFromConversation(conversation);
    } catch (error) {
        console.error('Error in quickStartAuditFromConversation:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to start audit: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
};

window.startAssignedAudit = async function(assignmentId, employeeEmail, scorecardId) {
    try {
        // Update assignment status to 'in_progress'
        const { error: updateError } = await window.supabaseClient
            .from('audit_assignments')
            .update({ status: 'in_progress' })
            .eq('id', assignmentId);
        
        if (updateError) throw updateError;
        
        // Navigate to audit-form.html with assignment parameter
        window.location.href = `audit-form.html?assignment=${assignmentId}`;
        
    } catch (error) {
        console.error('Error starting assigned audit:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to start audit: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
};

// Start audit from Intercom conversation
window.startAuditFromConversation = async function(conversation) {
    try {
        console.log('═══════════════════════════════════════════════════════');
        console.log('🚀 START AUDIT FROM CONVERSATION');
        console.log('═══════════════════════════════════════════════════════');
        console.log('Conversation:', conversation);
        
        // Extract admin information from conversation
        const adminInfo = extractAdminFromConversation(conversation);
        
        if (!adminInfo || !adminInfo.id) {
            await window.confirmationDialog.show({
                title: 'Admin Not Found',
                message: 'Could not find admin information in this conversation. Please select the employee manually.',
                confirmText: 'OK',
                type: 'warning'
            });
        }
        
        // If admin email is not available, try to look it up
        let adminEmail = adminInfo?.email;
        if (!adminEmail && adminInfo?.id) {
            console.log('🔍 Looking up admin email for ID:', adminInfo.id);
            
            // Try to find in Supabase cache first
            const supabaseClient = window.SupabaseConfig?.getClient?.();
            if (supabaseClient) {
                try {
                    const { data: cachedAdmins, error: queryError } = await supabaseClient
                        .from('intercom_admin_cache')
                        .select('id, email, name, admin_data')
                        .eq('id', String(adminInfo.id))
                        .limit(1);
                    
                    if (!queryError && cachedAdmins && cachedAdmins.length > 0) {
                        const cachedAdmin = cachedAdmins[0];
                        adminEmail = cachedAdmin.email || cachedAdmin.admin_data?.email;
                        if (!adminInfo.name && cachedAdmin.name) {
                            adminInfo.name = cachedAdmin.name;
                        }
                        console.log('✅ Admin found in cache:', adminEmail);
                    }
                } catch (cacheError) {
                    console.warn('⚠️ Error accessing Supabase cache:', cacheError);
                }
            }
            
            // If still not found, fetch from Intercom API
            if (!adminEmail) {
                try {
                    const supabaseUrl = window.SupabaseConfig?.url || '';
                    const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';
                    const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?endpoint=admins`;
                    
                    const response = await fetch(edgeFunctionUrl, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${supabaseAnonKey}`,
                            'apikey': supabaseAnonKey,
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const admins = data.admins || data || [];
                        const admin = admins.find(a => String(a.id) === String(adminInfo.id));
                        
                        if (admin) {
                            adminEmail = admin.email;
                            if (!adminInfo.name && admin.name) {
                                adminInfo.name = admin.name;
                            }
                            console.log('✅ Admin found via Intercom API:', adminEmail);
                        }
                    }
                } catch (apiError) {
                    console.warn('⚠️ Error fetching admin from Intercom API:', apiError);
                }
            }
        }
        
        // Hide the pull conversations section
        const pullConversationsSection = document.getElementById('pullConversationsSection');
        if (pullConversationsSection) {
            pullConversationsSection.style.display = 'none';
        }
        
        // Check if an assignment is selected
        if (selectedAuditId) {
            console.log('📌 Assignment selected, linking conversation to assignment:', selectedAuditId);
            
            // Get Supabase client
            const supabaseClient = window.SupabaseConfig?.getClient?.();
            if (supabaseClient) {
                try {
                    // ============================================================================
                    // VALIDATION CHECKS BEFORE LINKING CONVERSATION
                    // ============================================================================
                    
                    // 1. Get the current assignment to check if it already has a conversation_id
                    const { data: currentAssignment, error: fetchError } = await supabaseClient
                        .from('audit_assignments')
                        .select('id, conversation_id, employee_email, employee_name, auditor_email, status')
                        .eq('id', selectedAuditId)
                        .single();
                    
                    if (fetchError || !currentAssignment) {
                        console.error('Error fetching assignment:', fetchError);
                        await window.confirmationDialog.show({
                            title: 'Error',
                            message: 'Failed to load assignment details: ' + (fetchError?.message || 'Assignment not found'),
                            confirmText: 'OK',
                            type: 'error'
                        });
                        return;
                    }
                    
                    const conversationId = conversation.id || null;
                    if (!conversationId) {
                        await window.confirmationDialog.show({
                            title: 'Error',
                            message: 'Invalid conversation: No conversation ID found',
                            confirmText: 'OK',
                            type: 'error'
                        });
                        return;
                    }
                    
                    // 2. Check if current assignment already has a conversation_id
                    if (currentAssignment.conversation_id) {
                        const existingConvId = String(currentAssignment.conversation_id);
                        const newConvId = String(conversationId);
                        
                        // If it's the same conversation, just proceed (no need to warn)
                        if (existingConvId === newConvId) {
                            console.log('✅ Same conversation already linked, proceeding...');
                            // Just navigate to the assignment
                            window.location.href = `audit-form.html?assignment=${selectedAuditId}`;
                            return;
                        }
                        
                        // Different conversation - show warning
                        const proceed = await window.confirmationDialog.show({
                            title: 'Warning: Conversation Already Linked',
                            message: `This assignment already has a conversation linked (ID: ${existingConvId}).\n\n` +
                                    `You are trying to link a different conversation (ID: ${newConvId}).\n\n` +
                                    `Do you want to replace the existing conversation?`,
                            confirmText: 'Replace',
                            cancelText: 'Cancel',
                            type: 'warning'
                        });
                        
                        if (!proceed) {
                            console.log('User cancelled conversation replacement');
                            return;
                        }
                    }
                    
                    // 3. Check if another assignment already has this conversation_id
                    const { data: existingAssignments, error: checkError } = await supabaseClient
                        .from('audit_assignments')
                        .select('id, employee_email, employee_name, auditor_email, status, created_at')
                        .eq('conversation_id', String(conversationId))
                        .neq('id', selectedAuditId); // Exclude current assignment
                    
                    if (checkError) {
                        console.error('Error checking for existing conversation links:', checkError);
                        // Continue anyway, but log the error
                    } else if (existingAssignments && existingAssignments.length > 0) {
                        // Found other assignments with this conversation
                        // Hard block: Cannot link same conversation to multiple assignments
                        const existingAssignment = existingAssignments[0];
                        const assignmentInfo = existingAssignment.employee_name 
                            ? `${existingAssignment.employee_name} (${existingAssignment.employee_email})`
                            : existingAssignment.employee_email || 'Unknown';
                        
                        await window.confirmationDialog.show({
                            title: 'Error: Conversation Already Linked to Another Assignment',
                            message: `This conversation (ID: ${conversationId}) is already linked to another audit assignment:\n\n` +
                                    `• Employee: ${assignmentInfo}\n` +
                                    `• Status: ${existingAssignment.status || 'Unknown'}\n` +
                                    `• Assignment ID: ${existingAssignment.id}\n\n` +
                                    `You cannot link the same conversation to multiple assignments. Please select a different conversation.`,
                            confirmText: 'OK',
                            type: 'error'
                        });
                        
                        console.log('❌ Blocked: Conversation already linked to another assignment - cannot proceed');
                        return;
                    }
                    
                    // 4. Extract admin email from conversation and compare with assignment employee_email
                    // NOTE: TEMPORARILY COMMENTED OUT - Employee email matching disabled
                    /*
                    // Note: adminEmail is already extracted earlier in this function (lines 6581-6652)
                    // We need to ensure it's available and compare it with the assignment's employee_email
                    
                    // Get the admin email (it should already be extracted, but ensure we have it)
                    let conversationAdminEmail = adminEmail || null;
                    
                    // If adminEmail wasn't found earlier, try to extract it from adminInfo
                    if (!conversationAdminEmail && adminInfo?.email) {
                        conversationAdminEmail = adminInfo.email.toLowerCase().trim();
                    }
                    
                    // If still not found, try to extract from conversation directly
                    if (!conversationAdminEmail) {
                        const extractedAdmin = extractAdminFromConversation(conversation);
                        if (extractedAdmin?.email) {
                            conversationAdminEmail = extractedAdmin.email.toLowerCase().trim();
                        }
                    }
                    
                    // Compare with assignment employee_email
                    if (conversationAdminEmail && currentAssignment.employee_email) {
                        const assignmentEmployeeEmail = (currentAssignment.employee_email || '').toLowerCase().trim();
                        
                        if (assignmentEmployeeEmail && conversationAdminEmail !== assignmentEmployeeEmail) {
                            // Hard block: Admin email must match employee email - no option to proceed
                            await window.confirmationDialog.show({
                                title: 'Error: Admin Email Mismatch',
                                message: `The conversation's admin email (${conversationAdminEmail}) does not match the assignment's employee email (${assignmentEmployeeEmail}).\n\n` +
                                        `You cannot link this conversation to this audit assignment. Please select a conversation that belongs to the correct employee.`,
                                confirmText: 'OK',
                                type: 'error'
                            });
                            
                            console.log('❌ Blocked: Admin email mismatch - cannot proceed');
                            return;
                        }
                    } else if (conversationAdminEmail && !currentAssignment.employee_email) {
                        // Assignment has no employee_email, but conversation has admin email
                        // This is less critical, but we could still warn
                        console.log('⚠️ Assignment has no employee_email to compare with conversation admin');
                    } else if (!conversationAdminEmail && currentAssignment.employee_email) {
                        // Conversation has no admin email, but assignment has employee_email
                        // Hard block: Cannot verify match without admin email
                        await window.confirmationDialog.show({
                            title: 'Error: Cannot Verify Admin Email',
                            message: `The conversation does not have an admin email to verify against the assignment's employee email (${currentAssignment.employee_email}).\n\n` +
                                    `You cannot link this conversation to this audit assignment. Please select a conversation with valid admin information.`,
                            confirmText: 'OK',
                            type: 'error'
                        });
                        
                        console.log('❌ Blocked: Conversation has no admin email - cannot verify match');
                        return;
                    }
                    */
                    
                    // ============================================================================
                    // ALL VALIDATIONS PASSED - PROCEED WITH LINKING
                    // ============================================================================
                    
                    // Update assignment with conversation_id and set status to in_progress
                    const { error: updateError } = await supabaseClient
                        .from('audit_assignments')
                        .update({ 
                            conversation_id: conversationId,
                            status: 'in_progress'  // Update status to in_progress
                        })
                        .eq('id', selectedAuditId);
                    
                    if (updateError) {
                        console.error('Error updating assignment:', updateError);
                        await window.confirmationDialog.show({
                            title: 'Error',
                            message: 'Failed to link conversation to assignment: ' + updateError.message,
                            confirmText: 'OK',
                            type: 'error'
                        });
                        return;
                    }
                    
                    console.log('✅ Successfully linked conversation to assignment');
                    
                    // Store assignment ID before clearing selection
                    const assignmentIdToNavigate = selectedAuditId;
                    
                    // Clear selection
                    selectedAuditId = null;
                    
                    // Navigate to assignment (which will load the conversation automatically)
                    window.location.href = `audit-form.html?assignment=${assignmentIdToNavigate}`;
                    return;
                } catch (error) {
                    console.error('Exception updating assignment:', error);
                    await window.confirmationDialog.show({
                        title: 'Error',
                        message: 'Failed to link conversation to assignment: ' + error.message,
                        confirmText: 'OK',
                        type: 'error'
                    });
                    return;
                }
            } else {
                console.warn('⚠️ Supabase client not available');
            }
        }
        
        // Navigate to audit-form.html with conversation data (original flow when no assignment selected)
        // Store conversation data in sessionStorage to pass to new page
        sessionStorage.setItem('pendingConversationData', JSON.stringify({
            conversation: conversation,
            adminInfo: adminInfo,
            adminEmail: adminEmail,
            conversation_id: conversation.id || null  // Store conversation ID for linking
        }));
        window.location.href = 'audit-form.html?fromConversation=true';
        
    } catch (error) {
        console.error('Error starting audit from conversation:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to start audit from conversation: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
};

// ============================================================================
// Helper Functions
// ============================================================================

// Helper function to get initials
function getInitials(name) {
    if (!name) return '?';
    return name.split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
}

// Helper function to format date
function formatDate(dateString) {
    if (!dateString) return 'Unknown';
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    
    return date.toLocaleDateString();
}

// Helper function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Set initial average score based on scoring type
function setInitialAverageScore() {
    if (!currentScorecard) return;
    
    const averageScoreField = document.getElementById('averageScore');
    if (!averageScoreField) return;
    
    const scoringType = currentScorecard.scoring_type || 'deductive';
    let initialScore = 0;
    
    switch(scoringType) {
        case 'deductive':
            initialScore = 100; // Start at 100%, deduct errors
            break;
        case 'additive':
            initialScore = 0; // Start at 0%, add achievements
            break;
        case 'hybrid':
            initialScore = 100; // Start at 100%, can deduct errors and add bonuses
            break;
        default:
            initialScore = 100;
    }
    
    averageScoreField.value = initialScore.toFixed(2);
    updatePassingStatus(initialScore);
}

// Update feedback boxes for a parameter based on error count (max 10)
function updateFeedbackBoxesForParameter(fieldId, fieldType, paramType) {
    const feedbackContainer = document.getElementById(`feedback_container_${fieldId}`);
    if (!feedbackContainer) return;
    
    // Get current error count
    let errorCount = 0;
    if (fieldType === 'radio') {
        const selectedRadio = document.querySelector(`input[name="${fieldId}"]:checked`);
        if (selectedRadio) {
            const value = parseInt(selectedRadio.value) || 0;
            // For additive/achievement: NO (0) = not achieved = error
            // For error parameters: YES (1) = error occurred = error
            if (paramType === 'achievement' || paramType === 'bonus') {
                errorCount = value === 0 ? 1 : 0;
            } else {
                errorCount = value;
            }
        }
    } else {
        const field = document.getElementById(fieldId);
        errorCount = field ? (parseInt(field.value) || 0) : 0;
    }
    
    // Always show at least 1 feedback box, but limit to max 10 based on error count
    // If errorCount is 0, show 1 box (optional)
    // If errorCount > 0, show up to errorCount boxes (max 10), all required
    const feedbackCount = errorCount === 0 ? 1 : Math.min(errorCount, 10);
    const isRequired = errorCount > 0;
    
    // Get existing feedback values (if loading from saved audit)
    const existingFeedbacks = [];
    const existingTextareas = feedbackContainer.querySelectorAll(`textarea[id^="feedback_${fieldId}_"]`);
    existingTextareas.forEach(textarea => {
        const index = parseInt(textarea.id.split('_').pop()) || 0;
        existingFeedbacks[index] = textarea.value;
    });
    
    // Clear container
    feedbackContainer.innerHTML = '';
    
    // Create feedback boxes
    for (let i = 0; i < feedbackCount; i++) {
        const feedbackDiv = document.createElement('div');
        const feedbackId = `feedback_${fieldId}_${i}`;
        // Make required if errorCount > 0, otherwise optional
        const requiredAttr = isRequired ? 'required' : '';
        const placeholder = errorCount === 0 
            ? 'Enter feedback (optional)...' 
            : (feedbackCount === 1 
                ? 'Enter feedback (required)...' 
                : `Feedback ${i + 1} of ${feedbackCount} (required)...`);
        
        feedbackDiv.innerHTML = `
            <textarea 
                id="${feedbackId}" 
                name="${feedbackId}" 
                ${requiredAttr}
                placeholder="${placeholder}" 
                rows="1" 
                class="w-full px-2 py-1 bg-white text-sm focus:outline-none resize-none" 
                style="font-family: 'Poppins', sans-serif; font-size: 0.5659rem; line-height: 1.2; min-height: 1rem; max-height: 50rem; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; padding: 0.2425rem 0.3234rem;"
            >${existingFeedbacks[i] || ''}</textarea>
        `;
        feedbackContainer.appendChild(feedbackDiv);
        
        // Setup auto-expand for this textarea
        const textarea = feedbackDiv.querySelector('textarea');
        if (textarea) {
            setupFeedbackTextareaAutoExpand(feedbackId, textarea);
        }
    }
}

// Setup auto-expand functionality for feedback textarea
function setupFeedbackTextareaAutoExpand(fieldId, textareaElement = null) {
    const textarea = textareaElement || document.getElementById(fieldId);
    if (!textarea) return;
    
    // Auto-expand function
    const autoExpand = function() {
        textarea.style.height = 'auto';
        const scrollHeightRem = textarea.scrollHeight / 16;
        textarea.style.height = Math.min(scrollHeightRem, 50.0) + 'rem';
    };
    
    // Add focus/input styles for green border
    textarea.addEventListener('focus', function() {
        this.style.borderColor = '#10b981';
    });
    textarea.addEventListener('input', function() {
        // Clear validation error styling when user starts typing
        if (this.value && this.value.trim()) {
            this.style.borderColor = '#10b981';
        }
        autoExpand();
    });
    textarea.addEventListener('blur', function() {
        // Keep green border if there's content, otherwise default gray
        if (this.value && this.value.trim()) {
            this.style.borderColor = '#10b981';
        } else {
            this.style.borderColor = '#d1d5db';
        }
    });
    
    // Hide scrollbar but keep scrolling functional
    textarea.style.setProperty('scrollbar-width', 'none', 'important');
    textarea.style.setProperty('-ms-overflow-style', 'none', 'important');
    
    // For webkit browsers
    const style = document.createElement('style');
    style.textContent = `#${fieldId}::-webkit-scrollbar { display: none; }`;
    document.head.appendChild(style);
    
    // Trigger on initial load if there's content
    setTimeout(autoExpand, 0);
}

// Render error parameter fields dynamically
function renderErrorParameters() {
    const container = document.getElementById('errorParametersContainer');
    container.innerHTML = '';
    
    if (currentParameters.length === 0) {
        container.innerHTML = '<div style="padding: 1.2937rem; text-align: center; color: #6b7280; font-size: 0.5659rem;"><p>No parameters defined for this scorecard.</p></div>';
        // Reset header to default "Status"
        const headerStatusCol = document.querySelector('#errorParametersSection .error-details-header-status');
        if (headerStatusCol) {
            headerStatusCol.textContent = 'Status';
        }
        return;
    }
    
    // Determine column header based on field types (matching audit-view.html logic)
    let statusColumnHeader = 'Status';
    const allCounters = currentParameters.every(param => param.field_type === 'counter');
    const allRadio = currentParameters.every(param => param.field_type === 'radio');
    
    if (allCounters) {
        statusColumnHeader = 'Counts';
    } else if (allRadio) {
        statusColumnHeader = 'Achieved?';
    }
    
    // Update the header dynamically
    const headerStatusCol = document.querySelector('#errorParametersSection .error-details-header-status');
    if (headerStatusCol) {
        headerStatusCol.textContent = statusColumnHeader;
    }
    
    // Update scorecard display in header
    const scorecardDisplay = document.getElementById('formScorecardDisplay');
    if (scorecardDisplay && currentScorecard) {
        let scoringTypeIcon = '';
        let scoringTypeText = '';
        if (currentScorecard.scoring_type === 'deductive') {
            scoringTypeIcon = '<svg style="width: 0.4043rem; height: 0.4043rem; display: inline-block; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor"><path d="M7 10l5 5 5-5z"/></svg>';
            scoringTypeText = 'DEDUCTIVE';
        } else if (currentScorecard.scoring_type === 'additive') {
            scoringTypeIcon = '<svg style="width: 0.4043rem; height: 0.4043rem; display: inline-block; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14l5-5 5 5z"/></svg>';
            scoringTypeText = 'ADDITIVE';
        } else if (currentScorecard.scoring_type === 'hybrid') {
            scoringTypeIcon = '<svg style="width: 0.4043rem; height: 0.4043rem; display: inline-block; vertical-align: middle;" viewBox="0 0 24 24" fill="currentColor"><path d="M2 12h20M12 2v20"/></svg>';
            scoringTypeText = 'HYBRID';
        }
        
        scorecardDisplay.innerHTML = `<svg style="width: 0.5659rem; height: 0.5659rem; display: inline-block; vertical-align: middle; margin-right: 0.2425rem;" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg> ${currentScorecard.name}${scoringTypeText ? ' <span style="background: rgba(255,255,255,0.25); padding: 0.0971rem 0.3234rem; border-radius: 0.1617rem; font-size: 0.4043rem; font-weight: 600; text-transform: uppercase; border: 0.0304rem solid rgba(255,255,255,0.4); margin-left: 0.3234rem; display: inline-flex; align-items: center; gap: 0.1617rem;">' + scoringTypeIcon + ' ' + scoringTypeText + '</span>' : ''}`;
    }
    
    currentParameters.forEach(param => {
        // Determine parameter styling based on type
        const paramType = param.parameter_type || 'error';
        const paramIcon = paramType === 'error' ? '−' : (paramType === 'achievement' || paramType === 'bonus' ? '+' : '');
        
        // Different colors for different parameter types (matching expert-audits.html exactly)
        let severityColor = '#3b82f6';
        let severityBg = '#eff6ff';
        
        if (paramType === 'error') {
            if (param.error_category.includes('Fail')) {
                severityColor = '#ef4444';
                severityBg = '#fee2e2';
            } else if (param.error_category.includes('Critical')) {
                severityColor = '#f59e0b';
                severityBg = '#fef3c7';
            }
        } else if (paramType === 'achievement' || paramType === 'bonus') {
            severityColor = '#10b981';
            severityBg = '#d1fae5';
        }
        
        // Map error category to severity label
        let mappedSeverity = 'Significant'; // default
        const category = param.error_category || '';
        if (category.includes('Fail')) {
            mappedSeverity = 'Critical Fail';
        } else if (category.includes('Critical')) {
            mappedSeverity = 'Critical';
        } else if (category.includes('Significant')) {
            mappedSeverity = 'Significant';
        } else if (category.includes('Major')) {
            mappedSeverity = 'Major';
        } else if (category.includes('Minor')) {
            mappedSeverity = 'Minor';
        }
        
        const severityLabel = (paramType === 'achievement' || paramType === 'bonus') && param.field_type !== 'radio' ? 'ACHIEVEMENT' : mappedSeverity;
        
        let inputHtml = '';
        
        if (param.field_type === 'radio') {
            // Radio button field (YES/NO)
            inputHtml = `
                <div style="display: flex; align-items: center; gap: 0.3234rem;">
                    <label style="display: flex; align-items: center; gap: 0.1617rem; cursor: pointer;">
                        <input type="radio" name="${param.field_id}" id="${param.field_id}_yes" value="1" required data-penalty="${param.penalty_points}" data-category="${param.error_category}" data-param-type="${paramType}" onchange="calculateAverageScore()" style="width: 0.6469rem; height: 0.6469rem; cursor: pointer; accent-color: #10b981;">
                        <span style="font-size: 0.4852rem; font-weight: 600; color: #10b981;">✓ YES</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.1617rem; cursor: pointer;">
                        <input type="radio" name="${param.field_id}" id="${param.field_id}_no" value="0" required data-penalty="${param.penalty_points}" data-category="${param.error_category}" data-param-type="${paramType}" onchange="calculateAverageScore()" style="width: 0.6469rem; height: 0.6469rem; cursor: pointer; accent-color: #ef4444;">
                        <span style="font-size: 0.4852rem; font-weight: 600; color: #ef4444;">✗ NO</span>
                    </label>
                </div>
            `;
        } else {
            // Counter field (default) - plain text display for counter value (no container)
            inputHtml = `
                <div style="display: flex; align-items: center; gap: 0.2425rem;">
                    <button type="button" class="counter-btn" data-action="decrement" data-target="${param.field_id}" style="width: 1.1321rem; height: 1.1321rem; display: flex; align-items: center; justify-content: center; border: 0.0304rem solid #d1d5db; background-color: #ffffff; color: #4b5563; border-radius: 0.1617rem; font-size: 0.6469rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: 'Poppins', sans-serif; padding: 0; line-height: 1;">−</button>
                    <span id="${param.field_id}_display" style="font-size: 0.5659rem; font-weight: 700; font-family: 'Poppins', sans-serif; color: #1f2937; min-width: 0.8086rem; text-align: center;">0</span>
                    <button type="button" class="counter-btn" data-action="increment" data-target="${param.field_id}" style="width: 1.1321rem; height: 1.1321rem; display: flex; align-items: center; justify-content: center; border: 0.0304rem solid #d1d5db; background-color: #ffffff; color: #4b5563; border-radius: 0.1617rem; font-size: 0.6469rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: 'Poppins', sans-serif; padding: 0; line-height: 1;">+</button>
                    <input type="number" id="${param.field_id}" name="${param.field_id}" min="0" max="10" value="0" readonly data-penalty="${param.penalty_points}" data-category="${param.error_category}" data-param-type="${paramType}" style="display: none;">
                </div>
            `;
        }
        
        // Create row matching expert-audits.html exactly (lines 1232-1243)
        const rowDiv = document.createElement('div');
        rowDiv.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 3fr; gap: 0.6469rem; align-items: center; padding: 0.3234rem 0; border-bottom: 0.0405rem solid #f3f4f6;';
        
        rowDiv.innerHTML = `
            <div style="font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif;">
                <span style="font-weight: 700; color: ${paramType === 'error' ? '#dc2626' : '#10b981'};">${paramIcon}</span> ${param.error_name}
            </div>
            <div style="display: flex; justify-content: center; font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif;">
                ${param.penalty_points}
            </div>
            <div style="display: flex; justify-content: center;">
                <span style="background: ${severityBg}; color: ${severityColor}; padding: 0.1617rem 0.4852rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 600; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem;">${severityLabel}</span>
            </div>
            <div style="display: flex; justify-content: center;">
                ${inputHtml}
            </div>
            <div id="feedback_container_${param.field_id}" style="display: flex; flex-direction: column; gap: 0.3234rem;">
                <!-- Feedback boxes will be dynamically added here based on error count -->
            </div>
        `;
        
        container.appendChild(rowDiv);
        
        // Initialize feedback boxes based on current error count (initially 0, so no boxes shown)
        updateFeedbackBoxesForParameter(param.field_id, param.field_type || 'counter', param.parameter_type || 'error');
        
        // Setup auto-expand functionality helper
        setupFeedbackTextareaAutoExpand(param.field_id);
    });
    
    // Update summary badges when scores change
    calculateAverageScore();
}

// Clear error parameters
function clearErrorParameters() {
    const container = document.getElementById('errorParametersContainer');
    container.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; padding: 1.2937rem; color: #6b7280; font-size: 0.5659rem;"><p>Please select a scorecard above to load error parameters.</p></div>';
}

// ============================================================================
// Audit Timer Functionality
(function() {
    let timerInterval = null;
    let startTime = null;
    let elapsedTime = 0;
    let isRunning = false;
    let auditStartTimestamp = null; // Store the absolute audit start timestamp
    
    let timerDisplay = null;
    let timerControlBtn = null;
    
    // Initialize timer elements (will be set when timer is shown)
    function initializeTimerElements() {
        if (!timerDisplay) {
            timerDisplay = document.querySelector('#auditTimer span');
        }
        if (!timerControlBtn) {
            timerControlBtn = document.querySelector('#timerControlBtn');
        }
    }
    const playIcon = '<path d="M8 5v14l11-7z"/>';
    const pauseIcon = '<path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>';
    const resetIcon = '<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>';
    
    function formatTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        
        if (hours > 0) {
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        } else {
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
    }
    
    // Helper function to parse duration from database
    // Handles both legacy format (minutes) and new format (seconds)
    // Also handles legacy time strings (HH:MM:SS or MM:SS format)
    function parseDurationFromDatabase(duration) {
        if (duration === null || duration === undefined || duration === '') {
            return 0;
        }
        
        // If it's already a number
        if (typeof duration === 'number' || (!isNaN(duration) && !isNaN(parseFloat(duration)))) {
            const value = parseInt(duration);
            // If value is less than 1440 (24 hours in minutes), assume it's in minutes (legacy format)
            // Otherwise, assume it's already in seconds (new format)
            if (value < 1440) {
                return value * 60; // Convert minutes to seconds
            } else {
                return value; // Already in seconds
            }
        }
        
        // If it's a string, try to parse it
        if (typeof duration === 'string') {
            // Try parsing as integer first
            const asInt = parseInt(duration);
            if (!isNaN(asInt)) {
                // If value is less than 1440 (24 hours in minutes), assume it's in minutes (legacy format)
                // Otherwise, assume it's already in seconds (new format)
                if (asInt < 1440) {
                    return asInt * 60; // Convert minutes to seconds
                } else {
                    return asInt; // Already in seconds
                }
            }
            
            // Try parsing as time string (HH:MM:SS or MM:SS format)
            const timeParts = duration.split(':');
            if (timeParts.length === 2) {
                // MM:SS format
                const minutes = parseInt(timeParts[0]) || 0;
                const seconds = parseInt(timeParts[1]) || 0;
                return (minutes * 60) + seconds;
            } else if (timeParts.length === 3) {
                // HH:MM:SS format
                const hours = parseInt(timeParts[0]) || 0;
                const minutes = parseInt(timeParts[1]) || 0;
                const seconds = parseInt(timeParts[2]) || 0;
                return (hours * 3600) + (minutes * 60) + seconds;
            }
        }
        
        // Default fallback
        return 0;
    }
    
    // Helper function to convert duration to minutes (integer) for database storage
    // Future-proof: handles integer minutes, seconds, and legacy time strings
    function convertDurationToMinutes(duration) {
        if (duration === null || duration === undefined || duration === '') {
            return null;
        }
        
        // If it's already a number
        if (typeof duration === 'number') {
            // If it's less than 1440 (24 hours in minutes), assume it's already in minutes
            if (duration < 1440) {
                return Math.floor(duration);
            }
            // Otherwise assume it's in seconds and convert to minutes
            return Math.floor(duration / 60);
        }
        
        // If it's a string, parse it first
        if (typeof duration === 'string') {
            // Trim whitespace
            duration = duration.trim();
            
            // Try parsing as integer first
            const asInt = parseInt(duration);
            if (!isNaN(asInt)) {
                // If it's less than 1440, likely already in minutes
                if (asInt < 1440) {
                    return asInt;
                }
                // Otherwise assume it's in seconds
                return Math.floor(asInt / 60);
            }
            
            // Try parsing as time string (MM:SS or HH:MM:SS format)
            const timeParts = duration.split(':');
            if (timeParts.length === 2) {
                // MM:SS format
                const minutes = parseInt(timeParts[0]) || 0;
                const seconds = parseInt(timeParts[1]) || 0;
                return minutes + Math.floor(seconds / 60);
            } else if (timeParts.length === 3) {
                // HH:MM:SS format
                const hours = parseInt(timeParts[0]) || 0;
                const minutes = parseInt(timeParts[1]) || 0;
                const seconds = parseInt(timeParts[2]) || 0;
                return (hours * 60) + minutes + Math.floor(seconds / 60);
            }
        }
        
        // Default fallback
        return null;
    }
    
    
    function startTimer() {
        initializeTimerElements();
        if (!isRunning) {
            // If this is the first time starting (no elapsed time), capture the audit start timestamp
            if (elapsedTime === 0 && auditStartTimestamp === null) {
                auditStartTimestamp = new Date().toISOString();
            }
            startTime = Date.now() - (elapsedTime * 1000);
            isRunning = true;
            timerInterval = setInterval(updateDisplay, 1000);
            if (timerControlBtn) {
            timerControlBtn.innerHTML = `<svg style="width: 0.5659rem; height: 0.5659rem;" viewBox="0 0 24 24" fill="currentColor">${pauseIcon}</svg>`;
            timerControlBtn.title = "Pause Timer";
            }
        }
    }
    
    function pauseTimer() {
        initializeTimerElements();
        if (isRunning) {
            isRunning = false;
            clearInterval(timerInterval);
            if (timerControlBtn) {
            timerControlBtn.innerHTML = `<svg style="width: 0.5659rem; height: 0.5659rem;" viewBox="0 0 24 24" fill="currentColor">${playIcon}</svg>`;
            timerControlBtn.title = "Resume Timer";
            }
        }
    }
    
    function resetTimer() {
        initializeTimerElements();
        isRunning = false;
        clearInterval(timerInterval);
        elapsedTime = 0;
        startTime = null;
        auditStartTimestamp = null; // Reset audit start timestamp
        if (timerDisplay) {
        timerDisplay.textContent = '00:00';
        }
        if (timerControlBtn) {
        timerControlBtn.innerHTML = `<svg style="width: 0.5659rem; height: 0.5659rem;" viewBox="0 0 24 24" fill="currentColor">${playIcon}</svg>`;
        timerControlBtn.title = "Start Timer";
        }
        updateAuditDuration();
    }
    
    // Function to get the audit start timestamp
    function getAuditStartTimestamp() {
        return auditStartTimestamp;
    }
    
    // Function to restore the audit start timestamp (used when editing existing audit)
    function restoreAuditStartTimestamp(timestamp) {
        if (timestamp) {
            auditStartTimestamp = timestamp;
        }
    }
    
    function toggleTimer() {
        if (isRunning) {
            pauseTimer();
        } else {
            startTimer();
        }
    }
    
    // Make timer draggable
    let auditTimerEl = null;
    function getAuditTimerElement() {
        if (!auditTimerEl) {
            auditTimerEl = document.querySelector('#auditTimer');
        }
        return auditTimerEl;
    }
    
    // Event listeners for timer (attached when timer is shown)
    function attachTimerEventListeners() {
        initializeTimerElements();
        
        if (timerControlBtn) {
            // Remove existing listeners to avoid duplicates
            const newBtn = timerControlBtn.cloneNode(true);
            timerControlBtn.parentNode.replaceChild(newBtn, timerControlBtn);
            timerControlBtn = newBtn;
            
            timerControlBtn.addEventListener('click', toggleTimer);
            // Double-click to reset
            timerControlBtn.addEventListener('dblclick', (e) => {
                e.preventDefault();
                resetTimer();
            });
        }
        
        const timerEl = getAuditTimerElement();
        if (timerEl) {
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    
            timerEl.addEventListener('mousedown', (e) => {
                initializeTimerElements();
                if (e.target === timerControlBtn || e.target.closest('#timerControlBtn')) return;
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
                const rect = timerEl.getBoundingClientRect();
        startLeft = rect.left;
        startTop = rect.top;
                timerEl.style.cursor = 'grabbing';
        e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
                timerEl.style.left = (startLeft + deltaX) + 'px';
                timerEl.style.top = (startTop + deltaY) + 'px';
                timerEl.style.right = 'auto';
    });
    
    document.addEventListener('mouseup', () => {
        if (isDragging) {
            isDragging = false;
                    timerEl.style.cursor = 'grab';
                }
            });
        }
    }
    
    // Initialize timer - start immediately
    function initializeTimer() {
        // Capture audit start timestamp if not already set
        if (auditStartTimestamp === null) {
            auditStartTimestamp = new Date().toISOString();
        }
        startTime = Date.now();
        isRunning = true;
        timerInterval = setInterval(updateDisplay, 1000);
        timerControlBtn.innerHTML = `<svg style="width: 0.5659rem; height: 0.5659rem;" viewBox="0 0 24 24" fill="currentColor">${pauseIcon}</svg>`;
        timerControlBtn.title = "Pause Timer";
        updateDisplay();
        
        // Audit timestamp will be set on submission (hidden field)
        
        // Load user data from cache and populate auditor fields
        loadUserData();
        
        // Update week and quarter based on current date
        updateWeekAndQuarter();
    }
    
    // Load user data from localStorage cache (behind the scenes)
    function loadUserData() {
        try {
            const userInfo = localStorage.getItem('userInfo');
            if (userInfo) {
                const user = JSON.parse(userInfo);
                
                // Populate hidden auditor fields from cached user data
                const auditorEmail = document.getElementById('auditorEmail');
                const auditorName = document.getElementById('auditorName');
                
                if (auditorEmail && user.email) {
                    auditorEmail.value = user.email;
                }
                if (auditorName && user.name) {
                    auditorName.value = user.name;
                }
            } else {
                // Fallback to default values if no cached data
                const auditorEmail = document.getElementById('auditorEmail');
                const auditorName = document.getElementById('auditorName');
                if (auditorEmail) {
                    auditorEmail.value = 'auditor@company.com';
                }
                if (auditorName) {
                    auditorName.value = 'John Auditor';
                }
            }
        } catch (error) {
            console.error('Error loading user data from cache:', error);
            // Fallback to default values on error
            const auditorEmail = document.getElementById('auditorEmail');
            const auditorName = document.getElementById('auditorName');
            if (auditorEmail) {
                auditorEmail.value = 'auditor@company.com';
            }
            if (auditorName) {
                auditorName.value = 'John Auditor';
            }
        }
    }
    
    // Calculate week number (1-52) from date
    function getWeekNumber(date) {
        // Get the first day of the year
        const startOfYear = new Date(date.getFullYear(), 0, 1);
        
        // Calculate the Monday of week 1 (the Monday of the week containing Jan 1)
        // If Jan 1 is Sunday (getDay() === 0), Monday is 6 days before (previous Monday)
        // Otherwise, Monday is (getDay() - 1) days before Jan 1
        const dayOfWeek = startOfYear.getDay();
        const daysToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
        const mondayOfWeek1 = new Date(startOfYear);
        mondayOfWeek1.setDate(startOfYear.getDate() + daysToMonday);
        mondayOfWeek1.setHours(0, 0, 0, 0);
        
        // Calculate the Monday of the week containing the given date
        const dateDay = date.getDay();
        const dateDaysToMonday = dateDay === 0 ? -6 : 1 - dateDay;
        const mondayOfDateWeek = new Date(date);
        mondayOfDateWeek.setDate(date.getDate() + dateDaysToMonday);
        mondayOfDateWeek.setHours(0, 0, 0, 0);
        
        // Calculate the number of days from Monday of week 1 to Monday of date's week
        const daysSinceWeek1 = Math.floor((mondayOfDateWeek - mondayOfWeek1) / (24 * 60 * 60 * 1000));
        
        // Calculate the week number (starting from 1)
        const weekNumber = Math.floor(daysSinceWeek1 / 7) + 1;
        
        return weekNumber;
    }
    
    // Calculate quarter (Q1-Q4) from date
    function getQuarter(date) {
        const month = date.getMonth() + 1; // getMonth() returns 0-11
        if (month >= 1 && month <= 3) return 'Q1';
        if (month >= 4 && month <= 6) return 'Q2';
        if (month >= 7 && month <= 9) return 'Q3';
        if (month >= 10 && month <= 12) return 'Q4';
        return 'Q1'; // fallback
    }
    
    // Update week and quarter based on current date
    function updateWeekAndQuarter() {
        const weekField = document.getElementById('week');
        const quarterField = document.getElementById('quarter');
        const now = new Date();
        
        if (weekField) {
            weekField.value = getWeekNumber(now);
        }
        if (quarterField) {
            quarterField.value = getQuarter(now);
        }
    }
    
    // Get current elapsed time (accounting for running timer)
    function getCurrentElapsedTime() {
        if (isRunning && startTime) {
            // Timer is running, calculate current elapsed time
            return Math.floor((Date.now() - startTime) / 1000);
        } else {
            // Timer is paused or stopped, use stored elapsedTime
            return elapsedTime;
        }
    }
    
    // Update hidden audit duration field when timer changes
    // Store duration in seconds (integer) for database, not formatted string
    function updateAuditDuration() {
        const auditDuration = document.getElementById('auditDuration');
        if (auditDuration) {
            // Get current elapsed time (whether timer is running or paused)
            const currentElapsedTime = getCurrentElapsedTime();
            // Store elapsed time in seconds as integer for database
            auditDuration.value = currentElapsedTime;
        }
    }
    
    // Restore timer from saved duration (used when editing existing audit)
    function restoreTimerFromDuration(duration) {
        const durationInSeconds = parseDurationFromDatabase(duration);
        elapsedTime = durationInSeconds;
        
        // Update display
        if (timerDisplay) {
            timerDisplay.textContent = formatTime(elapsedTime);
        }
        
        // Update hidden field
        updateAuditDuration();
    }
    
    // Modified updateDisplay to also update audit duration
    function updateDisplay() {
        if (isRunning && startTime) {
            elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        }
        timerDisplay.textContent = formatTime(elapsedTime);
        updateAuditDuration();
    }
    
    // Make functions globally accessible
    window.resetTimer = resetTimer;
    window.startTimer = startTimer;
    window.loadUserData = loadUserData;
    window.updateWeekAndQuarter = updateWeekAndQuarter;
    window.restoreTimerFromDuration = restoreTimerFromDuration;
    window.parseDurationFromDatabase = parseDurationFromDatabase;
    window.convertDurationToMinutes = convertDurationToMinutes;
    window.attachTimerEventListeners = attachTimerEventListeners;
    window.updateAuditDuration = updateAuditDuration;
    window.getAuditStartTimestamp = getAuditStartTimestamp;
    window.restoreAuditStartTimestamp = restoreAuditStartTimestamp;
    
    // Timer will start when user clicks "Start Audit" button
    // Don't auto-start on page load
})();

// Employee List and Auto-Population Functionality
let allEmployees = []; // Store all employees loaded from Supabase

// Load employees from Supabase
async function loadEmployees() {
    try {
        const employeeSelect = document.getElementById('employeeName');
        
        // Check if Supabase is available
        if (!window.SupabaseUsers) {
            console.error('Supabase not initialized');
            employeeSelect.innerHTML = '<option value="">Error: Supabase not initialized</option>';
            return;
        }
        
        // Load users from Supabase
        allEmployees = await window.SupabaseUsers.getAllUsers({
            orderBy: { column: 'name', ascending: true }
        });
        
        // Populate the dropdown
        employeeSelect.innerHTML = '<option value="">Select Employee</option>';
        
        allEmployees.forEach(user => {
            const option = document.createElement('option');
            option.value = user.email; // Use email as the value
            option.textContent = user.name;
            option.dataset.email = user.email;
            option.dataset.role = user.role || '';
            option.dataset.department = user.department || '';
            option.dataset.designation = user.designation || '';
            option.dataset.employeeId = user.employee_id || '';
            option.dataset.country = user.country || '';
            option.dataset.channel = user.channel || '';
            employeeSelect.appendChild(option);
        });
        
    } catch (error) {
        console.error('Error loading employees:', error);
        const employeeSelect = document.getElementById('employeeName');
        employeeSelect.innerHTML = '<option value="">Error loading employees</option>';
    }
}

// Load channels from channels table
async function loadChannels() {
    try {
        const channelSelect = document.getElementById('channel');
        
        if (!window.supabaseClient) {
            console.error('Supabase client not initialized');
            channelSelect.innerHTML = '<option value="">Error: Supabase not initialized</option>';
            return;
        }
        
        // Fetch active channels from channels table
        const { data, error } = await window.supabaseClient
            .from('channels')
            .select('name')
            .eq('is_active', true)
            .order('name', { ascending: true });
        
        if (error) throw error;
        
        // Populate the dropdown
        channelSelect.innerHTML = '<option value="">Select Channel</option>';
        
        data.forEach(channel => {
            const option = document.createElement('option');
            option.value = channel.name;
            option.textContent = channel.name;
            channelSelect.appendChild(option);
        });
        
        // Set first channel as default if available
        if (data.length > 0) {
            channelSelect.value = data[0].name;
            // Auto-select matching scorecard after a short delay to ensure scorecards are loaded
            setTimeout(async () => {
                await autoSelectScorecardByChannel(data[0].name);
            }, 500);
        } else {
            // If no channels available, still auto-select first scorecard
            setTimeout(async () => {
                const scorecardSelect = document.getElementById('scorecardSelect');
                if (scorecardSelect && (!scorecardSelect.value || scorecardSelect.value === '')) {
                    await loadScorecards();
                }
            }, 500);
        }
        
        console.log('Loaded channels from channels table:', data.map(c => c.name));
        
    } catch (error) {
        console.error('Error loading channels:', error);
        const channelSelect = document.getElementById('channel');
        channelSelect.innerHTML = '<option value="">Error loading channels</option>';
    }
}


// Function to auto-populate Error Description from individual feedback fields (Dynamic)
function populateErrorDescription() {
    const allFeedback = [];
    
    currentParameters.forEach(param => {
        const feedbackElement = document.getElementById(`feedback_${param.field_id}`);
        if (feedbackElement && feedbackElement.value.trim()) {
            allFeedback.push(`${param.error_name}: ${feedbackElement.value.trim()}`);
        }
    });
    
    const errorDescription = document.getElementById('errorDescription');
    if (errorDescription) {
        errorDescription.value = allFeedback.join('\n\n');
    }
}

// ============================================================================
// Close Audit Form Function
// ============================================================================
window.closeAuditForm = async function() {
    const auditFormModal = document.getElementById('auditFormModal');
    if (auditFormModal) {
        auditFormModal.style.display = 'none';
    }
    
    // Hide Intercom alias field
    const intercomAliasContainer = document.getElementById('intercomAliasContainer');
    if (intercomAliasContainer) {
        intercomAliasContainer.style.display = 'none';
    }
    
    // Reset form
    const auditForm = document.getElementById('auditForm');
    if (auditForm) {
        auditForm.reset();
    }
    
    // Reset header back to green (passing state)
    const headerElement = document.getElementById('auditFormHeader');
    if (headerElement) {
        headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
    }
    
    // Hide timer
    const auditTimer = document.getElementById('auditTimer');
    if (auditTimer) {
        auditTimer.style.display = 'none';
    }
    
    // Reset timer if exists
    if (window.resetTimer) {
        window.resetTimer();
    }
    
    // Reset editing mode and assignment tracking
    isEditingPendingAudit = false;
    currentEditingAuditId = null;
    currentAssignmentId = null;
    isEditingExistingAudit = false;
    currentEditingTableName = null;
    
    // Reload and show pending audits
    await loadPendingAudits();
    
    // Update stats after closing form
    await updateYourStats();
    
    // Scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
};

// ============================================================================
// Load Audit for Editing from URL Parameters
// ============================================================================
// Calibration mode detection
let isCalibrationMode = false;
let calibrationSessionId = null;
let calibrationSampleAuditId = null;
let calibrationInteractionId = null;
let calibrationScorecardId = null;
let calibrationTableName = null;

// ATA mode detection
let isATAMode = false;
let ataAuditId = null;
let ataTableName = null;
let ataScorecardId = null;
let originalAuditData = null; // Store original audit data for comparison

// Check if we're in calibration mode
function checkCalibrationMode() {
    const urlParams = new URLSearchParams(window.location.search);
    const calibration = urlParams.get('calibration');
    
    if (calibration === 'true') {
        isCalibrationMode = true;
        calibrationSessionId = urlParams.get('sessionId');
        calibrationSampleAuditId = urlParams.get('auditId');
        calibrationInteractionId = urlParams.get('interactionId');
        calibrationScorecardId = urlParams.get('scorecardId');
        calibrationTableName = urlParams.get('tableName');
        
        console.log('Calibration mode detected:', {
            sessionId: calibrationSessionId,
            auditId: calibrationSampleAuditId,
            interactionId: calibrationInteractionId,
            scorecardId: calibrationScorecardId,
            tableName: calibrationTableName
        });
        
        return true;
    }
    return false;
}

// Check if we're in ATA mode
function checkATAMode() {
    const urlParams = new URLSearchParams(window.location.search);
    const ata = urlParams.get('ata');
    
    if (ata === 'true') {
        isATAMode = true;
        ataAuditId = urlParams.get('auditId');
        ataTableName = urlParams.get('table');
        ataScorecardId = urlParams.get('scorecard');
        
        console.log('ATA mode detected:', {
            auditId: ataAuditId,
            tableName: ataTableName,
            scorecardId: ataScorecardId
        });
        
        return true;
    }
    return false;
}

async function loadAuditForEditing() {
    const urlParams = new URLSearchParams(window.location.search);
    const auditId = urlParams.get('edit');
    const scorecardId = urlParams.get('scorecard');
    const tableName = urlParams.get('table');
    
    // Check for calibration mode first
    if (checkCalibrationMode()) {
        await loadCalibrationSampleAudit();
        return;
    }
    
    // Check for ATA mode
    if (checkATAMode()) {
        await loadATAOriginalAudit();
        return;
    }
    
    if (!auditId || !tableName) {
        return; // No edit parameters, normal create mode
    }
    
    try {
        console.log('Loading audit for editing:', auditId, 'from table:', tableName);
        
        // Load the audit data from the specified table
        const { data, error } = await window.supabaseClient
            .from(tableName)
            .select('*')
            .eq('id', auditId)
            .single();
        
        if (error) throw error;
        
        if (!data) {
            alert('Audit not found');
            return;
        }
        
        console.log('Loaded audit data:', data);
        
        // Navigate to edit-audit.html for editing existing audits
        window.location.href = `edit-audit.html?edit=${auditId}&scorecard=${scorecardId}&table=${tableName}`;
        return;
        
        // Load and select the scorecard
        if (scorecardId) {
            const scorecardSelect = document.getElementById('scorecardSelect');
            if (scorecardSelect) {
                // Wait for scorecard options to be populated
                let attempts = 0;
                while (scorecardSelect.options.length <= 1 && attempts < 50) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                if (scorecardSelect.options.length > 1) {
                    // Set the value (this will trigger the change event, but that's okay since we're in edit mode)
                    scorecardSelect.value = scorecardId;
                    
                    // Wait for scorecard parameters to fully load
                    // The isEditingExistingAudit flag should prevent the change handler from clearing the form
                    await loadScorecardParameters(scorecardId);
                    
                    // Additional wait to ensure parameters are rendered in DOM
                    await new Promise(resolve => setTimeout(resolve, 300));
                } else {
                    console.error('Scorecard dropdown not populated yet');
                    alert('Error: Scorecard dropdown not ready. Please refresh the page.');
                    return;
                }
            } else {
                console.error('Scorecard select element not found');
                alert('Error: Scorecard select element not found. Please refresh the page.');
                return;
            }
        }
        
        // Populate form fields with audit data
        await populateFormWithAuditData(data);
        
        // Update header to indicate editing mode
        const formHeader = document.getElementById('formScorecardDisplay');
        if (formHeader) {
            formHeader.innerHTML = 'Editing Audit - ' + formHeader.innerHTML;
        }
        
        // Restore audit start timestamp if editing existing audit
        if (window.restoreAuditStartTimestamp && data.audit_start_time) {
            window.restoreAuditStartTimestamp(data.audit_start_time);
        }
        
        // Restore timer from saved duration if editing existing audit
        if (window.restoreTimerFromDuration && data.audit_duration !== null && data.audit_duration !== undefined) {
            window.restoreTimerFromDuration(data.audit_duration);
        } else {
            // Start fresh timer if no saved duration
        if (window.resetTimer && window.startTimer) {
            window.resetTimer();
            window.startTimer();
            }
        }
        
    } catch (error) {
        console.error('Error loading audit for editing:', error);
        alert('Failed to load audit for editing: ' + error.message);
    }
}

// ============================================================================
// Populate Form with Audit Data
// ============================================================================
async function populateFormWithAuditData(audit) {
    try {
        // Populate employee information
        const employeeSelect = document.getElementById('employeeName');
        const employeeEmail = document.getElementById('employeeEmail');
        const employeeType = document.getElementById('employeeType');
        const employeeDepartment = document.getElementById('employeeDepartment');
        const countryOfEmployee = document.getElementById('countryOfEmployee');
        
        if (employeeSelect && audit.employee_email) {
            // Wait for employee options to be populated if not ready
            let attempts = 0;
            while (employeeSelect.options.length === 0 && attempts < 50) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            // Find and select the employee in dropdown
            let employeeFound = false;
            const normalizedEmail = (audit.employee_email || '').toLowerCase().trim();
            for (let i = 0; i < employeeSelect.options.length; i++) {
                const optionEmail = (employeeSelect.options[i].dataset.email || '').toLowerCase().trim();
                if (optionEmail === normalizedEmail) {
                    employeeSelect.selectedIndex = i;
                    // Trigger change event to populate other fields
                    employeeSelect.dispatchEvent(new Event('change'));
                    employeeFound = true;
                    break;
                }
            }
            
            if (!employeeFound && employeeSelect.options.length > 0) {
                console.warn('Employee not found in dropdown:', audit.employee_email);
            }
        }
        
        // Set employee fields directly from audit data (in case dropdown selection fails)
        if (employeeEmail) employeeEmail.value = audit.employee_email || '';
        if (employeeType) employeeType.value = audit.employee_type || '';
        if (employeeDepartment) employeeDepartment.value = audit.employee_department || '';
        if (countryOfEmployee) countryOfEmployee.value = audit.country_of_employee || '';
        
        // Populate interaction details
        const interactionId = document.getElementById('interactionId');
        const interactionDate = document.getElementById('interactionDate');
        const channel = document.getElementById('channel');
        const clientEmail = document.getElementById('clientEmail');
        
        if (interactionId) interactionId.value = audit.interaction_id || '';
        if (interactionDate) interactionDate.value = audit.interaction_date || '';
        if (channel) channel.value = audit.channel || '';
        if (clientEmail) clientEmail.value = audit.client_email || '';
        
        // Populate audit type and validation
        const auditType = document.getElementById('auditType');
        const validationStatus = document.getElementById('validationStatus');
        
        if (auditType) auditType.value = audit.audit_type || '';
        if (validationStatus) validationStatus.value = audit.validation_status || '';
        
        // Populate pre/post status
        const agentPreStatus = document.getElementById('agentPreStatus');
        const agentPostStatus = document.getElementById('agentPostStatus');
        
        if (agentPreStatus) agentPreStatus.value = audit.agent_pre_status || '';
        if (agentPostStatus) agentPostStatus.value = audit.agent_post_status || '';
        
        // Populate transcript and recommendations
        const transcript = document.getElementById('transcript');
        const recommendations = document.getElementById('recommendations');
        
        if (transcript) transcript.value = audit.transcript || '';
        if (recommendations) recommendations.value = audit.recommendations || '';
        
        // Wait for scorecard parameters to be fully loaded and rendered
        let attempts = 0;
        while ((!currentParameters || currentParameters.length === 0) && attempts < 30) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }
        
        if (attempts >= 30) {
            console.warn('Timeout waiting for scorecard parameters to load');
        }
        
        // Populate error parameters
        if (currentParameters && currentParameters.length > 0) {
            currentParameters.forEach(param => {
                const fieldValue = audit[param.field_id];
                
                if (param.field_type === 'radio') {
                    // Set radio button selection
                    const radioYes = document.getElementById(`${param.field_id}_yes`);
                    const radioNo = document.getElementById(`${param.field_id}_no`);
                    
                    if (fieldValue === 1 || fieldValue === true || fieldValue === 'true' || fieldValue === '1') {
                        if (radioYes) radioYes.checked = true;
                    } else {
                        if (radioNo) radioNo.checked = true;
                    }
                } else {
                    // Set counter value
                    const field = document.getElementById(param.field_id);
                    const counterValue = fieldValue || 0;
                    if (field) {
                        field.value = counterValue;
                    }
                    
                    // Update plain text display
                    const displayElement = document.getElementById(`${param.field_id}_display`);
                    if (displayElement) {
                        displayElement.textContent = counterValue;
                        // Update color based on value
                        if (counterValue > 0) {
                            displayElement.style.color = '#ef4444';
                            displayElement.style.fontWeight = '700';
                        } else {
                            displayElement.style.color = '#1f2937';
                            displayElement.style.fontWeight = '700';
                        }
                    }
                }
                
                // Populate feedback - handle both old format (string) and new format (JSON array)
                const feedbackData = audit[`feedback_${param.field_id}`];
                let feedbackArray = [];
                
                if (feedbackData) {
                    if (typeof feedbackData === 'string') {
                        // Try to parse as JSON array, fallback to single string
                        try {
                            const parsed = JSON.parse(feedbackData);
                            feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                        } catch (e) {
                            // If not valid JSON, treat as single string (backward compatibility)
                            feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                        }
                    } else if (Array.isArray(feedbackData)) {
                        feedbackArray = feedbackData;
                    } else {
                        feedbackArray = feedbackData ? [feedbackData] : [];
                    }
                }
                
                // Update feedback boxes based on error count first, then populate values
                const paramType = param.parameter_type || 'error';
                updateFeedbackBoxesForParameter(param.field_id, param.field_type || 'counter', paramType);
                
                // Populate feedback values into the boxes
                if (feedbackArray.length > 0) {
                    const feedbackContainer = document.getElementById(`feedback_container_${param.field_id}`);
                    if (feedbackContainer) {
                        feedbackArray.forEach((feedbackText, index) => {
                            const feedbackId = `feedback_${param.field_id}_${index}`;
                            const textarea = document.getElementById(feedbackId);
                            if (textarea && feedbackText) {
                                textarea.value = feedbackText;
                                // Trigger auto-expand
                                setTimeout(() => {
                                    textarea.style.height = 'auto';
                                    const scrollHeightRem = textarea.scrollHeight / 16;
                                    textarea.style.height = Math.min(scrollHeightRem, 50.0) + 'rem';
                                }, 100);
                            }
                        });
                    }
                }
            });
        }
        
        // Recalculate scores
        calculateAverageScore();
        
        console.log('Form populated with audit data');
        
    } catch (error) {
        console.error('Error populating form with audit data:', error);
    }
}

// ============================================================================
// Save Calibration Result
// ============================================================================
async function saveCalibrationResult(auditPayload, auditData) {
    try {
        // Get current user info
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const participantEmail = userInfo.email || '';
        const participantName = userInfo.name || '';

        // Build error parameters JSONB
        const errorParameters = {};
        const feedbackParameters = {};
        
        currentParameters.forEach(param => {
            const fieldValue = auditData[param.field_id];
            errorParameters[param.field_id] = fieldValue ? parseInt(fieldValue) : 0;
            
            const feedbackKey = `feedback_${param.field_id}`;
            if (auditData[feedbackKey]) {
                feedbackParameters[param.field_id] = auditData[feedbackKey];
            }
        });

        const calibrationResult = {
            calibration_session_id: calibrationSessionId,
            participant_email: participantEmail,
            participant_name: participantName,
            scorecard_id: calibrationScorecardId,
            sample_audit_id: calibrationSampleAuditId,
            
            // Audit timing
            audit_start_time: auditPayload.audit_start_time,
            audit_end_time: auditPayload.audit_end_time,
            audit_duration: auditPayload.audit_duration,
            
            // Employee info (from sample)
            employee_name: auditPayload.employee_name,
            employee_email: auditPayload.employee_email,
            employee_type: auditPayload.employee_type,
            employee_department: auditPayload.employee_department,
            country_of_employee: auditPayload.country_of_employee,
            
            // Interaction details (from sample)
            interaction_id: auditPayload.interaction_id,
            interaction_date: auditPayload.interaction_date,
            channel: auditPayload.channel,
            client_email: auditPayload.client_email,
            
            // Audit metadata
            audit_type: auditPayload.audit_type,
            agent_pre_status: auditPayload.agent_pre_status,
            agent_post_status: auditPayload.agent_post_status,
            passing_status: auditPayload.passing_status,
            validation_status: 'Validated',
            
            // Scores
            average_score: auditPayload.average_score,
            critical_errors: auditPayload.critical_errors || 0,
            critical_fail_error: auditPayload.critical_fail_error || 0,
            significant_error: auditPayload.significant_error || 0,
            total_errors_count: auditPayload.total_errors_count || 0,
            
            // Content
            transcript: auditPayload.transcript,
            recommendations: auditPayload.recommendations,
            
            // Dynamic parameters
            error_parameters: errorParameters,
            feedback_parameters: feedbackParameters,
            
            status: 'submitted'
        };

        console.log('Saving calibration result:', calibrationResult);

        const { data, error } = await window.supabaseClient
            .from('calibration_results')
            .insert([calibrationResult])
            .select();

        if (error) throw error;

        console.log('Calibration result saved successfully:', data);

        await window.confirmationDialog.show({
            title: 'Calibration Submitted!',
            message: 'Your calibration audit has been submitted successfully.',
            confirmText: 'OK',
            type: 'success'
        });

        // Close the form
        closeAuditForm();

        // If opened from calibration page, notify parent window
        if (window.opener) {
            window.opener.postMessage({ type: 'calibration_submitted', sessionId: calibrationSessionId }, '*');
            window.close();
        }

    } catch (error) {
        console.error('Error saving calibration result:', error);
        await window.confirmationDialog.show({
            title: 'Submission Error',
            message: 'Failed to submit calibration audit: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// Load calibration sample audit and populate form
async function loadCalibrationSampleAudit() {
    try {
        if (!isCalibrationMode || !calibrationScorecardId) {
            console.error('Missing calibration parameters');
            return;
        }

        // Check if we have audit_id or interaction_id
        if (!calibrationSampleAuditId && !calibrationInteractionId) {
            console.error('Missing audit ID or interaction ID');
            return;
        }

        console.log('Loading calibration sample audit...');

        let sampleAudit = null;
        
        if (calibrationSampleAuditId && calibrationTableName) {
            // Load the sample audit from database
            const { data, error: auditError } = await window.supabaseClient
                .from(calibrationTableName)
                .select('*')
                .eq('id', calibrationSampleAuditId)
                .single();

            if (auditError || !data) {
                alert('Error loading sample audit: ' + (auditError?.message || 'Audit not found'));
                return;
            }
            sampleAudit = data;
        } else if (calibrationInteractionId) {
            // Create minimal audit object from interaction_id
            // The interaction details will be loaded from Intercom
            sampleAudit = {
                interaction_id: calibrationInteractionId,
                scorecard_id: calibrationScorecardId,
                // Other fields will be populated from Intercom if available
            };
        }
        
        if (!sampleAudit) {
            alert('Error: Could not load sample audit or interaction');
            return;
        }

        // Load scorecard and parameters
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect) {
            scorecardSelect.value = calibrationScorecardId;
            await loadScorecardParameters(calibrationScorecardId);
        }

        // Wait a bit for parameters to load
        await new Promise(resolve => setTimeout(resolve, 500));

        // Show the audit form modal
        const auditFormModal = document.getElementById('auditFormModal');
        if (auditFormModal) {
            auditFormModal.style.display = 'flex';
        }

        // Hide pending audits section
        const pendingAuditsSection = document.getElementById('pendingAuditsSection');
        if (pendingAuditsSection) {
            pendingAuditsSection.style.display = 'none';
        }

        // Update header to indicate calibration mode
        const formHeader = document.getElementById('auditFormHeader');
        const scorecardDisplay = document.getElementById('formScorecardDisplay');
        if (formHeader && scorecardDisplay) {
            const h2 = formHeader.querySelector('h2');
            if (h2) h2.textContent = 'Calibration Audit';
            scorecardDisplay.innerHTML = '<svg style="width: 0.5659rem; height: 0.5659rem; display: inline-block; vertical-align: middle; margin-right: 0.2425rem;" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg> Calibration Mode';
        }

        // Populate form with sample audit data (read-only for some fields)
        await populateFormWithCalibrationSample(sampleAudit);

        // Start timer
        if (window.resetTimer && window.startTimer) {
            window.resetTimer();
            window.startTimer();
        }

        // Show timer
        const auditTimer = document.getElementById('auditTimer');
        if (auditTimer) {
            auditTimer.style.display = 'flex';
        }

    } catch (error) {
        console.error('Error loading calibration sample audit:', error);
        alert('Error loading calibration sample audit: ' + error.message);
    }
}

// Populate form with calibration sample audit (make certain fields read-only)
async function populateFormWithCalibrationSample(sampleAudit) {
    try {
        // First, ensure employees are loaded
        await loadEmployees();
        
        // Employee name dropdown (read-only - select from sample)
        const employeeSelect = document.getElementById('employeeName');
        if (employeeSelect && sampleAudit.employee_email) {
            // Find and select the employee in dropdown
            for (let i = 0; i < employeeSelect.options.length; i++) {
                if (employeeSelect.options[i].dataset.email === sampleAudit.employee_email) {
                    employeeSelect.selectedIndex = i;
                    break;
                }
            }
            employeeSelect.disabled = true;
            employeeSelect.style.backgroundColor = 'transparent';
            employeeSelect.style.color = 'white';
            employeeSelect.style.cursor = 'not-allowed';
            employeeSelect.style.opacity = '0.9';
        }

        // Employee information (read-only - from sample)
        const employeeEmail = document.getElementById('employeeEmail');
        const employeeType = document.getElementById('employeeType');
        const employeeDepartment = document.getElementById('employeeDepartment');
        const countryOfEmployee = document.getElementById('countryOfEmployee');

        // Set employee info from sample (read-only) - WHITE TEXT ON GREEN BACKGROUND
        if (employeeEmail) {
            employeeEmail.value = sampleAudit.employee_email || '';
            employeeEmail.readOnly = true;
            employeeEmail.style.backgroundColor = 'transparent';
            employeeEmail.style.color = 'white';
            employeeEmail.style.cursor = 'not-allowed';
            employeeEmail.style.opacity = '0.9';
        }

        if (employeeType) {
            employeeType.value = sampleAudit.employee_type || '';
            employeeType.readOnly = true;
            employeeType.style.backgroundColor = 'transparent';
            employeeType.style.color = 'white';
            employeeType.style.cursor = 'not-allowed';
            employeeType.style.opacity = '0.9';
        }

        if (employeeDepartment) {
            employeeDepartment.value = sampleAudit.employee_department || '';
            employeeDepartment.readOnly = true;
            employeeDepartment.style.backgroundColor = 'transparent';
            employeeDepartment.style.color = 'white';
            employeeDepartment.style.cursor = 'not-allowed';
            employeeDepartment.style.opacity = '0.9';
        }

        if (countryOfEmployee) {
            countryOfEmployee.value = sampleAudit.country_of_employee || '';
            countryOfEmployee.disabled = true;
            countryOfEmployee.style.backgroundColor = 'transparent';
            countryOfEmployee.style.color = 'white';
            countryOfEmployee.style.cursor = 'not-allowed';
            countryOfEmployee.style.opacity = '0.9';
        }

        // Interaction details (read-only - from sample) - NOT in header, so gray background
        // These fields should NOT be editable during calibration
        const interactionId = document.getElementById('interactionId');
        const interactionDate = document.getElementById('interactionDate');
        const channel = document.getElementById('channel');
        const clientEmail = document.getElementById('clientEmail');
        const viewChatBtn = document.getElementById('viewChatBtn');

        if (interactionId) {
            interactionId.value = sampleAudit.interaction_id || '';
            interactionId.readOnly = true;
            interactionId.disabled = true; // Disable to prevent editing
            interactionId.style.backgroundColor = '#f3f4f6';
            interactionId.style.cursor = 'not-allowed';
        }

        if (interactionDate) {
            interactionDate.value = sampleAudit.interaction_date || '';
            interactionDate.readOnly = true;
            interactionDate.disabled = true; // Disable to prevent editing
            interactionDate.style.backgroundColor = '#f3f4f6';
            interactionDate.style.cursor = 'not-allowed';
        }

        if (channel) {
            channel.value = sampleAudit.channel || '';
            channel.disabled = true;
            channel.style.backgroundColor = '#f3f4f6';
            channel.style.cursor = 'not-allowed';
        }

        if (clientEmail) {
            clientEmail.value = sampleAudit.client_email || '';
            clientEmail.readOnly = true;
            clientEmail.disabled = true; // Disable to prevent editing
            clientEmail.style.backgroundColor = '#f3f4f6';
            clientEmail.style.cursor = 'not-allowed';
        }

        // Disable "Open" button for interaction ID - interaction is read-only
        if (viewChatBtn) {
            viewChatBtn.disabled = true;
            viewChatBtn.style.opacity = '0.5';
            viewChatBtn.style.cursor = 'not-allowed';
        }

        // Show chat view by default for calibration (like audit-view.html)
        const transcriptChatView = document.getElementById('transcriptChatView');
        const transcriptTextView = document.getElementById('transcriptTextView');
        const chatMessagesContainer = document.getElementById('chatMessagesContainer');
        
        if (transcriptChatView && transcriptTextView) {
            // Show chat view by default
            transcriptChatView.style.display = 'flex';
            transcriptTextView.style.display = 'none';
            // Set global flag if available
            if (typeof window !== 'undefined') {
                window.isChatViewActive = true;
            }
        }

        // Load conversation from Intercom if interaction ID exists
        if (sampleAudit.interaction_id) {
            // Show loading state immediately
            if (chatMessagesContainer) {
                chatMessagesContainer.innerHTML = `
                    <div style="text-align: center; padding: 1.2937rem; color: #6b7280;">
                        <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
                    </div>
                `;
            }
            // Wait for the function to be available (it's defined in DOMContentLoaded)
            // Try multiple times to ensure DOMContentLoaded has fired
            let attempts = 0;
            const maxAttempts = 20;
            const checkAndLoad = setInterval(() => {
                attempts++;
                if (window.loadConversationFromIntercom && typeof window.loadConversationFromIntercom === 'function') {
                    clearInterval(checkAndLoad);
                    window.loadConversationFromIntercom(sampleAudit.interaction_id);
                } else if (attempts >= maxAttempts) {
                    clearInterval(checkAndLoad);
                    console.error('loadConversationFromIntercom function not available after waiting');
                    // Auto-fallback to text view on error
                    if (transcriptChatView && transcriptTextView) {
                        transcriptChatView.style.display = 'none';
                        transcriptTextView.style.display = 'flex';
                        if (typeof window !== 'undefined') {
                            window.isChatViewActive = false;
                        }
                    }
                }
            }, 100);
        } else {
            // No interaction ID - auto-fallback to text view with database transcript
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'none';
                transcriptTextView.style.display = 'flex';
                if (typeof window !== 'undefined') {
                    window.isChatViewActive = false;
                }
            }
        }

        // Transcript (read-only - from sample)
        const transcript = document.getElementById('transcript');
        if (transcript) {
            transcript.value = sampleAudit.transcript || '';
            transcript.readOnly = true;
            transcript.style.backgroundColor = '#f3f4f6';
            transcript.style.cursor = 'not-allowed';
        }

        // Pre-status (from sample - read-only)
        const agentPreStatus = document.getElementById('agentPreStatus');
        if (agentPreStatus) {
            agentPreStatus.value = sampleAudit.agent_pre_status || '';
            agentPreStatus.disabled = true;
            agentPreStatus.style.backgroundColor = '#f3f4f6';
            agentPreStatus.style.cursor = 'not-allowed';
        }

        // Audit type (from sample - read-only)
        const auditType = document.getElementById('auditType');
        if (auditType) {
            auditType.value = sampleAudit.audit_type || '';
            auditType.disabled = true;
            auditType.style.backgroundColor = '#f3f4f6';
            auditType.style.cursor = 'not-allowed';
        }

        // Validation status (read-only - always Validated for calibration)
        const validationStatus = document.getElementById('validationStatus');
        if (validationStatus) {
            validationStatus.value = 'Validated';
            validationStatus.disabled = true;
            validationStatus.style.backgroundColor = '#f3f4f6';
            validationStatus.style.cursor = 'not-allowed';
        }

        // Scorecard select (read-only - already selected) - check if it's in header
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect) {
            scorecardSelect.disabled = true;
            // Check if scorecard is in header (green background section)
            const headerElement = document.getElementById('auditFormHeader');
            if (headerElement && headerElement.contains(scorecardSelect)) {
                scorecardSelect.style.backgroundColor = 'transparent';
                scorecardSelect.style.color = 'white';
                scorecardSelect.style.opacity = '0.9';
            } else {
                scorecardSelect.style.backgroundColor = '#f3f4f6';
            }
            scorecardSelect.style.cursor = 'not-allowed';
        }

        // Populate error parameters (these are editable - participant scores them)
        // Don't pre-populate - let participant score fresh
        if (currentParameters && currentParameters.length > 0) {
            currentParameters.forEach(param => {
                if (param.field_type === 'radio') {
                    const radioYes = document.getElementById(`${param.field_id}_yes`);
                    const radioNo = document.getElementById(`${param.field_id}_no`);
                    if (radioYes) radioYes.checked = false;
                    if (radioNo) radioNo.checked = false;
                } else {
                    const field = document.getElementById(param.field_id);
                    if (field) {
                        field.value = 0;
                    }
                }
                
                // Clear feedback (participant provides their own)
                const feedbackField = document.getElementById(`feedback_${param.field_id}`);
                if (feedbackField) {
                    feedbackField.value = '';
                }
            });
        }

        // Initialize score calculation
        if (typeof calculateAverageScore === 'function') {
            calculateAverageScore();
        }

        console.log('Calibration form populated with sample audit data');

    } catch (error) {
        console.error('Error populating calibration form:', error);
    }
}

// Load ATA original audit and populate form
async function loadATAOriginalAudit() {
    try {
        if (!isATAMode || !ataAuditId || !ataTableName) {
            console.error('Missing ATA parameters');
            alert('Missing ATA review parameters. Please go back and try again.');
            return;
        }

        console.log('Loading ATA original audit...');

        // Load the original audit from database
        const { data, error: auditError } = await window.supabaseClient
            .from(ataTableName)
            .select('*')
            .eq('id', ataAuditId)
            .single();

        if (auditError || !data) {
            alert('Error loading original audit: ' + (auditError?.message || 'Audit not found'));
            return;
        }

        // Store original audit data for comparison
        originalAuditData = data;

        // Get scorecard info
        if (ataScorecardId) {
            const { data: scorecardData, error: scorecardError } = await window.supabaseClient
                .from('scorecards')
                .select('*')
                .eq('id', ataScorecardId)
                .single();

            if (!scorecardError && scorecardData) {
                currentScorecard = scorecardData;
            }
        }

        // Show the audit form modal
        const auditFormModal = document.getElementById('auditFormModal');
        if (auditFormModal) {
            auditFormModal.style.display = 'flex';
        }

        // Hide pending audits section
        const pendingAuditsSection = document.getElementById('pendingAuditsSection');
        if (pendingAuditsSection) {
            pendingAuditsSection.style.display = 'none';
        }

        // Update header to indicate ATA mode
        const formHeader = document.getElementById('auditFormHeader');
        const scorecardDisplay = document.getElementById('formScorecardDisplay');
        if (formHeader && scorecardDisplay) {
            const h2 = formHeader.querySelector('h2');
            if (h2) h2.textContent = 'Audit The Auditor (ATA) Review';
            scorecardDisplay.innerHTML = '<svg style="width: 0.5659rem; height: 0.5659rem; display: inline-block; vertical-align: middle; margin-right: 0.2425rem;" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg> ATA Review Mode';
        }
        
        // Update page title
        document.title = 'ATA Review | QMS';
        const pageHeading = document.querySelector('.page-heading');
        if (pageHeading) {
            pageHeading.textContent = 'Audit The Auditor (ATA) Review';
        }

        // Populate form with original audit data (read-only for some fields)
        await populateFormWithATAOriginal(data);

        // Start timer
        if (window.resetTimer && window.startTimer) {
            window.resetTimer();
            window.startTimer();
        }

        // Show timer
        const auditTimer = document.getElementById('auditTimer');
        if (auditTimer) {
            auditTimer.style.display = 'flex';
        }

    } catch (error) {
        console.error('Error loading ATA original audit:', error);
        alert('Error loading ATA original audit: ' + error.message);
    }
}

// Populate form with ATA original audit (make certain fields read-only, allow re-scoring)
async function populateFormWithATAOriginal(originalAudit) {
    try {
        // First, ensure employees are loaded
        await loadEmployees();
        
        // Load scorecard parameters
        if (ataScorecardId) {
            await loadScorecardParameters(ataScorecardId);
            // Wait for parameters to render
            await new Promise(resolve => setTimeout(resolve, 300));
        }
        
        // Employee name dropdown (read-only - from original audit)
        const employeeSelect = document.getElementById('employeeName');
        if (employeeSelect && originalAudit.employee_email) {
            for (let i = 0; i < employeeSelect.options.length; i++) {
                if (employeeSelect.options[i].dataset.email === originalAudit.employee_email) {
                    employeeSelect.selectedIndex = i;
                    break;
                }
            }
            employeeSelect.disabled = true;
            employeeSelect.style.backgroundColor = 'transparent';
            employeeSelect.style.color = 'white';
            employeeSelect.style.cursor = 'not-allowed';
            employeeSelect.style.opacity = '0.9';
        }

        // Employee information (read-only - from original audit)
        const employeeEmail = document.getElementById('employeeEmail');
        const employeeType = document.getElementById('employeeType');
        const employeeDepartment = document.getElementById('employeeDepartment');
        const countryOfEmployee = document.getElementById('countryOfEmployee');

        if (employeeEmail) {
            employeeEmail.value = originalAudit.employee_email || '';
            employeeEmail.readOnly = true;
            employeeEmail.style.backgroundColor = 'transparent';
            employeeEmail.style.color = 'white';
            employeeEmail.style.cursor = 'not-allowed';
            employeeEmail.style.opacity = '0.9';
        }

        if (employeeType) {
            employeeType.value = originalAudit.employee_type || '';
            employeeType.readOnly = true;
            employeeType.style.backgroundColor = 'transparent';
            employeeType.style.color = 'white';
            employeeType.style.cursor = 'not-allowed';
            employeeType.style.opacity = '0.9';
        }

        if (employeeDepartment) {
            employeeDepartment.value = originalAudit.employee_department || '';
            employeeDepartment.readOnly = true;
            employeeDepartment.style.backgroundColor = 'transparent';
            employeeDepartment.style.color = 'white';
            employeeDepartment.style.cursor = 'not-allowed';
            employeeDepartment.style.opacity = '0.9';
        }

        if (countryOfEmployee) {
            countryOfEmployee.value = originalAudit.country_of_employee || '';
            countryOfEmployee.disabled = true;
            countryOfEmployee.style.backgroundColor = 'transparent';
            countryOfEmployee.style.color = 'white';
            countryOfEmployee.style.cursor = 'not-allowed';
            countryOfEmployee.style.opacity = '0.9';
        }

        // Interaction details (read-only - from original audit)
        const interactionId = document.getElementById('interactionId');
        const interactionDate = document.getElementById('interactionDate');
        const channel = document.getElementById('channel');
        const clientEmail = document.getElementById('clientEmail');

        if (interactionId) {
            interactionId.value = originalAudit.interaction_id || '';
            interactionId.readOnly = true;
            interactionId.style.backgroundColor = 'transparent';
            interactionId.style.color = 'white';
            interactionId.style.cursor = 'not-allowed';
            interactionId.style.opacity = '0.9';
        }

        if (interactionDate) {
            interactionDate.value = originalAudit.interaction_date || '';
            interactionDate.readOnly = true;
            interactionDate.style.backgroundColor = 'transparent';
            interactionDate.style.color = 'white';
            interactionDate.style.cursor = 'not-allowed';
            interactionDate.style.opacity = '0.9';
        }

        if (channel) {
            channel.value = originalAudit.channel || '';
            channel.disabled = true;
            channel.style.backgroundColor = 'transparent';
            channel.style.color = 'white';
            channel.style.cursor = 'not-allowed';
            channel.style.opacity = '0.9';
        }

        if (clientEmail) {
            clientEmail.value = originalAudit.client_email || '';
            clientEmail.readOnly = true;
            clientEmail.style.backgroundColor = 'transparent';
            clientEmail.style.color = 'white';
            clientEmail.style.cursor = 'not-allowed';
            clientEmail.style.opacity = '0.9';
        }

        // Audit type and validation (read-only)
        const auditType = document.getElementById('auditType');
        const validationStatus = document.getElementById('validationStatus');

        if (auditType) {
            auditType.value = originalAudit.audit_type || '';
            auditType.disabled = true;
            auditType.style.backgroundColor = 'transparent';
            auditType.style.color = 'white';
            auditType.style.cursor = 'not-allowed';
            auditType.style.opacity = '0.9';
        }

        if (validationStatus) {
            validationStatus.value = 'Validated';
            validationStatus.disabled = true;
            validationStatus.style.backgroundColor = '#f3f4f6';
            validationStatus.style.cursor = 'not-allowed';
        }

        // Pre/post status (read-only)
        const agentPreStatus = document.getElementById('agentPreStatus');
        const agentPostStatus = document.getElementById('agentPostStatus');

        if (agentPreStatus) {
            agentPreStatus.value = originalAudit.agent_pre_status || '';
            agentPreStatus.disabled = true;
            agentPreStatus.style.backgroundColor = 'transparent';
            agentPreStatus.style.color = 'white';
            agentPreStatus.style.cursor = 'not-allowed';
            agentPreStatus.style.opacity = '0.9';
        }

        if (agentPostStatus) {
            agentPostStatus.value = originalAudit.agent_post_status || '';
            agentPostStatus.disabled = true;
            agentPostStatus.style.backgroundColor = 'transparent';
            agentPostStatus.style.color = 'white';
            agentPostStatus.style.cursor = 'not-allowed';
            agentPostStatus.style.opacity = '0.9';
        }

        // Transcript (read-only - supervisor reviews the same conversation)
        const transcript = document.getElementById('transcript');
        if (transcript) {
            transcript.value = originalAudit.transcript || '';
            transcript.readOnly = true;
            transcript.style.backgroundColor = '#f3f4f6';
            transcript.style.cursor = 'not-allowed';
        }

        // Scorecard select (read-only - already selected)
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect) {
            scorecardSelect.disabled = true;
            const headerElement = document.getElementById('auditFormHeader');
            if (headerElement && headerElement.contains(scorecardSelect)) {
                scorecardSelect.style.backgroundColor = 'transparent';
                scorecardSelect.style.color = 'white';
                scorecardSelect.style.opacity = '0.9';
            } else {
                scorecardSelect.style.backgroundColor = '#f3f4f6';
            }
            scorecardSelect.style.cursor = 'not-allowed';
        }

        // Error parameters (EDITABLE - supervisor re-scores)
        // Pre-populate with original values so supervisor can see what was scored
        // Supervisor can then change them as needed
        if (currentParameters && currentParameters.length > 0) {
            currentParameters.forEach(param => {
                const originalValue = originalAudit[param.field_id] || 0;
                
                if (param.field_type === 'radio') {
                    const radioYes = document.getElementById(`${param.field_id}_yes`);
                    const radioNo = document.getElementById(`${param.field_id}_no`);
                    if (radioYes && radioNo) {
                        // Radio buttons: 1 = yes, 0 = no
                        if (originalValue === 1 || originalValue === '1') {
                            radioYes.checked = true;
                        } else {
                            radioNo.checked = true;
                        }
                    }
                } else {
                    const field = document.getElementById(param.field_id);
                    if (field) {
                        field.value = originalValue;
                    }
                }
                
                // Pre-populate feedback from original audit (supervisor can modify)
                const feedbackKey = `feedback_${param.field_id}`;
                const originalFeedback = originalAudit[feedbackKey];
                const feedbackField = document.getElementById(feedbackKey);
                if (feedbackField && originalFeedback) {
                    if (Array.isArray(originalFeedback)) {
                        feedbackField.value = originalFeedback.join('\n');
                    } else if (typeof originalFeedback === 'string') {
                        feedbackField.value = originalFeedback;
                    }
                }
            });
        }

        // Initialize score calculation
        if (typeof calculateAverageScore === 'function') {
            calculateAverageScore();
        }

        console.log('ATA form populated with original audit data');

    } catch (error) {
        console.error('Error populating ATA form:', error);
    }
}

// Save ATA review result
async function saveATAResult(auditPayload, auditData) {
    try {
        // Get current user info (supervisor)
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const supervisorEmail = userInfo.email || '';
        const supervisorName = userInfo.name || '';

        if (!originalAuditData) {
            throw new Error('Original audit data not found');
        }

        // Calculate accuracy score (how close supervisor's score is to original)
        // Accuracy = 100 - |supervisor_score - original_score|
        const originalScore = parseFloat(originalAuditData.average_score) || 0;
        const supervisorScore = parseFloat(auditPayload.average_score) || 0;
        const scoreDifference = Math.abs(supervisorScore - originalScore);
        const accuracyScore = Math.max(0, 100 - scoreDifference);

        // Calculate discrepancies (differences between original and supervisor's review)
        const discrepancies = {
            score_difference: (supervisorScore - originalScore).toFixed(2),
            passing_status_changed: originalAuditData.passing_status !== auditPayload.passing_status,
            parameter_differences: {}
        };

        // Compare parameter values
        if (currentParameters && currentParameters.length > 0) {
            currentParameters.forEach(param => {
                const originalValue = originalAuditData[param.field_id] || 0;
                const supervisorValue = auditPayload[param.field_id] || 0;
                
                if (originalValue !== supervisorValue) {
                    discrepancies.parameter_differences[param.field_id] = {
                        original: originalValue,
                        supervisor: supervisorValue,
                        difference: supervisorValue - originalValue
                    };
                }
            });
        }

        // Get scorecard passing threshold
        let passingThreshold = 85;
        if (currentScorecard && currentScorecard.passing_threshold) {
            passingThreshold = parseFloat(currentScorecard.passing_threshold);
        }

        // Determine passing status based on supervisor's score
        const ataPassingStatus = supervisorScore >= passingThreshold ? 'Passing' : 'Not Passing';

        // Generate ID for ATA review
        const ataReviewId = `ata_${ataAuditId}_${Date.now()}`;

        const ataReview = {
            id: ataReviewId,
            audit_id: ataAuditId,
            audit_table_name: ataTableName,
            scorecard_id: ataScorecardId || null,
            
            // Original audit information (denormalized)
            original_auditor_email: originalAuditData.auditor_email || null,
            original_auditor_name: originalAuditData.auditor_name || null,
            original_employee_email: originalAuditData.employee_email || null,
            original_employee_name: originalAuditData.employee_name || null,
            original_interaction_id: originalAuditData.interaction_id || null,
            original_score: originalScore,
            original_passing_status: originalAuditData.passing_status || null,
            original_submitted_at: originalAuditData.submitted_at || null,
            
            // Supervisor who performed the ATA review
            supervisor_email: supervisorEmail,
            supervisor_name: supervisorName,
            
            // ATA review results
            ata_review_score: supervisorScore,
            ata_passing_status: ataPassingStatus,
            ata_accuracy_score: parseFloat(accuracyScore.toFixed(2)),
            discrepancies: discrepancies,
            feedback: auditPayload.recommendations || null,
            
            // Review metadata
            reviewed_at: new Date().toISOString()
        };

        console.log('Saving ATA review:', ataReview);

        const { data, error } = await window.supabaseClient
            .from('ata_reviews')
            .insert([ataReview])
            .select();

        if (error) throw error;

        console.log('ATA review saved successfully:', data);

        await window.confirmationDialog.show({
            title: 'ATA Review Submitted!',
            message: `Your ATA review has been submitted successfully. Accuracy Score: ${accuracyScore.toFixed(2)}%`,
            confirmText: 'OK',
            type: 'success'
        });

        // Close the form
        closeAuditForm();

        // Redirect back to ATA page
        window.location.href = 'ata.html';

    } catch (error) {
        console.error('Error saving ATA review:', error);
        await window.confirmationDialog.show({
            title: 'Submission Error',
            message: 'Failed to submit ATA review: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// Audit Form Submission Handler

document.addEventListener('DOMContentLoaded', function() {
    // Header dropdown functionality
    const headerDropdownBtn = document.getElementById('headerDropdownBtn');
    const headerDropdownMenu = document.getElementById('headerDropdownMenu');
    const headerDropdownIcon = document.getElementById('headerDropdownIcon');
    
    if (headerDropdownBtn && headerDropdownMenu) {
        // Toggle dropdown on button click
        headerDropdownBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            const isHidden = headerDropdownMenu.classList.contains('hidden');
            
            if (isHidden) {
                headerDropdownMenu.classList.remove('hidden');
                if (headerDropdownIcon) {
                    headerDropdownIcon.style.transform = 'rotate(180deg)';
                }
            } else {
                headerDropdownMenu.classList.add('hidden');
                if (headerDropdownIcon) {
                    headerDropdownIcon.style.transform = 'rotate(0deg)';
                }
            }
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!headerDropdownBtn.contains(e.target) && !headerDropdownMenu.contains(e.target)) {
                headerDropdownMenu.classList.add('hidden');
                if (headerDropdownIcon) {
                    headerDropdownIcon.style.transform = 'rotate(0deg)';
                }
            }
        });
    }
    
    // Helper function to copy conversation ID
    window.copyConversationId = function() {
        const interactionId = document.getElementById('interactionId');
        if (interactionId && interactionId.value) {
            navigator.clipboard.writeText(interactionId.value).then(() => {
                showNotification('Conversation ID copied to clipboard!', 'success');
            }).catch(() => {
                showNotification('Failed to copy Conversation ID', 'error');
            });
        } else {
            showNotification('No Conversation ID available', 'error');
        }
    };
    
    // Helper function to copy client email
    window.copyClientEmail = function() {
        const clientEmail = document.getElementById('clientEmail');
        if (clientEmail && clientEmail.value) {
            navigator.clipboard.writeText(clientEmail.value).then(() => {
                showNotification('Client email copied to clipboard!', 'success');
            }).catch(() => {
                showNotification('Failed to copy client email', 'error');
            });
        } else {
            showNotification('No client email available', 'error');
        }
    };
    console.log('DOMContentLoaded fired');
    
    // Check page access using centralized access control
    if (!window.accessControl || !window.accessControl.enforcePageAccess('create-audit.html')) {
        return; // Access denied, user will be redirected
    }
    
    // Initialize form immediately - the submit handler will wait for Supabase
    initializeForm();
    
    function initializeForm() {
        // Check if user is an Employee and hide create manual audit button
        try {
            const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
            const userRole = userInfo.role || '';
            
            if (userRole === 'Employee') {
                const createManualAuditBtn = document.getElementById('createManualAuditBtn');
                if (createManualAuditBtn) {
                    createManualAuditBtn.style.display = 'none';
                }
            }
        } catch (error) {
            console.error('Error checking user role for button visibility:', error);
        }
        
        const auditForm = document.getElementById('auditForm');
        const cancelBtn = document.getElementById('cancelBtn');
        const employeeSelect = document.getElementById('employeeName');
        const employeeEmail = document.getElementById('employeeEmail');
        const employeeType = document.getElementById('employeeType');
        const countryOfEmployee = document.getElementById('countryOfEmployee');
        
        if (!auditForm) {
            console.error('auditForm element not found!');
            window.confirmationDialog.show({
                title: 'Form Error',
                message: 'Error: Form element not found! Please refresh the page.',
                confirmText: 'Refresh',
                cancelText: 'OK',
                type: 'error'
            });
            return;
        }
        
        console.log('Form element found:', auditForm);
        
        // Load scorecards when page loads
        loadScorecards();
        
        // Initialize sort dropdown
        const sortBy = document.getElementById('auditSortBy');
        if (sortBy) {
            sortBy.value = currentSortOrder;
        }
        
        // Load pending audits when page loads (all assigned audits)
        loadPendingAudits();
        
        // Initialize date selector for pull conversations
        const pullConversationsDateInput = document.getElementById('pullConversationsDate');
        if (pullConversationsDateInput) {
            pullConversationsDateInput.addEventListener('change', async function() {
                if (pullConversationsAdminId && this.value) {
                    await fetchConversationsForCurrentUser(this.value);
                }
            });
        }

        // Setup tooltip positioning for all column headers
        function setupColumnTooltips() {
            const tooltipContainers = document.querySelectorAll('.column-tooltip-container');
            tooltipContainers.forEach(container => {
                const infoIcon = container.querySelector('.info-icon');
                const tooltip = container.querySelector('.column-tooltip');
                
                if (infoIcon && tooltip) {
                    // Remove existing listeners by cloning
                    const newInfoIcon = infoIcon.cloneNode(true);
                    const newTooltip = tooltip.cloneNode(true);
                    infoIcon.parentNode.replaceChild(newInfoIcon, infoIcon);
                    tooltip.parentNode.replaceChild(newTooltip, tooltip);
                    
                    newInfoIcon.addEventListener('mouseenter', function(e) {
                        const rect = newInfoIcon.getBoundingClientRect();
                        
                        // Position tooltip above the icon, aligned to the right
                        let top = rect.top - 10; // Start above, will adjust if needed
                        let left = rect.right - 320; // 20rem = 320px, align right edge
                        
                        // If tooltip would go off screen to the left, align to icon's left edge
                        if (left < 8) {
                            left = rect.left;
                        }
                        
                        // Temporarily show tooltip to measure its height
                        newTooltip.style.position = 'fixed';
                        newTooltip.style.top = '-9999px';
                        newTooltip.style.left = left + 'px';
                        newTooltip.style.opacity = '1';
                        newTooltip.style.visibility = 'visible';
                        const tooltipHeight = newTooltip.offsetHeight;
                        
                        // Now position it correctly above the icon
                        top = rect.top - tooltipHeight - 8;
                        
                        // If tooltip would go off screen to the top, position below instead
                        if (top < 8) {
                            top = rect.bottom + 8;
                        }
                        
                        newTooltip.style.top = top + 'px';
                        newTooltip.style.right = 'auto';
                        newTooltip.style.bottom = 'auto';
                        newTooltip.style.transform = 'none';
                        newTooltip.style.zIndex = '9999';
                    });
                    
                    newInfoIcon.addEventListener('mouseleave', function() {
                        newTooltip.style.opacity = '0';
                        newTooltip.style.visibility = 'hidden';
                    });
                }
            });
        }

        // Setup tooltip after page load
        document.addEventListener('DOMContentLoaded', function() {
            setupColumnTooltips();
        });

        // Also setup after conversations are displayed
        const originalDisplayPullConversationsList = window.displayPullConversationsList;
        if (originalDisplayPullConversationsList) {
            window.displayPullConversationsList = function(conversations) {
                originalDisplayPullConversationsList(conversations);
                setTimeout(setupColumnTooltips, 100);
            };
        }
        
        // Initialize filters
        populateScorecardFilter();
        
        // Add event listener for search input (real-time filtering with debounce)
        const searchInput = document.getElementById('filterSearch');
        if (searchInput) {
            let searchTimeout;
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    applyFilters();
                }, 300); // Debounce search by 300ms
            });
        }
        
        // All other filters (date, status, scorecard) already have onchange="applyFilters()" in HTML
        
        // Load your stats when page loads
        updateYourStats();
        
        // Load employees when page loads
        loadEmployees();
        
        // Check if we're editing an existing audit from URL parameters
        // Wait for dependencies to load: Supabase, scorecards, and employees
        setTimeout(async () => {
            // Ensure scorecards and employees are loaded before editing
            let attempts = 0;
            const maxAttempts = 30; // 3 seconds max wait
            
            while (attempts < maxAttempts) {
                // Check if scorecards dropdown has options (other than the default "Select a scorecard..." option)
                const scorecardSelect = document.getElementById('scorecardSelect');
                const employeeSelect = document.getElementById('employeeName');
                
                const scorecardsLoaded = scorecardSelect && scorecardSelect.options.length > 1;
                const employeesLoaded = employeeSelect && employeeSelect.options.length > 0;
                const supabaseReady = window.supabaseClient;
                
                if (scorecardsLoaded && employeesLoaded && supabaseReady) {
                    console.log('Dependencies loaded, proceeding with edit mode');
                    await loadAuditForEditing();
                    break;
                }
                
                attempts++;
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (attempts >= maxAttempts) {
                console.warn('Timeout waiting for dependencies, attempting to load audit anyway');
                await loadAuditForEditing();
            }
        }, 500); // Start checking after 500ms
        
        // Handle scorecard selection change
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (scorecardSelect) {
            scorecardSelect.addEventListener('change', async function() {
                // Don't clear form if we're in edit mode
                if (isEditingExistingAudit) {
                    return; // Let the edit mode handler manage the scorecard selection
                }
                
                const selectedValue = this.value;
                // Validate before loading to prevent UUID errors
                if (selectedValue && selectedValue !== 'null' && selectedValue !== 'undefined' && selectedValue.trim() !== '') {
                    await loadScorecardParameters(selectedValue);
                    
                    // Update default badge indicator
                    const channelFilter = document.getElementById('channel')?.value;
                    const selectedScorecard = allAvailableScorecards.find(s => s.id === selectedValue);
                    if (selectedScorecard) {
                        updateDefaultScorecardBadge(selectedScorecard, channelFilter);
                    } else {
                        // Remove badge if scorecard not found
                        removeDefaultScorecardBadge();
                    }
                } else {
                    // Clear scorecard info if invalid selection
                    currentScorecard = null;
                    currentParameters = [];
                    document.getElementById('scorecardInfo').style.display = 'none';
                    clearErrorParameters();
                    removeDefaultScorecardBadge();
                }
            });
        }
        
        // Load employees when page loads
        loadEmployees();
        
        // Load channels from users' teams
        loadChannels();
        
        // Handle channel selection change - auto-select matching scorecard
        const channelSelect = document.getElementById('channel');
        if (channelSelect) {
            channelSelect.addEventListener('change', async function() {
                const selectedChannel = this.value;
                if (selectedChannel) {
                    await autoSelectScorecardByChannel(selectedChannel);
                    // Badge will be updated by loadScorecards function
                } else {
                    // If channel is cleared, reload all scorecards
                    await loadScorecards();
                    // Remove badge when channel is cleared
                    removeDefaultScorecardBadge();
                }
            });
            
            // Also trigger on page load if channel is already selected
            if (channelSelect.value) {
                setTimeout(async () => {
                    await autoSelectScorecardByChannel(channelSelect.value);
                }, 500);
            } else {
                // If no channel selected, ensure first scorecard is auto-selected after a delay
                setTimeout(async () => {
                    const scorecardSelect = document.getElementById('scorecardSelect');
                    if (scorecardSelect && (!scorecardSelect.value || scorecardSelect.value === '')) {
                        await loadScorecards();
                    }
                }, 800);
            }
        }
        
        // Handle employee selection change
        employeeSelect.addEventListener('change', function() {
            const selectedOption = this.options[this.selectedIndex];
            
            if (selectedOption && selectedOption.value) {
                // Auto-populate email from the selected employee
                const email = selectedOption.dataset.email || selectedOption.value;
                if (employeeEmail) {
                    employeeEmail.value = email;
                }
                
                // Auto-populate employee type from designation
                const designation = selectedOption.dataset.designation || '';
                if (employeeType && designation) {
                    employeeType.value = designation;
                }
                
                // Auto-populate department from selected employee
                const department = selectedOption.dataset.department || '';
                const employeeDepartment = document.getElementById('employeeDepartment');
                if (employeeDepartment) {
                    employeeDepartment.value = department;
                }
                
                // Auto-populate country from selected employee
                const country = selectedOption.dataset.country || '';
                if (countryOfEmployee && country) {
                    countryOfEmployee.value = country;
                }
                
                // Auto-populate channel from selected employee
                const channel = selectedOption.dataset.channel || '';
                const channelSelect = document.getElementById('channel');
                if (channelSelect && channel) {
                    // Check if the channel exists in the dropdown
                    const channelExists = Array.from(channelSelect.options).some(
                        opt => opt.value === channel
                    );
                    if (channelExists) {
                        channelSelect.value = channel;
                        // Trigger change event to auto-select matching scorecard
                        channelSelect.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }
            } else {
                // Clear fields if no employee selected
                if (employeeEmail) {
                    employeeEmail.value = '';
                }
                if (employeeType) {
                    employeeType.value = '';
                }
                const employeeDepartment = document.getElementById('employeeDepartment');
                if (employeeDepartment) {
                    employeeDepartment.value = '';
                }
                if (countryOfEmployee) {
                    countryOfEmployee.value = '';
                }
                // Clear channel field
                const channelSelect = document.getElementById('channel');
                if (channelSelect) {
                    channelSelect.value = '';
                    // Trigger change event to reload scorecards without channel filter
                    channelSelect.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }
        });
        
        // Load user data when page loads
        loadUserData();
        
        // Update week and quarter when page loads
        updateWeekAndQuarter();
        
        // Refresh user data when window gains focus (in case user data was updated)
        window.addEventListener('focus', function() {
            loadUserData();
            updateWeekAndQuarter();
        });
        
        // Handle form submission
        console.log('Setting up form submission handler...');
        
        // Also add click handler to submit button for debugging
        const submitBtn = auditForm.querySelector('button[type="submit"]');
        if (submitBtn) {
            console.log('Submit button found:', submitBtn);
            submitBtn.addEventListener('click', function(e) {
                console.log('Submit button clicked!');
            });
        } else {
            console.log('Submit button not found');
        }
        
        console.log('Attaching submit event listener to form...');
        
        // Guard to prevent duplicate submissions
        let isSubmitting = false;
        
        // Handler function
        const handleSubmit = async function(e) {
            console.log('DEBUG: Form submit event fired!'); // Debug log only
            console.log('Submit event fired! Event object:', e);
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            // Prevent duplicate submissions
            if (isSubmitting) {
                console.log('Submission already in progress, ignoring duplicate submit event');
                return;
            }
            
            isSubmitting = true;
            
            console.log('===== FORM SUBMISSION STARTED =====');
            
            // Validate scorecard selection
            if (!currentScorecard || !currentParameters || currentParameters.length === 0) {
                await window.confirmationDialog.show({
                    title: 'No Scorecard Selected',
                    message: 'Please select a scorecard before submitting the audit.',
                    confirmText: 'OK',
                    type: 'warning'
                });
                isSubmitting = false;
                return;
            }
            
            // Wait for Supabase client to be ready (maximum 5 seconds)
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds with 100ms intervals
            while (!window.supabaseClient && attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (!window.supabaseClient) {
                await window.confirmationDialog.show({
                    title: 'Initialization Error',
                    message: 'Supabase client not initialized. Please refresh the page and try again.',
                    confirmText: 'Refresh Page',
                    cancelText: 'OK',
                    type: 'error'
                });
                console.error('Supabase client not available after waiting');
                isSubmitting = false;
                return;
            }
            
            console.log('Supabase client is ready');
            console.log('Saving to table:', currentScorecard.table_name);
            
            // Update week and quarter based on current date
            updateWeekAndQuarter();
            
            // Auto-populate Error Description from individual feedback fields
            populateErrorDescription();
            
            // Update audit duration from timer before collecting form data
            if (window.updateAuditDuration) {
                window.updateAuditDuration();
            }
            
            // Sync chat messages to textarea before form submission (if chat view is active)
            const chatMessagesContainer = document.getElementById('chatMessagesContainer');
            const transcriptTextarea = document.getElementById('transcript');
            if (chatMessagesContainer && transcriptTextarea && chatMessagesContainer.children.length > 0) {
                syncChatMessagesToTextarea();
            }
            
            // Collect all form data
            const formData = new FormData(auditForm);
            const auditData = {};
            
            // Convert FormData to object
            for (let [key, value] of formData.entries()) {
                auditData[key] = value;
            }
            
            // Log audit duration for debugging
            const auditDurationField = document.getElementById('auditDuration');
            if (auditDurationField) {
                console.log('Audit duration from timer (seconds):', auditDurationField.value);
            }
            
            console.log('Form validation completed');
            
            // Validate interaction ID is provided
            const interactionIdField = document.getElementById('interactionId');
            if (!interactionIdField || !interactionIdField.value || !interactionIdField.value.trim()) {
                await window.confirmationDialog.show({
                    title: 'Validation Error',
                    message: 'Interaction ID is required. Please enter an Interaction ID before submitting.',
                    confirmText: 'OK',
                    type: 'error'
                });
                if (interactionIdField) {
                    interactionIdField.focus();
                }
                isSubmitting = false;
                return;
            }
            
            // Validate feedback fields when error count > 0
            let validationErrors = [];
            currentParameters.forEach(param => {
                // Get error count for this parameter
                let errorCount = 0;
                if (param.field_type === 'radio') {
                    const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
                    if (selectedRadio) {
                        const value = parseInt(selectedRadio.value) || 0;
                        const paramType = param.parameter_type || 'error';
                        if (paramType === 'achievement' || paramType === 'bonus') {
                            errorCount = value === 0 ? 1 : 0;
                        } else {
                            errorCount = value;
                        }
                    }
                } else {
                    const field = document.getElementById(param.field_id);
                    errorCount = field ? (parseInt(field.value) || 0) : 0;
                }
                
                // If error count > 0, validate that all feedback boxes are filled
                if (errorCount > 0) {
                    const feedbackCount = Math.min(errorCount, 10);
                    for (let i = 0; i < feedbackCount; i++) {
                        const feedbackId = `feedback_${param.field_id}_${i}`;
                        const feedbackField = document.getElementById(feedbackId);
                        if (!feedbackField || !feedbackField.value || !feedbackField.value.trim()) {
                            validationErrors.push(`Feedback is required for "${param.error_name}" (Feedback ${i + 1} of ${feedbackCount})`);
                            if (feedbackField) {
                                feedbackField.style.borderColor = '#ef4444';
                                feedbackField.focus();
                            }
                        }
                    }
                }
            });
            
            // If there are validation errors, show them and stop submission
            if (validationErrors.length > 0) {
                await window.confirmationDialog.show({
                    title: 'Validation Error',
                    message: 'Please fill in all required feedback fields:\n\n' + validationErrors.slice(0, 5).join('\n') + (validationErrors.length > 5 ? `\n... and ${validationErrors.length - 5} more` : ''),
                    confirmText: 'OK',
                    type: 'error'
                });
                isSubmitting = false;
                return;
            }
            
            // Explicitly handle dynamic parameter fields (counters and radio buttons)
            currentParameters.forEach(param => {
                if (param.field_type === 'radio') {
                    // For radio buttons, get the selected value
                    const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
                    auditData[param.field_id] = selectedRadio ? parseInt(selectedRadio.value) : 0;
                } else {
                    // For counters, store the numeric value
                    const field = document.getElementById(param.field_id);
                    auditData[param.field_id] = field ? (parseInt(field.value) || 0) : 0;
                }
                
                // Collect all feedback boxes for this parameter as an array
                const feedbacks = [];
                const feedbackContainer = document.getElementById(`feedback_container_${param.field_id}`);
                if (feedbackContainer) {
                    const feedbackTextareas = feedbackContainer.querySelectorAll(`textarea[id^="feedback_${param.field_id}_"]`);
                    feedbackTextareas.forEach(textarea => {
                        if (textarea.value && textarea.value.trim()) {
                            feedbacks.push(textarea.value.trim());
                        }
                    });
                }
                auditData[`feedback_${param.field_id}`] = feedbacks.length > 0 ? feedbacks : null;
            });
            
            // Update employeeName with the actual name from the selected option
            const selectedEmployeeOption = employeeSelect.options[employeeSelect.selectedIndex];
            if (selectedEmployeeOption && selectedEmployeeOption.textContent) {
                auditData.employeeName = selectedEmployeeOption.textContent;
            }
            
            // Ensure auditorName is populated (from hidden field)
            const auditorNameField = document.getElementById('auditorName');
            if (auditorNameField && auditorNameField.value) {
                auditData.auditorName = auditorNameField.value;
            }
            
            // Ensure quarter and week are included
            const quarterField = document.getElementById('quarter');
            if (quarterField && quarterField.value) {
                auditData.quarter = quarterField.value;
            }
            
            const weekField = document.getElementById('week');
            if (weekField && weekField.value) {
                auditData.week = weekField.value;
            }
            
            // Add unique ID and submission timestamp
            auditData.id = 'audit_' + Date.now();
            auditData.submittedAt = new Date().toISOString();
            
            // FIXED: Recalculate passing status right before saving to ensure is_fail_all is checked
            const finalScore = parseFloat(auditData.averageScore) || 0;
            const threshold = currentScorecard ? parseFloat(currentScorecard.passing_threshold) : 85;
            
            // Check if any "fail all" parameters have errors
            let hasFailAllError = false;
            currentParameters.forEach(param => {
                if (param.is_fail_all) {
                    const paramType = param.parameter_type || 'error';
                    const fieldValue = auditData[param.field_id];
                    let errorCount = 0;
                    
                    if (param.field_type === 'radio') {
                        errorCount = fieldValue ? parseInt(fieldValue) : 0;
                    } else {
                        errorCount = fieldValue ? parseInt(fieldValue) : 0;
                    }
                    
                    if (errorCount > 0) {
                        hasFailAllError = true;
                    }
                }
            });
            
            // Set passing status based on fail-all errors first, then score
            if (hasFailAllError) {
                auditData.passingStatus = 'Not Passing';
            } else if (finalScore >= threshold) {
                auditData.passingStatus = 'Passing';
            } else {
                auditData.passingStatus = 'Not Passing';
            }
            
            // Capture audit start and end timestamps
            // For editing existing audits, preserve original start time if it exists
            let auditStartTime = null;
            if (isEditingExistingAudit && currentEditingAuditId && currentEditingTableName) {
                // When editing, try to preserve original start time from database
                // We'll fetch it if not already restored, otherwise use restored value
                auditStartTime = window.getAuditStartTimestamp ? window.getAuditStartTimestamp() : null;
                // If still null and we're editing, it means we didn't restore it, so it will remain null
                // (we should preserve the original from the database in the update, but for now let's use restored value or current)
            } else {
                // For new audits, use the captured start timestamp
                auditStartTime = window.getAuditStartTimestamp ? window.getAuditStartTimestamp() : null;
            }
            const auditEndTime = new Date().toISOString();
            
            console.log('All form data keys:', Object.keys(auditData));
            console.log('Audit data to be saved:', auditData);
            console.log('Audit start time:', auditStartTime);
            console.log('Audit end time:', auditEndTime);
            
            // Save to Supabase
            console.log('Saving to Supabase...');
            
            try {
                // Build base payload
                // The hidden field stores duration in seconds as integer, but FormData converts it to string
                let auditDurationSeconds = null;
                if (auditData.auditDuration && auditData.auditDuration !== '' && auditData.auditDuration !== 'null' && auditData.auditDuration !== null) {
                    // The hidden field contains seconds as integer, but FormData makes it a string
                    // So we parse it as integer (already in seconds)
                    const parsed = parseInt(auditData.auditDuration);
                    if (!isNaN(parsed) && parsed >= 0) {
                        auditDurationSeconds = parsed; // Already in seconds
                    } else {
                        // Fallback: if somehow we got a time string or minutes, try to convert it
                        if (window.convertDurationToMinutes) {
                            const minutes = window.convertDurationToMinutes(auditData.auditDuration);
                            if (minutes !== null && !isNaN(minutes)) {
                                auditDurationSeconds = minutes * 60; // Convert minutes to seconds
                            }
                        }
                    }
                    // Final validation: ensure it's a valid non-negative integer
                    if (auditDurationSeconds !== null && (isNaN(auditDurationSeconds) || auditDurationSeconds < 0)) {
                        auditDurationSeconds = null;
                    }
                }
                
                const auditPayload = {
                    id: auditData.id,
                    submitted_at: auditData.submittedAt,
                    audit_start_time: auditStartTime,
                    audit_end_time: auditEndTime,
                    audit_duration: auditDurationSeconds,
                    auditor_email: auditData.auditorEmail || null,
                    auditor_name: auditData.auditorName || null,
                    employee_name: auditData.employeeName || null,
                    employee_email: auditData.employeeEmail || null,
                    employee_type: auditData.employeeType || null,
                    employee_department: auditData.employeeDepartment || null,
                    interaction_id: auditData.interactionId || null,
                    interaction_date: auditData.interactionDate || null,
                    audit_type: auditData.auditType || null,
                    channel: auditData.channel || null,
                    quarter: auditData.quarter || null,
                    week: auditData.week ? parseInt(auditData.week) : null,
                    country_of_employee: auditData.countryOfEmployee || null,
                    client_email: auditData.clientEmail || null,
                    agent_pre_status: auditData.agentPreStatus || null,
                    agent_post_status: auditData.agentPostStatus || null,
                    passing_status: auditData.passingStatus || null,
                    validation_status: auditData.validationStatus || null,
                    average_score: auditData.averageScore ? parseFloat(auditData.averageScore) : null,
                    critical_errors: auditData.criticalErrors ? parseInt(auditData.criticalErrors) : 0,
                    critical_fail_error: auditData.criticalFailError ? parseInt(auditData.criticalFailError) : 0,
                    significant_error: auditData.significantError ? parseInt(auditData.significantError) : 0,
                    total_errors_count: auditData.totalErrorsCount ? parseInt(auditData.totalErrorsCount) : 0,
                    transcript: auditData.transcript || null,
                    error_description: auditData.errorDescription || null,
                    recommendations: auditData.recommendations || null,
                    // Reversal tracking fields
                    reversal_requested_at: auditData.reversalRequestedAt || null,
                    reversal_responded_at: auditData.reversalRespondedAt || null,
                    sla_in_hours: auditData.slaInHours ? parseFloat(auditData.slaInHours) : null,
                    response_from_auditor: auditData.reasonForReversalResponseDelay || null,
                    reversal_approved: auditData.reversalApproved !== undefined ? auditData.reversalApproved : null,
                    within_auditor_scope: auditData.withinAuditorScope !== undefined ? auditData.withinAuditorScope : null,
                    score_before_appeal: auditData.scoreBeforeAppeal ? parseFloat(auditData.scoreBeforeAppeal) : null,
                    score_after_appeal: auditData.scoreAfterAppeal ? parseFloat(auditData.scoreAfterAppeal) : null,
                    did_result_in_pass: auditData.didResultInPass !== undefined ? auditData.didResultInPass : null,
                    reversal_type: auditData.reversalType || null,
                    reversal_metrics_parameters: auditData.reversalMetricsParameters || null,
                    reversal_justification_from_agent: auditData.reversalJustificationFromAgent || null,
                    reversal_attachments: auditData.reversalAttachments || null,
                    reversal_approved_by: auditData.reversalApprovedBy || null,
                    reversal_resolved_by: auditData.reversalResolvedBy || null,
                    // Acknowledgement tracking fields
                    acknowledgement_status: auditData.acknowledgementStatus || 'Pending',
                    acknowledgement_status_updated_at: auditData.acknowledgementStatusUpdatedAt || null
                };
                
                // Add dynamic error fields based on currentParameters
                currentParameters.forEach(param => {
                    const fieldValue = auditData[param.field_id];
                    auditPayload[param.field_id] = fieldValue ? parseInt(fieldValue) : 0;
                    
                    // Add feedback field as JSONB array (send array directly, Supabase will handle JSONB conversion)
                    const feedbackKey = `feedback_${param.field_id}`;
                    const feedbackValue = auditData[feedbackKey];
                    // Send array directly if non-empty, null otherwise
                    // Supabase will automatically convert JavaScript arrays to JSONB
                    auditPayload[feedbackKey] = Array.isArray(feedbackValue) && feedbackValue.length > 0 
                        ? feedbackValue 
                        : null;
                });
                
                console.log('Payload to save:', auditPayload);
                console.log('Target table:', currentScorecard.table_name);
                console.log('Is editing pending audit:', isEditingPendingAudit);
                console.log('Current editing audit ID:', currentEditingAuditId);
                console.log('Is calibration mode:', isCalibrationMode);
                console.log('Is ATA mode:', isATAMode);
                
                // If in calibration mode, save to calibration_results instead
                if (isCalibrationMode) {
                    await saveCalibrationResult(auditPayload, auditData);
                    return;
                }
                
                // If in ATA mode, save to ata_reviews instead
                if (isATAMode) {
                    await saveATAResult(auditPayload, auditData);
                    return;
                }
                
                let data, error;
                const wasEditingExistingAudit = isEditingExistingAudit; // Store before resetting
                
                // Helper function to retry database operations on schema cache errors
                async function retryOnSchemaCacheError(operation, maxRetries = 3) {
                    for (let attempt = 0; attempt < maxRetries; attempt++) {
                        if (attempt > 0) {
                            // Wait longer on each retry (exponential backoff)
                            console.log(`Retrying database operation (attempt ${attempt + 1}/${maxRetries})...`);
                            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                        }
                        
                        const result = await operation();
                        
                        // If no error, return success
                        if (!result.error) {
                            return result;
                        }
                        
                        // If it's a schema cache error, retry
                        if (result.error.message && result.error.message.includes('schema cache')) {
                            console.log(`Schema cache not ready, retrying (attempt ${attempt + 1}/${maxRetries})...`);
                            continue;
                        }
                        
                        // If it's not a schema cache error, return immediately
                        return result;
                    }
                    
                    // Return last result after all retries exhausted
                    return await operation();
                }
                
                // Check if we're editing an existing audit from audit reports
                if (isEditingExistingAudit && currentEditingAuditId && currentEditingTableName) {
                    // UPDATE existing audit record
                    console.log('Updating existing audit from reports...');
                    
                    // Keep the original ID and submitted_at
                    auditPayload.id = currentEditingAuditId;
                    // Don't update submitted_at when editing, keep original
                    delete auditPayload.submitted_at;
                    
                    // For editing, only update audit_start_time if it wasn't previously set
                    // Otherwise preserve the original start time (don't include it in update)
                    // If auditStartTime is null, remove it from payload to preserve existing value
                    if (!auditStartTime) {
                        delete auditPayload.audit_start_time;
                    }
                    // Always update end time and duration when editing
                    
                    const result = await retryOnSchemaCacheError(async () => {
                        return await window.supabaseClient
                            .from(currentEditingTableName)
                            .update(auditPayload)
                            .eq('id', currentEditingAuditId)
                            .select();
                    });
                    
                    data = result.data;
                    error = result.error;
                    
                    if (!error) {
                        console.log('Successfully updated audit from reports:', data);
                        
                        // Reset editing mode
                        isEditingExistingAudit = false;
                        currentEditingAuditId = null;
                        currentEditingTableName = null;
                    }
                    
                } else if (isEditingPendingAudit && currentEditingAuditId) {
                    // UPDATE existing pending audit record
                    console.log('Updating existing pending audit...');
                    
                    // Update validation status to 'Validated' when completing the audit
                    auditPayload.validation_status = 'Validated';
                    auditPayload.submitted_at = new Date().toISOString();
                    
                    const result = await retryOnSchemaCacheError(async () => {
                        return await window.supabaseClient
                            .from(currentScorecard.table_name)
                            .update(auditPayload)
                            .eq('id', currentEditingAuditId)
                            .select();
                    });
                    
                    data = result.data;
                    error = result.error;
                    
                    if (!error) {
                        console.log('Successfully updated pending audit:', data);
                        
                        // If this was from an audit assignment, mark it as completed
                        if (isEditingPendingAudit && currentEditingAuditId) {
                            try {
                                const { data: updateData, error: assignmentError } = await window.supabaseClient
                                    .from('audit_assignments')
                                    .update({ 
                                        status: 'completed',
                                        completed_at: new Date().toISOString()
                                    })
                                    .eq('id', currentEditingAuditId)
                                    .select();
                                
                                if (assignmentError) {
                                    console.error('Error marking assignment as completed:', assignmentError);
                                } else {
                                    console.log('Successfully marked assignment as completed:', updateData);
                                }
                            } catch (assignmentError) {
                                console.error('Exception marking assignment as completed:', assignmentError);
                                // Don't fail the audit submission if marking as completed fails
                            }
                        }
                        
                        // Reset editing mode
                        isEditingPendingAudit = false;
                        currentEditingAuditId = null;
                    }
                    
                } else {
                    // INSERT new audit record
                    console.log('Inserting new audit...');
                    
                    const result = await retryOnSchemaCacheError(async () => {
                        return await window.supabaseClient
                            .from(currentScorecard.table_name)
                            .insert([auditPayload])
                            .select();
                    });
                    
                    data = result.data;
                    error = result.error;
                    
                    if (!error) {
                        console.log('Successfully inserted new audit:', data);
                        
                        // If this was from an audit assignment, mark it as completed
                        if (currentAssignmentId) {
                            try {
                                const { data: updateData, error: assignmentError } = await window.supabaseClient
                                    .from('audit_assignments')
                                    .update({ 
                                        status: 'completed',
                                        completed_at: new Date().toISOString(),
                                        audit_id: auditPayload.id  // Link the completed audit
                                    })
                                    .eq('id', currentAssignmentId)
                                    .select();
                                
                                if (assignmentError) {
                                    console.error('Error marking assignment as completed:', assignmentError);
                                } else {
                                    console.log('Successfully marked assignment as completed:', updateData);
                                }
                            } catch (assignmentError) {
                                console.error('Exception marking assignment as completed:', assignmentError);
                                // Don't fail the audit submission if marking as completed fails
                            }
                        }
                    }
                }
                
                if (error) {
                    console.error('Error saving to Supabase:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    await window.confirmationDialog.show({
                        title: 'Error Saving Audit',
                        message: 'An error occurred while saving the audit: ' + error.message,
                        confirmText: 'OK',
                        cancelText: 'Close',
                        type: 'error'
                    });
                    return;
                }
                
                // Send email notification to the audited employee
                if (data && data[0] && (data[0].employee_email || auditPayload.employee_email)) {
                    try {
                        await sendAuditEmailNotification(data[0], currentScorecard);
                    } catch (emailError) {
                        // Log error but don't fail the audit submission
                        console.error('Error sending email notification:', emailError);
                    }
                }
                
                // Show success message
                const message = wasEditingExistingAudit ? 'Audit updated successfully!' : 'Audit submitted successfully!';
                const confirmed = await window.confirmationDialog.show({
                    title: 'Success!',
                    message: message,
                    confirmText: 'View Reports',
                    cancelText: 'Stay Here',
                    type: 'success'
                });
                
                // Reset form
                auditForm.reset();
                
                // Reset header back to green (passing state)
                const headerElement = document.getElementById('auditFormHeader');
                if (headerElement) {
                    headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
                }
                
                // Hide timer
                const auditTimer = document.getElementById('auditTimer');
                if (auditTimer) {
                    auditTimer.style.display = 'none';
                }
                
                // Reset timer
                if (window.resetTimer) {
                    window.resetTimer();
                }
                
                // Hide form modal, show pending audits section
                const auditFormModal = document.getElementById('auditFormModal');
                if (auditFormModal) {
                    auditFormModal.style.display = 'none';
                }
                
                // Reload pending audits (in case there are more)
                await loadPendingAudits();
                
                // Update stats after submission
                await updateYourStats();
                
                // Redirect to audit reports if user clicked "View Reports"
                if (confirmed) {
                    window.location.href = 'expert-audits.html';
                } else {
                    // Scroll to top to show pending audits
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
                
            } catch (err) {
                console.error('Exception saving to Supabase:', err);
                console.error('Exception stack:', err.stack);
                await window.confirmationDialog.show({
                    title: 'Error Saving Audit',
                    message: 'An error occurred while saving the audit: ' + err.message,
                    confirmText: 'OK',
                    cancelText: 'Close',
                    type: 'error'
                });
            } finally {
                // Always reset the submitting flag
                isSubmitting = false;
            }
        };
        
        // Attach the handler to the form submit event
        auditForm.addEventListener('submit', handleSubmit);
        
        console.log('Event listeners attached successfully');
        
        // Handle cancel button
        cancelBtn.addEventListener('click', async function() {
            const confirmed = await window.confirmationDialog.show({
                title: 'Cancel Audit',
                message: 'Are you sure you want to cancel? All data will be lost.',
                confirmText: 'Cancel Audit',
                cancelText: 'Keep Editing',
                type: 'warning'
            });
            
            if (confirmed) {
                auditForm.reset();
                
                // Reset header back to green (passing state)
                const headerElement = document.getElementById('auditFormHeader');
                if (headerElement) {
                    headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
                }
                
                // Hide timer
                const auditTimer = document.getElementById('auditTimer');
                if (auditTimer) {
                    auditTimer.style.display = 'none';
                }
                
                if (window.resetTimer) {
                    window.resetTimer();
                }
                
                // Reset editing mode and assignment tracking
                isEditingPendingAudit = false;
                currentEditingAuditId = null;
                currentAssignmentId = null;
                isEditingExistingAudit = false;
                currentEditingTableName = null;
                
                // Hide form modal
                const auditFormModal = document.getElementById('auditFormModal');
                if (auditFormModal) {
                    auditFormModal.style.display = 'none';
                }
                
                // Reload and show pending audits
                await loadPendingAudits();
                
                // Update stats
                await updateYourStats();
                
                // Scroll to top to show pending audits
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        });
    } // End of initializeForm()
    
    // Initialize default conversation dates to yesterday on page load
    // Use a small delay to ensure DOM elements are fully ready
    setTimeout(() => {
        setDefaultConversationsDateRange();
    }, 100);
    
    // Check for assignment parameter in URL
    const urlParams = new URLSearchParams(window.location.search);
    const assignmentId = urlParams.get('assignment');
    
    if (assignmentId) {
        // Load the assignment and start the audit
        loadAssignmentFromURL(assignmentId);
    }
}); // End of DOMContentLoaded

// Load assignment from URL parameter and start audit
async function loadAssignmentFromURL(assignmentId) {
    try {
        console.log('Loading assignment from URL:', assignmentId);
        
        // Wait for Supabase to be ready
        let attempts = 0;
        while (!window.supabaseClient && attempts < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }
        
        if (!window.supabaseClient) {
            console.error('Supabase client not initialized');
            alert('Error: Database connection not ready. Please refresh the page.');
            return;
        }
        
        // Load the assignment from database with scorecard info
        const { data: assignment, error } = await window.supabaseClient
            .from('audit_assignments')
            .select(`
                *,
                scorecards:scorecard_id (
                    id,
                    name,
                    table_name
                )
            `)
            .eq('id', assignmentId)
            .single();
        
        if (error) {
            console.error('Error loading assignment:', error);
            alert('Error: Assignment not found. It may have been deleted or you may not have access.');
            // Clean URL
            window.history.replaceState({}, document.title, window.location.pathname);
            return;
        }
        
        if (!assignment) {
            alert('Assignment not found');
            // Clean URL
            window.history.replaceState({}, document.title, window.location.pathname);
            return;
        }
        
        // Check if assignment belongs to current user
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const userRole = userInfo.role || '';
        const isAgent = userRole === 'Employee';
        const currentUserEmail = (userInfo.email || '').toLowerCase().trim();
        
        // For agents, check if they are the employee being audited
        // For auditors, check if they are the auditor
        const assignmentEmployeeEmail = (assignment.employee_email || '').toLowerCase().trim();
        const assignmentAuditorEmail = (assignment.auditor_email || '').toLowerCase().trim();
        const hasPermission = isAgent 
            ? assignmentEmployeeEmail === currentUserEmail
            : assignmentAuditorEmail === currentUserEmail;
        
        if (!hasPermission) {
            alert('You do not have permission to access this assignment.');
            // Clean URL
            window.history.replaceState({}, document.title, window.location.pathname);
            return;
        }
        
        // Get the table name from the scorecard
        const assignmentTable = assignment.scorecards?.table_name || assignment.scorecard_table_name;
        const scorecardId = assignment.scorecard_id || assignment._scorecard_id;
        
        // Check if assignment is already completed
        if (assignment.status === 'completed' || assignment.audit_status === 'completed') {
            // Redirect to view the completed audit
            if (scorecardId && assignmentTable) {
                window.location.href = `audit-view.html?id=${assignment.id}&scorecard=${scorecardId}&table=${assignmentTable}`;
                return;
            }
            alert('This assignment has already been completed.');
            // Clean URL
            window.history.replaceState({}, document.title, window.location.pathname);
            return;
        }
        
        // Map assignment to expected format
        const mappedAssignment = {
            id: assignment.id,
            employee_email: assignment.employee_email,
            employee_name: assignment.employee_name,
            auditor_email: assignment.auditor_email,
            scorecard_id: scorecardId,
            status: assignment.status || assignment.audit_status,
            scorecards: {
                id: scorecardId,
                table_name: assignmentTable
            }
        };
        
        // Start the assigned audit
        console.log('Starting audit from assignment:', mappedAssignment);
        await window.startAssignedAudit(
            mappedAssignment.id,
            mappedAssignment.employee_email,
            mappedAssignment.scorecard_id
        );
        
        // Clean URL after starting (optional - keeps the assignment ID for reference)
        // window.history.replaceState({}, document.title, window.location.pathname);
        
    } catch (error) {
        console.error('Error loading assignment from URL:', error);
        alert('Error loading assignment: ' + error.message);
        // Clean URL
        window.history.replaceState({}, document.title, window.location.pathname);
    }
}

// Calculate errors by category (Dynamic)
function calculateErrorsByCategory() {
    const categoryCounts = {
        'Critical Fail Error': 0,
        'Critical Error': 0,
        'Significant Error': 0
    };
    
    const scoringType = currentScorecard ? currentScorecard.scoring_type : 'deductive';
    
    currentParameters.forEach(param => {
        // FIXED: Default to 'error' if parameter_type is null/undefined/empty
        const paramType = param.parameter_type || 'error';
        
        // Only count error parameters, not achievements/bonuses
        if (paramType === 'achievement' || paramType === 'bonus') {
            return; // Skip achievements/bonuses for error counting
        }
        
        let count = 0;
        
        if (param.field_type === 'radio') {
            // Get the selected radio button value
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            
            // Only count if something is actually selected
            if (selectedRadio) {
                const selectedValue = parseInt(selectedRadio.value);
                // For error types: YES (1) = error occurred = counts as error
                count = selectedValue; // YES = 1 error, NO = 0 errors
            }
            // If nothing selected, count = 0 (don't count as error yet)
        } else {
            // Counter field - the value itself is the error count
            const field = document.getElementById(param.field_id);
            count = field ? (parseInt(field.value) || 0) : 0;
        }
        
        if (categoryCounts.hasOwnProperty(param.error_category)) {
            categoryCounts[param.error_category] += count;
        }
    });
    
    // Update fields
    const criticalFailField = document.getElementById('criticalFailError');
    const criticalField = document.getElementById('criticalErrors');
    const significantField = document.getElementById('significantError');
    
    if (criticalFailField) criticalFailField.value = categoryCounts['Critical Fail Error'];
    if (criticalField) criticalField.value = categoryCounts['Critical Error'];
    if (significantField) significantField.value = categoryCounts['Significant Error'];
    
    return categoryCounts;
}

// Calculate average score based on dynamic parameters
function calculateAverageScore() {
    if (!currentParameters || currentParameters.length === 0 || !currentScorecard) {
        return 100; // Default if no parameters loaded
    }
    
    const scoringType = currentScorecard.scoring_type || 'deductive';
    let score = 0;
    
    switch(scoringType) {
        case 'deductive':
            score = calculateDeductiveScore();
            break;
        case 'additive':
            score = calculateAdditiveScore();
            break;
        case 'hybrid':
            score = calculateHybridScore();
            break;
        default:
            score = calculateDeductiveScore();
    }
    
    // Update average score field
    const averageScoreField = document.getElementById('averageScore');
    if (averageScoreField) {
        averageScoreField.value = score.toFixed(2);
    }
    
    // Calculate and update error counts and summary badges
    let criticalFailCount = 0;
    let criticalCount = 0;
    let significantCount = 0;
    let totalErrorsCount = 0;
    
    currentParameters.forEach(param => {
        // FIXED: Default to 'error' if parameter_type is null/undefined/empty
        const paramType = param.parameter_type || 'error';
        
        // Only count error parameters, not achievements/bonuses
        if (paramType === 'achievement' || paramType === 'bonus') {
            return; // Skip achievements/bonuses for error counting
        }
        
        let value = 0;
        let errorCount = 0;
        
        if (param.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
            // For error parameters: YES (1) = error occurred = error
            errorCount = value; // YES = error, NO = no error
        } else {
            // Counter field - count is the value itself
            const field = document.getElementById(param.field_id);
            errorCount = field ? (parseInt(field.value) || 0) : 0;
        }
        
        if (errorCount > 0) {
            // Determine severity - properly map all error categories
            const category = param.error_category || '';
            let severity = 'Significant'; // default
            if (category.includes('Fail')) {
                severity = 'Critical Fail';
            } else if (category.includes('Critical')) {
                severity = 'Critical';
            } else if (category.includes('Significant')) {
                severity = 'Significant';
            } else if (category.includes('Major')) {
                severity = 'Major';
            } else if (category.includes('Minor')) {
                severity = 'Minor';
            }
            
            if (severity === 'Critical Fail') {
                criticalFailCount += errorCount;
            } else if (severity === 'Critical') {
                criticalCount += errorCount;
            } else if (severity === 'Significant' || severity === 'Major' || severity === 'Minor') {
                // For now, Significant, Major, and Minor all count as significant errors
                // This maintains backward compatibility with existing error counting
                significantCount += errorCount;
            }
            
            totalErrorsCount += errorCount;
        }
    });
    
    // Update hidden error count fields for form submission
    const criticalErrorsField = document.getElementById('criticalErrors');
    const criticalFailErrorField = document.getElementById('criticalFailError');
    const significantErrorField = document.getElementById('significantError');
    const totalErrorsField = document.getElementById('totalErrorsCount');
    
    // Update display fields
    const criticalFailErrorDisplay = document.getElementById('criticalFailErrorDisplay');
    
    if (criticalErrorsField) criticalErrorsField.value = criticalCount;
    if (criticalFailErrorField) criticalFailErrorField.value = criticalFailCount;
    if (significantErrorField) significantErrorField.value = significantCount;
    if (totalErrorsField) totalErrorsField.value = totalErrorsCount;
    if (criticalFailErrorDisplay) criticalFailErrorDisplay.value = criticalFailCount;
    
    // Update passing status based on score and threshold
    updatePassingStatus(score);
    
    return score;
}

// Deductive scoring: Start at 100, subtract for errors
function calculateDeductiveScore() {
    let totalDeduction = 0;
    
    currentParameters.forEach(param => {
        // Skip only if it's explicitly an achievement or bonus type (not an error type)
        // Include if: parameter_type is 'error', points_direction is 'subtract', or parameter_type is null/undefined/empty (default to error)
        const paramType = param.parameter_type || 'error';
        const pointsDirection = param.points_direction;
        
        // Skip achievement/bonus types that don't have subtract direction
        if ((paramType === 'achievement' || paramType === 'bonus') && pointsDirection !== 'subtract') {
            return;
        }
        
        let value = 0;
        
        if (param.field_type === 'radio') {
            // Get the selected radio button value
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            // Counter field
            const field = document.getElementById(param.field_id);
            value = field ? (parseInt(field.value) || 0) : 0;
        }
        
        const penalty = parseFloat(param.penalty_points) || 0;
        totalDeduction += value * penalty;
    });
    
    return Math.max(0, 100 - totalDeduction);
}

// Additive scoring: Start at 0, add for achievements
function calculateAdditiveScore() {
    let totalPoints = 0;
    let maxPossiblePoints = 0;
    
    currentParameters.forEach(param => {
        if (param.parameter_type !== 'achievement' && param.points_direction !== 'add') return;
        
        const points = parseFloat(param.penalty_points) || 0;
        
        // Max possible is if all achievements were completed
        if (param.field_type === 'radio') {
            maxPossiblePoints += points;
        } else {
            // For counters in additive, we assume max count of 1 unless specified
            maxPossiblePoints += points;
        }
        
        let value = 0;
        
        if (param.field_type === 'radio') {
            // Get the selected radio button value
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            // Counter field
            const field = document.getElementById(param.field_id);
            value = field ? (parseInt(field.value) || 0) : 0;
        }
        
        totalPoints += value * points;
    });
    
    // Convert to percentage
    if (maxPossiblePoints === 0) return 0;
    return Math.min(100, (totalPoints / maxPossiblePoints) * 100);
}

// Hybrid scoring: Deduct for errors, add for achievements
function calculateHybridScore() {
    let baseScore = 100;
    let bonusPoints = 0;
    
    currentParameters.forEach(param => {
        let value = 0;
        
        if (param.field_type === 'radio') {
            // Get the selected radio button value
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            // Counter field
            const field = document.getElementById(param.field_id);
            value = field ? (parseInt(field.value) || 0) : 0;
        }
        
        const points = parseFloat(param.penalty_points) || 0;
        
        // Default to 'error' if parameter_type is null/undefined/empty
        const paramType = param.parameter_type || 'error';
        const pointsDirection = param.points_direction;
        
        if (paramType === 'error' || pointsDirection === 'subtract') {
            // Subtract from base score
            baseScore -= value * points;
        } else if (paramType === 'achievement' || paramType === 'bonus' || pointsDirection === 'add') {
            // Add to bonus
            bonusPoints += value * points;
        }
        // If parameter doesn't match any condition, it's skipped (no deduction or bonus)
    });
    
    // Apply max bonus cap if set
    const maxBonus = parseFloat(currentScorecard.max_bonus_points) || 0;
    if (maxBonus > 0) {
        bonusPoints = Math.min(bonusPoints, maxBonus);
    }
    
    // Calculate final score
    let finalScore = baseScore + bonusPoints;
    
    // Apply over 100% cap if not allowed
    const allowOver100 = currentScorecard.allow_over_100 || false;
    if (!allowOver100) {
        finalScore = Math.min(100, finalScore);
    }
    
    // Ensure minimum of 0
    finalScore = Math.max(0, finalScore);
    
    return finalScore;
}

// Update passing status based on average score and scorecard threshold
function updatePassingStatus(score) {
    const passingStatusField = document.getElementById('passingStatus');
    const headerElement = document.getElementById('auditFormHeader');
    
    if (passingStatusField) {
        const threshold = currentScorecard ? parseFloat(currentScorecard.passing_threshold) : 85;
        
        // Check if any "fail all" parameters have errors
        let failAllErrorCount = 0;
        
        currentParameters.forEach(param => {
            // Check if this parameter causes automatic fail
            if (param.is_fail_all) {
                const paramType = param.parameter_type || 'error';
                let errorCount = 0;
                
                if (param.field_type === 'radio') {
                    const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
                    const value = selectedRadio ? parseInt(selectedRadio.value) : 0;
                    
                    // For additive/achievement: NO (0) = error
                    // For error parameters: YES (1) = error
                    if (paramType === 'achievement' || paramType === 'bonus') {
                        errorCount = value === 0 ? 1 : 0;
                    } else {
                        errorCount = value;
                    }
                } else {
                    // Counter field
                    const field = document.getElementById(param.field_id);
                    errorCount = field ? (parseInt(field.value) || 0) : 0;
                }
                
                failAllErrorCount += errorCount;
            }
        });
        
        let isPassing = false;
        
        // Check for "fail all" conditions first
        if (failAllErrorCount > 0) {
            // Any fail-all parameter has errors = automatic fail
            passingStatusField.value = 'Not Passing';
            isPassing = false;
        } else if (score >= threshold) {
            // No fail-all errors and score meets threshold = pass
            passingStatusField.value = 'Passing';
            isPassing = true;
        } else {
            // No fail-all errors but score below threshold = fail
            passingStatusField.value = 'Not Passing';
            isPassing = false;
        }
        
        // Update header background color based on passing status
        if (headerElement) {
            if (isPassing) {
                headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
            } else {
                headerElement.style.background = 'linear-gradient(135deg, #d41212 0%, #b91c1c 100%)';
            }
        }
    }
}

// Calculate total errors count (Dynamic)
function calculateTotalErrorsCount() {
    let totalCount = 0;
    
    currentParameters.forEach(param => {
        // FIXED: Default to 'error' if parameter_type is null/undefined/empty
        const paramType = param.parameter_type || 'error';
        
        // Only count error parameters, not achievements/bonuses
        if (paramType === 'achievement' || paramType === 'bonus') {
            return; // Skip achievements/bonuses for error counting
        }
        
        let count = 0;
        
        if (param.field_type === 'radio') {
            // Get the selected radio button value
            const selectedRadio = document.querySelector(`input[name="${param.field_id}"]:checked`);
            
            // Only count if something is actually selected
            if (selectedRadio) {
                const selectedValue = parseInt(selectedRadio.value);
                // For error types: YES (1) = error occurred = counts as error
                count = selectedValue; // YES = 1 error, NO = 0 errors
            }
            // If nothing selected, count = 0 (don't count as error yet)
        } else {
            // Counter field - the value itself is the error count
            const field = document.getElementById(param.field_id);
            count = field ? (parseInt(field.value) || 0) : 0;
        }
        
        totalCount += count;
    });
    
    // Update total errors count field
    const totalErrorsField = document.getElementById('totalErrorsCount');
    if (totalErrorsField) {
        totalErrorsField.value = totalCount;
    }
    
    return totalCount;
}

// Counter Button Functionality
document.addEventListener('click', function(e) {
    if (e.target.classList.contains('counter-btn')) {
        const action = e.target.getAttribute('data-action');
        const targetId = e.target.getAttribute('data-target');
        const targetInput = document.getElementById(targetId);
        
        if (targetInput) {
            let currentValue = parseInt(targetInput.value) || 0;
            
            if (action === 'increment') {
                // Cap at maximum of 10
                currentValue = Math.min(currentValue + 1, 10);
            } else if (action === 'decrement') {
                currentValue = Math.max(0, currentValue - 1);
            }
            
            targetInput.value = currentValue;
            
            // Update plain text display
            const displayElement = document.getElementById(`${targetId}_display`);
            if (displayElement) {
                displayElement.textContent = currentValue;
                // Update color based on value
                if (currentValue > 0) {
                    displayElement.style.color = '#ef4444';
                    displayElement.style.fontWeight = '700';
                } else {
                    displayElement.style.color = '#1f2937';
                    displayElement.style.fontWeight = '700';
                }
            }
            
            // Calculate total errors count and average score whenever any error count changes
            calculateTotalErrorsCount();
            calculateAverageScore();
            calculateErrorsByCategory();
            
            // Update feedback boxes based on error count
            const param = currentParameters.find(p => p.field_id === targetId);
            if (param) {
                updateFeedbackBoxesForParameter(targetId, param.field_type || 'counter', param.parameter_type || 'error');
                
                // Clear any validation error styling when value changes
                const feedbackContainer = document.getElementById(`feedback_container_${targetId}`);
                if (feedbackContainer) {
                    const feedbackFields = feedbackContainer.querySelectorAll('textarea');
                    feedbackFields.forEach(field => {
                        if (field.value && field.value.trim()) {
                            field.style.borderColor = '#d1d5db';
                        }
                    });
                }
            }
        }
    }
});

// Radio Button Change Handler (for achievements/yes-no fields)
document.addEventListener('change', function(e) {
    if (e.target.type === 'radio' && e.target.dataset.penalty) {
        const fieldName = e.target.name;
        const selectedValue = parseInt(e.target.value) || 0;
        
        // Calculate totals
        calculateTotalErrorsCount();
        calculateAverageScore();
        calculateErrorsByCategory();
        
        // Update feedback boxes based on error count
        const param = currentParameters.find(p => p.field_id === fieldName);
        if (param) {
            updateFeedbackBoxesForParameter(fieldName, param.field_type || 'radio', param.parameter_type || 'error');
            
            // Clear any validation error styling when value changes
            const feedbackContainer = document.getElementById(`feedback_container_${fieldName}`);
            if (feedbackContainer) {
                const feedbackFields = feedbackContainer.querySelectorAll('textarea');
                feedbackFields.forEach(field => {
                    if (field.value && field.value.trim()) {
                        field.style.borderColor = '#d1d5db';
                    }
                });
            }
        }
    }
});

// ============================================================================
// Intercom API Integration and Chat Interface
// ============================================================================
document.addEventListener('DOMContentLoaded', function() {
    const interactionIdInput = document.getElementById('interactionId');
    const viewChatBtn = document.getElementById('viewChatBtn');
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    const transcriptTextarea = document.getElementById('transcript');
    
    let isChatViewActive = false;
    let currentConversationData = null;

    // Configuration - Uses intercom-config.js (generated from environment variables)
    const INTERCOM_CONFIG = window.intercomConfig || {
        appId: '',
        apiBaseUrl: 'https://api.intercom.io',
        baseUrl: 'https://app.intercom.com/a/inbox'
    };

    // Get Supabase URL for Edge Function (generated from environment variables)
    const SUPABASE_URL = window.SupabaseConfig?.url || '';
    const SUPABASE_ANON_KEY = window.SupabaseConfig?.anonKey || '';

    // Show chat view by default (will auto-load transcripts or fallback to text view on failure)
    if (transcriptChatView && transcriptTextView) {
            transcriptChatView.style.display = 'flex';
            transcriptTextView.style.display = 'none';
        isChatViewActive = true;
    }

    // Auto-load conversation when Interaction ID changes
    let loadTimeout = null;
    if (interactionIdInput) {
        interactionIdInput.addEventListener('input', function() {
        const interactionId = interactionIdInput.value.trim();
        
            // Clear previous timeout
            if (loadTimeout) {
                clearTimeout(loadTimeout);
            }
            
            // Disable Open button while typing
            if (viewChatBtn) {
                viewChatBtn.disabled = true;
                viewChatBtn.style.backgroundColor = '#9ca3af';
                viewChatBtn.style.cursor = 'not-allowed';
                viewChatBtn.style.opacity = '0.6';
                viewChatBtn.title = 'Open in Intercom (load conversation first)';
            }
            
            // Debounce: wait 500ms after user stops typing before loading
            if (interactionId) {
                loadTimeout = setTimeout(async () => {
        await loadConversationFromIntercom(interactionId);
                }, 500);
            }
    });
    }

    // View in Intercom button - opens in new tab
    if (viewChatBtn) {
    viewChatBtn.addEventListener('click', async function() {
        const interactionId = interactionIdInput.value.trim();
        
        if (!interactionId) {
            await window.confirmationDialog.show({
                title: 'Interaction ID Required',
                message: 'Please enter an Interaction ID to view the chat in Intercom.',
                confirmText: 'OK',
                cancelText: 'Close',
                type: 'info'
            });
            interactionIdInput.focus();
            return;
        }

        const conversationUrl = `https://app.intercom.com/a/inbox/aphmhtyj/inbox/conversation/${interactionId}?view`;
        window.open(conversationUrl, '_blank', 'noopener,noreferrer,width=1200,height=800,scrollbars=yes,resizable=yes');
    });
    }

    // Auto-focus Interaction ID when page loads
    if (interactionIdInput) {
        interactionIdInput.focus();
    }

    // Fetch conversation from Intercom API
    // Make it globally available for calibration mode
    window.loadConversationFromIntercom = async function(conversationId) {
        // Show loading state
        if (viewChatBtn) {
            viewChatBtn.disabled = true;
            viewChatBtn.style.backgroundColor = '#9ca3af';
            viewChatBtn.style.cursor = 'not-allowed';
            viewChatBtn.style.opacity = '0.6';
            viewChatBtn.textContent = 'Loading...';
            viewChatBtn.title = 'Loading conversation...';
        }
        
        chatMessagesContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: #6b7280;">
                <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
            </div>
        `;

        try {
            // Fetch conversation data from Intercom API via Supabase Edge Function (to avoid CORS)
            // Use display_as=html to get proper HTML with image tags, or plaintext for text-based references
            // We'll handle both formats in the parsing logic
            const edgeFunctionUrl = `${SUPABASE_URL}/functions/v1/intercom-proxy?conversation_id=${encodeURIComponent(conversationId)}&display_as=html`;
            
            const response = await fetch(edgeFunctionUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    'apikey': SUPABASE_ANON_KEY,
                    'Accept': 'application/json'
                }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
            }

            const conversation = await response.json();
            currentConversationData = conversation;

            // DEBUG: Log raw API response
            console.log('=== RAW API RESPONSE ===');
            console.log('Full conversation object:', conversation);
            console.log('Total conversation parts:', conversation.conversation_parts?.conversation_parts?.length || 0);
            
            // Check specific email parts to see if email_message_metadata is present
            if (conversation.conversation_parts?.conversation_parts) {
                const part32842906801 = conversation.conversation_parts.conversation_parts.find(p => p.id === '32842906801');
                const part32842914590 = conversation.conversation_parts.conversation_parts.find(p => p.id === '32842914590');
                
                if (part32842906801) {
                    console.log('=== PART 32842906801 (should be email) ===');
                    console.log('Full part:', JSON.stringify(part32842906801, null, 2));
                    console.log('Has email_message_metadata key?', 'email_message_metadata' in part32842906801);
                    console.log('email_message_metadata value:', part32842906801.email_message_metadata);
                    console.log('All keys:', Object.keys(part32842906801));
                }
                
                if (part32842914590) {
                    console.log('=== PART 32842914590 (should be email) ===');
                    console.log('Full part:', JSON.stringify(part32842914590, null, 2));
                    console.log('Has email_message_metadata key?', 'email_message_metadata' in part32842914590);
                    console.log('email_message_metadata value:', part32842914590.email_message_metadata);
                    console.log('All keys:', Object.keys(part32842914590));
                }
            }
            console.log('========================');

            // Autofill email and date from conversation data (only if not in calibration mode)
            if (!isCalibrationMode) {
                autofillConversationFields(conversation);
            }

            // Parse and display conversation messages
            displayConversationMessages(conversation);

            // Extract and display all conversation attributes
            displayConversationAttributes(conversation);

            // Ensure chat view is active (it should already be)
            if (!isChatViewActive) {
                isChatViewActive = true;
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
            }

            // Enable Open button after successful load
            if (viewChatBtn) {
                viewChatBtn.disabled = false;
                viewChatBtn.style.backgroundColor = '#6b7280';
                viewChatBtn.style.cursor = 'pointer';
                viewChatBtn.style.opacity = '1';
                viewChatBtn.textContent = 'Open';
                viewChatBtn.title = 'Open in Intercom';
            }

            // Show success notification
            showNotification('Conversation loaded successfully!', 'success');

        } catch (error) {
            console.error('Error loading conversation from Intercom:', error);
            
            // Auto-fallback to text view on error
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'none';
                transcriptTextView.style.display = 'flex';
                isChatViewActive = false;
            }

            // Keep Open button disabled on error
            if (viewChatBtn) {
                viewChatBtn.disabled = true;
                viewChatBtn.style.backgroundColor = '#9ca3af';
                viewChatBtn.style.cursor = 'not-allowed';
                viewChatBtn.style.opacity = '0.6';
                viewChatBtn.textContent = 'Open';
                viewChatBtn.title = 'Open in Intercom (load conversation first)';
            }

            // Show error message in chat container (for debugging, but user will see text view)
            chatMessagesContainer.innerHTML = `
                <div style="text-align: center; padding: 1.2937rem; color: #ef4444;">
                    <svg style="width: 1.9406rem; height: 1.9406rem; margin: 0 auto 0.6469rem; opacity: 0.5;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="12"></line>
                        <line x1="12" y1="16" x2="12.01" y2="16"></line>
                    </svg>
                    <p style="font-size: 0.5659rem; font-weight: 600; margin-bottom: 0.3234rem;">Failed to load conversation from Intercom</p>
                    <p style="font-size: 0.4852rem; color: #6b7280;">${escapeHtml(error.message)}</p>
                    <p style="font-size: 0.4852rem; color: #9ca3af; margin-top: 0.3234rem;">Falling back to text view.</p>
                </div>
            `;
        }
    };
    // Also create a local reference for backward compatibility
    const loadConversationFromIntercom = window.loadConversationFromIntercom;

    // Autofill email and date from conversation data
    function autofillConversationFields(conversation) {
        // Extract email from conversation
        // Try multiple possible locations in the Intercom API response
        let email = null;
        
        // Check source.author.email (user/contact who initiated conversation)
        if (conversation.source?.author?.email) {
            email = conversation.source.author.email;
        }
        // Check source.owner.email (assigned agent/team)
        else if (conversation.source?.owner?.email) {
            email = conversation.source.owner.email;
        }
        // Check contacts associated with conversation
        else if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
            const contact = conversation.contacts.contacts[0];
            if (contact.email) {
                email = contact.email;
            }
        }
        // Check source.contacts
        else if (conversation.source?.contacts?.contacts && conversation.source.contacts.contacts.length > 0) {
            const contact = conversation.source.contacts.contacts[0];
            if (contact.email) {
                email = contact.email;
            }
        }
        // Check source.author.contacts
        else if (conversation.source?.author?.contacts && conversation.source.author.contacts.length > 0) {
            const contact = conversation.source.author.contacts[0];
            if (contact.email) {
                email = contact.email;
            }
        }
        // Check conversation_parts for user email (from first user message)
        else if (conversation.conversation_parts?.conversation_parts) {
            for (const part of conversation.conversation_parts.conversation_parts) {
                if (part.author?.type === 'user' || part.author?.type === 'contact') {
                    if (part.author.email) {
                        email = part.author.email;
                        break;
                    }
                }
            }
        }
        
        // Extract date from message timestamps (preferred method)
        // Intercom API returns Unix timestamps (in seconds), not ISO strings
        // Get the earliest message timestamp from conversation_parts
        let conversationDate = null;
        
        // Helper function to convert Unix timestamp (seconds) to Date object
        function unixTimestampToDate(timestamp) {
            if (!timestamp) return null;
            // If it's already a Date object, return it
            if (timestamp instanceof Date) return timestamp;
            // If it's a number (Unix timestamp in seconds), convert it
            if (typeof timestamp === 'number') {
                // If timestamp is less than 10^10, it's in seconds (multiply by 1000)
                // If timestamp is 10^10 or more, it's in milliseconds
                const timestampMs = timestamp < 10000000000 ? timestamp * 1000 : timestamp;
                return new Date(timestampMs);
            }
            // If it's a string, try to parse as ISO date
            if (typeof timestamp === 'string') {
                return new Date(timestamp);
            }
            return null;
        }
        
        if (conversation.conversation_parts?.conversation_parts && conversation.conversation_parts.conversation_parts.length > 0) {
            // Find the earliest message timestamp
            let earliestTimestamp = null;
            for (const part of conversation.conversation_parts.conversation_parts) {
                if (part.created_at) {
                    const partDate = unixTimestampToDate(part.created_at);
                    if (partDate && !isNaN(partDate.getTime())) {
                        if (!earliestTimestamp || partDate < earliestTimestamp) {
                            earliestTimestamp = partDate;
                        }
                    }
                }
            }
            
            if (earliestTimestamp) {
                conversationDate = earliestTimestamp;
            }
        }
        
        // Fallback to conversation-level dates if no message timestamps found
        if (!conversationDate) {
            if (conversation.created_at) {
                conversationDate = unixTimestampToDate(conversation.created_at);
            } else if (conversation.updated_at) {
                conversationDate = unixTimestampToDate(conversation.updated_at);
            } else if (conversation.source?.created_at) {
                conversationDate = unixTimestampToDate(conversation.source.created_at);
            }
        }
        
        // Autofill email field if email was found and field is empty
        const emailInput = document.getElementById('clientEmail');
        if (email && emailInput && (!emailInput.value || emailInput.value.trim() === '')) {
            emailInput.value = email;
            // Trigger change event to notify any listeners
            emailInput.dispatchEvent(new Event('change', { bubbles: true }));
        }
        
        // Autofill date field if date was found and field is empty
        const dateInput = document.getElementById('interactionDate');
        if (conversationDate && dateInput && (!dateInput.value || dateInput.value.trim() === '')) {
            // conversationDate should already be a Date object at this point
            if (!isNaN(conversationDate.getTime())) {
                const year = conversationDate.getFullYear();
                const month = String(conversationDate.getMonth() + 1).padStart(2, '0');
                const day = String(conversationDate.getDate()).padStart(2, '0');
                dateInput.value = `${year}-${month}-${day}`;
                
                // Format date as DD-MMM-YY (e.g., 21-Aug-25)
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const formattedDate = `${day}-${monthNames[conversationDate.getMonth()]}-${String(year).slice(-2)}`;
                console.log('Date from Intercom formatted as:', formattedDate);
                
                // Trigger change event to notify any listeners
                dateInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
        }
        
        console.log('Autofilled from Intercom:', {
            email: email || 'not found',
            date: conversationDate ? conversationDate.toISOString() : 'not found',
            formattedDate: conversationDate ? `${String(conversationDate.getDate()).padStart(2, '0')}-${['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][conversationDate.getMonth()]}-${String(conversationDate.getFullYear()).slice(-2)}` : 'not found'
        });
    }

    // Display conversation messages in chat interface
    // Helper function to generate avatar with initials
    function generateAvatar(name, type) {
        // Extract initials from name
        const getInitials = (name) => {
            if (!name || name === 'Unknown') return '?';
            const parts = name.trim().split(/\s+/);
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        };
        
        const initials = getInitials(name);
        
        // Determine colors and gradients based on type
        let bgGradient, textColor, label, borderColor;
        if (type === 'user' || type === 'contact') {
            // Blue gradient for client
            bgGradient = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
            textColor = '#ffffff';
            label = 'Client'; // Use "Client" label under avatar
            borderColor = '#2563eb';
        } else if (type === 'ai' || type === 'bot') {
            // Darker green gradient for AI
            bgGradient = 'linear-gradient(135deg, #15803d 0%, #166534 100%)';
            textColor = '#ffffff';
            label = 'AI';
            borderColor = '#166534';
        } else {
            // Green gradient for agent
            bgGradient = 'linear-gradient(135deg, #1A733E 0%, #14532d 100%)';
            textColor = '#ffffff';
            label = 'Agent';
            borderColor = '#14532d';
        }
        
        return {
            initials,
            bgGradient,
            textColor,
            label,
            borderColor
        };
    }

    function displayConversationMessages(conversation) {
        const parts = conversation.conversation_parts?.conversation_parts || [];
        
        console.log('═══════════════════════════════════════════════════════');
        console.log('🔄 displayConversationMessages called');
        console.log('═══════════════════════════════════════════════════════');
        console.log('Total parts:', parts.length);
        console.log('Conversation ID:', conversation.id);
        
        // Log conversation structure for debugging
        if (parts.length > 0) {
            console.log('Sample part structure:', {
                partId: parts[0].id,
                partType: parts[0].part_type,
                hasBody: !!parts[0].body,
                bodyType: typeof parts[0].body,
                bodyPreview: typeof parts[0].body === 'string' ? parts[0].body.substring(0, 200) : 'object/other',
                hasAttachments: !!(parts[0].attachments && parts[0].attachments.length > 0),
                attachmentCount: parts[0].attachments?.length || 0
            });
        }
        
        // Extract client name from conversation
        let clientName = null;
        // Try to get client name from source.author
        if (conversation.source?.author?.name) {
            clientName = conversation.source.author.name;
        }
        // Try contacts
        else if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
            const contact = conversation.contacts.contacts[0];
            if (contact.name) {
                clientName = contact.name;
            }
        }
        // Try to find first user/contact in conversation parts
        else if (parts.length > 0) {
            for (const part of parts) {
                if (part.author && (part.author.type === 'user' || part.author.type === 'contact')) {
                    if (part.author.name) {
                        clientName = part.author.name;
                        break;
                    }
                }
            }
        }
        
        // Update conversation heading with client name
        const transcriptHeading = document.querySelector('h3');
        if (transcriptHeading && clientName) {
            // Update heading text (keep the icon)
            const icon = transcriptHeading.querySelector('svg');
            if (icon) {
                // Keep the SVG icon and replace "Transcript" with client name
                transcriptHeading.innerHTML = icon.outerHTML + ' ' + escapeHtml(clientName);
            } else {
                transcriptHeading.textContent = clientName;
            }
        }
        
        // Update client name in header section
        const clientNameInput = document.getElementById('clientName');
        if (clientNameInput) {
            if (clientName) {
                clientNameInput.value = clientName;
            } else {
                clientNameInput.value = '';
            }
        }
        
        // Log all part types to see what we're getting
        const partTypes = parts.map(p => ({ id: p.id, type: p.part_type, hasEmailMeta: !!p.email_message_metadata, hasAttachments: (p.attachments || []).length > 0 }));
        console.log('Part types:', partTypes);
        
        if (parts.length === 0) {
            chatMessagesContainer.innerHTML = `
                <div style="text-align: center; padding: 1.2937rem; color: #9ca3af;">
                    <p>No messages found in this conversation.</p>
                </div>
            `;
            syncChatToTextarea();
            return;
        }

        // Sort parts by created_at timestamp
        const sortedParts = [...parts].sort((a, b) => {
            // Handle Unix timestamps (in seconds) and Date objects
            const timeA = typeof a.created_at === 'number' 
                ? (a.created_at < 10000000000 ? a.created_at * 1000 : a.created_at)
                : new Date(a.created_at).getTime();
            const timeB = typeof b.created_at === 'number'
                ? (b.created_at < 10000000000 ? b.created_at * 1000 : b.created_at)
                : new Date(b.created_at).getTime();
            return timeA - timeB;
        });

        // Clear container and remove empty state message
        chatMessagesContainer.innerHTML = '';
        chatMessagesContainer.style.gap = '0.3234rem';
        
        // Reset images array
        allConversationImages = [];

        sortedParts.forEach(part => {
            const message = part.body || '';
            const author = part.author || {};
            const authorName = author.name || author.email || 'Unknown';
            const authorType = author.type || 'unknown'; // 'user', 'admin', 'bot', etc.
            const partType = part.part_type || 'comment'; // 'comment', 'assignment', etc.
            
            // Convert Unix timestamp to Date object (Intercom returns timestamps in seconds)
            let timestamp;
            if (typeof part.created_at === 'number') {
                // Unix timestamp in seconds - convert to milliseconds
                timestamp = new Date(part.created_at < 10000000000 ? part.created_at * 1000 : part.created_at);
            } else {
                timestamp = new Date(part.created_at);
            }
            const isUser = authorType === 'user' || authorType === 'contact';
            const isAdmin = authorType === 'admin' || authorType === 'team';
            // Detect AI/Bot messages - be strict: only if explicitly bot type or has AI flags
            // Don't check name for "ai" as admins might be labeled as "AI" but are actually agents
            const isAI = authorType === 'bot' || 
                        author.from_ai_agent === true || 
                        author.is_ai_answer === true ||
                        (part.from_ai_agent === true) ||
                        (part.is_ai_answer === true);
            
            // Debug logging for message type detection
            if (isAdmin && !isUser) {
                console.log(`Message from ${authorName} (${authorType}):`, {
                    isAI: isAI,
                    isAdmin: isAdmin,
                    authorType: authorType,
                    from_ai_agent: author.from_ai_agent,
                    is_ai_answer: author.is_ai_answer,
                    part_from_ai_agent: part.from_ai_agent,
                    part_is_ai_answer: part.is_ai_answer,
                    willBeTreatedAs: isAI ? 'AI (dark)' : 'Agent (green)'
                });
            }
            
            // Format the message body to check if it has content
            // This extracts images from HTML img tags and text-based [Image "..."] references
            const messageData = formatMessageBody(message);
            const formattedText = messageData.text;
            const formattedHtml = messageData.html || null; // HTML with inline images
            const images = messageData.images || [];
            
            // Debug logging for message body parsing
            if (images.length > 0 || (message && typeof message === 'string' && message.includes('[Image'))) {
                console.log(`📝 Part ${part.id} body parsing:`, {
                    hasFormattedText: !!formattedText,
                    hasFormattedHtml: !!formattedHtml,
                    imagesFromBody: images.length,
                    messagePreview: typeof message === 'string' ? message.substring(0, 200) : 'object/other',
                    hasImageReferences: typeof message === 'string' && message.includes('[Image')
                });
            }
            
            // Check if this is an email interaction
            // email_message_metadata is either null (not an email) or an object with properties (is an email)
            // Note: typeof null === 'object' in JavaScript, so we must explicitly check for null
            const isEmail = !!(part.email_message_metadata && 
                part.email_message_metadata !== null && 
                typeof part.email_message_metadata === 'object' && 
                Object.keys(part.email_message_metadata).length > 0);
            const emailMetadata = isEmail ? part.email_message_metadata : {};
            
            // Debug logging for email detection
            if (partType === 'open' || partType === 'comment') {
                console.log(`Part ${part.id} (${partType}):`, {
                    hasEmailMetadataKey: 'email_message_metadata' in part,
                    hasEmailMetadata: !!part.email_message_metadata,
                    emailMetadataType: typeof part.email_message_metadata,
                    emailMetadataValue: part.email_message_metadata,
                    isEmail: isEmail,
                    subject: part.email_message_metadata?.subject || 'N/A',
                    allKeys: Object.keys(part).slice(0, 15) // First 15 keys to see structure
                });
            }
            
            if (isEmail) {
                console.log('✅ Email detected:', {
                    partId: part.id,
                    partType: partType,
                    subject: emailMetadata.subject,
                    from: emailMetadata.email_address_headers?.find(h => h.type === 'from')?.email_address,
                    to: emailMetadata.email_address_headers?.find(h => h.type === 'to')?.email_address,
                    hasAttachments: (part.attachments || []).length > 0
                });
            }
            
            // Extract attachments from attachments array (separate from body images)
            const attachments = part.attachments || [];
            
            // Extract image attachments - check multiple possible structures
            const attachmentImages = [];
            attachments.forEach(att => {
                // Check if it's an image attachment
                const isImage = (
                    (att.type === 'upload' || att.type === 'image' || !att.type) &&
                    (
                        (att.content_type && att.content_type.startsWith('image/')) ||
                        (att.url && /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i.test(att.url))
                    ) &&
                    att.url
                );
                
                if (isImage && att.url) {
                    attachmentImages.push(att.url);
                }
            });
            
            // Debug logging for attachments
            if (attachments.length > 0) {
                console.log(`📎 Part ${part.id} has ${attachments.length} attachments:`, {
                    totalAttachments: attachments.length,
                    imageAttachments: attachmentImages.length,
                    attachmentTypes: attachments.map(a => ({ type: a.type, contentType: a.content_type, hasUrl: !!a.url }))
                });
            }
            
            // Combine body images and attachment images
            // Body images come first (they appear inline in text), then attachments
            const allImages = [...images, ...attachmentImages];
            
            // Debug logging for combined images
            if (allImages.length > 0) {
                console.log(`🖼️ Part ${part.id} total images: ${allImages.length}`, {
                    fromBody: images.length,
                    fromAttachments: attachmentImages.length,
                    allImageUrls: allImages
                });
            }
            
            // Add images to global array with their index for viewer navigation
            const imageStartIndex = allConversationImages.length;
            allImages.forEach((imgSrc, idx) => {
                allConversationImages.push({
                    src: imgSrc,
                    partIndex: sortedParts.indexOf(part),
                    localIndex: idx
                });
            });
            
            // Skip empty messages or non-comment parts (like assignments, system messages, etc.)
            // BUT allow email interactions even if part_type is not 'comment' or 'note'
            // Only show parts that have actual text content, images, attachments, or email metadata
            if ((!formattedText || formattedText.trim() === '' || formattedText.trim() === '{}') && 
                allImages.length === 0 && 
                attachments.length === 0 && 
                !isEmail) {
                return; // Skip this part
            }
            
            // Also skip if part type is not a comment, note, or email
            // Email interactions can have various part_types (open, close, etc.)
            if (!isEmail && partType !== 'comment' && partType !== 'note') {
                console.log('Skipping part:', { partId: part.id, partType: partType, isEmail: isEmail });
                return; // Skip non-comment parts (unless it's an email)
            }
            
            // Log when we're displaying a part
            if (isEmail) {
                console.log('Displaying email part:', part.id, 'with', allImages.length, 'images and', attachments.length, 'attachments');
            }
            
            // Format timestamp
            const timeStr = timestamp.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });
            const dateStr = timestamp.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });

            // Determine message type for avatar and styling
            // Important: Agents should be green, AI should be dark gray
            const messageType = isUser ? 'user' : (isAI ? 'ai' : 'agent');
            const avatar = generateAvatar(authorName, messageType);
            
            // Debug: Log if we're treating an admin as AI when they should be an agent
            if (isAdmin && isAI && authorType !== 'bot') {
                console.warn(`⚠️ Admin "${authorName}" is being treated as AI. Check AI detection flags.`);
            }
            
            // Create message bubble container (avatar will be added in innerHTML)
            const messageDiv = document.createElement('div');

            // Colors: User = white, Agent = #1A733E, AI = #1d1d1d (dark gray)
            const bubbleStyle = isUser 
                ? `
                    background: white;
                    color: #374151;
                    border: 0.0304rem solid #e5e7eb;
                    border-radius: 0.4852rem 0.4852rem 0.4852rem 0.1617rem;
                    max-width: 100%;
                    width: fit-content;
                    margin-right: auto;
                    margin-left: 0;
                `
                : isAI
                ? `
                    background: #1d1d1d;
                    color: white;
                    border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                    max-width: 100%;
                    width: fit-content;
                    margin-left: auto;
                    margin-right: 0;
                `
                : `
                    background: #1A733E;
                    color: white;
                    border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                    max-width: 100%;
                    width: fit-content;
                    margin-left: auto;
                    margin-right: 0;
                `;

            // Build email header if this is an email
            let emailHeaderHTML = '';
            if (isEmail) {
                const emailHeaders = emailMetadata.email_address_headers || [];
                const fromHeader = emailHeaders.find(h => h.type === 'from') || {};
                const toHeader = emailHeaders.find(h => h.type === 'to') || {};
                const replyToHeader = emailHeaders.find(h => h.type === 'reply_to') || {};
                const subject = emailMetadata.subject || 'No Subject';
                
                // Format email addresses
                const formatEmailAddress = (header) => {
                    if (!header) return '';
                    const name = header.name || '';
                    const email = header.email_address || '';
                    if (name && email) {
                        return `${escapeHtml(name)} <${escapeHtml(email)}>`;
                    } else if (email) {
                        return escapeHtml(email);
                    } else if (name) {
                        return escapeHtml(name);
                    }
                    return '';
                };
                
                const fromStr = formatEmailAddress(fromHeader);
                const toStr = formatEmailAddress(toHeader);
                const replyToStr = formatEmailAddress(replyToHeader);
                
                // For agent emails, use a more prominent blue background that stands out from green
                // For user emails, use a light blue background
                // For AI emails, use dark gray background matching chat bubble
                const emailBgColor = isUser ? '#e0f2fe' : (isAI ? '#2d2d2d' : '#1e40af');
                const emailBorderColor = isUser ? '#0284c7' : (isAI ? '#1d1d1d' : '#3b82f6');
                const emailIconColor = isUser ? '#0284c7' : (isAI ? '#ffffff' : '#93c5fd');
                const emailTextColor = isUser ? '#0369a1' : (isAI ? '#ffffff' : '#bfdbfe');
                const emailLabelColor = isUser ? '#0369a1' : (isAI ? '#ffffff' : '#bfdbfe');
                const emailSubjectColor = isUser ? '#0c4a6e' : (isAI ? '#ffffff' : '#dbeafe');
                const emailFieldColor = isUser ? '#075985' : (isAI ? '#e5e7eb' : '#bfdbfe');
                const emailBorderBottomColor = isUser ? 'rgba(2, 132, 199, 0.2)' : (isAI ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.2)');
                
                emailHeaderHTML = `
                    <div style="
                        background: ${emailBgColor};
                        border: 0.0606rem solid ${emailBorderColor};
                        padding: 0.4852rem 0.5659rem;
                        margin-bottom: 0.4043rem;
                        border-radius: 0.3234rem;
                        font-size: 0.4447rem;
                        box-shadow: 0 0.0405rem 0.1213rem rgba(0,0,0,0.1);
                    ">
                        <div style="display: flex; align-items: center; gap: 0.3234rem; margin-bottom: 0.2426rem; padding-bottom: 0.1617rem; border-bottom: 0.0304rem solid ${emailBorderBottomColor};">
                            <svg style="width: 0.6064rem; height: 0.6064rem; color: ${emailIconColor}; flex-shrink: 0;" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"></path>
                                <path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"></path>
                            </svg>
                            <span style="font-weight: 700; color: ${emailLabelColor}; text-transform: uppercase; font-size: 0.4043rem; letter-spacing: 0.0405rem;">Email</span>
                        </div>
                        ${subject ? `<div style="color: ${emailSubjectColor}; margin-bottom: 0.2426rem; font-weight: 600;">
                            <span style="color: ${emailFieldColor}; font-weight: 700;">Subject:</span> ${escapeHtml(subject)}
                        </div>` : ''}
                        <div style="color: ${emailSubjectColor}; font-size: 0.4043rem; line-height: 1.6;">
                            ${fromStr ? `<div style="margin-bottom: 0.1213rem;"><span style="color: ${emailFieldColor}; font-weight: 600;">From:</span> ${fromStr}</div>` : ''}
                            ${toStr ? `<div style="margin-bottom: 0.1213rem;"><span style="color: ${emailFieldColor}; font-weight: 600;">To:</span> ${toStr}</div>` : ''}
                            ${replyToStr ? `<div style="margin-top: 0.1213rem; font-size: 0.3639rem; opacity: 0.9;"><span style="color: ${emailFieldColor}; font-weight: 600;">Reply-To:</span> ${replyToStr}</div>` : ''}
                        </div>
                    </div>
                `;
            }

            // Build attachments HTML (non-image attachments)
            let attachmentsHTML = '';
            const nonImageAttachments = attachments.filter(att => 
                att.type === 'upload' && 
                (!att.content_type || !att.content_type.startsWith('image/'))
            );
            if (nonImageAttachments.length > 0) {
                attachmentsHTML = '<div style="margin-top: 0.3234rem; display: flex; flex-direction: column; gap: 0.1617rem;">';
                nonImageAttachments.forEach(att => {
                    attachmentsHTML += `
                        <a 
                            href="${escapeHtml(att.url)}" 
                            target="_blank"
                            rel="noopener noreferrer"
                            style="
                                display: flex;
                                align-items: center;
                                gap: 0.2426rem;
                                padding: 0.2426rem 0.3234rem;
                                background: ${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'};
                                border-radius: 0.2426rem;
                                text-decoration: none;
                                color: ${isUser ? '#374151' : 'white'};
                                font-size: 0.4447rem;
                                transition: background 0.2s ease;
                            "
                            onmouseover="this.style.background='${isUser ? '#e5e7eb' : 'rgba(255,255,255,0.15)'}'"
                            onmouseout="this.style.background='${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'}'"
                        >
                            <svg style="width: 0.4852rem; height: 0.4852rem; flex-shrink: 0;" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd"/>
                            </svg>
                            <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(att.name || 'Attachment')}</span>
                            ${att.filesize ? `<span style="color: ${isUser ? '#9ca3af' : 'rgba(255,255,255,0.7)'}; font-size: 0.3639rem;">${(att.filesize / 1024).toFixed(1)} KB</span>` : ''}
                        </a>
                    `;
                });
                attachmentsHTML += '</div>';
            }

            // Build images HTML (for images that aren't inline in text)
            let imagesHTML = '';
            if (allImages.length > 0 && !formattedHtml) {
                imagesHTML = '<div style="margin-top: 0.3234rem; display: flex; flex-wrap: wrap; gap: 0.3234rem;">';
                allImages.forEach((imgSrc, idx) => {
                    const globalIndex = imageStartIndex + idx;
                    const escapedSrc = escapeHtmlAttribute(imgSrc);
                    imagesHTML += `<img src="${escapedSrc}" alt="Attachment ${idx + 1}" onclick="window.openImageViewer(${globalIndex})" style="max-width: 200px; max-height: 200px; border-radius: 0.3234rem; cursor: pointer; object-fit: cover; border: 0.0304rem solid ${isUser ? '#e5e7eb' : 'rgba(255,255,255,0.3)'}; transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0.1617rem 0.4852rem rgba(0,0,0,0.2)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'" onerror="console.error('Failed to load image:', this.src);" loading="lazy" />`;
                });
                imagesHTML += '</div>';
            }

            // Compact layout: timestamp next to sender name for both user and agent messages
            // For emails, make the border more prominent
            const emailBorderStyle = isEmail ? `border: 0.0808rem solid ${isUser ? '#0284c7' : (isAI ? '#1d1d1d' : '#3b82f6')} !important; box-shadow: 0 0.0606rem 0.1617rem ${isUser ? 'rgba(2, 132, 199, 0.3)' : (isAI ? 'rgba(29, 29, 29, 0.3)' : 'rgba(59, 130, 246, 0.3)')} !important;` : '';
            
            // Avatar alignment: Client on left, Agent/AI on right
            const avatarAlign = isUser ? 'flex-start' : 'flex-end';
            const avatarMargin = isUser ? 'margin-right: 0.3234rem;' : 'margin-left: 0.3234rem;';
            const avatarOrder = isUser ? '1' : '3';
            
            // Avatar HTML - Client left, Agent/AI right
            // For AI, use the image avatar; for others, use gradient with initials
            const avatarHTML = isAI ? `
                <div style="display: flex; flex-direction: column; align-items: ${avatarAlign}; margin-bottom: 0.2426rem; ${avatarMargin} flex-shrink: 0; order: ${avatarOrder};">
                    <div style="
                        width: 1.455rem;
                        height: 1.455rem;
                        border-radius: 50%;
                        background: ${avatar.bgGradient};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-shrink: 0;
                        box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1);
                        border: 0.0203rem solid ${avatar.borderColor};
                        position: relative;
                        overflow: hidden;
                    ">
                        <img src="./assets/logos/ai_avatar.webp" alt="AI Avatar" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" onerror="console.error('AI avatar image failed to load:', this.src); this.style.display='none'; this.parentElement.innerHTML='<span style=\\'position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2); color: ${avatar.textColor}; font-size: 0.5257rem; font-weight: 700;\\'>${avatar.initials}</span>';" />
                    </div>
                    <span style="
                        font-size: 0.3639rem;
                        font-weight: 600;
                        color: ${isUser ? '#6b7280' : (isAI ? '#1d1d1d' : '#1A733E')};
                        margin-top: 0.0808rem;
                        text-transform: uppercase;
                        letter-spacing: 0.0203rem;
                    ">${avatar.label}</span>
                </div>
            ` : `
                <div style="display: flex; flex-direction: column; align-items: ${avatarAlign}; margin-bottom: 0.2426rem; ${avatarMargin} flex-shrink: 0; order: ${avatarOrder};">
                    <div style="
                        width: 1.455rem;
                        height: 1.455rem;
                        border-radius: 50%;
                        background: ${avatar.bgGradient};
                        color: ${avatar.textColor};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 0.5257rem;
                        font-weight: 700;
                        flex-shrink: 0;
                        box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1), inset 0 0.0203rem 0 rgba(255,255,255,0.2);
                        border: 0.0203rem solid ${avatar.borderColor};
                        position: relative;
                        overflow: hidden;
                    ">
                        <span style="position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2);">${avatar.initials}</span>
                    </div>
                    <span style="
                        font-size: 0.3639rem;
                        font-weight: 600;
                        color: ${isUser ? '#6b7280' : (isAI ? '#1d1d1d' : '#1A733E')};
                        margin-top: 0.0808rem;
                        text-transform: uppercase;
                        letter-spacing: 0.0203rem;
                    ">${avatar.label}</span>
                </div>
            `;
            
            // Message container: Client avatar left, Agent/AI avatar right
            messageDiv.style.cssText = `
                display: flex;
                flex-direction: row;
                align-items: flex-start;
                margin-bottom: 0;
                width: 100%;
                justify-content: ${isUser ? 'flex-start' : 'flex-end'};
                gap: 0.3234rem;
            `;
            
            messageDiv.innerHTML = `
                ${isUser ? avatarHTML : ''}
                <div style="flex: 1; display: flex; flex-direction: column; align-items: ${isUser ? 'flex-start' : 'flex-end'}; order: ${isUser ? '2' : '1'}; min-width: 0; max-width: calc(100% - 3.5rem);">
                    <div style="${bubbleStyle} padding: 0.4043rem 0.5659rem; box-shadow: 0 0.0304rem 0.0606rem rgba(0,0,0,0.08); ${emailBorderStyle} word-wrap: break-word; overflow-wrap: break-word;">
                    ${isUser ? `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${isEmail ? '0' : '0.1213rem'}; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: #6b7280;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.7; color: #6b7280; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>` : `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${isEmail ? '0' : '0.1213rem'}; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: white;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.8; color: white; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>`}
                    ${emailHeaderHTML}
                    ${formattedHtml ? renderMessageWithInlineImages(formattedHtml, images, imageStartIndex, part.id, isUser) : (formattedText ? `<div class="message-text-content" data-original-text="${escapeHtml(formattedText.replace(/"/g, '&quot;'))}" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#374151' : 'white'};">${formattedText}</div>` : '')}
                    ${!formattedHtml && imagesHTML ? imagesHTML : ''}
                    ${attachmentsHTML}
                    </div>
                </div>
                ${!isUser ? avatarHTML : ''}
            `;

            chatMessagesContainer.appendChild(messageDiv);
        });

        // Scroll to bottom after a brief delay to ensure DOM is updated
        setTimeout(() => {
            const transcriptChatView = document.getElementById('transcriptChatView');
            if (transcriptChatView) {
                transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
            }
        }, 100);

        // Sync to textarea for form submission
        syncChatToTextarea();
    }

    // Format message body (handle HTML/plain text and extract images)
    function formatMessageBody(body) {
        if (!body) return { text: '', images: [], html: null };
        
        // If body is an object, extract text
        if (typeof body === 'object') {
            // Handle empty objects
            if (Object.keys(body).length === 0) return { text: '', images: [], html: null };
            
            // Check for text content in various possible fields
            if (body.plaintext) {
                const text = String(body.plaintext).trim();
                return { text: text ? escapeHtml(text) : '', images: [], html: null };
            }
            if (body.text) {
                const text = String(body.text).trim();
                return { text: text ? escapeHtml(text) : '', images: [], html: null };
            }
            if (body.body) {
                return parseHtmlBody(String(body.body));
            }
            
            // Check for HTML content
            if (body.html) {
                return parseHtmlBody(String(body.html));
            }
            
            // If object has no text content, return empty
            // Don't stringify as that would just show "{}"
            return { text: '', images: [], html: null };
        }
        
        // Handle string body (which may contain HTML)
        return parseHtmlBody(String(body));
    }
    
    // Escape HTML attribute value (for src attributes, preserve URL structure)
    // Important: Only escape characters that would break HTML attributes
    // Don't double-encode URL parameters (they're already properly encoded)
    function escapeHtmlAttribute(value) {
        if (!value) return '';
        const str = String(value);
        
        // Only escape characters that would break the HTML attribute
        // Preserve URL structure including query parameters
        return str
            .replace(/&/g, '&amp;')  // Must escape & first
            .replace(/"/g, '&quot;')  // Escape quotes
            .replace(/'/g, '&#x27;')  // Escape single quotes
            .replace(/</g, '&lt;')    // Escape <
            .replace(/>/g, '&gt;');   // Escape >
        
        // Note: We don't escape spaces, slashes, or other URL characters
        // as they're already properly encoded in the URL
    }
    
    // Render message with inline images (replace placeholders with actual image elements)
    function renderMessageWithInlineImages(htmlWithPlaceholders, images, imageStartIndex, messageId, isUser) {
        if (!htmlWithPlaceholders) return '';
        
        let renderedHtml = htmlWithPlaceholders;
        let replacedCount = 0;
        
        // Replace each image placeholder with an actual image element
        images.forEach((imgSrc, idx) => {
            const globalIndex = imageStartIndex + idx;
            const placeholder = `__IMAGE_PLACEHOLDER_${idx}__`;
            
            // Escape the image src for HTML attribute (preserve URL structure)
            // Only escape characters that would break the HTML attribute, preserve URL structure
            const escapedSrc = escapeHtmlAttribute(imgSrc);
            
            // Create image HTML with proper styling and click handler
            // Use proper attribute escaping for src, but don't double-encode URL parameters
            const imageHtml = `<img src="${escapedSrc}" alt="Image ${idx + 1}" onclick="window.openImageViewer(${globalIndex})" onerror="console.error('Failed to load image:', this.src); this.style.display='none';" style="max-width: 100%; max-height: 20rem; border-radius: 0.3234rem; margin: 0.3234rem 0; cursor: pointer; display: block; box-shadow: 0 0.1213rem 0.2426rem rgba(0,0,0,0.1); transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 0.2426rem 0.4852rem rgba(0,0,0,0.15)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0.1213rem 0.2426rem rgba(0,0,0,0.1)';" loading="lazy" />`;
            
            if (renderedHtml.includes(placeholder)) {
                renderedHtml = renderedHtml.replace(placeholder, imageHtml);
                replacedCount++;
            } else {
                console.warn(`⚠️ Image placeholder ${placeholder} not found in HTML for message ${messageId}`);
            }
        });
        
        // Clean up any remaining placeholders (shouldn't happen, but just in case)
        const remainingPlaceholders = (renderedHtml.match(/__IMAGE_PLACEHOLDER_\d+__/g) || []).length;
        if (remainingPlaceholders > 0) {
            console.warn(`⚠️ ${remainingPlaceholders} image placeholders not replaced in message ${messageId}`);
            renderedHtml = renderedHtml.replace(/__IMAGE_PLACEHOLDER_\d+__/g, '');
        }
        
        // Debug logging
        if (images.length > 0) {
            console.log(`🖼️ Rendered ${replacedCount}/${images.length} images inline for message ${messageId}`);
        }
        
        return `<div class="message-text-content" data-message-id="${messageId}" style="font-size: 0.5257rem; line-height: 1.6; word-wrap: break-word; margin-top: 0; margin-bottom: 0; color: ${isUser ? '#374151' : 'white'};">
            ${renderedHtml}
        </div>`;
    }

    // Parse HTML body to extract text and images (preserve inline images)
    // Handles both HTML <img> tags and text-based [Image "..."] references
    function parseHtmlBody(htmlBody) {
        if (!htmlBody) return { text: '', images: [], html: '' };
        
        const htmlString = String(htmlBody);
        const images = [];
        let processedHtml = htmlString;
        
        // Step 1: Extract images from HTML <img> tags
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlString;
        
        const imgTags = tempDiv.querySelectorAll('img');
        let imageIndex = 0;
        
        imgTags.forEach((img) => {
            const src = img.getAttribute('src') || '';
            if (src) {
                // Decode HTML entities in URL (but preserve the original URL structure)
                let decodedSrc = src;
                // Only decode if it's clearly an HTML entity, not part of URL encoding
                if (src.includes('&amp;') && !src.includes('?')) {
                    decodedSrc = src.replace(/&amp;/g, '&');
                }
                images.push(decodedSrc);
                
                // Replace img tag with a placeholder
                const placeholder = document.createTextNode(`__IMAGE_PLACEHOLDER_${imageIndex}__`);
                if (img.parentNode) {
                    img.parentNode.replaceChild(placeholder, img);
                }
                imageIndex++;
            }
        });
        
        // Get HTML with placeholders from img tags
        processedHtml = tempDiv.innerHTML;
        
        // Step 2: Extract images from text-based [Image "..."] references
        // Pattern: [Image "URL"] or [Image 'URL'] or [Image URL]
        // Need to handle URLs with query parameters that might contain quotes
        // More robust pattern: [Image "..."], [Image '...'], or [Image ...]
        const imageReferencePattern = /\[Image\s+(?:"([^"]+)"|'([^']+)'|([^\]]+))\]/gi;
        let match;
        const textImageMatches = [];
        
        // Find all matches and their positions
        while ((match = imageReferencePattern.exec(htmlString)) !== null) {
            // match[1] = double-quoted URL, match[2] = single-quoted URL, match[3] = unquoted URL
            const imageUrl = match[1] || match[2] || match[3];
            const fullMatch = match[0];
            const matchIndex = match.index;
            
            if (imageUrl && imageUrl.trim() && !images.includes(imageUrl.trim())) {
                const trimmedUrl = imageUrl.trim();
                // Only add if not already found in HTML img tags
                textImageMatches.push({
                    url: trimmedUrl,
                    fullMatch: fullMatch,
                    index: matchIndex,
                    placeholderIndex: imageIndex
                });
                images.push(trimmedUrl);
                imageIndex++;
            }
        }
        
        // Replace text-based image references with placeholders (in reverse order to preserve indices)
        textImageMatches.reverse().forEach(match => {
            const placeholder = `__IMAGE_PLACEHOLDER_${match.placeholderIndex}__`;
            processedHtml = processedHtml.substring(0, match.index) + 
                          placeholder + 
                          processedHtml.substring(match.index + match.fullMatch.length);
        });
        
        // Step 3: Extract plain text for fallback (remove placeholders)
        const tempDiv2 = document.createElement('div');
        tempDiv2.innerHTML = processedHtml;
        const plainText = tempDiv2.textContent || tempDiv2.innerText || '';
        const cleanedText = plainText.replace(/__IMAGE_PLACEHOLDER_\d+__/g, '').trim();
        
        // Debug logging
        if (images.length > 0) {
            console.log(`📸 Extracted ${images.length} images from message body:`, {
                htmlImages: imgTags.length,
                textReferences: textImageMatches.length,
                totalImages: images.length,
                imageUrls: images
            });
        }
        
        // Return HTML with placeholders, plain text, and images array
        return { 
            text: cleanedText, 
            images: images, 
            html: processedHtml // HTML with image placeholders, preserving other formatting
        };
    }

    // Store all images from conversation for image viewer
    let allConversationImages = [];
    let currentImageIndex = 0;

    // Open image viewer modal
    window.openImageViewer = function(index) {
        if (!allConversationImages || allConversationImages.length === 0) return;
        
        currentImageIndex = Math.max(0, Math.min(index, allConversationImages.length - 1));
        const modal = document.getElementById('imageViewerModal');
        const img = document.getElementById('imageViewerImg');
        const prevBtn = document.getElementById('imageViewerPrev');
        const nextBtn = document.getElementById('imageViewerNext');
        const counter = document.getElementById('imageViewerCounter');
        const closeBtn = document.getElementById('imageViewerClose');
        
        if (modal && img) {
            img.src = allConversationImages[currentImageIndex].src;
            img.style.display = 'block';
            
            // Update counter
            if (counter) {
                counter.textContent = `${currentImageIndex + 1} / ${allConversationImages.length}`;
            }
            
            // Show/hide navigation buttons
            if (prevBtn) {
                prevBtn.style.display = allConversationImages.length > 1 ? 'flex' : 'none';
            }
            if (nextBtn) {
                nextBtn.style.display = allConversationImages.length > 1 ? 'flex' : 'none';
            }
            
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Focus on modal for keyboard navigation
            modal.focus();
        }
    };

    // Close image viewer modal
    window.closeImageViewer = function() {
        const modal = document.getElementById('imageViewerModal');
        if (modal) {
            modal.style.display = 'none';
            document.body.style.overflow = '';
        }
    };

    // Navigate to previous image
    window.navigateImage = function(direction) {
        if (!allConversationImages || allConversationImages.length === 0) return;
        
        if (direction === 'prev') {
            currentImageIndex = (currentImageIndex - 1 + allConversationImages.length) % allConversationImages.length;
        } else if (direction === 'next') {
            currentImageIndex = (currentImageIndex + 1) % allConversationImages.length;
        }
        
        const img = document.getElementById('imageViewerImg');
        const counter = document.getElementById('imageViewerCounter');
        
        if (img) {
            img.style.display = 'none';
            setTimeout(() => {
                img.src = allConversationImages[currentImageIndex].src;
                img.style.display = 'block';
            }, 150);
        }
        
        if (counter) {
            counter.textContent = `${currentImageIndex + 1} / ${allConversationImages.length}`;
        }
    };

    // Sync chat messages to textarea for form submission
    function syncChatToTextarea() {
        if (!chatMessagesContainer || !transcriptTextarea) return;
        
        const messages = chatMessagesContainer.querySelectorAll('div[style*="display: flex"]');
        const transcriptLines = [];
        
        messages.forEach(msgDiv => {
            const authorDiv = msgDiv.querySelector('div[style*="font-size: 0.4852rem"]');
            const messageDiv = msgDiv.querySelector('div[style*="white-space: pre-wrap"]');
            const timeDiv = msgDiv.querySelector('div[style*="font-size: 0.4043rem"]');
            
            if (messageDiv) {
                const author = authorDiv ? authorDiv.textContent.trim() : 'User';
                const message = messageDiv.textContent.trim();
                const time = timeDiv ? timeDiv.textContent.trim() : '';
                
                if (message) {
                    transcriptLines.push(`${author} (${time}): ${message}`);
                }
            }
        });
        
        transcriptTextarea.value = transcriptLines.join('\n\n');
    }

    // Show notification
    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        const bgColor = type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#1A733E';
        
        notification.style.cssText = `
            position: fixed;
            top: 0.6064rem;
            right: 0.6064rem;
            background: ${bgColor};
            color: white;
            padding: 0.3639rem 0.6064rem;
            border-radius: 0.1819rem;
            font-family: 'Poppins', sans-serif;
            font-size: 0.4245rem;
            z-index: 10000;
            box-shadow: 0 0.1213rem 0.3639rem rgba(0,0,0,0.15);
            animation: slideInRight 0.3s ease-out;
        `;
        notification.textContent = message;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }

    // Escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Add CSS animation for spinner and custom scrollbar
    if (!document.getElementById('intercomChatStyles')) {
        const style = document.createElement('style');
        style.id = 'intercomChatStyles';
        style.textContent = `
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
            @keyframes slideInRight {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }
            /* Custom scrollbar for chat interface */
            #transcriptChatView::-webkit-scrollbar {
                width: 0.1819rem;
            }
            #transcriptChatView::-webkit-scrollbar-track {
                background: #f0f2f5;
                border-radius: 0.091rem;
            }
            #transcriptChatView::-webkit-scrollbar-thumb {
                background: #9ca3af;
                border-radius: 0.091rem;
            }
            #transcriptChatView::-webkit-scrollbar-thumb:hover {
                background: #6b7280;
            }
            /* Ensure Interaction Details Bar doesn't get cut off */
            #leftColumn {
                min-width: 13.6451rem !important;
            }
            #leftColumn > div:first-child {
                overflow-x: auto !important;
            }
            #leftColumn > div:first-child::-webkit-scrollbar {
                height: 0.1819rem;
            }
            #leftColumn > div:first-child::-webkit-scrollbar-track {
                background: #f9fafb;
                border-radius: 0.091rem;
            }
            #leftColumn > div:first-child::-webkit-scrollbar-thumb {
                background: #9ca3af;
                border-radius: 0.091rem;
            }
            #leftColumn > div:first-child::-webkit-scrollbar-thumb:hover {
                background: #6b7280;
            }
            /* Custom scrollbar for conversation attributes panels */
            #conversationAttributesContent::-webkit-scrollbar,
            #conversationAttributesPanelTextView::-webkit-scrollbar {
                width: 0.1819rem;
            }
            #conversationAttributesContent::-webkit-scrollbar-track,
            #conversationAttributesPanelTextView::-webkit-scrollbar-track {
                background: #f9fafb;
                border-radius: 0.091rem;
            }
            #conversationAttributesContent::-webkit-scrollbar-thumb,
            #conversationAttributesPanelTextView::-webkit-scrollbar-thumb {
                background: #9ca3af;
                border-radius: 0.091rem;
            }
            #conversationAttributesContent::-webkit-scrollbar-thumb:hover,
            #conversationAttributesPanelTextView::-webkit-scrollbar-thumb:hover {
                background: #6b7280;
            }
        `;
        document.head.appendChild(style);
    }

    // Make sync function globally accessible for form submission
    window.syncChatMessagesToTextarea = syncChatToTextarea;

    // Function removed - attributes are now always shown by default

    // Display all conversation attributes in UI-friendly format
    // Toggle function for conversation info grid
    function toggleConversationInfoGrid() {
        const content = document.getElementById('conversationInfoGridContent');
        const icon = document.getElementById('toggleInfoGridIcon');
        if (!content || !icon) return;
        
        const isHidden = content.style.display === 'none';
        content.style.display = isHidden ? 'grid' : 'none';
        icon.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
    }
    
    // Make toggle function globally accessible
    window.toggleConversationInfoGrid = toggleConversationInfoGrid;
    
    // Language detection function - simple heuristic to detect non-English text
    function detectLanguage(text) {
        if (!text || text.trim().length === 0) return 'en';
        
        // Remove HTML tags and get plain text
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        const plainText = tempDiv.textContent || tempDiv.innerText || '';
        
        // Simple heuristic: check for common English patterns
        // Count English letters vs non-English characters
        const englishPattern = /[a-zA-Z]/g;
        const nonEnglishPattern = /[^\x00-\x7F]/g;
        
        const englishChars = (plainText.match(englishPattern) || []).length;
        const nonEnglishChars = (plainText.match(nonEnglishPattern) || []).length;
        const totalChars = plainText.replace(/\s/g, '').length;
        
        // If more than 30% non-ASCII characters, likely not English
        if (totalChars > 0 && (nonEnglishChars / totalChars) > 0.3) {
            return 'auto'; // Needs translation
        }
        
        // Check for common non-English language patterns
        const commonNonEnglishPatterns = [
            /[\u0600-\u06FF]/g, // Arabic
            /[\u4E00-\u9FFF]/g, // Chinese
            /[\u3040-\u309F\u30A0-\u30FF]/g, // Japanese
            /[\u0400-\u04FF]/g, // Cyrillic
            /[\u0590-\u05FF]/g, // Hebrew
            /[\u0E00-\u0E7F]/g, // Thai
        ];
        
        for (const pattern of commonNonEnglishPatterns) {
            if (pattern.test(plainText)) {
                return 'auto'; // Needs translation
            }
        }
        
        return 'en'; // Likely English
    }
    
    // Translate text using LibreTranslate API with retry logic
    async function translateText(text, targetLang = 'en', retryCount = 0) {
        if (!text || text.trim().length === 0) return text;
        
        const maxRetries = 3;
        const baseDelay = 1000; // Start with 1 second delay
        
        try {
            // Use LibreTranslate public API
            const response = await fetch('https://libretranslate.com/translate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    q: text,
                    source: 'auto',
                    target: targetLang,
                    format: 'text'
                })
            });
            
            // Handle rate limiting with exponential backoff
            if (response.status === 429) {
                if (retryCount < maxRetries) {
                    const delay = baseDelay * Math.pow(2, retryCount); // Exponential backoff: 1s, 2s, 4s
                    console.log(`Rate limited. Retrying in ${delay}ms... (attempt ${retryCount + 1}/${maxRetries})`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return translateText(text, targetLang, retryCount + 1);
                } else {
                    throw new Error('Rate limit exceeded. Please try again later.');
                }
            }
            
            // Handle bad requests (400) - skip this message
            if (response.status === 400) {
                console.warn('Bad request for translation, skipping:', text.substring(0, 50));
                return text; // Return original text
            }
            
            if (!response.ok) {
                throw new Error(`Translation API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.translatedText || text;
        } catch (error) {
            // If it's a rate limit error and we've exhausted retries, try fallback
            if (error.message.includes('Rate limit') && retryCount >= maxRetries) {
                console.log('Trying fallback translation API...');
                // Fallback: try MyMemory Translation API
                try {
                    const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=auto|en`);
                    const data = await response.json();
                    if (data.responseData && data.responseData.translatedText) {
                        return data.responseData.translatedText;
                    }
                } catch (fallbackError) {
                    console.error('Fallback translation error:', fallbackError);
                }
            }
            
            // If error doesn't mention rate limit, log it but return original text
            if (!error.message.includes('Rate limit')) {
                console.error('Translation error:', error);
            }
            
            return text; // Return original if translation fails
        }
    }
    
    // Main translation function
    async function translateChatMessages() {
        // Feature is currently disabled
        const translateBtn = document.getElementById('translateChatBtn');
        if (translateBtn && translateBtn.disabled) {
            return;
        }
        
        const chatMessagesContainer = document.getElementById('chatMessagesContainer');
        
        if (!chatMessagesContainer) {
            showNotification('Chat messages container not found', 'error');
            return;
        }
        
        // Get all message text elements
        const messageTextElements = chatMessagesContainer.querySelectorAll('.message-text-content');
        
        if (messageTextElements.length === 0) {
            showNotification('No messages to translate', 'info');
            return;
        }
        
        // Disable button and show loading state
        if (translateBtn) {
            translateBtn.disabled = true;
            const originalText = translateBtn.querySelector('span').textContent;
            translateBtn.querySelector('span').textContent = 'Translating...';
            translateBtn.style.opacity = '0.6';
            translateBtn.style.cursor = 'not-allowed';
        }
        
        let translatedCount = 0;
        let skippedCount = 0;
        
        // Process messages sequentially to avoid rate limiting
        // Use longer delays for public API (500ms between requests)
        const delayBetweenRequests = 500;
        
        for (let i = 0; i < messageTextElements.length; i++) {
            const element = messageTextElements[i];
            const originalText = element.getAttribute('data-original-text');
            if (!originalText) continue;
            
            // Decode HTML entities to get plain text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalText;
            const plainText = tempDiv.textContent || tempDiv.innerText || '';
            
            // Skip if text is too short or empty
            if (plainText.trim().length < 3) {
                skippedCount++;
                continue;
            }
            
            // Detect language
            const detectedLang = detectLanguage(plainText);
            
            if (detectedLang === 'en') {
                skippedCount++;
                continue; // Skip English messages
            }
            
            // Update button text to show progress
            if (translateBtn && i % 5 === 0) {
                const remaining = messageTextElements.length - i;
                translateBtn.querySelector('span').textContent = `Translating... (${remaining} remaining)`;
            }
            
            // Translate the text
            try {
                const translatedText = await translateText(plainText, 'en');
                
                // Only update if translation is different from original
                if (translatedText && translatedText.trim() !== plainText.trim() && translatedText !== plainText) {
                    // Update the element with translated text (escape HTML for safety)
                    element.innerHTML = escapeHtml(translatedText);
                    translatedCount++;
                } else {
                    skippedCount++;
                }
                
                // Delay between requests to avoid rate limiting (500ms)
                // Skip delay for last message
                if (i < messageTextElements.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, delayBetweenRequests));
                }
            } catch (error) {
                console.error('Error translating message:', error);
                skippedCount++;
                // If rate limited, add extra delay
                if (error.message && error.message.includes('Rate limit')) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
        }
        
        // Re-enable button
        if (translateBtn) {
            translateBtn.disabled = false;
            translateBtn.querySelector('span').textContent = 'Translate';
            translateBtn.style.opacity = '1';
            translateBtn.style.cursor = 'pointer';
        }
        
        // Show completion notification
        if (translatedCount > 0) {
            showNotification(`Translated ${translatedCount} message(s) to English`, 'success');
        } else if (skippedCount > 0) {
            showNotification('All messages are already in English', 'info');
        } else {
            showNotification('No messages found to translate', 'info');
        }
    }
    
    // Make translation function globally accessible
    window.translateChatMessages = translateChatMessages;
    
    function displayConversationAttributes(conversation) {
        // Hide the old panels
        const chatPanel = document.getElementById('conversationAttributesPanel');
        const textPanel = document.getElementById('conversationAttributesPanelTextView');
        if (chatPanel) chatPanel.style.display = 'none';
        if (textPanel) textPanel.style.display = 'none';
        
        // Show and populate the expanded info grid
        const infoGrid = document.getElementById('conversationInfoGrid');
        if (!infoGrid) return;
        
        const attributes = extractConversationAttributes(conversation);
        infoGrid.style.display = 'block';
        
        // Helper function to format value
        const formatValue = (key, value) => {
            if (value === null || value === undefined) return null;
            if (typeof value === 'boolean') return value ? 'Yes' : 'No';
            
            // Handle URLs (for Web Link)
            if (key.toLowerCase().includes('link') || key.toLowerCase().includes('url')) {
                const url = String(value);
                if (url.startsWith('http://') || url.startsWith('https://')) {
                    return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" style="color: #1A733E; text-decoration: underline; font-weight: 600;">View in Intercom →</a>`;
                }
            }
            
            if (typeof value === 'object') {
                if (Array.isArray(value)) {
                    if (value.length === 0) return null;
                    return value.map(item => {
                        if (typeof item === 'object') {
                            return Object.values(item).filter(v => v).join(' - ');
                        }
                        return String(item);
                    }).join(', ');
                }
                return JSON.stringify(value, null, 2);
            }
            return String(value);
        };
        
        // Helper function to get icon and color for a key
        const getIconAndColor = (key) => {
            const iconMap = {
                'State': { icon: 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z', color: '#1A733E' },
                'Priority': { icon: 'M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z', color: '#f59e0b' },
                'Total Messages': { icon: 'M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z', color: '#3b82f6' },
                'Time to Admin Reply': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
                'Time to Assignment': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
                'Time to First Close': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
                'Time to Last Close': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
                'Median Time to Reply': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
                'Author Email': { icon: 'M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z', color: '#ec4899' },
                'Assigned To': { icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z', color: '#10b981' },
                'Created At': { icon: 'M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z', color: '#6366f1' },
                'Updated At': { icon: 'M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z', color: '#6366f1' },
                'Rating': { icon: 'M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z', color: '#f97316' },
                'Tags': { icon: 'M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z', color: '#06b6d4' },
                'User Messages': { icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z', color: '#3b82f6' },
                'Admin Messages': { icon: 'M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z', color: '#10b981' },
                'Reopens Count': { icon: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15', color: '#f59e0b' },
                'Assignments Count': { icon: 'M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2', color: '#8b5cf6' }
            };
            
            return iconMap[key] || { icon: 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z', color: '#6b7280' };
        };
        
        // Helper function to create copy button
        const createCopyButton = (value, fieldName) => {
            if (!value) return '';
            return `
                <button onclick="event.stopPropagation(); navigator.clipboard.writeText('${escapeHtml(String(value))}').then(() => showNotification('${fieldName} copied!', 'success')).catch(() => showNotification('Failed to copy', 'error')); return false;" 
                    style="padding: 0.0808rem; background: rgba(26, 115, 62, 0.1); border: none; border-radius: 0.1617rem; cursor: pointer; transition: all 0.2s; margin-left: 0.1617rem;"
                    onmouseover="this.style.background='rgba(26, 115, 62, 0.2)';" onmouseout="this.style.background='rgba(26, 115, 62, 0.1)';"
                    title="Copy ${fieldName}">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.3234rem; height: 0.3234rem; color: #1A733E;">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                    </svg>
                </button>
            `;
        };
        
        let html = '';
        const gridContainer = document.getElementById('conversationInfoGridContent');
        if (!gridContainer) return;
        
        // Display ALL attributes
        Object.keys(attributes).forEach(key => {
            const value = formatValue(key, attributes[key]);
            if (!value) return;
            
            const label = formatLabelForAttribute(key);
            const { icon, color } = getIconAndColor(key);
            const needsCopyButton = key === 'Author Email' || key === 'Custom: Account Number (MT4/MT5)' || key === 'Conversation ID';
            const copyBtn = needsCopyButton ? createCopyButton(attributes[key], label) : '';
            
            html += `
                <div style="background: #ffffff; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; padding: 0.3234rem; box-shadow: 0 0.0203rem 0.0606rem rgba(0,0,0,0.05); transition: all 0.2s;" onmouseover="this.style.boxShadow='0 0.0405rem 0.1213rem rgba(0,0,0,0.1)'; this.style.borderColor='#1A733E';" onmouseout="this.style.boxShadow='0 0.0203rem 0.0606rem rgba(0,0,0,0.05)'; this.style.borderColor='#e5e7eb';">
                    <div style="display: flex; align-items: center; gap: 0.2425rem; margin-bottom: 0.1617rem;">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem; color: ${color}; flex-shrink: 0;">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${icon}"></path>
                        </svg>
                        <span style="font-size: 0.3639rem; font-weight: 600; color: #6b7280; text-transform: uppercase; letter-spacing: 0.0092rem;">${escapeHtml(label)}</span>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <span style="font-size: 0.4447rem; font-weight: 600; color: #1f2937; word-break: break-word; flex: 1;">${key.toLowerCase().includes('link') ? value : escapeHtml(String(value))}</span>
                        ${copyBtn}
                    </div>
                </div>
            `;
        });
        
        gridContainer.innerHTML = html;
    }
    
    // Helper function to format label (used in both functions)
    function formatLabelForAttribute(label) {
        return label.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    }
    
    // Extract all relevant conversation attributes from Intercom API response
    function extractConversationAttributes(conversation) {
        const attributes = {};
        
        // Helper function to convert Unix timestamp to readable date
        const formatTimestamp = (timestamp) => {
            if (!timestamp) return null;
            const date = typeof timestamp === 'number' 
                ? new Date(timestamp < 10000000000 ? timestamp * 1000 : timestamp)
                : new Date(timestamp);
            if (isNaN(date.getTime())) return null;
            return date.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                hour12: true
            });
        };
        
        // Basic Information
        if (conversation.id) attributes['Conversation ID'] = conversation.id;
        if (conversation.type) attributes['Type'] = conversation.type;
        if (conversation.state) attributes['State'] = conversation.state;
        if (conversation.read) attributes['Read'] = conversation.read;
        if (conversation.created_at) attributes['Created At'] = formatTimestamp(conversation.created_at);
        if (conversation.updated_at) attributes['Updated At'] = formatTimestamp(conversation.updated_at);
        if (conversation.waiting_since) attributes['Waiting Since'] = formatTimestamp(conversation.waiting_since);
        
        // Source Information
        if (conversation.source) {
            if (conversation.source.type) attributes['Source Type'] = conversation.source.type;
            if (conversation.source.id) attributes['Source ID'] = conversation.source.id;
            if (conversation.source.delivered_as) attributes['Delivered As'] = conversation.source.delivered_as;
            if (conversation.source.subject) attributes['Subject'] = conversation.source.subject;
            
            // Author (who initiated)
            if (conversation.source.author) {
                const author = conversation.source.author;
                if (author.type) attributes['Author Type'] = author.type;
                if (author.id) attributes['Author ID'] = author.id;
                if (author.name) attributes['Author Name'] = author.name;
                if (author.email) attributes['Author Email'] = author.email;
            }
            
            // Owner (assigned to)
            if (conversation.source.owner) {
                const owner = conversation.source.owner;
                if (owner.type) attributes['Owner Type'] = owner.type;
                if (owner.id) attributes['Owner ID'] = owner.id;
                if (owner.name) attributes['Assigned To'] = owner.name;
                if (owner.email) attributes['Owner Email'] = owner.email;
            }
        }
        
        // Statistics
        if (conversation.statistics) {
            const stats = conversation.statistics;
            if (stats.time_to_assignment !== undefined && stats.time_to_assignment !== null) attributes['Time to Assignment'] = `${Math.round(stats.time_to_assignment / 60)} minutes`;
            if (stats.time_to_admin_reply !== undefined && stats.time_to_admin_reply !== null) attributes['Time to Admin Reply'] = `${Math.round(stats.time_to_admin_reply / 60)} minutes`;
            if (stats.time_to_first_close !== undefined && stats.time_to_first_close !== null) attributes['Time to First Close'] = `${Math.round(stats.time_to_first_close / 60)} minutes`;
            if (stats.time_to_last_close !== undefined && stats.time_to_last_close !== null) attributes['Time to Last Close'] = `${Math.round(stats.time_to_last_close / 60)} minutes`;
            if (stats.median_time_to_reply !== undefined && stats.median_time_to_reply !== null) attributes['Median Time to Reply'] = `${Math.round(stats.median_time_to_reply / 60)} minutes`;
            if (stats.first_contact_reply_at) attributes['First Contact Reply At'] = formatTimestamp(stats.first_contact_reply_at);
            if (stats.first_admin_reply_at) attributes['First Admin Reply At'] = formatTimestamp(stats.first_admin_reply_at);
            if (stats.last_contact_reply_at) attributes['Last Contact Reply At'] = formatTimestamp(stats.last_contact_reply_at);
            if (stats.last_admin_reply_at) attributes['Last Admin Reply At'] = formatTimestamp(stats.last_admin_reply_at);
            if (stats.count_reopens) attributes['Reopens Count'] = stats.count_reopens;
            if (stats.count_assignments) attributes['Assignments Count'] = stats.count_assignments;
        }
        
        // Tags
        if (conversation.tags && conversation.tags.tags && conversation.tags.tags.length > 0) {
            attributes['Tags'] = conversation.tags.tags.map(tag => tag.name || tag).join(', ');
        }
        
        // Teammates (participating admins)
        if (conversation.teammates && conversation.teammates.teammates && conversation.teammates.teammates.length > 0) {
            attributes['Teammates'] = conversation.teammates.teammates.map(teammate => 
                teammate.name || teammate.email || teammate.id
            ).join(', ');
        }
        
        // Contacts (users involved)
        if (conversation.contacts && conversation.contacts.contacts && conversation.contacts.contacts.length > 0) {
            const contacts = conversation.contacts.contacts.map(contact => {
                const parts = [];
                if (contact.name) parts.push(contact.name);
                if (contact.email) parts.push(contact.email);
                return parts.length > 0 ? parts.join(' - ') : contact.id;
            });
            attributes['Contacts'] = contacts.join(', ');
        }
        
        // Conversation Parts Summary
        if (conversation.conversation_parts && conversation.conversation_parts.conversation_parts) {
            const parts = conversation.conversation_parts.conversation_parts;
            attributes['Total Messages'] = parts.length;
            
            const userMessages = parts.filter(p => p.author && (p.author.type === 'user' || p.author.type === 'contact')).length;
            const adminMessages = parts.filter(p => p.author && (p.author.type === 'admin' || p.author.type === 'team')).length;
            
            if (userMessages > 0) attributes['User Messages'] = userMessages;
            if (adminMessages > 0) attributes['Admin Messages'] = adminMessages;
        }
        
        // Priority
        if (conversation.priority) {
            attributes['Priority'] = conversation.priority === 'priority' ? 'High' : conversation.priority;
        }
        
        // Custom Attributes (if any)
        if (conversation.custom_attributes) {
            Object.entries(conversation.custom_attributes).forEach(([key, value]) => {
                if (value !== null && value !== undefined) {
                    attributes[`Custom: ${formatLabelForAttribute(key)}`] = value;
                }
            });
        }
        
        // Links (store URL separately, will be handled in display)
        if (conversation.links) {
            if (conversation.links.conversation_web) {
                attributes['Web Link'] = conversation.links.conversation_web;
            }
        }
        
        // Conversation Rating (if available)
        if (conversation.conversation_rating) {
            attributes['Rating'] = conversation.conversation_rating.rating || 'N/A';
            if (conversation.conversation_rating.remark) {
                attributes['Rating Remark'] = conversation.conversation_rating.remark;
            }
        }
        
        return attributes;
    }
});

// ============================================================================
// Resizable Splitter Functionality (matching expert-audits.html)
// ============================================================================
document.addEventListener('DOMContentLoaded', function() {
    const splitter = document.getElementById('splitter');
    const leftColumn = document.getElementById('leftColumn');
    const rightColumn = document.getElementById('rightColumn');
    const auditContent = document.getElementById('auditContent');
    
    if (splitter && leftColumn && rightColumn && auditContent) {
        let isResizing = false;
        
        splitter.addEventListener('mousedown', function(e) {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            splitter.style.background = '#9ca3af';
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const containerRect = auditContent.getBoundingClientRect();
            const offsetX = e.clientX - containerRect.left;
            const containerWidth = containerRect.width;
            
            // Calculate percentage (with min/max constraints)
            // Min width: 13.6451rem (~13.625rem at 1.0rem base) - convert to percentage
            // Max width: 75% of container
            const minWidthPx = 13.6451 * 16; // Convert rem to pixels (assuming 1.0rem base)
            const minWidthPercent = Math.max(15, (minWidthPx / containerWidth) * 100); // At least 15%
            const maxWidthPercent = 75; // Maximum 75% of container
            
            let leftPercentage = (offsetX / containerWidth) * 100;
            leftPercentage = Math.max(minWidthPercent, Math.min(maxWidthPercent, leftPercentage));
            
            leftColumn.style.width = leftPercentage + '%';
            leftColumn.style.flex = '0 0 ' + leftPercentage + '%';
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                splitter.style.background = '#e5e7eb';
            }
        });
        
        // Hover effect
        splitter.addEventListener('mouseenter', function() {
            if (!isResizing) {
                splitter.style.background = '#d1d5db';
            }
        });
        
        splitter.addEventListener('mouseleave', function() {
            if (!isResizing) {
                splitter.style.background = '#e5e7eb';
            }
        });
    }
    
    // Select all checkbox event listener
    const selectAllCheckbox = document.getElementById('selectAllPullConversations');
    if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', function() {
            selectAllPullConversations(this.checked);
        });
    }
    
});

// ============================================================================
// Helper Function: Submit Dummy Audit Data (for testing)
// Usage: Call window.submitDummyAudit() in the browser console
// ============================================================================
window.submitDummyAudit = async function() {
    console.log('=== Starting Dummy Audit Submission ===');
    
    try {
        // Step 1: Open the manual audit form
        if (typeof window.createManualAudit === 'function') {
            await window.createManualAudit();
            console.log('✓ Opened audit form');
            await new Promise(resolve => setTimeout(resolve, 1500));
        } else {
            console.error('createManualAudit function not found');
            return;
        }
        
        // Step 2: Select first available scorecard
        const scorecardSelect = document.getElementById('scorecardSelect');
        if (!scorecardSelect || scorecardSelect.options.length <= 1) {
            console.error('No scorecards available');
            return;
        }
        
        scorecardSelect.value = scorecardSelect.options[1].value;
        scorecardSelect.dispatchEvent(new Event('change', { bubbles: true }));
        console.log('✓ Selected scorecard:', scorecardSelect.options[1].text);
        
        // Wait for parameters to load
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Step 3: Fill employee information
        const employeeSelect = document.getElementById('employeeName');
        if (employeeSelect && employeeSelect.options.length > 1) {
            employeeSelect.value = employeeSelect.options[1].value;
            employeeSelect.dispatchEvent(new Event('change', { bubbles: true }));
            console.log('✓ Selected employee:', employeeSelect.options[1].text);
        } else {
            // Fill manually if dropdown not available
            const employeeName = document.getElementById('employeeName');
            const employeeEmail = document.getElementById('employeeEmail');
            const employeeType = document.getElementById('employeeType');
            const countryOfEmployee = document.getElementById('countryOfEmployee');
            
            if (employeeName && employeeName.tagName === 'INPUT') employeeName.value = 'John Doe';
            if (employeeEmail) employeeEmail.value = 'john.doe@example.com';
            if (employeeType) employeeType.value = 'Employee';
            if (countryOfEmployee) countryOfEmployee.value = 'Bangladesh';
            console.log('✓ Filled employee info (dummy)');
        }
        
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Step 4: Fill interaction details
        const interactionId = document.getElementById('interactionId');
        const interactionDate = document.getElementById('interactionDate');
        const channel = document.getElementById('channel');
        const clientEmail = document.getElementById('clientEmail');
        
        if (interactionId) {
            interactionId.value = 'INT-' + Date.now();
            console.log('✓ Filled interaction ID:', interactionId.value);
        }
        
        if (interactionDate) {
            const today = new Date();
            interactionDate.value = today.toISOString().split('T')[0];
            console.log('✓ Filled interaction date:', interactionDate.value);
        }
        
        if (channel) {
            if (channel.options && channel.options.length > 1) {
                channel.value = channel.options[1].value;
                channel.dispatchEvent(new Event('change', { bubbles: true }));
            } else {
                channel.value = 'FN Email';
            }
            console.log('✓ Selected channel:', channel.value);
        }
        
        if (clientEmail) {
            clientEmail.value = 'client@example.com';
            console.log('✓ Filled client email');
        }
        
        // Step 5: Fill transcript
        const transcript = document.getElementById('transcript');
        if (transcript) {
            transcript.value = `Customer: Hello, I need help with my account.
Agent: Hello! I'd be happy to help you with your account. Could you please provide me with your account number?
Customer: Sure, it's 123456789.
Agent: Thank you. I can see your account. How can I assist you today?
Customer: I want to update my email address.
Agent: I can help you with that. What is your new email address?
Customer: newemail@example.com
Agent: Perfect, I've updated your email address. Is there anything else I can help you with?
Customer: No, that's all. Thank you!
Agent: You're welcome! Have a great day!`;
            transcript.dispatchEvent(new Event('input', { bubbles: true }));
            console.log('✓ Filled transcript');
        }
        
        // Step 6: Fill audit type and validation status
        const auditType = document.getElementById('auditType');
        const validationStatus = document.getElementById('validationStatus');
        
        if (auditType) {
            auditType.value = 'Routine Audit (Recorded)';
            auditType.dispatchEvent(new Event('change', { bubbles: true }));
            console.log('✓ Selected audit type');
        }
        
        if (validationStatus) {
            validationStatus.value = 'Validated';
            console.log('✓ Selected validation status');
        }
        
        // Step 7: Fill pre/post status
        const agentPreStatus = document.getElementById('agentPreStatus');
        const agentPostStatus = document.getElementById('agentPostStatus');
        
        if (agentPreStatus) {
            agentPreStatus.value = 'No active quality concerns';
            console.log('✓ Selected pre-status');
        }
        
        if (agentPostStatus) {
            agentPostStatus.value = 'No active quality concerns';
            console.log('✓ Selected post-status');
        }
        
        // Step 8: Fill error parameters
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const errorParametersContainer = document.getElementById('errorParametersContainer');
        if (errorParametersContainer) {
            const counterInputs = errorParametersContainer.querySelectorAll('input[type="number"]');
            const radioGroups = errorParametersContainer.querySelectorAll('input[type="radio"]');
            const feedbackInputs = errorParametersContainer.querySelectorAll('input[id^="feedback_"]');
            
            // Fill first 3 counters with random values (1-2)
            counterInputs.forEach((input, index) => {
                if (index < 3) {
                    input.value = Math.floor(Math.random() * 2) + 1;
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                    console.log(`✓ Filled counter ${input.id || input.name}: ${input.value}`);
                }
            });
            
            // Select some radio buttons
            let radioIndex = 0;
            radioGroups.forEach((radio) => {
                if (radioIndex < 2 && radio.value === '1') {
                    radio.checked = true;
                    radio.dispatchEvent(new Event('change', { bubbles: true }));
                    console.log(`✓ Selected radio ${radio.name}: ${radio.value}`);
                    radioIndex++;
                }
            });
            
            // Fill feedback fields
            feedbackInputs.forEach((input, index) => {
                if (index < 3 && (!input.value || input.value.trim() === '')) {
                    input.value = `Sample feedback for error parameter ${index + 1}. This is dummy data for testing purposes. Agent demonstrated good communication skills but needs improvement in handling customer requests.`;
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                    console.log(`✓ Filled feedback ${input.id || input.name}`);
                }
            });
        }
        
        // Wait for calculations to update
        await new Promise(resolve => setTimeout(resolve, 1500));
        
        // Step 9: Fill recommendations
        const recommendations = document.getElementById('recommendations');
        if (recommendations) {
            recommendations.value = `Recommendations for improvement:
1. Continue maintaining professional communication standards
2. Ensure all customer information is verified before making changes
3. Follow up with customers to ensure satisfaction

Next Steps:
- Review this audit with the employee
- Provide additional training if needed
- Schedule follow-up audit in next quarter`;
            recommendations.dispatchEvent(new Event('input', { bubbles: true }));
            console.log('✓ Filled recommendations');
        }
        
        // Step 10: Final wait and submit
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        console.log('=== Submitting form ===');
        const auditForm = document.getElementById('auditForm');
        if (auditForm) {
            // Trigger form validation and submission
            const submitBtn = auditForm.querySelector('button[type="submit"]');
            if (submitBtn) {
                submitBtn.click();
                console.log('✓ Form submission triggered!');
            } else {
                const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
                auditForm.dispatchEvent(submitEvent);
                console.log('✓ Form submitted via event!');
            }
            console.log('=== Dummy Audit Submission Complete ===');
        } else {
            console.error('Audit form not found');
        }
        
    } catch (error) {
        console.error('Error submitting dummy audit:', error);
        console.error('Stack:', error.stack);
    }
};
</script>

    <!-- Image Viewer Modal -->
    <div id="imageViewerModal" tabindex="0" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 10000; align-items: center; justify-content: center; cursor: pointer;" onclick="if(event.target.id === 'imageViewerModal') window.closeImageViewer();" onkeydown="if(event.key === 'Escape') window.closeImageViewer(); if(event.key === 'ArrowLeft') window.navigateImage('prev'); if(event.key === 'ArrowRight') window.navigateImage('next');">
        <!-- Close Button -->
        <button id="imageViewerClose" onclick="window.closeImageViewer(); event.stopPropagation();" style="position: absolute; top: 1rem; right: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 2.5rem; height: 2.5rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Close (Esc)">
            ×
        </button>
        
        <!-- Previous Button -->
        <button id="imageViewerPrev" onclick="window.navigateImage('prev'); event.stopPropagation();" style="position: absolute; left: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 3rem; height: 3rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Previous (←)">
            ‹
        </button>
        
        <!-- Next Button -->
        <button id="imageViewerNext" onclick="window.navigateImage('next'); event.stopPropagation();" style="position: absolute; right: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 3rem; height: 3rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Next (→)">
            ›
        </button>
        
        <!-- Image Counter -->
        <div id="imageViewerCounter" style="position: absolute; bottom: 1rem; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); color: white; padding: 0.5rem 1rem; border-radius: 1.5rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; z-index: 10001;">
            1 / 1
        </div>
        
        <!-- Image Container -->
        <div style="max-width: 95%; max-height: 95%; display: flex; align-items: center; justify-content: center;" onclick="event.stopPropagation();">
            <img id="imageViewerImg" src="" alt="Conversation image" style="max-width: 100%; max-height: 90vh; object-fit: contain; border-radius: 0.5rem; box-shadow: 0 0.5rem 2rem rgba(0,0,0,0.5);">
        </div>
    </div>

</body>
</html>