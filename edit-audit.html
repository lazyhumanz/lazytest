<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Edit Audit | QMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="intercom-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="access-control.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="load-sidebar.js"></script>
    <script src="search.js"></script>
    <script src="audit-template.js"></script>
    <script src="keyboard-shortcuts.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f9fafb;
        }
        
        .full-width-container {
            width: 100%;
            padding: 0;
            margin: 0;
        }
        
        /* Override main-content padding and width for full-width form */
        .main-content {
            padding: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
        }
        
    </style>
</head>

<body style="margin: 0; padding: 0;">
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
<main class="main-content" role="main">
<div class="full-width-container">

    <!-- Edit Form - No reversal form needed in edit mode -->

    <!-- Audit Content Container -->
    <div id="auditContainer" style="width: 100%; box-sizing: border-box;">
        <!-- Loading indicator -->
        <div id="loadingIndicator" style="display: flex; align-items: center; justify-content: center; padding: 3rem; width: 100%;">
            <div style="text-align: center;">
                <div style="border: 0.1406rem solid #f3f4f6; border-top: 0.1406rem solid #1A733E; border-radius: 50%; width: 2.25rem; height: 2.25rem; animation: spin 1s linear infinite; margin: 0 auto 0.75rem;"></div>
                <p style="color: #6b7280; font-family: 'Poppins', sans-serif;">Loading audit details...</p>
            </div>
        </div>

        <!-- Error message -->
        <div id="errorMessage" style="display: none; text-align: center; padding: 1.5rem; color: #ef4444; font-family: 'Poppins', sans-serif; width: 100%;">
            <p style="font-size: 0.8438rem; font-weight: 600; margin-bottom: 0.375rem;">Error Loading Audit</p>
            <p id="errorText" style="font-size: 0.6562rem;"></p>
            <button onclick="window.history.back()" style="margin-top: 0.75rem; padding: 0.375rem 1.125rem; background-color: #1A733E; color: white; border: none; border-radius: 0.1875rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer;">Go Back</button>
        </div>

        <!-- Audit content will be dynamically loaded here -->
        <div id="auditContent"></div>
    </div>

</div>
<!-- End full-width-container -->
</main>

<style>
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    @keyframes pulse-attention {
        0%, 100% { 
            opacity: 1;
            transform: scale(1);
        }
        50% { 
            opacity: 0.8;
            transform: scale(1.02);
        }
    }

    @keyframes spin-slow {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    @keyframes flash-text {
        0%, 100% { 
            opacity: 1;
        }
        50% { 
            opacity: 0.6;
        }
    }

    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        10%, 30%, 50%, 70%, 90% { transform: translateX(-2px); }
        20%, 40%, 60%, 80% { transform: translateX(2px); }
    }


/* Chat view scrollbar styling */
#transcriptChatView::-webkit-scrollbar {
    width: 0.3234rem;
}

#transcriptChatView::-webkit-scrollbar-track {
    background: #f0f2f5;
}

#transcriptChatView::-webkit-scrollbar-thumb {
    background: #9ca3af;
    border-radius: 0.1617rem;
}

#transcriptChatView::-webkit-scrollbar-thumb:hover {
    background: #6b7280;
    }
</style>

<script>
// Global audit data
let currentAudit = null;
let currentScorecardId = null;
let currentTableName = null;
let currentErrorFields = [];
let currentUserEmail = null;
let currentAuditScorecard = null;

// Get current logged-in user email
function getCurrentUserEmail() {
    try {
        const userInfo = localStorage.getItem('userInfo');
        if (userInfo) {
            const user = JSON.parse(userInfo);
            return user?.email || null;
        }
    } catch (error) {
        console.error('Error getting current user email:', error);
    }
    return null;
}

// Get current logged-in user info
function getCurrentUserInfo() {
    try {
        const userInfo = localStorage.getItem('userInfo');
        if (userInfo) {
            return JSON.parse(userInfo);
        }
    } catch (error) {
        console.error('Error getting current user info:', error);
    }
    return null;
}

// Check if current user is the audited employee
function isCurrentUserAuditedEmployee() {
    if (!currentUserEmail || !currentAudit) {
        return false;
    }
    
    // Compare emails (case-insensitive)
    const auditEmployeeEmail = currentAudit.employeeEmail || currentAudit.employee_email || '';
    return auditEmployeeEmail.toLowerCase() === currentUserEmail.toLowerCase();
}

// Check if current user is a Quality Analyst or above (not an Agent/Employee)
function isCurrentUserQualityAnalyst() {
    const userInfo = getCurrentUserInfo();
    if (!userInfo) {
        return false;
    }
    
    const role = userInfo.role || '';
    // Allow Quality Analyst and any role above (not Employee)
    return role !== 'Employee' && role !== '';
}

// Check if current user is an Agent/Employee
function isCurrentUserAgent() {
    const userInfo = getCurrentUserInfo();
    if (!userInfo) {
        return false;
    }
    
    const role = userInfo.role || '';
    return role === 'Employee';
}

// Check if current user is the auditor of the current audit
function isCurrentUserAuditor() {
    if (!currentUserEmail || !currentAudit) {
        return false;
    }
    
    // Compare emails (case-insensitive)
    const auditAuditorEmail = currentAudit.auditorEmail || currentAudit.auditor_email || '';
    return auditAuditorEmail.toLowerCase() === currentUserEmail.toLowerCase();
}

// Helper function to check if acknowledgement status is considered "acknowledged" (locked, no edits/comments)
function isAcknowledgedStatus(status) {
    if (!status) return false;
    const statusLower = status.toLowerCase();
    return statusLower === 'acknowledged' || 
           statusLower === 'acknowledged - after reversal approved' || 
           statusLower === 'acknowledged - after reversal rejected';
}

// Helper function to check if acknowledgement status should show acknowledge button
function shouldShowAcknowledgeButtonForStatus(status) {
    if (!status) return true; // Empty status - show button
    const statusLower = status.toLowerCase();
    
    // Show button for pending statuses (needs acknowledgment)
    return statusLower === 'pending' || 
           statusLower === 'pending - after reversal approved' || 
           statusLower === 'pending - after reversal rejected';
    
    // All acknowledged statuses return false (locked)
}

// Check if there's a pending reversal request
function hasPendingReversalRequest() {
    if (!currentAudit) {
        return false;
    }
    
    // The schema doesn't have reversal_status column
    // Status is determined by reversal_approved and reversal_responded_at
    const reversalRequestedAt = currentAudit.reversal_requested_at || currentAudit.reversalRequestedAt;
    const reversalRespondedAt = currentAudit.reversal_responded_at || currentAudit.reversalRespondedAt;
    const reversalApproved = currentAudit.reversal_approved || currentAudit.reversalApproved;
    
    // Pending if reversal was requested but not yet responded to
    if (reversalRequestedAt && !reversalRespondedAt) {
        return true;
    }
    
    // Also check if reversal_approved is null (which means pending)
    if (reversalRequestedAt && reversalApproved === null || reversalApproved === undefined) {
        return true;
    }
    
    return false;
}

// Check if edit button should be shown
function shouldShowEditButton() {
    // Check if audit is acknowledged - if so, lock editing for everyone
    const acknowledgementStatus = currentAudit?.acknowledgementStatus || currentAudit?.acknowledgement_status || '';
    if (isAcknowledgedStatus(acknowledgementStatus)) {
        return false; // Locked - no edits allowed
    }
    
    // Auditors can edit anytime unless acknowledged
    if (isCurrentUserAuditor()) {
        return true;
    }
    
    // For Quality Analysts (non-auditors), can only edit when reversal is pending
    if (hasPendingReversalRequest() && isCurrentUserQualityAnalyst()) {
        return true;
    }
    
    return false;
}

// Check if reversal approval interface should be shown (Quality Analysts and above when reversal is pending)
function shouldShowReversalApprovalInterface() {
    return hasPendingReversalRequest() && isCurrentUserQualityAnalyst();
}

// Check if reversal button should be shown (hide after 48 hours from audit submission)
function checkIfReversalButtonShouldShow(auditSubmissionTime) {
    if (!auditSubmissionTime) {
        return true; // If no timestamp, show button (fallback)
    }
    
    const submissionDate = new Date(auditSubmissionTime);
    const now = new Date();
    const diffMs = now - submissionDate;
    const diffHours = diffMs / (1000 * 60 * 60);
    
    // Hide after 48 hours
    return diffHours < 48;
}

// Get time remaining until 48 hours expires (in seconds)
function getTimeRemainingUntil48Hours(auditSubmissionTime) {
    if (!auditSubmissionTime) {
        return null;
    }
    
    const submissionDate = new Date(auditSubmissionTime);
    const now = new Date();
    const expirationTime = new Date(submissionDate.getTime() + (48 * 60 * 60 * 1000)); // 48 hours
    const remainingMs = expirationTime - now;
    
    if (remainingMs <= 0) {
        return 0; // Already expired
    }
    
    return Math.floor(remainingMs / 1000); // Return seconds
}

// Format time remaining for display (always show seconds)
function formatTimeRemaining(seconds) {
    if (seconds <= 0) {
        return 'Expired';
    }
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    if (hours > 0) {
        return `${hours}h ${minutes}m ${secs.toString().padStart(2, '0')}s`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs.toString().padStart(2, '0')}s`;
    } else {
        return `${secs}s`;
    }
}

// Handle closing/navigating away - check if acknowledgement is pending or comments without reversal
async function handleCloseAuditView() {
    // Check if user is the audited employee
    if (isCurrentUserAuditedEmployee() && currentAudit) {
        // Check if user has comments but hasn't submitted a reversal
        const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
        const hasComments = Object.keys(parameterComments).some(key => {
            const comment = parameterComments[key];
            return comment && comment.comment && comment.comment.trim();
        });
        
        // Check if reversal has been submitted (check both camelCase and snake_case)
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        const hasSubmittedReversal = !!reversalRequestedAt;
        
        // If user has comments but hasn't submitted reversal, prevent navigation
        // Only check if reversal hasn't been submitted yet
        if (hasComments && !hasSubmittedReversal) {
            // Wait for confirmation dialog to be available
            if (!window.confirmationDialog) {
                await new Promise(resolve => setTimeout(resolve, 100));
                if (!window.confirmationDialog) {
                    alert('Warning: You have unsaved parameter comments. If you leave now, your comments will be lost. Please submit a reversal request to save them.');
                    return false; // Prevent navigation
                }
            }
            
            const result = await window.confirmationDialog.show({
                title: '⚠ Unsaved Comments',
                message: 'You have added parameter comments but haven\'t submitted a reversal request yet. If you leave now, your comments will be erased.\n\nPlease submit a reversal request to save your comments before leaving.',
                confirmText: 'Submit Reversal',
                cancelText: 'Leave Anyway (Comments will be lost)'
            });
            
            if (result) {
                // User wants to submit reversal - open the reversal form
                toggleReversalForm();
                return false; // Prevent navigation
            } else {
                // User chose to leave anyway - they understand comments will be lost
                // Allow navigation but warn them one more time
                const confirmLeave = confirm('Are you sure you want to leave? Your parameter comments will be permanently erased from the database.');
                if (!confirmLeave) {
                    return false; // User changed their mind
                }
                
                // Delete comments from database before allowing navigation
                try {
                    if (currentAudit && currentTableName) {
                        await window.supabaseClient
                            .from(currentTableName)
                            .update({
                                parameter_comments: null
                            })
                            .eq('id', currentAudit.id);
                        
                        // Clear from local object
                        if (currentAudit) {
                            currentAudit.parameterComments = {};
                            currentAudit.parameter_comments = {};
                        }
                    }
                } catch (error) {
                    console.error('Error deleting comments:', error);
                    // Continue anyway - user already confirmed they want to leave
                }
                
                return true; // Allow navigation
            }
        }
        
        const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
        const acknowledgementStatusLower = acknowledgementStatus.toLowerCase();
        
        // Determine reversal status
        const reversalRespondedAt = currentAudit.reversalRespondedAt || currentAudit.reversal_responded_at;
        const reversalStatus = reversalRequestedAt && !reversalRespondedAt ? 'Pending' : 
                              (currentAudit.reversalApproved === true || currentAudit.reversal_approved === true) ? 'Approved' :
                              (currentAudit.reversalApproved === false || currentAudit.reversal_approved === false) ? 'Rejected' : null;
        
        // If a reversal is pending, user cannot acknowledge - allow navigation without showing modal
        if (reversalStatus === 'Pending') {
            return true; // Allow navigation
        }
        
        // If acknowledgement is pending (not acknowledged) and no reversal is pending, show the same confirmation as acknowledge button
        // Use global helper function - only show modal if status is not acknowledged (including pending statuses)
        if (!isAcknowledgedStatus(acknowledgementStatus)) {
            // Use the same confirmation dialog that appears when clicking acknowledge button
            // Create a wrapper that tracks success and shows the same confirmation
            const acknowledgeWithNavigation = async () => {
                try {
                    // Verify that current user is the audited employee
                    if (!isCurrentUserAuditedEmployee()) {
                        return false;
                    }
                    
                    // Wait for confirmation dialog to be available
                    if (!window.confirmationDialog) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        if (!window.confirmationDialog) {
                            alert('Error: Confirmation dialog not available. Please refresh the page.');
                            return false;
                        }
                    }
                    
                    // Show the same confirmation dialog as the acknowledge button
                    const result = await window.confirmationDialog.show({
                        title: 'Acknowledge Audit',
                        message: 'By acknowledging this audit, you confirm that you have reviewed the results and do not wish to submit a reversal request. Continue?',
                        confirmText: 'Acknowledge',
                        cancelText: 'Cancel'
                    });
                    
                    if (!result) {
                        return false; // User cancelled
                    }
                    
                    if (!currentAudit || !currentTableName) {
                        alert('Error: Audit data not available');
                        return false;
                    }
                    
                    // Record acknowledgment in the database
                    const acknowledgementTime = new Date().toISOString();
                    const { data, error } = await window.supabaseClient
                        .from(currentTableName)
                        .update({
                            acknowledgement_status: 'Acknowledged',
                            acknowledgement_status_updated_at: acknowledgementTime
                        })
                        .eq('id', currentAudit.id)
                        .select();
                    
                    if (error) throw error;
                    
                    // Show success message
                    if (window.confirmationDialog) {
                        await window.confirmationDialog.show({
                            title: 'Success',
                            message: '✓ Audit acknowledged. Thank you for your confirmation.',
                            confirmText: 'OK',
                            type: 'success'
                        });
                    } else {
                        alert('✓ Audit acknowledged. Thank you for your confirmation.');
                    }
                    
                    // Update currentAudit to reflect acknowledgement
                    if (currentAudit) {
                        currentAudit.acknowledgementStatus = 'Acknowledged';
                        currentAudit.acknowledgement_status = 'Acknowledged';
                        currentAudit.acknowledgementStatusUpdatedAt = acknowledgementTime;
                        currentAudit.acknowledgement_status_updated_at = acknowledgementTime;
                    }
                    
                    return true; // Success
                    
                } catch (error) {
                    console.error('Error acknowledging audit:', error);
                    if (window.confirmationDialog) {
                        await window.confirmationDialog.show({
                            title: 'Error',
                            message: 'Failed to record acknowledgment. Please try again.',
                            confirmText: 'OK',
                            type: 'error'
                        });
                    } else {
                        alert('Failed to record acknowledgment. Please try again.');
                    }
                    return false;
                }
            };
            
            // Call the acknowledge function
            acknowledgementSuccessful = await acknowledgeWithNavigation();
            
            // If acknowledgement was successful, allow navigation
            // If user cancelled, prevent navigation
            return acknowledgementSuccessful;
        }
    }
    
    // If no acknowledgement pending or not the audited employee, allow navigation
    return true;
}

// Load audit on page load
document.addEventListener('DOMContentLoaded', async function() {
    try {
        // Check page access using centralized access control (basic check)
        // Resource-level check will be done after loading audit data
        if (!window.accessControl || !window.accessControl.enforcePageAccess('edit-audit.html')) {
            return; // Access denied, user will be redirected
        }
        
        // Check if user is an agent/employee - redirect to view page if so
        if (isCurrentUserAgent()) {
            // Get URL parameters to redirect to view page
            const urlParams = new URLSearchParams(window.location.search);
            const auditId = urlParams.get('id');
            const scorecardId = urlParams.get('scorecard');
            const tableName = urlParams.get('table');
            
            if (auditId && tableName) {
                // Redirect to audit-view.html with same parameters
                const viewUrl = `audit-view.html?id=${auditId}&table=${tableName}${scorecardId ? `&scorecard=${scorecardId}` : ''}`;
                window.location.href = viewUrl;
                return;
            } else {
                // If no valid parameters, redirect to home
                window.location.href = 'home.html';
                return;
            }
        }
        
        // Get current user email first
        currentUserEmail = getCurrentUserEmail();
        
        await loadAuditFromURL();
        
        // Add escape key listener - check acknowledgement before closing
        document.addEventListener('keydown', async function(event) {
            if (event.key === 'Escape') {
                event.preventDefault(); // Prevent default escape behavior
                const canNavigate = await handleCloseAuditView();
                if (canNavigate) {
                    window.location.href = 'expert-audits.html';
                }
            }
        });
        
        // Prevent browser close/refresh when user has unsaved comments
        window.addEventListener('beforeunload', function(event) {
            if (isCurrentUserAuditedEmployee() && currentAudit) {
                const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
                const hasComments = Object.keys(parameterComments).some(key => {
                    const comment = parameterComments[key];
                    return comment && comment.comment && comment.comment.trim();
                });
                
                const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
                const hasSubmittedReversal = !!reversalRequestedAt;
                
                // If user has comments but hasn't submitted reversal, prevent page unload
                if (hasComments && !hasSubmittedReversal) {
                    // Modern browsers ignore custom messages, but we still need to set returnValue
                    event.preventDefault();
                    event.returnValue = 'You have unsaved parameter comments. If you leave now, your comments will be erased. Please submit a reversal request to save them.';
                    return event.returnValue;
                }
            }
        });
    } catch (error) {
        console.error('Error loading audit:', error);
        showError('Failed to load audit: ' + error.message);
    }
});

// Load audit from URL parameters
async function loadAuditFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    const auditId = urlParams.get('id');
    const scorecardId = urlParams.get('scorecard');
    const tableName = urlParams.get('table');

    if (!auditId || !tableName) {
        showError('Invalid URL parameters. Missing audit ID or table name.');
        return;
    }

    currentTableName = tableName;

    try {
        // Wait for Supabase to initialize
        let attempts = 0;
        const maxAttempts = 50;
        while (!window.supabaseClient && attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }

        if (!window.supabaseClient) {
            throw new Error('Supabase client not initialized');
        }

        // Load audit data
        // Try to get the audit - if .single() fails, check if it's because no results were found
        let data, error;
        const result = await window.supabaseClient
            .from(tableName)
            .select('*')
            .eq('id', auditId);
        
        if (result.error) {
            error = result.error;
            data = null;
        } else if (result.data && result.data.length === 0) {
            // No results found
            error = { message: `Audit with ID "${auditId}" not found in table "${tableName}"` };
            data = null;
        } else if (result.data && result.data.length === 1) {
            // Exactly one result - success
            data = result.data[0];
            error = null;
        } else if (result.data && result.data.length > 1) {
            // Multiple results - use first one but log warning
            console.warn(`Multiple audits found with ID "${auditId}" in table "${tableName}". Using first result.`);
            data = result.data[0];
            error = null;
        } else {
            error = { message: 'Unknown error loading audit' };
            data = null;
        }

        if (error) throw error;
        if (!data) throw new Error('Audit not found');

        currentAudit = data;
        
        // Get scorecard ID from URL parameter, or try to get it from audit data or table name
        let finalScorecardId = scorecardId;
        
        // If not in URL, try to get from audit data
        if (!finalScorecardId && data.scorecard_id) {
            finalScorecardId = data.scorecard_id;
        }
        
        // If still not found, try to find scorecard by matching table name
        if (!finalScorecardId && tableName) {
            try {
                const { data: scorecards, error: scorecardError } = await window.supabaseClient
                    .from('scorecards')
                    .select('id')
                    .eq('table_name', tableName)
                    .limit(1);
                
                if (!scorecardError && scorecards && scorecards.length > 0) {
                    finalScorecardId = scorecards[0].id;
                }
            } catch (err) {
                console.warn('Could not find scorecard by table name:', err);
            }
        }
        
        currentScorecardId = finalScorecardId;

        // Map snake_case to camelCase
        const audit = {
            ...data,
            id: data.id,
            submittedAt: data.submitted_at || data.audit_timestamp,
            auditTimestamp: data.submitted_at || data.audit_timestamp, // Using submitted_at for backward compatibility
            auditDuration: data.audit_duration,
            auditorEmail: data.auditor_email,
            auditorName: data.auditor_name,
            employeeName: data.employee_name,
            employeeEmail: data.employee_email,
            employeeType: data.employee_type,
            employeeDepartment: data.employee_department,
            interactionId: data.interaction_id,
            interactionDate: data.interaction_date,
            auditType: data.audit_type,
            channel: data.channel,
            quarter: data.quarter,
            week: data.week,
            countryOfEmployee: data.country_of_employee,
            clientEmail: data.client_email,
            agentPreStatus: data.agent_pre_status,
            agentPostStatus: data.agent_post_status,
            passingStatus: data.passing_status,
            validationStatus: data.validation_status,
            averageScore: data.average_score,
            criticalErrors: data.critical_errors,
            totalErrorsCount: data.total_errors_count,
            transcript: data.transcript,
            errorDescription: data.error_description,
            criticalFailError: data.critical_fail_error,
            criticalError: data.critical_error,
            significantError: data.significant_error,
            recommendations: data.recommendations,
            // Reversal tracking fields
            reversalRequestedAt: data.reversal_requested_at,
            reversalRespondedAt: data.reversal_responded_at,
            reversalStatus: data.reversal_status, // Map reversal_status
            slaInHours: data.sla_in_hours,
            reasonForReversalResponseDelay: data.response_from_auditor,
            reversalApproved: data.reversal_approved,
            withinAuditorScope: data.within_auditor_scope,
            scoreBeforeAppeal: data.score_before_appeal,
            scoreAfterAppeal: data.score_after_appeal,
            didResultInPass: data.did_result_in_pass,
            reversalType: data.reversal_type,
            reversalMetricsParameters: data.reversal_metrics_parameters,
            reversalJustificationFromAgent: data.reversal_justification_from_agent,
            reversalAttachments: data.reversal_attachments,
            reversalApprovedBy: data.reversal_approved_by,
            reversalResolvedBy: data.reversal_resolved_by,
            // Acknowledgement tracking fields
            acknowledgementStatus: data.acknowledgement_status,
            acknowledgementStatusUpdatedAt: data.acknowledgement_status_updated_at,
            // Parameter comments
            parameterComments: data.parameter_comments || {},
            parameter_comments: data.parameter_comments || {},
            _scorecard_id: finalScorecardId,
            scorecardId: finalScorecardId,
            scorecard_id: finalScorecardId,
            _scorecard_table: tableName
        };

        // Load scorecard parameters
        let errorFields = [];
        let auditScorecard = null;

        if (finalScorecardId) {
            try {
                // Load scorecard info
                const { data: scorecardData, error: scorecardError } = await window.supabaseClient
                    .from('scorecards')
                    .select('*')
                    .eq('id', finalScorecardId)
                    .single();

                if (!scorecardError && scorecardData) {
                    auditScorecard = scorecardData;
                }

                // Load parameters
                const { data: parameters, error: paramsError } = await window.supabaseClient
                    .from('scorecard_parameters')
                    .select('*')
                    .eq('scorecard_id', finalScorecardId)
                    .eq('is_active', true)
                    .order('display_order', { ascending: true });

                if (!paramsError && parameters) {
                    errorFields = parameters.map(param => {
                        // Map error category to severity label
                        const category = param.error_category || '';
                        let severity = 'Significant'; // default
                        if (category.includes('Fail')) {
                            severity = 'Critical Fail';
                        } else if (category.includes('Critical')) {
                            severity = 'Critical';
                        } else if (category.includes('Significant')) {
                            severity = 'Significant';
                        } else if (category.includes('Major')) {
                            severity = 'Major';
                        } else if (category.includes('Minor')) {
                            severity = 'Minor';
                        }
                        
                        return {
                            key: param.field_id,
                            label: param.error_name,
                            feedback: `feedback_${param.field_id}`,
                            severity: severity,
                            field_type: param.field_type || 'counter',
                            parameter_type: param.parameter_type || 'error',
                            points: param.penalty_points || 0,
                            is_fail_all: param.is_fail_all || false,
                            error_category: param.error_category || ''
                        };
                    });
                }
            } catch (err) {
                console.error('Error loading scorecard parameters:', err);
            }
        }

        // Store errorFields globally for reversal form
        currentErrorFields = errorFields;
        
        // Store scorecard globally for score calculation
        currentAuditScorecard = auditScorecard;

        // Render the audit
        renderAudit(audit, auditScorecard, errorFields, 'edit');

        // Hide loading indicator
        document.getElementById('loadingIndicator').style.display = 'none';

    } catch (error) {
        console.error('Error loading audit:', error);
        showError(error.message);
    }
}

// Show error message
function showError(message) {
    document.getElementById('loadingIndicator').style.display = 'none';
    document.getElementById('errorMessage').style.display = 'block';
    document.getElementById('errorText').textContent = message;
}

// Edit current audit
function editCurrentAudit() {
    // Verify that current user is a Quality Analyst and there's a pending reversal
    if (!shouldShowEditButton()) {
        alert('Error: You can only edit audits with pending reversal requests.');
        return;
    }
    
    if (!currentAudit || !currentScorecardId || !currentTableName) {
        alert('Cannot edit audit: missing required data');
        return;
    }
    // This function is only for audit-view.html, not needed in edit-audit.html
    // window.location.href = `edit-audit.html?id=${currentAudit.id}&scorecard=${currentScorecardId}&table=${currentTableName}`;
}

// Generate error details HTML
function generateErrorDetails(audit, errorFields, mode = 'view') {
    const isEditMode = mode === 'edit';
    // Calculate actual totals from individual error counts
    let criticalFailTotal = 0;
    let criticalTotal = 0;
    let significantTotal = 0;
    let calculatedTotalErrors = 0;
    
    errorFields.forEach(field => {
        const count = audit[field.key] ? parseInt(audit[field.key]) : 0;
        // Only count error parameters (not achievements/bonuses) in total
        if (field.parameter_type === 'error' || !field.parameter_type) {
            calculatedTotalErrors += count;
        }
        if (count > 0) {
            if (field.severity === 'Critical Fail') {
                criticalFailTotal += count;
            } else if (field.severity === 'Critical') {
                criticalTotal += count;
            } else if (field.severity === 'Significant') {
                significantTotal += count;
            }
        }
    });
    
    // Use calculated total instead of stored total_errors_count to ensure accuracy
    const totalErrorsCount = calculatedTotalErrors;
    
    // Determine column header based on field types
    let statusColumnHeader = 'Status';
    if (errorFields.length > 0) {
        const allCounters = errorFields.every(field => field.field_type === 'counter');
        const allRadio = errorFields.every(field => field.field_type === 'radio');
        
        if (allCounters) {
            statusColumnHeader = 'Counts';
        } else if (allRadio) {
            statusColumnHeader = 'Achieved?';
        }
    }
    
    // Check if current user is the audited employee (for showing comment boxes)
    const isAuditedEmployee = isCurrentUserAuditedEmployee();
    
    // Check if reversal has been submitted (disable inputs if so)
    const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
    const hasReversalSubmitted = !!reversalRequestedAt;
    
    // Check if audit is acknowledged - if so, lock everything (no edits, no comments)
    const acknowledgementStatus = audit.acknowledgementStatus || audit.acknowledgement_status || '';
    const isAcknowledged = isAcknowledgedStatus(acknowledgementStatus);
    
    // Load parameter comments from audit data
    const parameterComments = audit.parameterComments || audit.parameter_comments || {};
    
    // Check if any parameter has a comment (handle both single comment and comments array format)
    const hasAnyComments = errorFields.some(field => {
        const comment = parameterComments[field.key];
        if (!comment) return false;
        // Check for single comment format
        if (comment.comment && comment.comment.trim()) return true;
        // Check for comments array format
        if (comment.comments && Array.isArray(comment.comments) && comment.comments.some(c => c && c.trim())) return true;
        return false;
    });
    
    // Get employee name and extract first name
    const employeeName = audit.employeeName || audit.employee_name || 'Employee';
    const firstName = employeeName.split(' ')[0] || employeeName;
    const commentColumnHeader = `${firstName}'s Comment`;
    
    // Show comments column if comments exist OR if audited employee (always show for audited employees)
    // Use a global variable to track if comment column should be shown
    if (typeof window.showCommentsColumn === 'undefined') {
        // For audited employees, always show the comment column by default
        window.showCommentsColumn = isAuditedEmployee || hasAnyComments;
    }
    const showCommentsColumn = window.showCommentsColumn;
    
    const errorRows = errorFields.map(field => {
        const rawValue = audit[field.key];
        let displayValue = '';
        let count = 0;
        
        if (field.field_type === 'radio') {
            // For radio buttons, show YES/NO
            const isYes = rawValue === 1 || rawValue === true || rawValue === 'true' || rawValue === '1';
            displayValue = isYes ? '✓ YES' : '✗ NO';
            count = isYes ? 1 : 0;
        } else {
            // For counters, show the number
            count = rawValue ? parseInt(rawValue) : 0;
            displayValue = count.toString();
        }
        
        // Handle feedback - support both old format (string) and new format (JSON array)
        const feedbackData = audit[field.feedback];
        let feedbackArray = [];
        
        if (feedbackData) {
            if (typeof feedbackData === 'string') {
                // Try to parse as JSON array, fallback to single string
                try {
                    const parsed = JSON.parse(feedbackData);
                    feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                } catch (e) {
                    // If not valid JSON, treat as single string (backward compatibility)
                    feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                }
            } else if (Array.isArray(feedbackData)) {
                feedbackArray = feedbackData;
            } else {
                feedbackArray = feedbackData ? [feedbackData] : [];
            }
        }
        
        // Filter out empty feedbacks
        feedbackArray = feedbackArray.filter(f => f && f.trim());
        const hasFeedback = feedbackArray.length > 0;
        const combinedFeedback = feedbackArray.join('\n\n---\n\n'); // Combine with separator
        
        // Different colors for different parameter types
        let severityColor = '#3b82f6';
        let severityBg = '#eff6ff';
        
        if (field.parameter_type === 'error') {
            if (field.severity === 'Critical Fail') {
                severityColor = '#ef4444';
                severityBg = '#fee2e2';
            } else if (field.severity === 'Critical') {
                severityColor = '#f59e0b';
                severityBg = '#fef3c7';
            }
        } else if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
            severityColor = '#10b981';
            severityBg = '#d1fae5';
        }
        
        // Get existing comments for this parameter (can have multiple comments for multiple feedbacks)
        const existingComments = parameterComments[field.key] || {};
        const commentsArray = existingComments.comments || (existingComments.comment ? [existingComments.comment] : []);
        
        // Generate comment HTML - simple input boxes for each feedback
        let commentHtml = '';
        if (showCommentsColumn) {
            // For auditors (non-audited employees), always show comments as read-only text
            // For audited employees, show input boxes (or read-only if reversal submitted)
            if (hasFeedback) {
                // Create input boxes/display for each feedback
                commentHtml = feedbackArray.map((feedbackText, index) => {
                    const existingComment = commentsArray[index] || '';
                    const commentInputId = `comment_${field.key}_${index}`;
                    return `
                        <div style="margin-bottom: ${index < feedbackArray.length - 1 ? '0.6469rem' : '0'};">
                            ${feedbackArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #6b7280; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Comment ${index + 1}:</div>` : ''}
                            ${!isAuditedEmployee || hasReversalSubmitted ? 
                                // For auditors or after reversal submitted, show as read-only text
                                (existingComment ? 
                                    `<div style="font-size: 0.5659rem; color: #4b5563; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(existingComment)}</div>` :
                                    '<span style="color: #9ca3af; font-style: italic; font-size: 0.5659rem;">-</span>'
                                ) :
                                // For audited employees - show input box if not acknowledged and not after reversal submitted
                                (isAcknowledged || hasReversalSubmitted ?
                                    `<div style="font-size: 0.5659rem; color: #9ca3af; font-style: italic;">${existingComment ? escapeHtml(existingComment) : '-'}</div>` :
                                    `<input type="text" id="${commentInputId}" data-param-key="${field.key}" data-feedback-index="${index}" value="${escapeHtml(existingComment)}" placeholder="Enter your comment..." style="width: 100%; padding: 0.2425rem 0.3234rem; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif;" onchange="saveParameterComment('${field.key}', ${index}, this.value)" onblur="saveParameterComment('${field.key}', ${index}, this.value)">`
                                )
                            }
                        </div>
                    `;
                }).join('');
            } else {
                // No feedback for this parameter - check if there are comments anyway
                // (in case comments were added but feedback was removed, or for backward compatibility)
                if (commentsArray.length > 0 && commentsArray.some(c => c && c.trim())) {
                    // Show comments even without feedback
                    commentHtml = commentsArray.map((comment, index) => {
                        if (!comment || !comment.trim()) return '';
                        return `
                            <div style="margin-bottom: ${index < commentsArray.length - 1 ? '0.6469rem' : '0'};">
                                ${commentsArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #6b7280; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Comment ${index + 1}:</div>` : ''}
                                <div style="font-size: 0.5659rem; color: #4b5563; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">${escapeHtml(comment)}</div>
                            </div>
                        `;
                    }).filter(html => html).join('');
                } else {
                    // No comments and no feedback - show dash
                    commentHtml = '<span style="color: #9ca3af; font-style: italic;">-</span>';
                }
            }
        }
        
        // Generate feedback HTML - display all feedbacks (plain, no containers)
        let feedbackHtml = '-';
        if (hasFeedback) {
            // Plain display - multiple feedbacks separated by line breaks
            feedbackHtml = feedbackArray.map((feedbackText, index) => {
                const label = feedbackArray.length > 1 ? `<div style="font-size: 0.4043rem; color: #6b7280; font-weight: 600; margin-bottom: 0.1617rem; font-family: 'Poppins', sans-serif;">Feedback ${index + 1}:</div>` : '';
                return `${label}<div style="font-size: 0.5659rem; color: #4b5563; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; margin-bottom: ${index < feedbackArray.length - 1 ? '0.6469rem' : '0'};">${escapeHtml(feedbackText)}</div>`;
            }).join('');
        }
        
        // Build grid columns - must match header columns for proper alignment
        // For audited employees, always show comment column (persistent)
        const gridColumns = showCommentsColumn 
            ? '2fr 1fr 1fr 1fr 2fr 2.5fr' 
            : '2fr 1fr 1fr 1fr 2fr';
        
        return `
            <div style="display: grid; grid-template-columns: ${gridColumns}; gap: 0.6469rem; align-items: start; padding: 0.3234rem 0; border-bottom: 0.0405rem solid #f3f4f6; width: 100%; min-width: 0;">
                <div style="font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                    ${field.label}
                </div>
                <div style="display: flex; justify-content: center; font-size: 0.5659rem; color: #1f2937; font-weight: 600; font-family: 'Poppins', sans-serif; min-width: 0;">
                    ${field.points}
                </div>
                <div style="display: flex; justify-content: center; min-width: 0;">
                    <span style="background: ${severityBg}; color: ${severityColor}; padding: 0.1617rem 0.4852rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 600; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; white-space: nowrap;">${(field.parameter_type === 'achievement' || field.parameter_type === 'bonus') && field.field_type !== 'radio' ? 'ACHIEVEMENT' : field.severity}</span>
                </div>
                <div style="display: flex; justify-content: center; min-width: 0;">
                    ${isEditMode ? (
                        // Lock inputs if acknowledged
                        isAcknowledged ? (
                            `<div style="font-size: 0.5659rem; font-weight: 700; font-family: 'Poppins', sans-serif; color: ${count > 0 ? '#ef4444' : '#1f2937'};">${field.field_type === 'radio' ? (count === 1 ? '✓ YES' : '✗ NO') : count}</div>`
                        ) : (
                            field.field_type === 'radio' ? `
                                <div style="display: flex; align-items: center; gap: 0.3234rem;">
                                    <label style="display: flex; align-items: center; gap: 0.1617rem; cursor: pointer;">
                                        <input type="radio" name="${field.key}" id="${field.key}_yes" value="1" ${count === 1 ? 'checked' : ''} data-penalty="${field.points}" data-category="${field.severity}" data-param-type="${field.parameter_type || 'error'}" style="width: 0.6469rem; height: 0.6469rem; cursor: pointer; accent-color: #10b981;">
                                        <span style="font-size: 0.4852rem; font-weight: 600; color: #10b981;">✓ YES</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.1617rem; cursor: pointer;">
                                        <input type="radio" name="${field.key}" id="${field.key}_no" value="0" ${count === 0 ? 'checked' : ''} data-penalty="${field.points}" data-category="${field.severity}" data-param-type="${field.parameter_type || 'error'}" style="width: 0.6469rem; height: 0.6469rem; cursor: pointer; accent-color: #ef4444;">
                                        <span style="font-size: 0.4852rem; font-weight: 600; color: #ef4444;">✗ NO</span>
                                    </label>
                                </div>
                            ` : `
                                <div style="display: flex; align-items: center; gap: 0.2425rem;">
                                    <button type="button" class="counter-btn" data-action="decrement" data-target="${field.key}" style="width: 1.1321rem; height: 1.1321rem; display: flex; align-items: center; justify-content: center; border: 0.0304rem solid #d1d5db; background-color: #ffffff; color: #4b5563; border-radius: 0.1617rem; font-size: 0.6469rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: 'Poppins', sans-serif; padding: 0; line-height: 1;">−</button>
                                    <span id="${field.key}_display" style="font-size: 0.5659rem; font-weight: 700; font-family: 'Poppins', sans-serif; color: ${count > 0 ? '#ef4444' : '#1f2937'}; min-width: 0.8086rem; text-align: center;">${count}</span>
                                    <button type="button" class="counter-btn" data-action="increment" data-target="${field.key}" style="width: 1.1321rem; height: 1.1321rem; display: flex; align-items: center; justify-content: center; border: 0.0304rem solid #d1d5db; background-color: #ffffff; color: #4b5563; border-radius: 0.1617rem; font-size: 0.6469rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; font-family: 'Poppins', sans-serif; padding: 0; line-height: 1;">+</button>
                                    <input type="number" id="${field.key}" name="${field.key}" min="0" max="10" value="${count}" readonly data-penalty="${field.points}" data-category="${field.severity}" data-field-type="${field.field_type || 'counter'}" data-param-type="${field.parameter_type || 'error'}" style="display: none;">
                                </div>
                            `
                        )
                    ) : (
                        `<div style="font-size: 0.5659rem; color: #1f2937; text-align: center; font-weight: 700; font-family: 'Poppins', sans-serif;">${displayValue}</div>`
                    )}
                </div>
                <div style="font-size: 0.5659rem; color: #4b5563; font-family: 'Poppins', sans-serif; min-width: 0; word-wrap: break-word; overflow-wrap: break-word;">
                    ${isEditMode ? `
                        <div id="feedback_container_${field.key}" style="display: flex; flex-direction: column; gap: 0.3234rem;">
                            ${feedbackArray.map((feedbackText, index) => `
                                <textarea 
                                    id="feedback_${field.key}_${index}" 
                                    name="feedback_${field.key}_${index}" 
                                    placeholder="${count > 0 ? 'Enter feedback (required)...' : 'Enter feedback (optional)...'}" 
                                    rows="2" 
                                    ${count > 0 ? 'required' : ''}
                                    style="font-family: 'Poppins', sans-serif; font-size: 0.5659rem; line-height: 1.2; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; padding: 0.2425rem 0.3234rem; width: 100%; resize: vertical; min-height: 2rem;"
                                >${escapeHtml(feedbackText)}</textarea>
                            `).join('')}
                            ${feedbackArray.length === 0 ? `
                                <textarea 
                                    id="feedback_${field.key}_0" 
                                    name="feedback_${field.key}_0" 
                                    placeholder="Enter feedback (optional)..." 
                                    rows="2" 
                                    style="font-family: 'Poppins', sans-serif; font-size: 0.5659rem; line-height: 1.2; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; padding: 0.2425rem 0.3234rem; width: 100%; resize: vertical; min-height: 2rem;"
                                ></textarea>
                            ` : ''}
                        </div>
                    ` : feedbackHtml}
                </div>
                ${showCommentsColumn ? `
                    <div style="font-size: 0.5659rem; color: #4b5563; font-family: 'Poppins', sans-serif; min-width: 0; overflow: hidden;">
                        ${commentHtml || '<span style="color: #9ca3af; font-style: italic;">-</span>'}
                    </div>
                ` : ''}
            </div>
        `;
    }).join('');
    
    return `
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4852rem; flex-wrap: wrap; gap: 0.4852rem;">
                <h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
                    Error Details
                </h3>
                <div style="display: flex; gap: 0.2425rem;">
                    <span id="errorDetailsCriticalFailTotal" style="background: #dc2626; color: #ffffff; padding: 0.1617rem 0.3234rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 700; font-family: 'Poppins', sans-serif; white-space: nowrap;">Critical Fail: ${criticalFailTotal}</span>
                    <span id="errorDetailsCriticalTotal" style="background: #f59e0b; color: #ffffff; padding: 0.1617rem 0.3234rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 700; font-family: 'Poppins', sans-serif; white-space: nowrap;">Critical: ${criticalTotal}</span>
                    <span id="errorDetailsSignificantTotal" style="background: #3b82f6; color: #ffffff; padding: 0.1617rem 0.3234rem; border-radius: 0.2425rem; font-size: 0.4852rem; font-weight: 700; font-family: 'Poppins', sans-serif; white-space: nowrap;">Significant: ${significantTotal}</span>
                </div>
            </div>
            
            <div style="background: white; border-radius: 0.4852rem; box-shadow: 0 0.0405rem 0.1213rem 0 rgba(0, 0, 0, 0.1); overflow: hidden;">
                <div style="background-color: #f8f9fa; padding: 0.4852rem 0.6469rem; border-bottom: 0.0405rem solid #e5e7eb;">
                    <div style="display: grid; grid-template-columns: ${showCommentsColumn ? '2fr 1fr 1fr 1fr 2fr 2.5fr' : '2fr 1fr 1fr 1fr 2fr'}; gap: 0.6469rem; align-items: center; font-weight: 700; font-size: 0.5659rem; color: #1f2937; text-transform: uppercase; letter-spacing: 0.05em; width: 100%; min-width: 0;">
                        <div style="min-width: 0;">Error Type</div>
                        <div style="text-align: center; min-width: 0;">Points</div>
                        <div style="text-align: center; min-width: 0;">Severity</div>
                        <div style="text-align: center; min-width: 0;">${statusColumnHeader}</div>
                        <div style="min-width: 0;">Feedback</div>
                        ${showCommentsColumn ? 
                            `<div style="min-width: 0;">${escapeHtml(commentColumnHeader)}</div>` : 
                            ''
                        }
                    </div>
                </div>
                <div style="padding: 0 0.6469rem 0.6469rem 0.6469rem; box-shadow: 0 -0.0606rem 0.1213rem rgba(0, 0, 0, 0.05);">
                    ${errorRows}
                </div>
                </div>
            </div>
            
        <!-- Avg Score & Passing Status -->
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Avg Score</p>
                    <div id="averageScoreDisplay" style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.averageScore || '0'}%</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Status</p>
                    <div id="passingStatusDisplay" style="font-size: 0.5659rem; font-weight: 600; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${audit.passingStatus || 'N/A'}</div>
                </div>
            </div>
        </div>

        <!-- Error Counts: Total Errors, Critical Fail, Critical, Significant -->
        <div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; margin-bottom: 0.6469rem; border: 0.0304rem solid #e5e7eb;">
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr)); gap: 0.6469rem;">
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Total Errors</p>
                    <div id="totalErrorsCountDisplay" style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${totalErrorsCount}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical Fail</p>
                    <div id="criticalFailTotalDisplay" style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${criticalFailTotal}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Critical</p>
                    <div id="criticalTotalDisplay" style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${criticalTotal}</div>
                </div>
                <div>
                    <p style="font-size: 0.4447rem; color: #6b7280; margin: 0 0 0.3234rem 0; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.0151rem; font-weight: 600;">Significant Error</p>
                    <div id="significantTotalDisplay" style="font-size: 0.6469rem; font-weight: 700; margin: 0; font-family: 'Poppins', sans-serif; background: white; border: 0.0304rem solid #d1d5db; border-radius: 0.1617rem; color: #374151; width: 100%; padding: 0.2425rem 0.3234rem; text-align: center;">${significantTotal}</div>
                </div>
            </div>
        </div>
    `;
}

// Populate edit form fields with audit data
async function populateEditFormFields(audit) {
    // Populate header fields
    const employeeNameSelect = document.getElementById('employeeName');
    if (employeeNameSelect) {
        // Load employees first if needed
        if (employeeNameSelect.options.length <= 1) {
            await loadEmployeesForDropdown(employeeNameSelect, audit.employeeEmail || audit.employee_email);
        }
        
        const employeeEmail = audit.employeeEmail || audit.employee_email || '';
        const employeeName = audit.employeeName || audit.employee_name || '';
        const normalizedEmail = employeeEmail.toLowerCase().trim();
        
        // Try to find matching option by email (dataset.email or value)
        let matchingOption = null;
        const options = Array.from(employeeNameSelect.options);
        for (const option of options) {
            const optionEmail = (option.dataset.email || option.value || '').toLowerCase().trim();
            if (optionEmail === normalizedEmail) {
                matchingOption = option;
                break;
            }
        }
        
        if (matchingOption) {
            employeeNameSelect.value = matchingOption.value;
            // Trigger change event to populate other fields
            employeeNameSelect.dispatchEvent(new Event('change', { bubbles: true }));
        } else if (employeeName && employeeEmail) {
            // If no match, add the option and select it
            const newOption = document.createElement('option');
            newOption.value = employeeEmail;
            newOption.text = employeeName;
            newOption.dataset.email = employeeEmail;
            employeeNameSelect.appendChild(newOption);
            employeeNameSelect.value = employeeEmail;
        }
    }
    
    const employeeEmailInput = document.getElementById('employeeEmail');
    if (employeeEmailInput) {
        employeeEmailInput.value = audit.employeeEmail || audit.employee_email || '';
    }
    
    const employeeTypeInput = document.getElementById('employeeType');
    if (employeeTypeInput) {
        employeeTypeInput.value = audit.employeeType || audit.employee_type || '';
    }
    
    const employeeDepartmentInput = document.getElementById('employeeDepartment');
    if (employeeDepartmentInput) {
        employeeDepartmentInput.value = audit.employeeDepartment || audit.employee_department || '';
    }
    
    const countryOfEmployeeSelect = document.getElementById('countryOfEmployee');
    if (countryOfEmployeeSelect) {
        const country = audit.countryOfEmployee || audit.country_of_employee || '';
        countryOfEmployeeSelect.value = country;
    }
    
    // Populate transcript section fields
    const interactionIdInput = document.getElementById('interactionId');
    if (interactionIdInput) {
        interactionIdInput.value = audit.interactionId || audit.interaction_id || '';
    }
    
    const interactionDateInput = document.getElementById('interactionDate');
    if (interactionDateInput) {
        const interactionDate = audit.interactionDate || audit.interaction_date || '';
        if (interactionDate) {
            // Convert date to YYYY-MM-DD format for date input
            const date = new Date(interactionDate);
            if (!isNaN(date.getTime())) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                interactionDateInput.value = `${year}-${month}-${day}`;
            }
        }
    }
    
    const clientEmailInput = document.getElementById('clientEmail');
    if (clientEmailInput) {
        clientEmailInput.value = audit.clientEmail || audit.client_email || '';
    }
    
    const clientNameInput = document.getElementById('clientName');
    if (clientNameInput) {
        // Client name will be populated when conversation is loaded from Intercom
        clientNameInput.value = '';
    }
    
    const transcriptTextarea = document.getElementById('transcript');
    if (transcriptTextarea) {
        transcriptTextarea.value = audit.transcript || audit.transcript_text || '';
    }
    
    // Populate channel and audit type in metadata cards (if they exist as form fields)
    // Note: These might be read-only in the template, but we'll populate if they exist
    const channelInput = document.getElementById('channel');
    if (channelInput) {
        channelInput.value = audit.channel || '';
    }
    
    const auditTypeInput = document.getElementById('auditType');
    if (auditTypeInput) {
        auditTypeInput.value = audit.auditType || audit.audit_type || '';
    }
    
    // Populate recommendations field
    const recommendationsTextarea = document.getElementById('recommendations');
    if (recommendationsTextarea) {
        recommendationsTextarea.value = audit.recommendations || '';
    }
}

// Helper function to copy conversation ID
window.copyConversationId = function() {
    const interactionId = document.getElementById('interactionId');
    if (interactionId && interactionId.value) {
        navigator.clipboard.writeText(interactionId.value).then(() => {
            showNotification('Conversation ID copied to clipboard!', 'success');
        }).catch(() => {
            showNotification('Failed to copy Conversation ID', 'error');
        });
    } else {
        showNotification('No Conversation ID available', 'error');
    }
};

// Helper function to copy client email
window.copyClientEmail = function() {
    const clientEmail = document.getElementById('clientEmail');
    if (clientEmail && clientEmail.value) {
        navigator.clipboard.writeText(clientEmail.value).then(() => {
            showNotification('Client email copied to clipboard!', 'success');
        }).catch(() => {
            showNotification('Failed to copy client email', 'error');
        });
    } else {
        showNotification('No client email available', 'error');
    }
};

// Load employees for dropdown
async function loadEmployeesForDropdown(selectElement, currentEmployeeEmail) {
    try {
        const { data: users, error } = await window.supabaseClient
            .from('users')
            .select('email, name, role, department, designation, country')
            .eq('is_active', true)
            .order('name', { ascending: true });
        
        if (error) throw error;
        
        // Clear existing options except the first one (placeholder)
        while (selectElement.options.length > 1) {
            selectElement.remove(1);
        }
        
        // Add employee options
        const normalizedCurrentEmail = (currentEmployeeEmail || '').toLowerCase().trim();
        (users || []).forEach(user => {
            // Only show employees (not auditors)
            if (user.role === 'Employee') {
                const option = document.createElement('option');
                option.value = user.email;
                option.text = user.name || user.email;
                option.dataset.email = user.email;
                option.dataset.role = user.role || '';
                option.dataset.department = user.department || '';
                option.dataset.designation = user.designation || '';
                option.dataset.country = user.country || '';
                
                // Select current employee if matches
                if (user.email && user.email.toLowerCase().trim() === normalizedCurrentEmail) {
                    option.selected = true;
                }
                
                selectElement.appendChild(option);
            }
        });
        
        // Attach change event listener to auto-populate fields when employee is selected
        selectElement.removeEventListener('change', handleEmployeeSelectionChange);
        selectElement.addEventListener('change', handleEmployeeSelectionChange);
    } catch (error) {
        console.error('Error loading employees:', error);
    }
}

// Handle employee selection change to auto-populate fields
function handleEmployeeSelectionChange() {
    const employeeSelect = this;
    const selectedOption = employeeSelect.options[employeeSelect.selectedIndex];
    
    if (selectedOption && selectedOption.value) {
        const employeeEmailInput = document.getElementById('employeeEmail');
        const employeeTypeInput = document.getElementById('employeeType');
        const employeeDepartmentInput = document.getElementById('employeeDepartment');
        const countryOfEmployeeSelect = document.getElementById('countryOfEmployee');
        
        // Auto-populate email
        const email = selectedOption.dataset.email || selectedOption.value;
        if (employeeEmailInput) {
            employeeEmailInput.value = email;
        }
        
        // Auto-populate employee type from designation
        const designation = selectedOption.dataset.designation || '';
        if (employeeTypeInput && designation) {
            employeeTypeInput.value = designation;
        }
        
        // Auto-populate department
        const department = selectedOption.dataset.department || '';
        if (employeeDepartmentInput && department) {
            employeeDepartmentInput.value = department;
        }
        
        // Auto-populate country
        const country = selectedOption.dataset.country || '';
        if (countryOfEmployeeSelect && country) {
            countryOfEmployeeSelect.value = country;
        }
    }
}

// Render audit HTML
function renderAudit(audit, auditScorecard, errorFields, mode = 'view') {
    // Helper functions are now in audit-template.js
    // Use them from the global scope (formatDate, getCountryFlag, escapeHtml)

    const isEditMode = mode === 'edit';

    // Check for passing status (handle both "Passing" and "Passed", but exclude "Not Passing")
    const passingStatus = audit.passingStatus ? audit.passingStatus.toLowerCase() : '';
    const isPassing = passingStatus && passingStatus.includes('pass') && !passingStatus.includes('not');

    const errorDetailsHtml = errorFields.length > 0 ? generateErrorDetails(audit, errorFields, mode) : '';

    // Determine header gradient based on passing status (handle both old and new values)
    const normalizedPassingStatus = passingStatus && passingStatus.includes('not') ? 'Not Passed' : 'Passed';
    const headerGradient = normalizedPassingStatus === 'Not Passed' 
        ? 'linear-gradient(135deg, #d41212 0%, #b91c1c 100%)' 
        : 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
    
    // Use formatDate and getCountryFlag from audit-template.js
    const formatDate = window.formatDate || function(dateString, includeTime) {
        if (!dateString) return 'N/A';
        const date = new Date(dateString);
        const day = date.getDate();
        const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
        const month = months[date.getMonth()];
        const year = date.getFullYear();
        if (includeTime) {
            let hours = date.getHours();
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12;
            return `${day} ${month} ${year}, ${hours}:${minutes} ${ampm}`;
        }
        return `${day} ${month} ${year}`;
    };
    const getCountryFlag = window.getCountryFlag || function(countryName) {
        if (!countryName) return '🏳️';
        const country = countryName.toLowerCase();
        const flagMap = {
            'bangladesh': '🇧🇩', 'india': '🇮🇳', 'pakistan': '🇵🇰', 'philippines': '🇵🇭',
            'indonesia': '🇮🇩', 'sri lanka': '🇱🇰', 'nepal': '🇳🇵', 'thailand': '🇹🇭',
            'vietnam': '🇻🇳', 'malaysia': '🇲🇾', 'singapore': '🇸🇬', 'usa': '🇺🇸',
            'united states': '🇺🇸', 'uk': '🇬🇧', 'united kingdom': '🇬🇧', 'canada': '🇨🇦',
            'australia': '🇦🇺', 'new zealand': '🇳🇿', 'south africa': '🇿🇦', 'egypt': '🇪🇬',
            'kenya': '🇰🇪', 'nigeria': '🇳🇬', 'ghana': '🇬🇭'
        };
        return flagMap[country] || '🏳️';
    };
    const escapeHtml = window.escapeHtml || function(text) {
        if (text == null) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    };

    // Build interaction ID HTML (clickable link if available)
    // Get Intercom app ID from config (generated from environment variables)
    const INTERCOM_APP_ID = window.intercomConfig?.appId || '';
    let interactionIdHtml;
    if (audit.interactionId) {
        const interactionId = audit.interactionId;
        const intercomUrl = `https://app.intercom.com/a/inbox/aphmhtyj/inbox/conversation/${interactionId}?view`;
        interactionIdHtml = '<a href="' + escapeHtml(intercomUrl) + '" target="_blank" rel="noopener noreferrer" style="font-size: 0.4852rem; color: #1A733E; font-family: \'Poppins\', sans-serif; font-weight: 600; text-decoration: underline; cursor: pointer; transition: color 0.2s ease;" onmouseover="this.style.color=\'#2d9a5a\'" onmouseout="this.style.color=\'#1A733E\'">' + escapeHtml(interactionId) + '</a>';
    } else {
        interactionIdHtml = '<span style="font-size: 0.4852rem; color: #1f2937; font-family: \'Poppins\', sans-serif; font-weight: 600;">N/A</span>';
    }

    // Generate recommendations HTML
    // In edit mode, show editable textarea; otherwise show read-only div
    const recommendationsHtml = isEditMode
        ? `<div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;"><h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0 0 0.4852rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;"><svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/></svg>Recommendations / Next Steps</h3><textarea id="recommendations" name="recommendations" rows="4" placeholder="Enter recommendations and next steps for the employee..." style="width: 100%; padding: 0.5659rem; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; font-size: 0.5257rem; line-height: 1.6; color: #374151; font-family: 'Poppins', sans-serif; background-color: white; resize: vertical; box-sizing: border-box;">${escapeHtml(audit.recommendations || '')}</textarea></div>`
        : (audit.recommendations 
            ? `<div style="background: #f9fafb; border-radius: 0.3234rem; padding: 0.6469rem; border: 0.0304rem solid #e5e7eb; margin-bottom: 0.6469rem;"><h3 style="font-size: 0.6064rem; font-weight: 600; color: #1A733E; margin: 0 0 0.4852rem 0; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.3234rem;"><svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="#1A733E"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/></svg>Recommendations / Next Steps</h3><div style="background: white; padding: 0.5659rem; border-radius: 0.2425rem; border: 0.0304rem solid #e5e7eb; white-space: pre-wrap; font-size: 0.5257rem; line-height: 1.6; color: #374151; font-family: 'Poppins', sans-serif;">${escapeHtml(audit.recommendations)}</div></div>`
            : '');

    // Check if current user is the audited employee (for showing acknowledge button)
    const showAcknowledgeButton = isCurrentUserAuditedEmployee();
    
    // Check if edit button should be shown (only for Quality Analysts when reversal is pending)
    const showEditButton = shouldShowEditButton();
    
    // Check if reversal button should be shown (hide after 48 hours from audit submission)
    const auditSubmissionTime = audit.submittedAt || audit.auditTimestamp || audit.submitted_at || audit.audit_timestamp;
    const showReversalButton = checkIfReversalButtonShouldShow(auditSubmissionTime);
    
    // Get reversal and acknowledgement status for footer styling
    // Note: reversal_status column doesn't exist - status is determined by reversal_approved
    const reversalRequestedAt = audit.reversal_requested_at || audit.reversalRequestedAt;
    const reversalRespondedAt = audit.reversal_responded_at || audit.reversalRespondedAt;
    const reversalApproved = audit.reversal_approved || audit.reversalApproved;
    // Determine status: null/undefined = pending, 'true' = approved, 'false' = rejected
    let reversalStatus = null;
    if (reversalRequestedAt && !reversalRespondedAt) {
        reversalStatus = 'Pending';
    } else if (reversalApproved === 'true' || reversalApproved === true) {
        reversalStatus = 'Approved';
    } else if (reversalApproved === 'false' || reversalApproved === false) {
        reversalStatus = 'Rejected';
    }
    
    const acknowledgementStatus = audit.acknowledgementStatus || audit.acknowledgement_status || '';

    // Generate action buttons HTML
    // Only show acknowledge/reversal buttons if current user is the audited employee
    let employeeButtonsHtml = '';
    if (showAcknowledgeButton) {
        // Check if reversal is pending (disables acknowledge button and reversal button)
        const isReversalPending = reversalStatus === 'Pending';
        
        // Generate reversal button HTML (always show if within 48 hours, regardless of acknowledgement status)
        // But disable if reversal is already pending
        let reversalButtonHtml = '';
        if (showReversalButton) {
            const reversalDisabled = isReversalPending;
            reversalButtonHtml = `
                <button id="reversalBtn" onclick="toggleReversalForm()" ${reversalDisabled ? 'disabled' : ''} style="padding: 0.4852rem 1.2937rem; background-color: #dc2626; color: white; border: none; border-radius: ${acknowledgementStatus === 'Acknowledged' ? '0.2425rem' : '0 0.2425rem 0.2425rem 0'}; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: ${reversalDisabled ? 'not-allowed' : 'pointer'}; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem; opacity: ${reversalDisabled ? '0.5' : '1'}; ${acknowledgementStatus !== 'Acknowledged' ? 'border-left: 0.0304rem solid rgba(255,255,255,0.3);' : ''}">
                        <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                            <line x1="12" y1="9" x2="12" y2="13"/>
                            <line x1="12" y1="17" x2="12.01" y2="17"/>
                        </svg>
                        Submit Reversal
                    </button>
            `;
        }
        
        // Show acknowledge button based on status (simplified)
        const shouldShowAcknowledgeButton = shouldShowAcknowledgeButtonForStatus(acknowledgementStatus);
        
        if (shouldShowAcknowledgeButton) {
            // Disable acknowledge button if reversal is pending
            const acknowledgeDisabled = isReversalPending;
            employeeButtonsHtml = `
                <!-- Split button for Acknowledge/Reversal -->
                <div style="position: relative; display: inline-flex;">
                    <button id="acknowledgeBtn" onclick="acknowledgeAudit()" ${acknowledgeDisabled ? 'disabled' : ''} style="padding: 0.4852rem 1.2937rem; background-color: #1A733E; color: white; border: none; border-radius: ${reversalButtonHtml ? '0.2425rem 0 0 0.2425rem' : '0.2425rem'}; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: ${acknowledgeDisabled ? 'not-allowed' : 'pointer'}; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem; opacity: ${acknowledgeDisabled ? '0.5' : '1'};">
                        <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="20 6 9 17 4 12"/>
                        </svg>
                        Acknowledge
                    </button>
                    ${reversalButtonHtml}
                </div>
            `;
        } else {
            // If acknowledged with new status (after reversal), only show reversal button (if within 48 hours)
            if (reversalButtonHtml) {
                employeeButtonsHtml = reversalButtonHtml;
            }
        }
    }
    
    // Generate edit button HTML (only if pending reversal and user is Quality Analyst)
    let editButtonHtml = '';
    if (showEditButton) {
        editButtonHtml = `
                <button id="editAuditBtn" onclick="editCurrentAudit()" style="padding: 0.4852rem 1.2937rem; background-color: #f59e0b; color: white; border: none; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                    </svg>
                    Edit Audit
                </button>
        `;
    }
    
    // Generate delete button HTML (only if current user is the auditor)
    let deleteButtonHtml = '';
    const showDeleteButton = isCurrentUserAuditor();
    if (showDeleteButton) {
        deleteButtonHtml = `
                <button id="deleteAuditBtn" onclick="deleteCurrentAudit()" style="padding: 0.4852rem 1.2937rem; background-color: #dc2626; color: white; border: none; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Delete Audit
                </button>
        `;
    }
    
    // Generate save button HTML for edit mode
    let saveButtonHtml = '';
    if (mode === 'edit') {
        saveButtonHtml = `
                <button id="saveAuditBtn" onclick="saveAuditChanges()" style="padding: 0.4852rem 1.2937rem; background-color: #1A733E; color: white; border: none; border-radius: 0.2425rem; font-size: 0.5659rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 0.3234rem;">
                    <svg style="width: 0.7278rem; height: 0.7278rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Save Changes
                </button>
        `;
    }
    
    // Determine footer background color based on acknowledgement status
    // Green: Acknowledged (including new statuses) | Gray: Default (not acknowledged or pending)
    let footerBackgroundColor = '#f9fafb'; // Default gray
    let footerTextColor = '#6b7280'; // Default gray text
    
    // Check if status is acknowledged (including new statuses) - show green footer
    if (isAcknowledgedStatus(acknowledgementStatus)) {
        footerBackgroundColor = '#065f46'; // Deep green
        footerTextColor = 'white';
    }
    
    // Also show green footer for pending statuses after reversal (they need acknowledgment)
    const statusLower = acknowledgementStatus.toLowerCase();
    if ((statusLower === 'pending - after reversal approved' || statusLower === 'pending - after reversal rejected')) {
        footerBackgroundColor = '#065f46'; // Deep green
        footerTextColor = 'white';
    }
    
    // Generate timer HTML for footer (if reversal button is visible and within 48 hours)
    // Don't show timer if reversal is already pending
    let timerHtml = '';
    if (showAcknowledgeButton && showReversalButton && auditSubmissionTime && reversalStatus !== 'Pending') {
        const timeRemaining = getTimeRemainingUntil48Hours(auditSubmissionTime);
        if (timeRemaining && timeRemaining > 0) {
            // Check if time is running low (less than 2 hours remaining)
            const isLowTime = timeRemaining < 7200; // 2 hours in seconds
            // Use white for green footer, default gray text for gray footer
            const statusLowerTimer = acknowledgementStatus.toLowerCase();
            const shouldShowGreenFooter = isAcknowledgedStatus(acknowledgementStatus) || 
                                         statusLowerTimer === 'pending - after reversal approved' || 
                                         statusLowerTimer === 'pending - after reversal rejected';
            const timerTextColor = shouldShowGreenFooter ? 'white' : footerTextColor;
            timerHtml = `
                <div id="reversalTimer" style="display: flex; align-items: center; gap: 0.375rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif; color: ${timerTextColor}; ${isLowTime ? 'animation: pulse-attention 2s ease-in-out infinite;' : ''}">
                    <svg id="reversalTimerIcon" style="width: 0.75rem; height: 0.75rem; opacity: 0.6; ${isLowTime ? 'animation: spin-slow 2s linear infinite;' : ''}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span id="reversalTimerText">Reversal window: <span id="reversalTimerValue" style="font-weight: 600; color: ${isLowTime ? '#ef4444' : timerTextColor}; ${isLowTime ? 'animation: flash-text 1s ease-in-out infinite;' : ''}">${formatTimeRemaining(timeRemaining)}</span></span>
            </div>
            `;
        }
    }
    
    // Determine if footer should show green (acknowledged or pending after reversal)
    const statusLowerFooter = acknowledgementStatus.toLowerCase();
    const shouldShowFooterStatus = isAcknowledgedStatus(acknowledgementStatus) || 
                                   statusLowerFooter === 'pending - after reversal approved' || 
                                   statusLowerFooter === 'pending - after reversal rejected';
    
    // Generate acknowledgement status HTML for footer (shown in body of footer)
    let acknowledgementStatusHtml = '';
    if (shouldShowFooterStatus) {
        // Format acknowledgement timestamp
        let timestampText = '';
        const ackTimestamp = audit.acknowledgementStatusUpdatedAt || audit.acknowledgement_status_updated_at;
        if (ackTimestamp) {
            const ackDate = new Date(ackTimestamp);
            const now = new Date();
            const diffMs = now - ackDate;
            const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
            const diffDays = Math.floor(diffHours / 24);
            
            if (diffHours < 1) {
                const diffMins = Math.floor(diffMs / (1000 * 60));
                timestampText = diffMins <= 1 ? 'just now' : `${diffMins} minutes ago`;
            } else if (diffHours < 24) {
                timestampText = diffHours === 1 ? '1 hour ago' : `${diffHours} hours ago`;
            } else if (diffDays === 1) {
                timestampText = '1 day ago';
            } else {
                timestampText = formatDate(ackTimestamp, true);
            }
        }
        
        // Determine display text for acknowledgement status
        let displayText = 'Acknowledged';
        const statusLower = acknowledgementStatus.toLowerCase();
        if (statusLower === 'acknowledged - after reversal approved') {
            displayText = 'Acknowledged - After Reversal Approved';
        } else if (statusLower === 'acknowledged - after reversal rejected') {
            displayText = 'Acknowledged - After Reversal Rejected';
        } else if (statusLower === 'pending - after reversal approved') {
            displayText = 'Pending - After Reversal Approved';
        } else if (statusLower === 'pending - after reversal rejected') {
            displayText = 'Pending - After Reversal Rejected';
        }
        
        // Use checkmark icon for acknowledged, clock icon for pending
        const isAcknowledged = isAcknowledgedStatus(acknowledgementStatus);
        const iconSvg = isAcknowledged 
            ? `<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>`
            : `<circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/>`;
        
        acknowledgementStatusHtml = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <div style="width: 1.25rem; height: 1.25rem; border-radius: 50%; background-color: rgba(255, 255, 255, 0.2); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                    <svg style="width: 0.875rem; height: 0.875rem;" viewBox="0 0 24 24" fill="white">
                        ${iconSvg}
                    </svg>
                </div>
                <span style="font-size: 0.75rem; font-weight: 600; color: white; font-family: 'Poppins', sans-serif;">${displayText}</span>
                <span style="font-size: 0.6562rem; color: rgba(255, 255, 255, 0.9); font-family: 'Poppins', sans-serif;">${timestampText}</span>
            </div>
        `;
    }
    
    const actionButtonsHtml = `
        <div id="footerBar" class="no-print" style="display: flex; justify-content: space-between; align-items: center; gap: 0.4852rem; padding: 0.6469rem 0.9704rem; border-top: 0.0405rem solid ${shouldShowFooterStatus ? 'rgba(255,255,255,0.2)' : '#e5e7eb'}; background-color: ${footerBackgroundColor}; color: ${footerTextColor};">
            <div style="display: flex; align-items: center; gap: 0.4852rem; flex: 1;">
                ${acknowledgementStatusHtml}
            </div>
            <div style="display: flex; align-items: center; gap: 0.4852rem; margin-left: auto;">
                ${timerHtml}
                ${employeeButtonsHtml}
                ${editButtonHtml}
                ${deleteButtonHtml}
                ${saveButtonHtml}
            </div>
        </div>
    `;
    
    // Store mode for later use
    window.currentEditMode = mode;

    // Generate header actions HTML
    const headerActionsHtml = `
        <button onclick="handleCloseButtonClick()" style="background: rgba(255,255,255,0.2); border: 0.0606rem solid white; border-radius: 0.2425rem; width: 1.2937rem; height: 1.2937rem; font-size: 0.8086rem; cursor: pointer; color: white; font-weight: bold; transition: all 0.2s; display: flex; align-items: center; justify-content: center; flex-shrink: 0;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Close (Esc)">×</button>
    `;

    // Use shared template to generate HTML (errorDetailsHtml already generated above)
    const html = window.generateAuditFormHTML({
        audit: audit,
        mode: 'edit',
        headerTitle: 'Edit Audit',
        headerGradient: headerGradient,
        headerActions: headerActionsHtml,
        interactionIdHtml: interactionIdHtml,
        errorDetailsHtml: errorDetailsHtml,
        recommendationsHtml: recommendationsHtml,
        actionButtonsHtml: actionButtonsHtml
    });

    const auditContentDiv = document.getElementById('auditContent');

    // Preserve reversal form container state before re-rendering
    const reversalFormContainer = document.getElementById('reversalFormContainer');
    const wasFormVisible = reversalFormContainer && reversalFormContainer.style.display !== 'none';
    
    // Temporarily remove form container from DOM to preserve it during innerHTML replacement
    let formContainerParent = null;
    let formContainerNextSibling = null;
    if (reversalFormContainer && reversalFormContainer.parentElement) {
        formContainerParent = reversalFormContainer.parentElement;
        formContainerNextSibling = reversalFormContainer.nextSibling;
        reversalFormContainer.remove();
    }
    
    auditContentDiv.innerHTML = html;

    // Populate form fields in edit mode (with delay to ensure DOM is ready)
    if (mode === 'edit') {
        setTimeout(() => {
            populateEditFormFields(audit);
            // Update score display after form is populated
            // This will recalculate based on current form values
            updateAverageScoreDisplay();
            
            // Also update the currentAudit object with the calculated score
            // so it matches what's displayed
            const calculatedScore = calculateNewScore();
            if (currentAudit) {
                currentAudit.averageScore = calculatedScore;
                currentAudit.average_score = calculatedScore;
            }
        }, 100);
    }

    // Re-insert reversal form container after rendering
    if (reversalFormContainer && auditContentDiv) {
        const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
        if (buttonsSection && buttonsSection.parentElement) {
            buttonsSection.parentElement.insertBefore(reversalFormContainer, buttonsSection.nextSibling);
        } else {
            auditContentDiv.appendChild(reversalFormContainer);
        }
        
        // Restore visibility state
        if (wasFormVisible) {
            reversalFormContainer.style.display = 'block';
        } else {
            reversalFormContainer.style.display = 'none';
        }
    }

    // Handle reversal status UI updates
    handleReversalStatusUI(audit);
    
    // Display submitted reversal form if reversal is pending
    if (reversalStatus === 'Pending') {
        displaySubmittedReversalForm(audit);
    }
    
    // Start timer countdown if reversal button is visible and reversal is not pending
    if (showAcknowledgeButton && showReversalButton && auditSubmissionTime && reversalStatus !== 'Pending') {
        startReversalTimer(auditSubmissionTime);
    }

    // Make splitter draggable
    initializeSplitter();
    
    // Auto-fetch conversation from Intercom if interaction ID exists
    // Show chat view by default (will show loading, then Intercom messages or fallback to text)
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    const toggleTranscriptViewBtn = document.getElementById('toggleTranscriptViewBtn');
    
    if (transcriptChatView && transcriptTextView) {
        transcriptChatView.style.display = 'flex';
        transcriptTextView.style.display = 'none';
        if (toggleTranscriptViewBtn) {
            toggleTranscriptViewBtn.textContent = 'Text View';
            toggleTranscriptViewBtn.title = 'Switch to text view';
        }
        isChatViewActive = true;
    }
    
    if (audit.interactionId || audit.interaction_id) {
        const interactionId = audit.interactionId || audit.interaction_id;
        // Show loading state immediately
        const chatMessagesContainer = document.getElementById('chatMessagesContainer');
        if (chatMessagesContainer) {
            chatMessagesContainer.innerHTML = `
                <div style="text-align: center; padding: 1.2937rem; color: #6b7280;">
                    <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                    <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
                </div>
            `;
        }
        // Delay slightly to ensure DOM is ready, then fetch
        setTimeout(() => {
            loadConversationFromIntercom(interactionId);
        }, 100);
    } else {
        // No interaction ID - try to parse database transcript and show in chat view
        const transcriptText = currentAudit?.transcript || currentAudit?.transcript_text || '';
        if (transcriptText && transcriptText.trim() && !transcriptText.includes('No transcript available')) {
            // Parse database transcript and show in chat view
            const interactionDate = currentAudit?.interaction_date || currentAudit?.interactionDate;
            parseTranscriptToChat(transcriptText, interactionDate);
            
            // Keep chat view active
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
                if (toggleTranscriptViewBtn) {
                    toggleTranscriptViewBtn.textContent = 'Text View';
                    toggleTranscriptViewBtn.title = 'Switch to text view';
                }
                isChatViewActive = true;
            }
        } else {
            // No database transcript available - show text view
        if (transcriptChatView && transcriptTextView) {
            transcriptChatView.style.display = 'none';
            transcriptTextView.style.display = 'flex';
            if (toggleTranscriptViewBtn) {
                toggleTranscriptViewBtn.textContent = 'Chat View';
                toggleTranscriptViewBtn.title = 'Switch to chat view';
            }
            isChatViewActive = false;
            }
        }
    }
}

// Handle reversal status UI updates
function handleReversalStatusUI(audit) {
    const acknowledgeBtn = document.getElementById('acknowledgeBtn');
    const reversalFormContainer = document.getElementById('reversalFormContainer');
    
    // Check if acknowledge button should be visible (only for audited employee)
    if (acknowledgeBtn && !isCurrentUserAuditedEmployee()) {
        // Hide acknowledge button if user is not the audited employee
        acknowledgeBtn.style.display = 'none';
        // Also hide the reversal button if both buttons are in a split button container
        const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
        if (reversalBtn) {
            reversalBtn.style.display = 'none';
        }
    }
    
    // Get the reversal status from audit data
    // Note: reversal_status column doesn't exist - derive from reversal_approved
    const reversalRequestedAt = currentAudit?.reversal_requested_at || currentAudit?.reversalRequestedAt;
    const reversalRespondedAt = currentAudit?.reversal_responded_at || currentAudit?.reversalRespondedAt;
    const reversalApproved = currentAudit?.reversal_approved || currentAudit?.reversalApproved;
    let reversalStatus = null;
    if (reversalRequestedAt && !reversalRespondedAt) {
        reversalStatus = 'Pending';
    } else if (reversalApproved === 'true' || reversalApproved === true) {
        reversalStatus = 'Approved';
    } else if (reversalApproved === 'false' || reversalApproved === false) {
        reversalStatus = 'Rejected';
    }
    
    // Get the acknowledgement status from audit data
    const acknowledgementStatus = currentAudit?.acknowledgementStatus || currentAudit?.acknowledgement_status;
    
    // Ensure button is enabled by default (will be disabled if needed below)
    if (acknowledgeBtn) {
        acknowledgeBtn.disabled = false;
        acknowledgeBtn.style.opacity = '1';
        acknowledgeBtn.style.cursor = 'pointer';
    }
    
    // Check if acknowledge button should be shown based on status
    const shouldShow = shouldShowAcknowledgeButtonForStatus(acknowledgementStatus);
    
    // If button should not be shown, disable it
    if (!shouldShow && acknowledgeBtn) {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
    
    // If reversal is pending, disable acknowledge button (can't acknowledge while reversal is pending)
    if (reversalStatus === 'Pending' && acknowledgeBtn) {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
    
    if (reversalStatus) {
        // Create status banner
        const statusBanner = document.createElement('div');
        statusBanner.style.cssText = `
            padding: 0.5625rem 0.75rem;
            margin-bottom: 0.75rem;
            border-radius: 0.2812rem;
            font-family: 'Poppins', sans-serif;
            font-size: 0.6562rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.375rem;
        `;
        
        if (reversalStatus === 'Pending') {
            statusBanner.style.background = '#fef3c7';
            statusBanner.style.color = '#92400e';
            statusBanner.style.border = '0.0352rem solid #fbbf24';
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                </svg>
                <span>Reversal request is pending review by the quality team. This cannot be acknowledged until the reversal is processed.</span>
            `;
            // Disable the reversal button (user can't submit another reversal while one is pending)
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = true;
                reversalBtn.style.opacity = '0.5';
                reversalBtn.style.cursor = 'not-allowed';
            }
        } else if (reversalStatus === 'Approved') {
            statusBanner.style.background = '#d1fae5';
            statusBanner.style.color = '#065f46';
            statusBanner.style.border = '0.0352rem solid #10b981';
            
            // Get auditor's response if available
            const auditorResponse = currentAudit?.reasonForReversalResponseDelay || currentAudit?.response_from_auditor || '';
            const shouldShowResponse = (isCurrentUserQualityAnalyst() || isCurrentUserAuditedEmployee()) && auditorResponse && auditorResponse.trim();
            
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <div style="flex: 1;">
                    <div>✓ Reversal request has been approved. Score updated to ${currentAudit?.score_after_appeal || 'N/A'}%. Please review the updated audit and acknowledge or submit a new reversal if needed.</div>
                    ${shouldShowResponse ? `
                        <div style="margin-top: 0.5625rem; padding: 0.5625rem; background: rgba(255, 255, 255, 0.5); border-radius: 0.2812rem; border-left: 0.1875rem solid #10b981;">
                            <div style="font-size: 0.5625rem; font-weight: 600; margin-bottom: 0.2812rem; text-transform: uppercase; letter-spacing: 0.05em;">Response From Auditor:</div>
                            <div style="font-size: 0.6094rem; white-space: pre-wrap; line-height: 1.5;">${escapeHtml(auditorResponse)}</div>
                        </div>
                    ` : ''}
                </div>
            `;
            // After reversal is processed, enable acknowledge button if status requires it
            // Show acknowledge button for pending statuses or simple "Acknowledged" if reversal was processed
            if (acknowledgeBtn && shouldShowAcknowledgeButtonForStatus(acknowledgementStatus, true)) {
                acknowledgeBtn.disabled = false;
                acknowledgeBtn.style.opacity = '1';
                acknowledgeBtn.style.cursor = 'pointer';
            }
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = false;
                reversalBtn.style.opacity = '1';
                reversalBtn.style.cursor = 'pointer';
            }
        } else if (reversalStatus === 'Rejected') {
            statusBanner.style.background = '#fee2e2';
            statusBanner.style.color = '#991b1b';
            statusBanner.style.border = '0.0352rem solid #ef4444';
            
            // Get auditor's response if available
            const auditorResponse = currentAudit?.reasonForReversalResponseDelay || currentAudit?.response_from_auditor || '';
            const shouldShowResponse = (isCurrentUserQualityAnalyst() || isCurrentUserAuditedEmployee()) && auditorResponse && auditorResponse.trim();
            
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                </svg>
                <div style="flex: 1;">
                    <div>Reversal request has been rejected. Please review the audit and acknowledge or submit a new reversal if needed.</div>
                    ${shouldShowResponse ? `
                        <div style="margin-top: 0.5625rem; padding: 0.5625rem; background: rgba(255, 255, 255, 0.5); border-radius: 0.2812rem; border-left: 0.1875rem solid #ef4444;">
                            <div style="font-size: 0.5625rem; font-weight: 600; margin-bottom: 0.2812rem; text-transform: uppercase; letter-spacing: 0.05em;">Response From Auditor:</div>
                            <div style="font-size: 0.6094rem; white-space: pre-wrap; line-height: 1.5;">${escapeHtml(auditorResponse)}</div>
                        </div>
                    ` : ''}
                </div>
            `;
            // After reversal is processed, enable acknowledge button if status requires it
            // Show acknowledge button for pending statuses or simple "Acknowledged" if reversal was processed
            if (acknowledgeBtn && shouldShowAcknowledgeButtonForStatus(acknowledgementStatus, true)) {
                acknowledgeBtn.disabled = false;
                acknowledgeBtn.style.opacity = '1';
                acknowledgeBtn.style.cursor = 'pointer';
            }
            const reversalBtn = acknowledgeBtn?.parentElement?.querySelector('button[onclick="toggleReversalForm()"]');
            if (reversalBtn) {
                reversalBtn.disabled = false;
                reversalBtn.style.opacity = '1';
                reversalBtn.style.cursor = 'pointer';
            }
        } else if (reversalStatus === 'Acknowledged') {
            statusBanner.style.background = '#dbeafe';
            statusBanner.style.color = '#1e40af';
            statusBanner.style.border = '0.0352rem solid #3b82f6';
            statusBanner.innerHTML = `
                <svg style="width: 0.9375rem; height: 0.9375rem; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <span>Audit has been acknowledged by the employee.</span>
            `;
            // Hide the button container (parent div with border-top style)
            const buttonsContainer = acknowledgeBtn?.closest('.no-print[style*="border-top"]');
            if (buttonsContainer) {
                buttonsContainer.style.display = 'none';
            }
        }
        
        // Insert reversal status banner into the DOM
        if (statusBanner) {
        const auditContentDiv = document.getElementById('auditContent');
        if (auditContentDiv) {
            const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
            if (buttonsSection && buttonsSection.parentElement) {
                buttonsSection.parentElement.insertBefore(statusBanner, buttonsSection);
            } else {
                auditContentDiv.appendChild(statusBanner);
            }
        }
    }
    }
    
    // Handle acknowledgement status separately
    // Note: Acknowledgement status is now shown in the footer, not as a separate banner
    if (acknowledgementStatus === 'Acknowledged' && acknowledgeBtn) {
        acknowledgeBtn.disabled = true;
        acknowledgeBtn.style.opacity = '0.5';
        acknowledgeBtn.style.cursor = 'not-allowed';
    }
}

// Display submitted reversal form details (read-only)
function displaySubmittedReversalForm(audit) {
    const auditContentDiv = document.getElementById('auditContent');
    if (!auditContentDiv) return;
    
    // Get reversal data from audit
    const reversalType = audit.reversalType || audit.reversal_type || 'N/A';
    const reversalJustification = audit.reversalJustificationFromAgent || audit.reversal_justification_from_agent || '';
    const reversalMetrics = audit.reversalMetricsParameters || audit.reversal_metrics_parameters || '';
    const withinAuditorScope = audit.withinAuditorScope || audit.within_auditor_scope;
    const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
    
    // Parse reversal justification (may contain reason and justification combined)
    let reversalReason = '';
    let detailedJustification = reversalJustification;
    if (reversalJustification && reversalJustification.includes(':')) {
        const parts = reversalJustification.split(':');
        if (parts.length >= 2) {
            reversalReason = parts[0].trim();
            detailedJustification = parts.slice(1).join(':').trim();
        }
    }
    
    // Format reversal requested date
    let requestedDateText = '';
    if (reversalRequestedAt) {
        const date = new Date(reversalRequestedAt);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        
        if (diffMins < 1) {
            requestedDateText = 'just now';
        } else if (diffMins < 60) {
            requestedDateText = `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
        } else if (diffHours < 24) {
            requestedDateText = `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
        } else if (diffDays === 1) {
            requestedDateText = '1 day ago';
        } else {
            requestedDateText = date.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
    }
    
    // Parse metrics parameters
    const selectedParameters = reversalMetrics ? reversalMetrics.split(',').map(p => p.trim()).filter(p => p) : [];
    
    // Create read-only reversal form display
    const submittedFormHtml = `
        <div id="submittedReversalForm" class="no-print" style="background: #fef3c7; border: 0.0703rem solid #fbbf24; border-radius: 0.375rem; padding: 0.75rem; margin: 1.125rem; box-shadow: 0 0.0703rem 0.2812rem rgba(0,0,0,0.1);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5625rem;">
                <div style="display: flex; align-items: center; gap: 0.375rem;">
                    <svg style="width: 0.9375rem; height: 0.9375rem; color: #f59e0b;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                    </svg>
                    <h3 style="margin: 0; font-size: 0.75rem; font-weight: 700; color: #b45309; font-family: 'Poppins', sans-serif;">Submitted Reversal Request</h3>
                </div>
                <span style="font-size: 0.5625rem; color: #92400e; font-family: 'Poppins', sans-serif;">Submitted ${requestedDateText}</span>
            </div>
            
            <div style="display: grid; gap: 0.5625rem; background: white; border-radius: 0.2812rem; padding: 0.75rem; border: 0.0352rem solid #e5e7eb;">
                <!-- Two-column grid for compact layout -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5625rem;">
                    <!-- Reversal Type -->
                    <div>
                        <label style="display: block; font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                            Reversal Type
                        </label>
                        <div style="padding: 0.375rem; border: 0.0352rem solid #e5e7eb; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: #f9fafb; color: #374151;">
                            ${escapeHtml(reversalType)}
                        </div>
                    </div>
                    
                    <!-- Reversal Reason -->
                    ${reversalReason ? `
                        <div>
                            <label style="display: block; font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                                Reversal Reason
                            </label>
                            <div style="padding: 0.375rem; border: 0.0352rem solid #e5e7eb; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: #f9fafb; color: #374151;">
                                ${escapeHtml(reversalReason)}
                            </div>
                        </div>
                    ` : ''}
                </div>
                
                <!-- Affected Error Parameters with Justifications -->
                ${selectedParameters.length > 0 ? `
                    <div>
                        <label style="display: block; font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                            Parameter Justifications
                        </label>
                        <div style="padding: 0.5625rem; border: 0.0352rem solid #e5e7eb; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: #f9fafb; color: #374151; max-height: 18.75rem; overflow-y: auto;">
                            ${selectedParameters.map(param => {
                                // Try to find matching comment from parameter comments
                                // Use currentAudit which has the latest data, or fall back to audit parameter
                                const auditData = currentAudit || audit;
                                const parameterComments = auditData.parameterComments || auditData.parameter_comments || {};
                                let paramComment = '';
                                
                                // Find the field key that matches this parameter label
                                // currentErrorFields should be available, but if not, try to find from audit data
                                let matchingField = null;
                                if (currentErrorFields && currentErrorFields.length > 0) {
                                    matchingField = currentErrorFields.find(f => f.label === param);
                                }
                                
                                // If found matching field, get comment from parameter_comments using field key
                                if (matchingField) {
                                    const comment = parameterComments[matchingField.key];
                                    if (comment && comment.comment) {
                                        paramComment = comment.comment;
                                    }
                                }
                                
                                // If no comment found from parameter_comments, try to extract from detailedJustification
                                if (!paramComment && detailedJustification) {
                                    const lines = detailedJustification.split('\n\n');
                                    for (const line of lines) {
                                        if (line.trim().startsWith(param + ':')) {
                                            paramComment = line.substring(param.length + 1).trim();
                                            break;
                                        }
                                    }
                                }
                                
                                // If still no comment found, try searching all parameter_comments for any comment that might match
                                if (!paramComment && Object.keys(parameterComments).length > 0) {
                                    // Try to find by matching parameter label with any comment
                                    for (const [key, commentData] of Object.entries(parameterComments)) {
                                        if (commentData && commentData.comment) {
                                            // Check if this field's label matches the param
                                            const field = currentErrorFields?.find(f => f.key === key);
                                            if (field && field.label === param) {
                                                paramComment = commentData.comment;
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                return `
                                    <div style="margin-bottom: 0.5625rem; padding: 0.5625rem; background: white; border-radius: 0.2812rem; border: 0.0352rem solid #e5e7eb;">
                                        <div style="font-size: 0.6562rem; font-weight: 600; color: #1f2937; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif; display: flex; align-items: center; gap: 0.375rem;">
                                            <svg style="width: 0.75rem; height: 0.75rem; color: #10b981; flex-shrink: 0;" viewBox="0 0 24 24" fill="currentColor">
                                                <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                                            </svg>
                                            ${escapeHtml(param)}
                                        </div>
                                        ${paramComment ? `
                                            <div style="font-size: 0.5625rem; color: #4b5563; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; padding-left: 1.125rem;">
                                                ${escapeHtml(paramComment)}
                                            </div>
                                        ` : '<div style="font-size: 0.5625rem; color: #9ca3af; font-family: \'Poppins\', sans-serif; padding-left: 1.125rem; font-style: italic;">No justification provided</div>'}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                ` : ''}
                
                <!-- Within Auditor Scope -->
                <div>
                    <label style="display: block; font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                        Within Auditor Scope
                    </label>
                    <div style="padding: 0.375rem; border: 0.0352rem solid #e5e7eb; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: #f9fafb; color: #374151; display: flex; align-items: center; gap: 0.375rem;">
                        ${withinAuditorScope === 'true' || withinAuditorScope === true ? `
                            <svg style="width: 0.75rem; height: 0.75rem; color: #10b981;" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                            </svg>
                            <span>Yes - I believe this can be resolved by the original auditor</span>
                        ` : `
                            <svg style="width: 0.75rem; height: 0.75rem; color: #6b7280;" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                            </svg>
                            <span>No</span>
                        `}
                    </div>
                </div>
                
                <!-- Auditor's Response (if reversal has been responded to) -->
                ${(() => {
                    const reversalRespondedAt = audit.reversalRespondedAt || audit.reversal_responded_at;
                    const auditorResponse = audit.reasonForReversalResponseDelay || audit.response_from_auditor || '';
                    const shouldShowResponse = (isCurrentUserQualityAnalyst() || isCurrentUserAuditedEmployee()) && reversalRespondedAt && auditorResponse && auditorResponse.trim();
                    
                    if (!shouldShowResponse) return '';
                    
                    return `
                        <div>
                            <label style="display: block; font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                                Response From Auditor
                            </label>
                            <div style="padding: 0.5625rem; border: 0.0352rem solid #e5e7eb; border-radius: 0.2812rem; font-size: 0.6094rem; font-family: 'Poppins', sans-serif; background-color: #f0f9ff; border-left: 0.1875rem solid #3b82f6; color: #1e40af; white-space: pre-wrap; line-height: 1.6;">
                                ${escapeHtml(auditorResponse)}
                            </div>
                        </div>
                    `;
                })()}
            </div>
        </div>
    `;
    
    // Insert submitted form after the footer bar
    const footerBar = document.getElementById('footerBar');
    if (footerBar && footerBar.parentElement) {
        // Check if already exists, remove it first
        const existingForm = document.getElementById('submittedReversalForm');
        if (existingForm) {
            existingForm.remove();
        }
        
        // Also remove approval interface if exists
        const existingApprovalInterface = document.getElementById('reversalApprovalInterface');
        if (existingApprovalInterface) {
            existingApprovalInterface.remove();
        }
        
        // Insert after footer bar
        footerBar.parentElement.insertAdjacentHTML('afterend', submittedFormHtml);
        
        // If user is Quality Analyst or above, add approval interface
        if (shouldShowReversalApprovalInterface()) {
            setTimeout(() => {
                displayReversalApprovalInterface(audit);
            }, 100);
        }
    } else {
        // Fallback: append to audit content
        auditContentDiv.insertAdjacentHTML('beforeend', submittedFormHtml);
        
        // If user is Quality Analyst or above, add approval interface
        if (shouldShowReversalApprovalInterface()) {
            setTimeout(() => {
                displayReversalApprovalInterface(audit);
            }, 100);
        }
    }
}

// Start reversal timer countdown
function startReversalTimer(auditSubmissionTime) {
    const timerElement = document.getElementById('reversalTimer');
    const timerTextElement = document.getElementById('reversalTimerText');
    const timerValueElement = document.getElementById('reversalTimerValue');
    const timerIconElement = document.getElementById('reversalTimerIcon');
    
    if (!timerElement || !timerTextElement) {
        return;
    }
    
    // Update timer every second
    const updateTimer = () => {
        const timeRemaining = getTimeRemainingUntil48Hours(auditSubmissionTime);
        
        if (timeRemaining <= 0) {
            // Timer expired - hide reversal button
            timerElement.style.display = 'none';
            const reversalBtn = document.getElementById('reversalBtn');
            if (reversalBtn) {
                reversalBtn.style.display = 'none';
                // Adjust acknowledge button border radius if reversal button is hidden
                const acknowledgeBtn = document.getElementById('acknowledgeBtn');
                if (acknowledgeBtn) {
                    acknowledgeBtn.style.borderRadius = '0.2425rem';
                }
            }
            return;
        }
        
        // Check if time is running low (less than 2 hours)
        const isLowTime = timeRemaining < 7200; // 2 hours in seconds
        const isVeryLowTime = timeRemaining < 3600; // 1 hour in seconds
        const isCriticalTime = timeRemaining < 600; // 10 minutes in seconds
        
        // Determine color and animation based on time remaining
        let timerColor = '#374151';
        let timerAnimation = 'none';
        let elementAnimation = 'none';
        let elementColor = '#6b7280';
        let elementFontWeight = '500';
        let iconColor = '';
        let iconAnimation = 'none';
        let iconOpacity = '0.6';
        
        if (isCriticalTime) {
            // Critical: Red color, flash animation, shake effect
            timerColor = '#ef4444';
            timerAnimation = 'flash-text 0.5s ease-in-out infinite';
            elementAnimation = 'pulse-attention 1s ease-in-out infinite, shake 0.5s ease-in-out infinite';
            elementColor = '#ef4444';
            elementFontWeight = '700';
            iconColor = '#ef4444';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        } else if (isVeryLowTime) {
            // Very low: Orange color, pulse animation
            timerColor = '#f59e0b';
            timerAnimation = 'flash-text 1s ease-in-out infinite';
            elementAnimation = 'pulse-attention 1.5s ease-in-out infinite';
            elementColor = '#f59e0b';
            elementFontWeight = '600';
            iconColor = '#f59e0b';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        } else if (isLowTime) {
            // Low: Red color, subtle pulse
            timerColor = '#ef4444';
            timerAnimation = 'flash-text 1.5s ease-in-out infinite';
            elementAnimation = 'pulse-attention 2s ease-in-out infinite';
            elementColor = '#ef4444';
            elementFontWeight = '600';
            iconColor = '#ef4444';
            iconAnimation = 'spin-slow 2s linear infinite';
            iconOpacity = '1';
        }
        
        // Get current footer to determine text color
        const footerBar = document.getElementById('footerBar');
        let defaultTimerColor = '#374151';
        let defaultTextColor = '#6b7280';
        
        if (footerBar) {
            const bgColor = footerBar.style.backgroundColor || window.getComputedStyle(footerBar).backgroundColor;
            const isFooterGreen = bgColor.includes('rgb(6, 95, 70)') || bgColor.includes('#065f46');
            
            if (isFooterGreen) {
                defaultTimerColor = 'white';
                defaultTextColor = 'white';
            }
        }
        
        // For critical time, use red; otherwise use the footer-appropriate color (white for green, gray for default)
        const finalTimerColor = isCriticalTime ? '#ef4444' : defaultTimerColor;
        
        timerTextElement.innerHTML = `Reversal window: <span id="reversalTimerValue" style="font-weight: 600; color: ${finalTimerColor}; animation: ${timerAnimation};">${formatTimeRemaining(timeRemaining)}</span>`;
        
        // Apply styles to timer element
        timerElement.style.animation = elementAnimation;
        timerElement.style.color = defaultTextColor;
        timerElement.style.fontWeight = elementFontWeight;
        
        // Update icon animation
        const currentIconElement = document.getElementById('reversalTimerIcon');
        if (currentIconElement) {
            currentIconElement.style.color = iconColor;
            currentIconElement.style.animation = iconAnimation;
            currentIconElement.style.opacity = iconOpacity;
        }
        
        // Continue updating
        setTimeout(updateTimer, 1000);
    };
    
    // Start the timer
    updateTimer();
}

// Toggle between text view and chat view
function toggleTranscriptView() {
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    const toggleBtn = document.getElementById('toggleTranscriptViewBtn');
    const chatPanel = document.getElementById('conversationAttributesPanel');
    const textPanel = document.getElementById('conversationAttributesPanelTextView');
    const rightColumn = document.getElementById('rightColumn');
    
    if (!transcriptChatView || !transcriptTextView || !toggleBtn) return;
    
    const isChatView = transcriptChatView.style.display !== 'none' && window.getComputedStyle(transcriptChatView).display !== 'none';
    
    if (isChatView) {
        // Switch to text view
        transcriptChatView.style.display = 'none';
        transcriptTextView.style.display = 'flex';
        toggleBtn.textContent = 'Chat View';
        toggleBtn.title = 'Switch to chat view';
        
        // Show text panel, hide chat panel
        if (textPanel) {
            textPanel.style.display = 'block';
            // Match height to transcript container (left column details)
            const transcriptContainer = transcriptTextView?.parentElement;
            if (transcriptContainer) {
                setTimeout(() => {
                    const transcriptHeight = transcriptContainer.offsetHeight || transcriptContainer.clientHeight;
                    if (transcriptHeight > 0) {
                        textPanel.style.maxHeight = transcriptHeight + 'px';
                        textPanel.style.height = 'auto';
                    }
                }, 100);
            }
        }
        if (chatPanel) {
            chatPanel.style.display = 'none';
        }
    } else {
        // Switch to chat view
        transcriptTextView.style.display = 'none';
        transcriptChatView.style.display = 'flex';
        toggleBtn.textContent = 'Text View';
        toggleBtn.title = 'Switch to text view';
        
        // Show chat panel, hide text panel
        if (chatPanel) {
            chatPanel.style.display = 'block';
            // Match height to transcript container (left column details)
            const transcriptContainer = transcriptChatView?.parentElement;
            if (transcriptContainer) {
                setTimeout(() => {
                    const transcriptHeight = transcriptContainer.offsetHeight || transcriptContainer.clientHeight;
                    if (transcriptHeight > 0) {
                        chatPanel.style.maxHeight = transcriptHeight + 'px';
                        chatPanel.style.height = 'auto';
                    }
                }, 100);
            }
        }
        if (textPanel) {
            textPanel.style.display = 'none';
        }
        
        // If Intercom conversation not loaded, try to parse plain text transcript
        const chatContainer = document.getElementById('chatMessagesContainer');
        if (chatContainer && (!currentConversationData && chatContainer.children.length === 0)) {
            // Read transcript directly from audit data instead of DOM
            const transcriptText = currentAudit?.transcript || currentAudit?.transcript_text || '';
            // Check if transcript exists and is not the "No transcript available" message
            if (transcriptText && transcriptText.trim() && !transcriptText.includes('No transcript available')) {
                const interactionDate = currentAudit?.interaction_date || currentAudit?.interactionDate;
                parseTranscriptToChat(transcriptText, interactionDate);
            }
        }
        
        // Scroll to bottom
        setTimeout(() => {
            transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
        }, 100);
    }
}

// Make toggleTranscriptView globally accessible
window.toggleTranscriptView = toggleTranscriptView;

// Intercom API Integration
let currentConversationData = null;
let isChatViewActive = false;

// Get Intercom and Supabase config (use existing globals from config files if available)
const INTERCOM_CONFIG = window.intercomConfig || {
    baseUrl: 'https://app.intercom.com',
    appId: ''
};

// Get Supabase config from window.SupabaseConfig (set by supabase-config.js)
// Use local variables with different names to avoid conflicts
const supabaseUrl = window.SupabaseConfig?.url || '';
const supabaseAnonKey = window.SupabaseConfig?.anonKey || '';

// Fetch conversation from Intercom API
async function loadConversationFromIntercom(conversationId) {
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    const transcriptChatView = document.getElementById('transcriptChatView');
    const transcriptTextView = document.getElementById('transcriptTextView');
    const toggleTranscriptViewBtn = document.getElementById('toggleTranscriptViewBtn');
    
    if (!chatMessagesContainer || !transcriptChatView) return;
    
    // Show loading state
    chatMessagesContainer.innerHTML = `
        <div style="text-align: center; padding: 1.2937rem; color: #6b7280;">
            <div style="display: inline-block; width: 1.2937rem; height: 1.2937rem; border: 0.091rem solid #e5e7eb; border-top-color: #1A733E; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            <p style="margin-top: 0.6469rem; font-size: 0.5659rem;">Loading conversation from Intercom...</p>
        </div>
    `;

    try {
        // Fetch conversation data from Intercom API via Supabase Edge Function (to avoid CORS)
        // Add display_as parameter to get full conversation data including email_message_metadata
        const edgeFunctionUrl = `${supabaseUrl}/functions/v1/intercom-proxy?conversation_id=${encodeURIComponent(conversationId)}&display_as=plaintext`;
        
        const response = await fetch(edgeFunctionUrl, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${supabaseAnonKey}`,
                'apikey': supabaseAnonKey,
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
        }

        const conversation = await response.json();
        currentConversationData = conversation;


        // Parse and display conversation messages
        displayConversationMessages(conversation);

        // Extract and display all conversation attributes
        displayConversationAttributes(conversation);

        // Auto-switch to chat view if not already active
        if (!isChatViewActive) {
            isChatViewActive = true;
            transcriptChatView.style.display = 'flex';
            if (transcriptTextView) transcriptTextView.style.display = 'none';
            if (toggleTranscriptViewBtn) {
                toggleTranscriptViewBtn.textContent = 'Text View';
                toggleTranscriptViewBtn.title = 'Switch to text view';
            }
        }

    } catch (error) {
        console.error('Error loading conversation from Intercom:', error);
        
        // Try to parse database transcript as fallback
        const transcriptText = currentAudit?.transcript || currentAudit?.transcript_text || '';
        if (transcriptText && transcriptText.trim() && !transcriptText.includes('No transcript available')) {
            // Parse database transcript and show in chat view
            const interactionDate = currentAudit?.interaction_date || currentAudit?.interactionDate;
            parseTranscriptToChat(transcriptText, interactionDate);
            
            // Keep chat view active
            if (transcriptChatView && transcriptTextView) {
                transcriptChatView.style.display = 'flex';
                transcriptTextView.style.display = 'none';
                if (toggleTranscriptViewBtn) {
                    toggleTranscriptViewBtn.textContent = 'Text View';
                    toggleTranscriptViewBtn.title = 'Switch to text view';
                }
                isChatViewActive = true;
            }
        } else {
            // No database transcript available - fallback to text view
        const transcriptChatView = document.getElementById('transcriptChatView');
        const transcriptTextView = document.getElementById('transcriptTextView');
        const toggleTranscriptViewBtn = document.getElementById('toggleTranscriptViewBtn');
        
        if (transcriptChatView && transcriptTextView) {
            // Switch to text view
            transcriptChatView.style.display = 'none';
            transcriptTextView.style.display = 'flex';
            if (toggleTranscriptViewBtn) {
                toggleTranscriptViewBtn.textContent = 'Chat View';
                toggleTranscriptViewBtn.title = 'Switch to chat view';
            }
            isChatViewActive = false;
        }
        
        // Show error message in chat container (for debugging, but user will see text view)
        chatMessagesContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: #ef4444;">
                <svg style="width: 1.9406rem; height: 1.9406rem; margin: 0 auto 0.6469rem; opacity: 0.5;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                </svg>
                <p style="font-size: 0.5659rem; font-weight: 600; margin-bottom: 0.3234rem;">Failed to load conversation from Intercom</p>
                <p style="font-size: 0.4852rem; color: #6b7280;">${escapeHtml(error.message)}</p>
                    <p style="font-size: 0.4852rem; color: #9ca3af; margin-top: 0.3234rem;">No database transcript available.</p>
            </div>
        `;
        }
    }
}

// Display conversation messages in chat interface
function displayConversationMessages(conversation) {
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    if (!chatMessagesContainer) return;
    
    // Helper function to generate avatar with initials
    function generateAvatar(name, type) {
        // Extract initials from name
        const getInitials = (name) => {
            if (!name || name === 'Unknown') return '?';
            const parts = name.trim().split(/\s+/);
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        };
        
        const initials = getInitials(name);
        
        // Determine colors and gradients based on type
        let bgGradient, textColor, label, borderColor;
        if (type === 'user' || type === 'contact') {
            // Blue gradient for client
            bgGradient = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
            textColor = '#ffffff';
            label = 'Client'; // Use "Client" label under avatar
            borderColor = '#2563eb';
        } else if (type === 'ai' || type === 'bot') {
            // Darker green gradient for AI
            bgGradient = 'linear-gradient(135deg, #15803d 0%, #166534 100%)';
            textColor = '#ffffff';
            label = 'AI';
            borderColor = '#166534';
        } else {
            // Green gradient for agent
            bgGradient = 'linear-gradient(135deg, #1A733E 0%, #14532d 100%)';
            textColor = '#ffffff';
            label = 'Agent';
            borderColor = '#14532d';
        }
        
        return {
            initials,
            bgGradient,
            textColor,
            label,
            borderColor
        };
    }

    const parts = conversation.conversation_parts?.conversation_parts || [];
    
    // Update conversation heading with client name
    const transcriptHeading = document.querySelector('h3');
    if (transcriptHeading) {
        // Extract client name from conversation
        let clientName = 'Transcript';
        // Try to get client name from source.author
        if (conversation.source?.author?.name) {
            clientName = conversation.source.author.name;
        }
        // Try contacts
        else if (conversation.contacts?.contacts && conversation.contacts.contacts.length > 0) {
            const contact = conversation.contacts.contacts[0];
            if (contact.name) {
                clientName = contact.name;
            }
        }
        // Try to find first user/contact in conversation parts
        else if (parts.length > 0) {
            for (const part of parts) {
                if (part.author && (part.author.type === 'user' || part.author.type === 'contact')) {
                    if (part.author.name) {
                        clientName = part.author.name;
                        break;
                    }
                }
            }
        }
        
        // Update client name input field
        const clientNameInput = document.getElementById('clientName');
        if (clientNameInput && clientName && clientName !== 'Transcript') {
            clientNameInput.value = clientName;
        }
        
        // Update heading text (keep the icon)
        const icon = transcriptHeading.querySelector('svg');
        if (icon) {
            // Keep the SVG icon and replace "Transcript" with client name
            transcriptHeading.innerHTML = icon.outerHTML + ' ' + escapeHtml(clientName);
        } else {
            transcriptHeading.textContent = clientName;
        }
    }
    
    if (parts.length === 0) {
        chatMessagesContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: #9ca3af;">
                <p>No messages found in this conversation.</p>
            </div>
        `;
        return;
    }

    // Sort parts by created_at timestamp
    const sortedParts = [...parts].sort((a, b) => {
        const timeA = typeof a.created_at === 'number' ? (a.created_at < 10000000000 ? a.created_at * 1000 : a.created_at) : new Date(a.created_at).getTime();
        const timeB = typeof b.created_at === 'number' ? (b.created_at < 10000000000 ? b.created_at * 1000 : b.created_at) : new Date(b.created_at).getTime();
        return timeA - timeB;
    });

    // Clear container and remove empty state message
    chatMessagesContainer.innerHTML = '';
    chatMessagesContainer.style.gap = '0.3234rem';
    
    // Reset images array
    allConversationImages = [];

    sortedParts.forEach(part => {
        const message = part.body || '';
        const author = part.author || {};
        const authorName = author.name || author.email || 'Unknown';
        const authorType = author.type || 'unknown'; // 'user', 'admin', 'bot', etc.
        const partType = part.part_type || 'comment'; // 'comment', 'assignment', etc.
        
        // Convert Unix timestamp to Date object (Intercom returns timestamps in seconds)
        let timestamp;
        if (typeof part.created_at === 'number') {
            // Unix timestamp in seconds - convert to milliseconds
            timestamp = new Date(part.created_at < 10000000000 ? part.created_at * 1000 : part.created_at);
        } else {
            timestamp = new Date(part.created_at);
        }
        
        // Format timestamp for display
        const timeStr = timestamp.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
        const dateStr = timestamp.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
        });
        
        // Check if this is a system comment part type (should be displayed outside chat bubbles)
        const systemCommentTypes = [
            'user_became_idle',
            'close',
            'fin_guidance_applied',
            'conversation_attribute_updated_by_admin',
            'attribute_collected'
        ];
        const isSystemComment = systemCommentTypes.includes(partType);
        
        // If this is a system comment, render it differently (outside chat bubbles)
        if (isSystemComment) {
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                width: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                margin: 0.4043rem 0;
                padding: 0 0.8086rem;
            `;
            
            // Format the message body
            let messageData;
            try {
                messageData = formatMessageBody(message);
            } catch (e) {
                console.error('Error formatting message body for system comment:', e);
                messageData = { text: '', html: null, images: [] };
            }
            const formattedText = messageData?.text || '';
            const formattedHtml = messageData?.html || null;
            
            // Create human-readable label for the part type
            const partTypeLabels = {
                'user_became_idle': 'User became idle',
                'close': 'Conversation closed',
                'fin_guidance_applied': 'Guidance applied',
                'conversation_attribute_updated_by_admin': 'Attribute updated by admin',
                'attribute_collected': 'Attribute collected'
            };
            const partTypeLabel = partTypeLabels[partType] || partType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            
            // Build the system comment content
            let commentContent = '';
            // Use text version for system comments to avoid HTML rendering issues
            if (formattedText && formattedText.trim() !== '' && formattedText.trim() !== '{}') {
                commentContent = formattedText;
            } else if (part.body && String(part.body).trim() !== '') {
                // Fallback: strip HTML tags from body and get plain text
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = String(part.body);
                commentContent = tempDiv.textContent || tempDiv.innerText || '';
            }
            
            // Escape HTML for safe display
            if (commentContent) {
                const tempEscDiv = document.createElement('div');
                tempEscDiv.textContent = commentContent;
                commentContent = tempEscDiv.innerHTML;
            }
            
            messageDiv.innerHTML = `
                <div style="
                    background: #f3f4f6;
                    border: 0.0304rem solid #e5e7eb;
                    border-radius: 0.2426rem;
                    padding: 0.3234rem 0.4852rem;
                    max-width: 80%;
                    text-align: center;
                    font-size: 0.4447rem;
                    color: #6b7280;
                    line-height: 1.5;
                ">
                    <div style="
                        font-weight: 600;
                        color: #4b5563;
                        margin-bottom: 0.1213rem;
                        text-transform: uppercase;
                        letter-spacing: 0.0405rem;
                        font-size: 0.4043rem;
                    ">${partTypeLabel.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}</div>
                    ${commentContent ? `<div style="margin-top: 0.1617rem; color: #6b7280; font-size: 0.4447rem;">${commentContent}</div>` : ''}
                    <div style="
                        margin-top: 0.1617rem;
                        font-size: 0.3639rem;
                        color: #9ca3af;
                        opacity: 0.8;
                    ">${timeStr} • ${dateStr}</div>
                </div>
            `;
            
            chatMessagesContainer.appendChild(messageDiv);
            return; // Skip normal message rendering for system comments
        }
        
        // Continue with normal message rendering for non-system-comment parts
        const isUser = authorType === 'user' || authorType === 'contact';
        const isAdmin = authorType === 'admin' || authorType === 'team';
        // Detect AI/Bot messages - be strict: only if explicitly bot type or has AI flags
        // Don't check name for "ai" as admins might be labeled as "AI" but are actually agents
        const isAI = authorType === 'bot' || 
                    author.from_ai_agent === true || 
                    author.is_ai_answer === true ||
                    (part.from_ai_agent === true) ||
                    (part.is_ai_answer === true);
        
        // Format the message body to check if it has content
        // This extracts images from HTML img tags and text-based [Image "..."] references
        const messageData = formatMessageBody(message);
        const formattedText = messageData.text;
        const formattedHtml = messageData.html || null; // HTML with inline images
        const images = messageData.images || [];
        
        // Check if this is an email interaction
        // email_message_metadata is either null (not an email) or an object with properties (is an email)
        // Note: typeof null === 'object' in JavaScript, so we must explicitly check for null
        const isEmail = !!(part.email_message_metadata && 
            part.email_message_metadata !== null && 
            typeof part.email_message_metadata === 'object' && 
            Object.keys(part.email_message_metadata).length > 0);
        const emailMetadata = isEmail ? part.email_message_metadata : {};
        
        // Extract attachments from attachments array (separate from body images)
        const attachments = part.attachments || [];
        
        // Extract image attachments - check multiple possible structures
        const attachmentImages = [];
        attachments.forEach(att => {
            // Check if it's an image attachment
            const isImage = (
                (att.type === 'upload' || att.type === 'image' || !att.type) &&
                (
                    (att.content_type && att.content_type.startsWith('image/')) ||
                    (att.url && /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i.test(att.url))
                ) &&
                att.url
            );
            
            if (isImage && att.url) {
                attachmentImages.push(att.url);
            }
        });
        
        // Combine body images and attachment images
        // Body images come first (they appear inline in text), then attachments
        const allImages = [...images, ...attachmentImages];
        
        // Add images to global array with their index for viewer navigation
        const imageStartIndex = allConversationImages.length;
        allImages.forEach((imgSrc, idx) => {
            allConversationImages.push({
                src: imgSrc,
                partIndex: sortedParts.indexOf(part),
                localIndex: idx
            });
        });
        
        // REMOVED: No longer skipping any parts - show ALL parts in the chatbox
        // Always display parts so users can see everything, even if empty
        
        // Check what content this part has (for display purposes)
        const hasBody = !!(part.body && String(part.body).trim() !== '');
        const hasText = !!(formattedText && formattedText.trim() !== '' && formattedText.trim() !== '{}');
        const hasHtml = !!formattedHtml;
        const hasImages = allImages.length > 0;
        const hasAttachments = attachments.length > 0;
        
        // Build content info badge to show in UI what this part contains
        // Always show part_type for all parts
        let contentInfoBadge = '';
        const contentTypes = [];
        
        // Always include part_type first
        if (partType) {
            contentTypes.push(`Type: ${partType}`);
        }
        
        // Then add content types
        if (hasText || hasHtml) contentTypes.push('Text');
        if (hasImages) contentTypes.push(`${allImages.length} Image${allImages.length > 1 ? 's' : ''}`);
        if (hasAttachments) contentTypes.push(`${attachments.length} Attachment${attachments.length > 1 ? 's' : ''}`);
        if (isEmail) contentTypes.push('Email');
        
        // Always show badge if we have part_type or any content
        if (contentTypes.length > 0 || partType) {
            contentInfoBadge = `<div style="
                font-size: 0.3639rem;
                color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.7)'};
                margin-bottom: 0.1617rem;
                padding: 0.1213rem 0.2426rem;
                background: ${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'};
                border-radius: 0.1617rem;
                display: inline-block;
            ">
                ${contentTypes.length > 0 ? contentTypes.join(' • ') : (partType ? `Part Type: ${partType}` : 'Empty Part')}
            </div>`;
        }

        // Determine message type for avatar and styling
        // Important: Agents should be green, AI should be dark gray
        const messageType = isUser ? 'user' : (isAI ? 'ai' : 'agent');
        const avatar = generateAvatar(authorName, messageType);
        
        // Create message bubble container (avatar will be added in innerHTML)
        const messageDiv = document.createElement('div');

        // Colors: User = white, Agent = #1A733E, AI = #1d1d1d (dark gray)
        const bubbleStyle = isUser 
            ? `
                background: white;
                color: #374151;
                border: 0.0304rem solid #e5e7eb;
                border-radius: 0.4852rem 0.4852rem 0.4852rem 0.1617rem;
                max-width: 100%;
                width: fit-content;
                margin-right: auto;
                margin-left: 0;
            `
            : isAI
            ? `
                background: #1d1d1d;
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 100%;
                width: fit-content;
                margin-left: auto;
                margin-right: 0;
            `
            : `
                background: #1A733E;
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 100%;
                width: fit-content;
                margin-left: auto;
                margin-right: 0;
            `;

        // Build email header if this is an email
        let emailHeaderHTML = '';
        if (isEmail) {
            const emailHeaders = emailMetadata.email_address_headers || [];
            const fromHeader = emailHeaders.find(h => h.type === 'from') || {};
            const toHeader = emailHeaders.find(h => h.type === 'to') || {};
            const replyToHeader = emailHeaders.find(h => h.type === 'reply_to') || {};
            const subject = emailMetadata.subject || 'No Subject';
            
            // Format email addresses
            const formatEmailAddress = (header) => {
                if (!header) return '';
                const name = header.name || '';
                const email = header.email_address || '';
                if (name && email) {
                    return `${escapeHtml(name)} <${escapeHtml(email)}>`;
                } else if (email) {
                    return escapeHtml(email);
                } else if (name) {
                    return escapeHtml(name);
                }
                return '';
            };
            
            const fromStr = formatEmailAddress(fromHeader);
            const toStr = formatEmailAddress(toHeader);
            const replyToStr = formatEmailAddress(replyToHeader);
            
            // For agent emails, use a more prominent blue background that stands out from green
            // For user emails, use a light blue background
            // For AI emails, use dark gray background matching chat bubble
            const emailBgColor = isUser ? '#e0f2fe' : (isAI ? '#2d2d2d' : '#1e40af');
            const emailBorderColor = isUser ? '#0284c7' : (isAI ? '#1d1d1d' : '#3b82f6');
            const emailIconColor = isUser ? '#0284c7' : (isAI ? '#ffffff' : '#93c5fd');
            const emailTextColor = isUser ? '#0369a1' : (isAI ? '#ffffff' : '#bfdbfe');
            const emailLabelColor = isUser ? '#0369a1' : (isAI ? '#ffffff' : '#bfdbfe');
            const emailSubjectColor = isUser ? '#0c4a6e' : (isAI ? '#ffffff' : '#dbeafe');
            const emailFieldColor = isUser ? '#075985' : (isAI ? '#e5e7eb' : '#bfdbfe');
            const emailBorderBottomColor = isUser ? 'rgba(2, 132, 199, 0.2)' : (isAI ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.2)');
            
            emailHeaderHTML = `
                <div style="
                    background: ${emailBgColor};
                    border: 0.0606rem solid ${emailBorderColor};
                    padding: 0.4852rem 0.5659rem;
                    margin-bottom: 0.4043rem;
                    border-radius: 0.3234rem;
                    font-size: 0.4447rem;
                    box-shadow: 0 0.0405rem 0.1213rem rgba(0,0,0,0.1);
                    max-width: 100%;
                    box-sizing: border-box;
                    word-wrap: break-word;
                    overflow-wrap: break-word;
                ">
                    <div style="display: flex; align-items: center; gap: 0.3234rem; margin-bottom: 0.2426rem; padding-bottom: 0.1617rem; border-bottom: 0.0304rem solid ${emailBorderBottomColor};">
                        <svg style="width: 0.6064rem; height: 0.6064rem; color: ${emailIconColor}; flex-shrink: 0;" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"></path>
                            <path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"></path>
                        </svg>
                        <span style="font-weight: 700; color: ${emailLabelColor}; text-transform: uppercase; font-size: 0.4043rem; letter-spacing: 0.0405rem;">Email</span>
                    </div>
                    ${subject ? `<div style="color: ${emailSubjectColor}; margin-bottom: 0.2426rem; font-weight: 600; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
                        <span style="color: ${emailFieldColor}; font-weight: 700;">Subject:</span> ${escapeHtml(subject)}
                    </div>` : ''}
                    <div style="color: ${emailSubjectColor}; font-size: 0.4043rem; line-height: 1.6; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word;">
                        ${fromStr ? `<div style="margin-bottom: 0.1213rem; word-wrap: break-word; overflow-wrap: break-word;"><span style="color: ${emailFieldColor}; font-weight: 600;">From:</span> ${fromStr}</div>` : ''}
                        ${toStr ? `<div style="margin-bottom: 0.1213rem; word-wrap: break-word; overflow-wrap: break-word;"><span style="color: ${emailFieldColor}; font-weight: 600;">To:</span> ${toStr}</div>` : ''}
                        ${replyToStr ? `<div style="margin-top: 0.1213rem; font-size: 0.3639rem; opacity: 0.9; word-wrap: break-word; overflow-wrap: break-word;"><span style="color: ${emailFieldColor}; font-weight: 600;">Reply-To:</span> ${replyToStr}</div>` : ''}
                    </div>
                </div>
            `;
        }

        // Build attachments HTML (non-image attachments)
        let attachmentsHTML = '';
        const nonImageAttachments = attachments.filter(att => 
            att.type === 'upload' && 
            (!att.content_type || !att.content_type.startsWith('image/'))
        );
        if (nonImageAttachments.length > 0) {
            attachmentsHTML = '<div style="margin-top: 0.3234rem; display: flex; flex-direction: column; gap: 0.1617rem;">';
            nonImageAttachments.forEach(att => {
                attachmentsHTML += `
                    <a 
                        href="${escapeHtml(att.url)}" 
                        target="_blank"
                        rel="noopener noreferrer"
                        style="
                            display: flex;
                            align-items: center;
                            gap: 0.2426rem;
                            padding: 0.2426rem 0.3234rem;
                            background: ${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'};
                            border-radius: 0.2426rem;
                            text-decoration: none;
                            color: ${isUser ? '#374151' : 'white'};
                            font-size: 0.4447rem;
                            transition: background 0.2s ease;
                        "
                        onmouseover="this.style.background='${isUser ? '#e5e7eb' : 'rgba(255,255,255,0.15)'}'"
                        onmouseout="this.style.background='${isUser ? '#f3f4f6' : 'rgba(255,255,255,0.1)'}'"
                    >
                        <svg style="width: 0.4852rem; height: 0.4852rem; flex-shrink: 0;" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z" clip-rule="evenodd"/>
                        </svg>
                        <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(att.name || 'Attachment')}</span>
                        ${att.filesize ? `<span style="color: ${isUser ? '#9ca3af' : 'rgba(255,255,255,0.7)'}; font-size: 0.3639rem;">${(att.filesize / 1024).toFixed(1)} KB</span>` : ''}
                    </a>
                `;
            });
            attachmentsHTML += '</div>';
        }

        // Build images HTML (for images that aren't inline in text)
        let imagesHTML = '';
        if (allImages.length > 0 && !formattedHtml) {
            imagesHTML = '<div style="margin-top: 0.3234rem; display: flex; flex-wrap: wrap; gap: 0.3234rem;">';
            allImages.forEach((imgSrc, idx) => {
                const globalIndex = imageStartIndex + idx;
                const escapedSrc = escapeHtmlAttribute(imgSrc);
                imagesHTML += `<img src="${escapedSrc}" alt="Attachment ${idx + 1}" onclick="window.openImageViewer(${globalIndex})" style="max-width: 200px; max-height: 200px; border-radius: 0.3234rem; cursor: pointer; object-fit: cover; border: 0.0304rem solid ${isUser ? '#e5e7eb' : 'rgba(255,255,255,0.3)'}; transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 0.1617rem 0.4852rem rgba(0,0,0,0.2)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'" onerror="console.error('Failed to load image:', this.src);" loading="lazy" />`;
            });
            imagesHTML += '</div>';
        }

        // Compact layout: timestamp next to sender name for both user and agent messages
        // For emails, make the border more prominent
        const emailBorderStyle = isEmail ? `border: 0.0808rem solid ${isUser ? '#0284c7' : (isAI ? '#1d1d1d' : '#3b82f6')} !important; box-shadow: 0 0.0606rem 0.1617rem ${isUser ? 'rgba(2, 132, 199, 0.3)' : (isAI ? 'rgba(29, 29, 29, 0.3)' : 'rgba(59, 130, 246, 0.3)')} !important;` : '';
        
        // Avatar alignment: Client on left, Agent/AI on right
        const avatarAlign = isUser ? 'flex-start' : 'flex-end';
        const avatarMargin = isUser ? 'margin-right: 0.3234rem;' : 'margin-left: 0.3234rem;';
        const avatarOrder = isUser ? '1' : '3';
        
        // Avatar HTML - Client left, Agent/AI right
        // For AI, use the image avatar; for others, use gradient with initials
        const avatarHTML = isAI ? `
            <div style="display: flex; flex-direction: column; align-items: ${avatarAlign}; margin-bottom: 0.2426rem; ${avatarMargin} flex-shrink: 0; order: ${avatarOrder};">
                <div style="
                    width: 1.455rem;
                    height: 1.455rem;
                    border-radius: 50%;
                    background: ${avatar.bgGradient};
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    flex-shrink: 0;
                    box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1);
                    border: 0.0203rem solid ${avatar.borderColor};
                    position: relative;
                    overflow: hidden;
                ">
                    <img src="./assets/logos/ai_avatar.webp" alt="AI Avatar" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" onerror="console.error('AI avatar image failed to load:', this.src); this.style.display='none'; this.parentElement.innerHTML='<span style=\\'position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2); color: ${avatar.textColor}; font-size: 0.5257rem; font-weight: 700;\\'>${avatar.initials}</span>';" />
                </div>
                <span style="
                    font-size: 0.3639rem;
                    font-weight: 600;
                    color: ${isUser ? '#6b7280' : (isAI ? '#1d1d1d' : '#1A733E')};
                    margin-top: 0.0808rem;
                    text-transform: uppercase;
                    letter-spacing: 0.0203rem;
                ">${avatar.label}</span>
            </div>
        ` : `
            <div style="display: flex; flex-direction: column; align-items: ${avatarAlign}; margin-bottom: 0.2426rem; ${avatarMargin} flex-shrink: 0; order: ${avatarOrder};">
                <div style="
                    width: 1.455rem;
                    height: 1.455rem;
                    border-radius: 50%;
                    background: ${avatar.bgGradient};
                    color: ${avatar.textColor};
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 0.5257rem;
                    font-weight: 700;
                    flex-shrink: 0;
                    box-shadow: 0 0.0808rem 0.1617rem rgba(0,0,0,0.2), 0 0.0203rem 0.0405rem rgba(0,0,0,0.1), inset 0 0.0203rem 0 rgba(255,255,255,0.2);
                    border: 0.0203rem solid ${avatar.borderColor};
                    position: relative;
                    overflow: hidden;
                ">
                    <span style="position: relative; z-index: 1; text-shadow: 0 0.0203rem 0.0405rem rgba(0,0,0,0.2);">${avatar.initials}</span>
                </div>
                <span style="
                    font-size: 0.3639rem;
                    font-weight: 600;
                    color: ${isUser ? '#6b7280' : (isAI ? '#1d1d1d' : '#1A733E')};
                    margin-top: 0.0808rem;
                    text-transform: uppercase;
                    letter-spacing: 0.0203rem;
                ">${avatar.label}</span>
            </div>
        `;
        
        // Message container: Client avatar left, Agent/AI avatar right
        messageDiv.style.cssText = `
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            margin-bottom: 0;
            width: 100%;
            justify-content: ${isUser ? 'flex-start' : 'flex-end'};
            gap: 0.3234rem;
        `;
        
        messageDiv.innerHTML = `
            ${isUser ? avatarHTML : ''}
            <div style="flex: 1; display: flex; flex-direction: column; align-items: ${isUser ? 'flex-start' : 'flex-end'}; order: ${isUser ? '2' : '1'}; min-width: 0; max-width: calc(100% - 3.5rem);">
                <div style="${bubbleStyle} padding: 0.4043rem 0.5659rem; box-shadow: 0 0.0304rem 0.0606rem rgba(0,0,0,0.08); ${emailBorderStyle} word-wrap: break-word; overflow-wrap: break-word;">
                ${isUser ? `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${isEmail ? '0' : '0.1213rem'}; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: #6b7280;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.7; color: #6b7280; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>` : `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: ${isEmail ? '0' : '0.1213rem'}; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: white;">${escapeHtml(authorName)}</span><span style="font-size: 0.3639rem; opacity: 0.8; color: white; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>`}
                ${emailHeaderHTML}
                ${contentInfoBadge}
                ${formattedHtml ? renderMessageWithInlineImages(formattedHtml, images, imageStartIndex, part.id, isUser) : 
                  (hasText ? 
                    `<div class="message-text-content" data-original-text="${escapeHtml(formattedText.replace(/"/g, '&quot;'))}" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; white-space: pre-wrap; word-wrap: break-word; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#374151' : 'white'};">${formattedText}</div>` : 
                    (partType && partType.trim() !== '' ? 
                        `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.8)'}; font-style: italic;">
                            <span style="text-transform: uppercase; font-weight: 600; letter-spacing: 0.0405rem; font-size: 0.4447rem; opacity: 0.8;">${escapeHtml(partType)}</span>
                            ${hasBody ? '<span style="margin-left: 0.2426rem; font-size: 0.4043rem; opacity: 0.6;">(body exists but no displayable content)</span>' : ''}
                        </div>` : 
                        (hasBody || hasImages || hasAttachments || isEmail ? 
                            `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#6b7280' : 'rgba(255,255,255,0.8)'}; font-style: italic;">
                                <span style="opacity: 0.7;">Part ID: ${part.id}</span>
                                ${hasBody ? '<span style="margin-left: 0.2426rem;">• Has body (no displayable text)</span>' : ''}
                            </div>` : 
                            `<div class="message-text-content" data-message-id="${part.id}" style="font-size: 0.5257rem; line-height: 1.5; margin-top: ${isEmail ? '0.2426rem' : '0'}; margin-bottom: ${(allImages.length > 0 || attachments.length > 0) ? '0.3234rem' : '0'}; color: ${isUser ? '#9ca3af' : 'rgba(255,255,255,0.5)'}; font-style: italic;">
                                <span style="opacity: 0.6;">Empty part (ID: ${part.id})</span>
                            </div>`
                        )
                    )
                )}
                ${!formattedHtml && imagesHTML ? imagesHTML : ''}
                ${attachmentsHTML}
                </div>
            </div>
            ${!isUser ? avatarHTML : ''}
        `;

        chatMessagesContainer.appendChild(messageDiv);
    });

    // Scroll to bottom after a brief delay to ensure DOM is updated
    setTimeout(() => {
        const transcriptChatView = document.getElementById('transcriptChatView');
        if (transcriptChatView) {
            transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
        }
    }, 100);
}

// Language detection function - simple heuristic to detect non-English text
function detectLanguage(text) {
    if (!text || text.trim().length === 0) return 'en';
    
    // Remove HTML tags and get plain text
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = text;
    const plainText = tempDiv.textContent || tempDiv.innerText || '';
    
    // Simple heuristic: check for common English patterns
    // Count English letters vs non-English characters
    const englishPattern = /[a-zA-Z]/g;
    const nonEnglishPattern = /[^\x00-\x7F]/g;
    
    const englishChars = (plainText.match(englishPattern) || []).length;
    const nonEnglishChars = (plainText.match(nonEnglishPattern) || []).length;
    const totalChars = plainText.replace(/\s/g, '').length;
    
    // If more than 30% non-ASCII characters, likely not English
    if (totalChars > 0 && (nonEnglishChars / totalChars) > 0.3) {
        return 'auto'; // Needs translation
    }
    
    // Check for common non-English language patterns
    const commonNonEnglishPatterns = [
        /[\u0600-\u06FF]/g, // Arabic
        /[\u4E00-\u9FFF]/g, // Chinese
        /[\u3040-\u309F\u30A0-\u30FF]/g, // Japanese
        /[\u0400-\u04FF]/g, // Cyrillic
        /[\u0590-\u05FF]/g, // Hebrew
        /[\u0E00-\u0E7F]/g, // Thai
    ];
    
    for (const pattern of commonNonEnglishPatterns) {
        if (pattern.test(plainText)) {
            return 'auto'; // Needs translation
        }
    }
    
    return 'en'; // Likely English
}

// Translate text using LibreTranslate API with retry logic
async function translateText(text, targetLang = 'en', retryCount = 0) {
    if (!text || text.trim().length === 0) return text;
    
    const maxRetries = 3;
    const baseDelay = 1000; // Start with 1 second delay
    
    try {
        // Use LibreTranslate public API
        const response = await fetch('https://libretranslate.com/translate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                q: text,
                source: 'auto',
                target: targetLang,
                format: 'text'
            })
        });
        
        // Handle rate limiting with exponential backoff
        if (response.status === 429) {
            if (retryCount < maxRetries) {
                const delay = baseDelay * Math.pow(2, retryCount); // Exponential backoff: 1s, 2s, 4s
                await new Promise(resolve => setTimeout(resolve, delay));
                return translateText(text, targetLang, retryCount + 1);
            } else {
                throw new Error('Rate limit exceeded. Please try again later.');
            }
        }
        
        // Handle bad requests (400) - skip this message
        if (response.status === 400) {
            console.warn('Bad request for translation, skipping:', text.substring(0, 50));
            return text; // Return original text
        }
        
        if (!response.ok) {
            throw new Error(`Translation API error: ${response.status}`);
        }
        
        const data = await response.json();
        return data.translatedText || text;
    } catch (error) {
        // If it's a rate limit error and we've exhausted retries, try fallback
        if (error.message && error.message.includes('Rate limit') && retryCount >= maxRetries) {
            // Fallback: try MyMemory Translation API
            try {
                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=auto|en`);
                const data = await response.json();
                if (data.responseData && data.responseData.translatedText) {
                    return data.responseData.translatedText;
                }
            } catch (fallbackError) {
                console.error('Fallback translation error:', fallbackError);
            }
        }
        
        // If error doesn't mention rate limit, log it but return original text
        if (!error.message || !error.message.includes('Rate limit')) {
            console.error('Translation error:', error);
        }
        
        return text; // Return original if translation fails
    }
}

// Main translation function
async function translateChatMessages() {
    // Feature is currently disabled
    const translateBtn = document.getElementById('translateChatBtn');
    if (translateBtn && translateBtn.disabled) {
        return;
    }
    
    const chatMessagesContainer = document.getElementById('chatMessagesContainer');
    
    if (!chatMessagesContainer) {
        showNotification('Chat messages container not found', 'error');
        return;
    }
    
    // Get all message text elements
    const messageTextElements = chatMessagesContainer.querySelectorAll('.message-text-content');
    
    if (messageTextElements.length === 0) {
        showNotification('No messages to translate', 'info');
        return;
    }
    
    let translatedCount = 0;
    let skippedCount = 0;
    
    // Process messages sequentially to avoid rate limiting
    // Use longer delays for public API (500ms between requests)
    const delayBetweenRequests = 500;
    
    for (let i = 0; i < messageTextElements.length; i++) {
        const element = messageTextElements[i];
        const originalText = element.getAttribute('data-original-text');
        if (!originalText) continue;
        
        // Decode HTML entities to get plain text
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = originalText;
        const plainText = tempDiv.textContent || tempDiv.innerText || '';
        
        // Skip if text is too short or empty
        if (plainText.trim().length < 3) {
            skippedCount++;
            continue;
        }
        
        // Detect language
        const detectedLang = detectLanguage(plainText);
        
        if (detectedLang === 'en') {
            skippedCount++;
            continue; // Skip English messages
        }
        
        // Translate the text
        try {
            const translatedText = await translateText(plainText, 'en');
            
            // Only update if translation is different from original
            if (translatedText && translatedText.trim() !== plainText.trim() && translatedText !== plainText) {
                // Update the element with translated text (escape HTML for safety)
                element.innerHTML = escapeHtml(translatedText);
                translatedCount++;
            } else {
                skippedCount++;
            }
            
            // Delay between requests to avoid rate limiting (500ms)
            // Skip delay for last message
            if (i < messageTextElements.length - 1) {
                await new Promise(resolve => setTimeout(resolve, delayBetweenRequests));
            }
        } catch (error) {
            console.error('Error translating message:', error);
            skippedCount++;
            // If rate limited, add extra delay
            if (error.message && error.message.includes('Rate limit')) {
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
    }
    
    // Show completion notification
    if (translatedCount > 0) {
        showNotification(`Translated ${translatedCount} message(s) to English`, 'success');
    } else if (skippedCount > 0) {
        showNotification('All messages are already in English', 'info');
    } else {
        showNotification('No messages found to translate', 'info');
    }
}

// Make translation function globally accessible
window.translateChatMessages = translateChatMessages;

// Format message body (handle HTML/plain text and extract images)
function formatMessageBody(body) {
    if (!body) return { text: '', images: [], html: null };
    
    // If body is an object, extract text
    if (typeof body === 'object') {
        // Handle empty objects
        if (Object.keys(body).length === 0) return { text: '', images: [], html: null };
        
        // Check for text content in various possible fields
        if (body.plaintext) {
            const text = String(body.plaintext).trim();
            return { text: text ? escapeHtml(text) : '', images: [], html: null };
        }
        if (body.text) {
            const text = String(body.text).trim();
            return { text: text ? escapeHtml(text) : '', images: [], html: null };
        }
        if (body.body) {
            return parseHtmlBody(String(body.body));
        }
        
        // Check for HTML content
        if (body.html) {
            return parseHtmlBody(String(body.html));
        }
        
        // If object has no text content, return empty
        // Don't stringify as that would just show "{}"
        return { text: '', images: [], html: null };
    }
    
    // Handle string body (which may contain HTML)
    return parseHtmlBody(String(body));
}

// Parse HTML body to extract text and images (preserve inline images)
// Handles both HTML <img> tags and text-based [Image "..."] references
function parseHtmlBody(htmlBody) {
    if (!htmlBody) return { text: '', images: [], html: '' };
    
    const htmlString = String(htmlBody);
    const images = [];
    let processedHtml = htmlString;
    
    // Step 1: Extract images from HTML <img> tags
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlString;
    
    const imgTags = tempDiv.querySelectorAll('img');
    let imageIndex = 0;
    
    imgTags.forEach((img) => {
        const src = img.getAttribute('src') || '';
        if (src) {
            // Decode HTML entities in URL (but preserve the original URL structure)
            let decodedSrc = src;
            // Only decode if it's clearly an HTML entity, not part of URL encoding
            if (src.includes('&amp;') && !src.includes('?')) {
                decodedSrc = src.replace(/&amp;/g, '&');
            }
            images.push(decodedSrc);
            
            // Replace img tag with a placeholder
            const placeholder = document.createTextNode(`__IMAGE_PLACEHOLDER_${imageIndex}__`);
            if (img.parentNode) {
                img.parentNode.replaceChild(placeholder, img);
            }
            imageIndex++;
        }
    });
    
    // Get HTML with placeholders from img tags
    processedHtml = tempDiv.innerHTML;
    
    // Step 2: Extract images from text-based [Image "..."] references
    // Pattern: [Image "URL"] or [Image 'URL'] or [Image URL]
    // Need to handle URLs with query parameters that might contain quotes
    // More robust pattern: [Image "..."], [Image '...'], or [Image ...]
    const imageReferencePattern = /\[Image\s+(?:"([^"]+)"|'([^']+)'|([^\]]+))\]/gi;
    let match;
    const textImageMatches = [];
    
    // Find all matches and their positions
    while ((match = imageReferencePattern.exec(htmlString)) !== null) {
        // match[1] = double-quoted URL, match[2] = single-quoted URL, match[3] = unquoted URL
        const imageUrl = match[1] || match[2] || match[3];
        const fullMatch = match[0];
        const matchIndex = match.index;
        
        if (imageUrl && imageUrl.trim() && !images.includes(imageUrl.trim())) {
            const trimmedUrl = imageUrl.trim();
            // Only add if not already found in HTML img tags
            textImageMatches.push({
                url: trimmedUrl,
                fullMatch: fullMatch,
                index: matchIndex,
                placeholderIndex: imageIndex
            });
            images.push(trimmedUrl);
            imageIndex++;
        }
    }
    
    // Replace text-based image references with placeholders (in reverse order to preserve indices)
    textImageMatches.reverse().forEach(match => {
        const placeholder = `__IMAGE_PLACEHOLDER_${match.placeholderIndex}__`;
        processedHtml = processedHtml.substring(0, match.index) + 
                      placeholder + 
                      processedHtml.substring(match.index + match.fullMatch.length);
    });
    
    // Step 3: Sanitize HTML using DOMPurify (security + clean HTML)
    if (typeof DOMPurify !== 'undefined') {
        processedHtml = DOMPurify.sanitize(processedHtml, {
            ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'b', 'i', 'u', 'a', 'ul', 'ol', 'li', 'code', 'pre', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
            ALLOWED_ATTR: ['href', 'target', 'rel', 'class'],
            ALLOW_DATA_ATTR: false,
            KEEP_CONTENT: true,
            RETURN_DOM: false,
            RETURN_DOM_FRAGMENT: false
        });
    }
    
    // Step 4: Extract plain text for fallback (remove placeholders)
    const tempDiv2 = document.createElement('div');
    tempDiv2.innerHTML = processedHtml;
    const plainText = tempDiv2.textContent || tempDiv2.innerText || '';
    const cleanedText = plainText.replace(/__IMAGE_PLACEHOLDER_\d+__/g, '').trim();
    
    // Return HTML with placeholders, plain text, and images array
    return { 
        text: cleanedText, 
        images: images, 
        html: processedHtml // HTML with image placeholders, sanitized and preserving formatting
    };
}

// Escape HTML attribute value (for src attributes, preserve URL structure)
// Important: Only escape characters that would break HTML attributes
// Don't double-encode URL parameters (they're already properly encoded)
function escapeHtmlAttribute(value) {
    if (!value) return '';
    const str = String(value);
    
    // Only escape characters that would break the HTML attribute
    // Preserve URL structure including query parameters
    return str
        .replace(/&/g, '&amp;')  // Must escape & first
        .replace(/"/g, '&quot;')  // Escape quotes
        .replace(/'/g, '&#x27;')  // Escape single quotes
        .replace(/</g, '&lt;')    // Escape <
        .replace(/>/g, '&gt;');   // Escape >
    
    // Note: We don't escape spaces, slashes, or other URL characters
    // as they're already properly encoded in the URL
}

// Render message with inline images (replace placeholders with actual image elements)
function renderMessageWithInlineImages(htmlWithPlaceholders, images, imageStartIndex, messageId, isUser) {
    if (!htmlWithPlaceholders) return '';
    
    let renderedHtml = htmlWithPlaceholders;
    let replacedCount = 0;
    
    // Replace each image placeholder with an actual image element
    images.forEach((imgSrc, idx) => {
        const globalIndex = imageStartIndex + idx;
        const placeholder = `__IMAGE_PLACEHOLDER_${idx}__`;
        
        // Escape the image src for HTML attribute (preserve URL structure)
        // Only escape characters that would break the HTML attribute, preserve URL structure
        const escapedSrc = escapeHtmlAttribute(imgSrc);
        
        // Create image HTML with proper styling and click handler
        // Use proper attribute escaping for src, but don't double-encode URL parameters
        const imageHtml = `<img src="${escapedSrc}" alt="Image ${idx + 1}" onclick="window.openImageViewer(${globalIndex})" onerror="console.error('Failed to load image:', this.src); this.style.display='none';" style="max-width: 100%; max-height: 20rem; border-radius: 0.3234rem; margin: 0.3234rem 0; cursor: pointer; display: block; box-shadow: 0 0.1213rem 0.2426rem rgba(0,0,0,0.1); transition: transform 0.2s ease, box-shadow 0.2s ease;" onmouseover="this.style.transform='scale(1.02)'; this.style.boxShadow='0 0.2426rem 0.4852rem rgba(0,0,0,0.15)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 0.1213rem 0.2426rem rgba(0,0,0,0.1)';" loading="lazy" />`;
        
        if (renderedHtml.includes(placeholder)) {
            renderedHtml = renderedHtml.replace(placeholder, imageHtml);
            replacedCount++;
        } else {
            console.warn(`⚠️ Image placeholder ${placeholder} not found in HTML for message ${messageId}`);
        }
    });
    
    // Clean up any remaining placeholders (shouldn't happen, but just in case)
    const remainingPlaceholders = (renderedHtml.match(/__IMAGE_PLACEHOLDER_\d+__/g) || []).length;
    if (remainingPlaceholders > 0) {
        console.warn(`⚠️ ${remainingPlaceholders} image placeholders not replaced in message ${messageId}`);
        renderedHtml = renderedHtml.replace(/__IMAGE_PLACEHOLDER_\d+__/g, '');
    }
    
    // Add CSS class based on message type for styling
    const messageClass = isUser ? '' : 'agent-message';
    const textColor = isUser ? '#374151' : 'white';
    
    return `<div class="message-text-content ${messageClass}" data-message-id="${messageId}" style="font-size: 0.5257rem; line-height: 1.6; word-wrap: break-word; margin-top: 0; margin-bottom: 0; color: ${textColor};">
        ${renderedHtml}
    </div>`;
}

// Store all images from conversation for image viewer
let allConversationImages = [];
let currentImageIndex = 0;

// Open image viewer modal
window.openImageViewer = function(index) {
    if (!allConversationImages || allConversationImages.length === 0) return;
    
    currentImageIndex = Math.max(0, Math.min(index, allConversationImages.length - 1));
    const modal = document.getElementById('imageViewerModal');
    const img = document.getElementById('imageViewerImg');
    const prevBtn = document.getElementById('imageViewerPrev');
    const nextBtn = document.getElementById('imageViewerNext');
    const counter = document.getElementById('imageViewerCounter');
    const closeBtn = document.getElementById('imageViewerClose');
    
    if (modal && img) {
        img.src = allConversationImages[currentImageIndex].src;
        img.style.display = 'block';
        
        // Update counter
        if (counter) {
            counter.textContent = `${currentImageIndex + 1} / ${allConversationImages.length}`;
        }
        
        // Show/hide navigation buttons
        if (prevBtn) {
            prevBtn.style.display = allConversationImages.length > 1 ? 'flex' : 'none';
        }
        if (nextBtn) {
            nextBtn.style.display = allConversationImages.length > 1 ? 'flex' : 'none';
        }
        
        modal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        
        // Focus on modal for keyboard navigation
        modal.focus();
    }
};

// Close image viewer modal
function closeImageViewer() {
    const modal = document.getElementById('imageViewerModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = '';
    }
}

// Navigate to previous image
function navigateImage(direction) {
    if (!allConversationImages || allConversationImages.length === 0) return;
    
    if (direction === 'prev') {
        currentImageIndex = (currentImageIndex - 1 + allConversationImages.length) % allConversationImages.length;
    } else if (direction === 'next') {
        currentImageIndex = (currentImageIndex + 1) % allConversationImages.length;
    }
    
    const img = document.getElementById('imageViewerImg');
    const counter = document.getElementById('imageViewerCounter');
    
    if (img) {
        img.style.display = 'none';
        setTimeout(() => {
            img.src = allConversationImages[currentImageIndex].src;
            img.style.display = 'block';
        }, 150);
    }
    
    if (counter) {
        counter.textContent = `${currentImageIndex + 1} / ${allConversationImages.length}`;
    }
}

// Helper function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Toggle conversation info grid
function toggleConversationInfoGrid() {
    const content = document.getElementById('conversationInfoGridContent');
    const icon = document.getElementById('toggleInfoGridIcon');
    if (!content || !icon) return;
    
    const isHidden = content.style.display === 'none';
    content.style.display = isHidden ? 'grid' : 'none';
    icon.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
}

// Make toggle function globally accessible
window.toggleConversationInfoGrid = toggleConversationInfoGrid;

// Display all conversation attributes in UI-friendly format
function displayConversationAttributes(conversation) {
    // Hide the old panels
    const chatPanel = document.getElementById('conversationAttributesPanel');
    const textPanel = document.getElementById('conversationAttributesPanelTextView');
    if (chatPanel) chatPanel.style.display = 'none';
    if (textPanel) textPanel.style.display = 'none';
    
    // Show and populate the expanded info grid
    const infoGrid = document.getElementById('conversationInfoGrid');
    if (!infoGrid) return;
    
    const attributes = extractConversationAttributes(conversation);
    infoGrid.style.display = 'block';
    
    // Helper function to format value
    const formatValue = (key, value) => {
        if (value === null || value === undefined) return null;
        if (typeof value === 'boolean') return value ? 'Yes' : 'No';
        
        // Handle URLs (for Web Link)
        if (key.toLowerCase().includes('link') || key.toLowerCase().includes('url')) {
            const url = String(value);
            if (url.startsWith('http://') || url.startsWith('https://')) {
                return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer" style="color: #1A733E; text-decoration: underline; font-weight: 600;">View in Intercom →</a>`;
            }
        }
        
        if (typeof value === 'object') {
            if (Array.isArray(value)) {
                if (value.length === 0) return null;
                return value.map(item => {
                    if (typeof item === 'object') {
                        return Object.values(item).filter(v => v).join(' - ');
                    }
                    return String(item);
                }).join(', ');
            }
            return JSON.stringify(value, null, 2);
        }
        return String(value);
    };
    
    // Helper function to get icon and color for a key
    const getIconAndColor = (key) => {
        const iconMap = {
            'State': { icon: 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z', color: '#1A733E' },
            'Priority': { icon: 'M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z', color: '#f59e0b' },
            'Total Messages': { icon: 'M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z', color: '#3b82f6' },
            'Time to Admin Reply': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Time to Assignment': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Time to First Close': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Time to Last Close': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Median Time to Reply': { icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z', color: '#8b5cf6' },
            'Author Email': { icon: 'M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z', color: '#ec4899' },
            'Assigned To': { icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z', color: '#10b981' },
            'Created At': { icon: 'M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z', color: '#6366f1' },
            'Updated At': { icon: 'M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z', color: '#6366f1' },
            'Rating': { icon: 'M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z', color: '#f97316' },
            'Tags': { icon: 'M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z', color: '#06b6d4' },
            'User Messages': { icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z', color: '#3b82f6' },
            'Admin Messages': { icon: 'M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z', color: '#10b981' },
            'Reopens Count': { icon: 'M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15', color: '#f59e0b' },
            'Assignments Count': { icon: 'M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2', color: '#8b5cf6' }
        };
        
        return iconMap[key] || { icon: 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z', color: '#6b7280' };
    };
    
    // Helper function to create copy button
    const createCopyButton = (value, fieldName) => {
        if (!value) return '';
        return `
            <button onclick="event.stopPropagation(); navigator.clipboard.writeText('${escapeHtml(String(value))}').then(() => showNotification('${fieldName} copied!', 'success')).catch(() => showNotification('Failed to copy', 'error')); return false;" 
                style="padding: 0.0808rem; background: rgba(26, 115, 62, 0.1); border: none; border-radius: 0.1617rem; cursor: pointer; transition: all 0.2s; margin-left: 0.1617rem;"
                onmouseover="this.style.background='rgba(26, 115, 62, 0.2)';" onmouseout="this.style.background='rgba(26, 115, 62, 0.1)';"
                title="Copy ${fieldName}">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.3234rem; height: 0.3234rem; color: #1A733E;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                </svg>
            </button>
        `;
    };
    
    let html = '';
    const gridContainer = document.getElementById('conversationInfoGridContent');
    if (!gridContainer) return;
    
    // Display ALL attributes
    Object.keys(attributes).forEach(key => {
        const value = formatValue(key, attributes[key]);
        if (!value) return;
        
        const label = formatLabelForAttribute(key);
        const { icon, color } = getIconAndColor(key);
        const needsCopyButton = key === 'Author Email' || key === 'Custom: Account Number (MT4/MT5)' || key === 'Conversation ID';
        const copyBtn = needsCopyButton ? createCopyButton(attributes[key], label) : '';
        
        html += `
            <div style="background: #ffffff; border: 0.0304rem solid #e5e7eb; border-radius: 0.2425rem; padding: 0.3234rem; box-shadow: 0 0.0203rem 0.0606rem rgba(0,0,0,0.05); transition: all 0.2s;" onmouseover="this.style.boxShadow='0 0.0405rem 0.1213rem rgba(0,0,0,0.1)'; this.style.borderColor='#1A733E';" onmouseout="this.style.boxShadow='0 0.0203rem 0.0606rem rgba(0,0,0,0.05)'; this.style.borderColor='#e5e7eb';">
                <div style="display: flex; align-items: center; gap: 0.2425rem; margin-bottom: 0.1617rem;">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.4043rem; height: 0.4043rem; color: ${color}; flex-shrink: 0;">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${icon}"></path>
                    </svg>
                    <span style="font-size: 0.3639rem; font-weight: 600; color: #6b7280; text-transform: uppercase; letter-spacing: 0.0092rem;">${escapeHtml(label)}</span>
                </div>
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <span style="font-size: 0.4447rem; font-weight: 600; color: #1f2937; word-break: break-word; flex: 1;">${key.toLowerCase().includes('link') ? value : escapeHtml(String(value))}</span>
                    ${copyBtn}
                </div>
            </div>
        `;
    });
    
    gridContainer.innerHTML = html;
}

// Helper function to format label (used in both functions)
function formatLabelForAttribute(label) {
    return label.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

// Extract all relevant conversation attributes from Intercom API response
function extractConversationAttributes(conversation) {
    const attributes = {};
    
    // Helper function to convert Unix timestamp to readable date
    const formatTimestamp = (timestamp) => {
        if (!timestamp) return null;
        const date = typeof timestamp === 'number' 
            ? new Date(timestamp < 10000000000 ? timestamp * 1000 : timestamp)
            : new Date(timestamp);
        if (isNaN(date.getTime())) return null;
        return date.toLocaleString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        });
    };
    
    // Basic Information
    if (conversation.id) attributes['Conversation ID'] = conversation.id;
    if (conversation.type) attributes['Type'] = conversation.type;
    if (conversation.state) attributes['State'] = conversation.state;
    if (conversation.read !== undefined) attributes['Read'] = conversation.read;
    if (conversation.created_at) attributes['Created At'] = formatTimestamp(conversation.created_at);
    if (conversation.updated_at) attributes['Updated At'] = formatTimestamp(conversation.updated_at);
    if (conversation.waiting_since) attributes['Waiting Since'] = formatTimestamp(conversation.waiting_since);
    
    // Source Information
    if (conversation.source) {
        if (conversation.source.type) attributes['Source Type'] = conversation.source.type;
        if (conversation.source.id) attributes['Source ID'] = conversation.source.id;
        if (conversation.source.delivered_as) attributes['Delivered As'] = conversation.source.delivered_as;
        if (conversation.source.subject) attributes['Subject'] = conversation.source.subject;
        
        // Author (who initiated)
        if (conversation.source.author) {
            const author = conversation.source.author;
            if (author.type) attributes['Author Type'] = author.type;
            if (author.id) attributes['Author ID'] = author.id;
            if (author.name) attributes['Author Name'] = author.name;
            if (author.email) attributes['Author Email'] = author.email;
        }
        
        // Owner (assigned to)
        if (conversation.source.owner) {
            const owner = conversation.source.owner;
            if (owner.type) attributes['Owner Type'] = owner.type;
            if (owner.id) attributes['Owner ID'] = owner.id;
            if (owner.name) attributes['Assigned To'] = owner.name;
            if (owner.email) attributes['Owner Email'] = owner.email;
        }
    }
    
    // Statistics
    if (conversation.statistics) {
        const stats = conversation.statistics;
        if (stats.time_to_assignment) attributes['Time to Assignment'] = `${Math.round(stats.time_to_assignment / 60)} minutes`;
        if (stats.time_to_admin_reply) attributes['Time to Admin Reply'] = `${Math.round(stats.time_to_admin_reply / 60)} minutes`;
        if (stats.time_to_first_close) attributes['Time to First Close'] = `${Math.round(stats.time_to_first_close / 60)} minutes`;
        if (stats.time_to_last_close) attributes['Time to Last Close'] = `${Math.round(stats.time_to_last_close / 60)} minutes`;
        if (stats.median_time_to_reply) attributes['Median Time to Reply'] = `${Math.round(stats.median_time_to_reply / 60)} minutes`;
        if (stats.first_contact_reply_at) attributes['First Contact Reply At'] = formatTimestamp(stats.first_contact_reply_at);
        if (stats.first_admin_reply_at) attributes['First Admin Reply At'] = formatTimestamp(stats.first_admin_reply_at);
        if (stats.last_contact_reply_at) attributes['Last Contact Reply At'] = formatTimestamp(stats.last_contact_reply_at);
        if (stats.last_admin_reply_at) attributes['Last Admin Reply At'] = formatTimestamp(stats.last_admin_reply_at);
        if (stats.count_reopens) attributes['Reopens Count'] = stats.count_reopens;
        if (stats.count_assignments) attributes['Assignments Count'] = stats.count_assignments;
    }
    
    // Tags
    if (conversation.tags && conversation.tags.tags && conversation.tags.tags.length > 0) {
        attributes['Tags'] = conversation.tags.tags.map(tag => tag.name || tag).join(', ');
    }
    
    // Teammates (participating admins)
    if (conversation.teammates && conversation.teammates.teammates && conversation.teammates.teammates.length > 0) {
        attributes['Teammates'] = conversation.teammates.teammates.map(teammate => 
            teammate.name || teammate.email || teammate.id
        ).join(', ');
    }
    
    // Contacts (users involved)
    if (conversation.contacts && conversation.contacts.contacts && conversation.contacts.contacts.length > 0) {
        const contacts = conversation.contacts.contacts.map(contact => {
            const parts = [];
            if (contact.name) parts.push(contact.name);
            if (contact.email) parts.push(contact.email);
            return parts.length > 0 ? parts.join(' - ') : contact.id;
        });
        attributes['Contacts'] = contacts.join(', ');
    }
    
    // Conversation Parts Summary
    if (conversation.conversation_parts && conversation.conversation_parts.conversation_parts) {
        const parts = conversation.conversation_parts.conversation_parts;
        attributes['Total Messages'] = parts.length;
    }
    
    // Custom Attributes (if present)
    if (conversation.source && conversation.source.custom && conversation.source.custom.length > 0) {
        conversation.source.custom.forEach(attr => {
            if (attr.value !== null && attr.value !== undefined && attr.value !== '') {
                attributes[attr.name || 'Custom Attribute'] = attr.value;
            }
        });
    }
    
    return attributes;
}

// Parse plain text transcript and render as chat bubbles (fallback if Intercom fetch fails)
function parseTranscriptToChat(transcriptText, interactionDate) {
    const chatContainer = document.getElementById('chatMessagesContainer');
    if (!chatContainer) return;
    
    if (!transcriptText || !transcriptText.trim()) {
        chatContainer.innerHTML = `
            <div style="text-align: center; padding: 1.2937rem; color: #9ca3af; font-size: 0.5659rem;">
                <p>No transcript available</p>
            </div>
        `;
        return;
    }
    
    // Clear container
    chatContainer.innerHTML = '';
    
    // Helper function to escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Parse transcript - try to detect user/agent messages
    // Common patterns:
    // - "User:" or "Customer:" at start of line
    // - "Agent:" or employee name at start of line
    // - Lines with timestamps
    // - Blank lines as separators
    
    const lines = transcriptText.split('\n').filter(line => line.trim());
    const messages = [];
    let currentMessage = null;
    
    // Use interaction date as base for timestamps
    const baseDate = interactionDate ? new Date(interactionDate) : new Date();
    
    // Build agent pattern with employee name if available
    const employeeName = currentAudit?.employeeName || '';
    const agentPatternStr = employeeName 
        ? `^(?:Agent|Support|Representative|${employeeName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}):\\s*(.*)`
        : '^(?:Agent|Support|Representative):\\s*(.*)';
    const agentPattern = new RegExp(agentPatternStr, 'i');
    
    lines.forEach((line, index) => {
        const trimmedLine = line.trim();
        if (!trimmedLine) {
            // Empty line - end current message if exists
            if (currentMessage) {
                messages.push(currentMessage);
                currentMessage = null;
            }
            return;
        }
        
        // Try to detect message patterns
        const userPattern = /^(?:User|Customer|Client):\s*(.*)/i;
        const timestampPattern = /^(\d{1,2}[:\.]\d{2}(?:\s*[AP]M)?|\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})/i;
        
        const userMatch = trimmedLine.match(userPattern);
        const agentMatch = trimmedLine.match(agentPattern);
        const timestampMatch = trimmedLine.match(timestampPattern);
        
        if (userMatch) {
            // Start new user message
            if (currentMessage) messages.push(currentMessage);
            currentMessage = {
                text: userMatch[1].trim(),
                isUser: true,
                author: 'User',
                timestamp: baseDate
            };
        } else if (agentMatch) {
            // Start new agent message
            if (currentMessage) messages.push(currentMessage);
            currentMessage = {
                text: agentMatch[1].trim(),
                isUser: false,
                author: currentAudit?.employeeName || 'Agent',
                timestamp: baseDate
            };
        } else if (timestampMatch && currentMessage) {
            // Timestamp found at start of line - could be new message or continuation
            // If timestamp is followed by text, it might be a new message
            const afterTimestamp = trimmedLine.substring(timestampMatch[0].length).trim();
            if (afterTimestamp && afterTimestamp.length > 5) {
                // Has substantial content after timestamp - likely new message
                if (currentMessage) messages.push(currentMessage);
                const lastMessage = messages[messages.length - 1];
                currentMessage = {
                    text: afterTimestamp,
                    isUser: lastMessage ? !lastMessage.isUser : true,
                    author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                    timestamp: baseDate
                };
            } else {
                // Just timestamp, continue current message
                currentMessage.text += ' ' + trimmedLine;
            }
        } else {
            // Continue current message or start new one if none exists
            if (currentMessage) {
                // Check if line looks like a new speaker (common patterns)
                const looksLikeNewSpeaker = /^[-–—]\s/.test(trimmedLine) || 
                                           /^\[/.test(trimmedLine) ||
                                           trimmedLine.length < 20 && /^[A-Z][a-z]+:/.test(trimmedLine);
                
                if (looksLikeNewSpeaker && currentMessage.text.length > 50) {
                    // End current message and start new one
                    messages.push(currentMessage);
                    const lastMessage = messages[messages.length - 1];
                    currentMessage = {
                        text: trimmedLine.replace(/^[-–—]\s*/, '').replace(/^\[.*?\]\s*/, ''),
                        isUser: lastMessage ? !lastMessage.isUser : true,
                        author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                        timestamp: baseDate
                    };
                } else {
                    currentMessage.text += (currentMessage.text ? '\n' : '') + trimmedLine;
                }
            } else {
                // Try to guess based on context - if previous message was user, this might be agent
                const lastMessage = messages[messages.length - 1];
                currentMessage = {
                    text: trimmedLine.replace(/^[-–—]\s*/, '').replace(/^\[.*?\]\s*/, ''),
                    isUser: lastMessage ? !lastMessage.isUser : true, // Alternate or default to user
                    author: lastMessage && !lastMessage.isUser ? 'User' : (currentAudit?.employeeName || 'Agent'),
                    timestamp: baseDate
                };
            }
        }
        
        // Set timestamp for new messages
        if (currentMessage && (!currentMessage.timestamp || currentMessage.timestamp.getTime() === baseDate.getTime())) {
            currentMessage.timestamp = new Date(baseDate.getTime() + messages.length * 60000);
        }
    });
    
    // Add last message
    if (currentMessage) {
        messages.push(currentMessage);
    }
    
    // If no structured messages found, treat entire transcript as single message
    if (messages.length === 0) {
        messages.push({
            text: transcriptText,
            isUser: true,
            author: 'User',
            timestamp: baseDate
        });
    }
    
    // Render messages as chat bubbles
    messages.forEach((msg, index) => {
        const timeStr = msg.timestamp.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
        const dateStr = msg.timestamp.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
        });
        
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = `
            display: flex;
            flex-direction: column;
            margin-bottom: 0.3234rem;
            align-items: ${msg.isUser ? 'flex-start' : 'flex-end'};
            width: 100%;
            min-width: 0;
            box-sizing: border-box;
        `;
        
        const bubbleStyle = msg.isUser 
            ? `
                background: white;
                color: #374151;
                border: 0.0304rem solid #e5e7eb;
                border-radius: 0.4852rem 0.4852rem 0.4852rem 0.1617rem;
                max-width: 75%;
                margin-right: auto;
                word-wrap: break-word;
                overflow-wrap: break-word;
                box-sizing: border-box;
            `
            : `
                background: #1A733E;
                color: white;
                border-radius: 0.4852rem 0.4852rem 0.1617rem 0.4852rem;
                max-width: 75%;
                margin-left: auto;
                word-wrap: break-word;
                overflow-wrap: break-word;
                box-sizing: border-box;
            `;
        
        messageDiv.innerHTML = `
            <div style="${bubbleStyle} padding: 0.3234rem 0.4852rem; box-shadow: 0 0.0304rem 0.0606rem rgba(0,0,0,0.08);">
                ${msg.isUser 
                    ? `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1213rem; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: #6b7280;">User</span><span style="font-size: 0.3639rem; opacity: 0.7; color: #6b7280; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>` 
                    : `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1213rem; gap: 0.3234rem;"><span style="font-size: 0.4447rem; font-weight: 600; color: white;">${escapeHtml(msg.author)}</span><span style="font-size: 0.3639rem; opacity: 0.8; color: white; white-space: nowrap;">${timeStr} • ${dateStr}</span></div>`}
                <div style="font-size: 0.5257rem; line-height: 1.4; white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; max-width: 100%; box-sizing: border-box;">${escapeHtml(msg.text)}</div>
            </div>
        `;
        
        chatContainer.appendChild(messageDiv);
    });
    
    // Scroll to bottom
    setTimeout(() => {
        const transcriptChatView = document.getElementById('transcriptChatView');
        if (transcriptChatView) {
            transcriptChatView.scrollTop = transcriptChatView.scrollHeight;
        }
    }, 100);
}

// Initialize resizable splitter
function initializeSplitter() {
    const splitter = document.getElementById('splitter');
    const leftColumn = document.getElementById('leftColumn');
    const rightColumn = document.getElementById('rightColumn');
    const auditContent = document.getElementById('auditMainContent');
    
    if (splitter && leftColumn && rightColumn && auditContent) {
        let isResizing = false;
        let startX = 0;
        let startLeftWidth = 0;
        
        splitter.addEventListener('mousedown', function(e) {
            isResizing = true;
            startX = e.clientX;
            startLeftWidth = leftColumn.offsetWidth;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            splitter.style.background = '#9ca3af';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isResizing) return;
            
            const containerRect = auditContent.getBoundingClientRect();
            const deltaX = e.clientX - startX;
            const containerWidth = containerRect.width;
            
            // Calculate new width based on delta
            let newLeftWidth = startLeftWidth + deltaX;
            
            // Convert to percentage with constraints
            let leftPercentage = (newLeftWidth / containerWidth) * 100;
            leftPercentage = Math.max(25, Math.min(75, leftPercentage));
            
            // Apply width and update right column
            leftColumn.style.width = leftPercentage + '%';
            leftColumn.style.flex = '0 0 ' + leftPercentage + '%';
            
            // Store in localStorage for persistence
            try {
                localStorage.setItem('auditViewSplitterPosition', leftPercentage.toString());
            } catch (err) {
                // Ignore localStorage errors
            }
        });
        
        document.addEventListener('mouseup', function() {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                splitter.style.background = '#e5e7eb';
            }
        });
        
        // Hover effect
        splitter.addEventListener('mouseenter', function() {
            if (!isResizing) {
                splitter.style.background = '#d1d5db';
            }
        });
        
        splitter.addEventListener('mouseleave', function() {
            if (!isResizing) {
                splitter.style.background = '#e5e7eb';
            }
        });
        
        // Restore saved position from localStorage
        try {
            const savedPosition = localStorage.getItem('auditViewSplitterPosition');
            if (savedPosition) {
                const percentage = parseFloat(savedPosition);
                if (!isNaN(percentage) && percentage >= 25 && percentage <= 75) {
                    leftColumn.style.width = percentage + '%';
                    leftColumn.style.flex = '0 0 ' + percentage + '%';
                }
            }
        } catch (err) {
            // Ignore localStorage errors
        }
    }
}

// Refresh audit data from database to get latest comments
async function refreshAuditData() {
    if (!currentAudit || !currentTableName) {
        return;
    }
    
    try {
        const { data, error } = await window.supabaseClient
            .from(currentTableName)
            .select('parameter_comments')
            .eq('id', currentAudit.id)
            .single();
        
        if (error) throw error;
        
        if (data && data.parameter_comments) {
            // Update parameter comments in currentAudit
            currentAudit.parameterComments = data.parameter_comments;
            currentAudit.parameter_comments = data.parameter_comments;
        }
    } catch (error) {
        console.error('Error refreshing audit data:', error);
        // Don't throw - just log the error
    }
}

// Toggle reversal form visibility
function toggleReversalForm() {
    // Verify that current user is the audited employee
    if (!isCurrentUserAuditedEmployee()) {
        alert('Error: You can only submit reversal requests for audits assigned to you.');
        return;
    }
    
    const formContainer = document.getElementById('reversalFormContainer');
    const auditContentDiv = document.getElementById('auditContent');
    
    if (!formContainer) {
        console.error('Reversal form container not found');
        return;
    }
    
    if (!auditContentDiv) {
        console.error('Audit content div not found');
        return;
    }
    
    // Ensure form container is in the DOM (might have been removed during re-render)
    if (!formContainer.parentElement) {
        const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
        if (buttonsSection) {
            buttonsSection.parentElement.insertBefore(formContainer, buttonsSection.nextSibling);
        } else {
            auditContentDiv.appendChild(formContainer);
        }
    }
    
    if (formContainer.style.display === 'none' || !formContainer.style.display) {
        formContainer.style.display = 'block';
        
        // Move form container to be after the action buttons if not already in auditContent
        if (auditContentDiv && formContainer.parentElement !== auditContentDiv) {
            const buttonsSection = auditContentDiv.querySelector('.no-print[style*="border-top"]');
            if (buttonsSection) {
                buttonsSection.parentElement.insertBefore(formContainer, buttonsSection.nextSibling);
            } else {
                auditContentDiv.appendChild(formContainer);
            }
        }
        
        // Refresh audit data to get latest comments before populating
        refreshAuditData().then(() => {
            // Populate parameters with comments after refresh
        populateParametersWithComments();
        }).catch(err => {
            console.error('Error refreshing audit data:', err);
            // Still try to populate with existing data
            populateParametersWithComments();
        });
        
        formContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    } else {
        formContainer.style.display = 'none';
    }
}

// Make toggleReversalForm globally accessible
window.toggleReversalForm = toggleReversalForm;

// Populate parameters with comments (compact display)
function populateParametersWithComments() {
    const container = document.getElementById('parametersWithCommentsContainer');
    const noCommentsMsg = document.getElementById('noCommentsMessage');
    
    if (!container) return;
    
    if (currentErrorFields.length === 0) {
        container.innerHTML = '<p style="margin: 0; font-size: 0.5625rem; color: #6b7280; font-family: \'Poppins\', sans-serif;">No parameters available</p>';
        return;
    }
    
    // Get parameter comments from database (from currentAudit - which is updated in real-time)
    let parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
    
    // Also check inline comment inputs in the DOM (real-time fallback - takes precedence)
    const inlineComments = {};
    currentErrorFields.forEach(field => {
        const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
        const comments = [];
        commentInputs.forEach(input => {
            if (input.value && input.value.trim()) {
                comments.push(input.value.trim());
            }
        });
        if (comments.length > 0) {
            // Always use inline comments if they exist (most up-to-date)
            inlineComments[field.key] = { comments: comments };
        }
    });
    
    // Merge: Start with database comments, then override with inline comments (which are more up-to-date)
    parameterComments = { ...parameterComments };
    // Override with inline comments if they exist (they're more current)
    Object.keys(inlineComments).forEach(key => {
        parameterComments[key] = inlineComments[key];
    });
    
    // Filter only parameters that have comments (check both formats)
    const parametersWithComments = currentErrorFields.filter(field => {
        const fieldComment = parameterComments[field.key];
        if (!fieldComment) return false;
        
        // Check for single comment format: {comment: "text"}
        if (fieldComment.comment && fieldComment.comment.trim()) {
            return true;
        }
        
        // Check for array format: {comments: ["text1", "text2"]}
        if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
            return fieldComment.comments.some(c => c && c.trim());
        }
        
        return false;
    });
    
    if (parametersWithComments.length === 0) {
        container.style.display = 'none';
        if (noCommentsMsg) {
            noCommentsMsg.style.display = 'block';
        }
        return;
    }
    
    if (noCommentsMsg) {
        noCommentsMsg.style.display = 'none';
    }
    container.style.display = 'block';
    
    // Create compact list of parameters with comments
    const commentsHtml = parametersWithComments.map(field => {
        const fieldComment = parameterComments[field.key];
        let commentText = '';
        
        // Get comment text (handle both formats)
        if (fieldComment.comment && fieldComment.comment.trim()) {
            commentText = fieldComment.comment.trim();
        } else if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
            // Join all comments with newlines, filter out empty ones, trim each comment, then trim the result
            commentText = fieldComment.comments
                .filter(c => c && c.trim())
                .map(c => c.trim())
                .join('\n')
                .trim();
        }
        
        // Ensure commentText is trimmed to remove leading/trailing whitespace
        commentText = commentText ? commentText.trim() : '';
        
        return `
            <div style="margin-bottom: 0.5625rem; padding: 0.5625rem; background: white; border-radius: 0.2812rem; border: 0.0352rem solid #e5e7eb;">
                <div style="font-size: 0.6094rem; font-weight: 600; color: #1f2937; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif;">
                    ${escapeHtml(field.label)}
        </div>
                <div style="font-size: 0.5625rem; color: #4b5563; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">
                    ${escapeHtml(commentText)}
                </div>
            </div>
        `;
    }).join('');
    
    container.innerHTML = commentsHtml;
}

// Select all parameters (kept for backward compatibility, but not used)
function selectAllParameters() {
    // Not used anymore - parameters are auto-selected based on comments
}

// Clear all parameters (kept for backward compatibility, but not used)
function clearAllParameters() {
    // Not used anymore - parameters are auto-selected based on comments
}

// Handle close button click - check acknowledgement before closing
async function handleCloseButtonClick() {
    const canNavigate = await handleCloseAuditView();
    if (canNavigate) {
        window.location.href = 'expert-audits.html';
    }
}

// Make handleCloseButtonClick globally accessible
window.handleCloseButtonClick = handleCloseButtonClick;

// Show parameter comment modal
function showParameterCommentModal(fieldId, fieldLabel, auditorFeedback) {
    if (!isCurrentUserAuditedEmployee()) {
        alert('Only the audited employee can add comments.');
        return;
    }
    
    // Get existing comment for this parameter
    const parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
    const existingComment = parameterComments[fieldId] || null;
    const hasComment = existingComment && existingComment.comment && existingComment.comment.trim();
    
    // Create modal overlay
    const modal = document.createElement('div');
    modal.id = 'parameterCommentModal';
    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: flex; align-items: center; justify-content: center; padding: 1.125rem;';
    
    modal.innerHTML = `
        <div style="background: white; border-radius: 0.375rem; padding: 1.125rem; max-width: 37.5rem; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 0.25rem 0.375rem rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                <h3 style="font-size: 0.8438rem; font-weight: 700; color: #1f2937; margin: 0; font-family: 'Poppins', sans-serif;">
                    Add Your Comment - ${escapeHtml(fieldLabel)}
                </h3>
                <button onclick="closeParameterCommentModal()" style="background: none; border: none; font-size: 1.5rem; color: #6b7280; cursor: pointer; padding: 0; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center; line-height: 1;">×</button>
            </div>
            
            <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f9fafb; border-radius: 0.2812rem; border: 0.0352rem solid #e5e7eb;">
                <div style="font-size: 0.5625rem; font-weight: 600; color: #6b7280; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                    Auditor Feedback
                </div>
                <div style="font-size: 0.6562rem; color: #374151; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6;">
                    ${escapeHtml(auditorFeedback)}
                </div>
            </div>
            
            ${hasComment ? `
                <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f0f9ff; border-radius: 0.2812rem; border: 0.0352rem solid #bae6fd;">
                    <div style="font-size: 0.5625rem; font-weight: 600; color: #0369a1; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif; text-transform: uppercase; letter-spacing: 0.05em;">
                        Your Previous Comment
                    </div>
                    <div style="font-size: 0.6562rem; color: #075985; font-family: 'Poppins', sans-serif; white-space: pre-wrap; line-height: 1.6; margin-bottom: 0.375rem;">
                        ${escapeHtml(existingComment.comment)}
                    </div>
                    <div style="font-size: 0.5625rem; color: #0284c7; font-family: 'Poppins', sans-serif;">
                        ${existingComment.commented_at ? new Date(existingComment.commented_at).toLocaleString() : ''}
                    </div>
                </div>
            ` : ''}
            
            <div style="margin-bottom: 0.75rem;">
                <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.375rem; font-family: 'Poppins', sans-serif;">
                    Your Comment / Justification
                </label>
                <textarea 
                    id="modalCommentInput_${fieldId}" 
                    placeholder="Provide your justification or response to the auditor's feedback..." 
                    rows="6"
                    style="width: 100%; padding: 0.75rem; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; resize: vertical; background: white; box-sizing: border-box;"
                >${hasComment ? escapeHtml(existingComment.comment) : ''}</textarea>
            </div>
            
            <div style="display: flex; justify-content: flex-end; gap: 0.75rem;">
                <button 
                    onclick="closeParameterCommentModal()" 
                    style="padding: 0.5625rem 1.125rem; background: #f3f4f6; color: #374151; border: 0.0352rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;"
                >
                    Cancel
                </button>
                <button 
                    onclick="saveParameterCommentFromModal('${fieldId}')" 
                    style="padding: 0.5625rem 1.125rem; background: #1A733E; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.2s ease;"
                >
                    ${hasComment ? 'Update' : 'Save'} Comment
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    // Focus the textarea
    setTimeout(() => {
        const textarea = document.getElementById(`modalCommentInput_${fieldId}`);
        if (textarea) {
            textarea.focus();
        }
    }, 100);
    
    // Close on overlay click
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            closeParameterCommentModal();
        }
    });
}

// Close parameter comment modal
function closeParameterCommentModal() {
    const modal = document.getElementById('parameterCommentModal');
    if (modal) {
        modal.remove();
    }
}

// Save parameter comment from modal
async function saveParameterCommentFromModal(fieldId) {
    try {
        if (!isCurrentUserAuditedEmployee()) {
            alert('Only the audited employee can add comments.');
            return;
        }
        
        if (!currentAudit || !currentTableName) {
            alert('Error: Audit data not available');
            return;
        }
        
        // Check if audit is acknowledged - lock everything
        const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
        if (isAcknowledgedStatus(acknowledgementStatus)) {
            alert('Comments cannot be edited after the audit has been acknowledged.');
            return;
        }
        
        // Check if reversal has been submitted - prevent editing comments if so
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        if (reversalRequestedAt) {
            alert('Comments cannot be edited after a reversal request has been submitted.');
            return;
        }
        
        const commentInput = document.getElementById(`modalCommentInput_${fieldId}`);
        if (!commentInput) {
            alert('Error: Comment input not found');
            return;
        }
        
        const commentText = commentInput.value.trim();
        if (!commentText) {
            alert('Please enter a comment before saving.');
            return;
        }
        
        // Get current parameter comments
        const currentComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
        
        // Update comment for this parameter
        const updatedComments = {
            ...currentComments,
            [fieldId]: {
                comment: commentText,
                commented_at: new Date().toISOString(),
                commented_by: currentUserEmail
            }
        };
        
        // Save to database
        const { data, error } = await window.supabaseClient
            .from(currentTableName)
            .update({
                parameter_comments: updatedComments
            })
            .eq('id', currentAudit.id)
            .select();
        
        if (error) throw error;
        
        // Update local audit object
        if (currentAudit) {
            currentAudit.parameterComments = updatedComments;
            currentAudit.parameter_comments = updatedComments;
        }
        
        // Close modal
        closeParameterCommentModal();
        
        // Reload audit to refresh the error details table with comments column
        await loadAuditFromURL();
        
        // Update reversal form if it's open (after reload)
        const reversalFormContainer = document.getElementById('reversalFormContainer');
        if (reversalFormContainer && reversalFormContainer.style.display !== 'none') {
            populateParametersWithComments();
        }
        
    } catch (error) {
        console.error('Error saving parameter comment:', error);
        alert('Failed to save comment. Please try again.');
    }
}

// Toggle comments column visibility
function toggleCommentsColumn() {
    if (typeof window.showCommentsColumn === 'undefined') {
        window.showCommentsColumn = false;
    }
    window.showCommentsColumn = !window.showCommentsColumn;
    
    // Update the existing table header and rows without recreating the container
    if (currentAudit && currentErrorFields) {
        // Find the table header row within the Error Details section
        const errorDetailsSection = Array.from(document.querySelectorAll('div')).find(div => {
            const h3 = div.querySelector('h3');
            return h3 && h3.textContent && h3.textContent.includes('Error Details');
        });
        
        if (!errorDetailsSection) return;
        
        // Find header row within the error details section
        const headerRows = Array.from(errorDetailsSection.querySelectorAll('div[style*="grid-template-columns"]')).filter(div => {
            const text = div.textContent || '';
            return text.includes('Error Type') && text.includes('Points') && text.includes('Severity');
        });
        
        if (headerRows.length === 0) return;
        
        const header = headerRows[0];
        const showComments = window.showCommentsColumn;
        
        // Get employee first name for column header
        const employeeName = currentAudit.employeeName || currentAudit.employee_name || 'Employee';
        const firstName = employeeName.split(' ')[0] || employeeName;
        const commentColumnHeader = `${firstName}'s Comment`;
        
        // Check if user is audited employee
        const isAuditedEmployee = isCurrentUserAuditedEmployee();
        
        // Update grid columns
        if (showComments) {
            header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2.5fr';
            // Find the "+ Comment" header cell (last child) and replace with actual column header
            const lastHeader = header.lastElementChild;
            if (lastHeader) {
                lastHeader.innerHTML = escapeHtml(commentColumnHeader);
                lastHeader.style.cursor = 'default';
                lastHeader.style.color = '#1f2937';
                lastHeader.style.textDecoration = 'none';
                lastHeader.removeAttribute('onclick');
            } else if (header.children.length === 5) {
                // Add new header cell if it doesn't exist
                const commentHeaderCell = document.createElement('div');
                commentHeaderCell.textContent = commentColumnHeader;
                commentHeaderCell.style.cssText = 'font-weight: 700; font-size: 0.5659rem; color: #1f2937; text-transform: uppercase; letter-spacing: 0.05em;';
                header.appendChild(commentHeaderCell);
            }
        } else {
            // When hiding comments, keep 6 columns if audited employee (to show + Comment button)
            if (isAuditedEmployee) {
                header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2fr';
                // Find the comment column header and replace with "+ Comment" button
                const lastHeader = header.lastElementChild;
                if (lastHeader && (lastHeader.textContent.includes("'s Comment") || lastHeader.textContent.includes("Comment"))) {
                    lastHeader.innerHTML = '<span style="cursor: pointer; color: #1A733E; text-decoration: underline;" onclick="toggleCommentsColumn()" title="Click to add comments">+ Comment</span>';
                    lastHeader.style.cursor = 'pointer';
                } else if (header.children.length === 5) {
                    // Add "+ Comment" button if it doesn't exist
                    const commentButtonCell = document.createElement('div');
                    commentButtonCell.innerHTML = '<span style="cursor: pointer; color: #1A733E; text-decoration: underline;" onclick="toggleCommentsColumn()" title="Click to add comments">+ Comment</span>';
                    commentButtonCell.style.cssText = 'font-weight: 700; font-size: 0.5659rem; color: #1A733E; text-transform: uppercase; letter-spacing: 0.05em;';
                    header.appendChild(commentButtonCell);
                }
            } else {
                header.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr';
                // Remove comment column if not audited employee
                if (header.children.length === 6) {
                    const lastHeader = header.lastElementChild;
                    if (lastHeader && (lastHeader.textContent.includes("'s Comment") || lastHeader.textContent.includes("Comment") || lastHeader.textContent.includes("+ Comment"))) {
                        lastHeader.remove();
                    }
                }
            }
        }
        
        // Update all data rows within the error details section
        const dataRows = Array.from(errorDetailsSection.querySelectorAll('div[style*="grid-template-columns"]')).filter(div => {
            return div !== header && div.style.display === 'grid' && !div.textContent.includes('Error Type');
        });
        
        dataRows.forEach(row => {
            if (showComments) {
                // Add comment column if not present
                if (row.children.length === 5 || row.children.length === 6) {
                    row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2.5fr';
                    // Remove existing comment column if present (to refresh it)
                    if (row.children.length === 6) {
                        const lastCell = row.lastElementChild;
                        if (lastCell && (lastCell.querySelector('input[data-param-key]') || lastCell.textContent.includes('Comment'))) {
                            lastCell.remove();
                        }
                    }
                    
                    // Get the field key from the row (first child text)
                    const firstCell = row.children[0];
                    const fieldLabel = firstCell.textContent.trim();
                    
                    // Find matching field
                    const field = currentErrorFields.find(f => f.label === fieldLabel);
                    if (field) {
                        // Get feedback data
                        const feedbackData = currentAudit[field.feedback];
                        let feedbackArray = [];
                        
                        if (feedbackData) {
                            if (typeof feedbackData === 'string') {
                                try {
                                    const parsed = JSON.parse(feedbackData);
                                    feedbackArray = Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
                                } catch (e) {
                                    feedbackArray = feedbackData.trim() ? [feedbackData] : [];
                                }
                            } else if (Array.isArray(feedbackData)) {
                                feedbackArray = feedbackData;
                            }
                        }
                        feedbackArray = feedbackArray.filter(f => f && f.trim());
                        
                        // Get existing comments
                        const parameterComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
                        const existingComments = parameterComments[field.key] || {};
                        const commentsArray = existingComments.comments || (existingComments.comment ? [existingComments.comment] : []);
                        const isAuditedEmployee = isCurrentUserAuditedEmployee();
                        
                        // Check if reversal has been submitted (disable inputs if so)
                        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
                        const hasReversalSubmitted = !!reversalRequestedAt;
                        
                        // Create comment column
                        const commentCell = document.createElement('div');
                        commentCell.style.cssText = 'font-size: 0.5659rem; color: #4b5563; font-family: Poppins, sans-serif; min-width: 0; overflow: hidden;';
                        
                        if (feedbackArray.length > 0) {
                            feedbackArray.forEach((feedbackText, index) => {
                                const existingComment = commentsArray[index] || '';
                                const commentInputId = `comment_${field.key}_${index}`;
                                const commentDiv = document.createElement('div');
                                commentDiv.style.marginBottom = index < feedbackArray.length - 1 ? '0.6469rem' : '0';
                                
                                if (feedbackArray.length > 1) {
                                    const label = document.createElement('div');
                                    label.textContent = `Comment ${index + 1}:`;
                                    label.style.cssText = 'font-size: 0.4043rem; color: #6b7280; font-weight: 600; margin-bottom: 0.1617rem; font-family: Poppins, sans-serif;';
                                    commentDiv.appendChild(label);
                                }
                                
                                // For auditors (non-audited employees) or after reversal submitted, show as read-only text
                                if (!isAuditedEmployee || hasReversalSubmitted) {
                                    if (existingComment && existingComment.trim()) {
                                        const textDiv = document.createElement('div');
                                        textDiv.textContent = existingComment;
                                        textDiv.style.cssText = 'font-size: 0.5659rem; color: #4b5563; font-family: Poppins, sans-serif; white-space: pre-wrap; line-height: 1.6;';
                                        commentDiv.appendChild(textDiv);
                                    } else {
                                        const dash = document.createElement('span');
                                        dash.textContent = '-';
                                        dash.style.cssText = 'color: #9ca3af; font-style: italic; font-size: 0.5659rem;';
                                        commentDiv.appendChild(dash);
                                    }
                                } else {
                                    // For audited employees (before reversal), show input box
                                    const input = document.createElement('input');
                                    input.type = 'text';
                                    input.id = commentInputId;
                                    input.setAttribute('data-param-key', field.key);
                                    input.setAttribute('data-feedback-index', index);
                                    input.value = existingComment;
                                    input.placeholder = 'Enter your comment...';
                                    input.style.cssText = 'width: 100%; max-width: 100%; padding: 0.2425rem 0.3234rem; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; font-size: 0.5659rem; font-family: Poppins, sans-serif; box-sizing: border-box;';
                                    // Save on both change and blur for real-time saving
                                    input.addEventListener('change', function() {
                                        saveParameterComment(field.key, index, this.value);
                                    });
                                    input.addEventListener('blur', function() {
                                        saveParameterComment(field.key, index, this.value);
                                    });
                                    commentDiv.appendChild(input);
                                }
                                
                                commentCell.appendChild(commentDiv);
                            });
                        } else {
                            const dash = document.createElement('span');
                            dash.textContent = '-';
                            dash.style.cssText = 'color: #9ca3af; font-style: italic;';
                            commentCell.appendChild(dash);
                        }
                        
                        row.appendChild(commentCell);
                    }
                }
            } else {
                // When hiding comments, keep 6 columns if audited employee (to match header with + Comment button)
                // Remove comment inputs but keep empty 6th column for alignment
                if (isAuditedEmployee) {
                    row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr 2fr';
                    if (row.children.length === 6) {
                        const lastCell = row.lastElementChild;
                        if (lastCell && (lastCell.querySelector('input[data-param-key]') || lastCell.textContent.includes('Comment'))) {
                            lastCell.innerHTML = '';
                        }
                    } else if (row.children.length === 5) {
                        // Add empty column for alignment with header
                        const emptyCell = document.createElement('div');
                        row.appendChild(emptyCell);
                    }
                } else {
                    // Remove comment column if not audited employee
                    if (row.children.length === 6) {
                        row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr 2fr';
                        const lastCell = row.lastElementChild;
                        if (lastCell) {
                            lastCell.remove();
                        }
                    }
                }
            }
        });
    }
}

// Save parameter comment from input box
async function saveParameterComment(paramKey, feedbackIndex, commentText) {
    try {
        // Ensure currentUserEmail is available
        if (!currentUserEmail) {
            currentUserEmail = getCurrentUserEmail();
        }
        
        if (!isCurrentUserAuditedEmployee()) {
            alert('Only the audited employee can add comments.');
            return;
        }
        
        if (!currentAudit || !currentTableName) {
            alert('Error: Audit data not available');
            return;
        }
        
        // Check if audit is acknowledged - lock everything
        const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
        if (isAcknowledgedStatus(acknowledgementStatus)) {
            alert('Comments cannot be edited after the audit has been acknowledged.');
            return;
        }
        
        // Check if reversal has been submitted - prevent editing comments if so
        const reversalRequestedAt = currentAudit.reversalRequestedAt || currentAudit.reversal_requested_at;
        if (reversalRequestedAt) {
            alert('Comments cannot be edited after a reversal request has been submitted.');
            return;
        }
        
        if (!currentUserEmail) {
            alert('Error: User email not available. Please refresh the page.');
            return;
        }
        
        // Get current parameter comments
        const currentComments = currentAudit.parameterComments || currentAudit.parameter_comments || {};
        
        // Get existing comments array for this parameter or create new structure
        const paramComments = currentComments[paramKey] || {};
        const commentsArray = paramComments.comments || (paramComments.comment ? [paramComments.comment] : []);
        
        // Ensure array is large enough
        while (commentsArray.length <= feedbackIndex) {
            commentsArray.push('');
        }
        
        // Update the comment at the specific index
        commentsArray[feedbackIndex] = commentText.trim();
        
        // Update comment for this parameter
        const updatedComments = {
            ...currentComments,
            [paramKey]: {
                comments: commentsArray,
                commented_at: new Date().toISOString(),
                commented_by: currentUserEmail
            }
        };
        
        // Save to database
        const { data, error } = await window.supabaseClient
            .from(currentTableName)
            .update({
                parameter_comments: updatedComments
            })
            .eq('id', currentAudit.id)
            .select();
        
        if (error) {
            console.error('Supabase error:', error);
            throw error;
        }
        
        // Update local audit object immediately (for real-time validation)
        if (currentAudit) {
            currentAudit.parameterComments = updatedComments;
            currentAudit.parameter_comments = updatedComments;
        }
        
        // Optional: Show a subtle success indicator (non-intrusive)
        const input = document.getElementById(`comment_${paramKey}_${feedbackIndex}`);
        if (input) {
            const originalBorder = input.style.borderColor;
            input.style.borderColor = '#10b981';
            setTimeout(() => {
                input.style.borderColor = originalBorder || '#d1d5db';
            }, 500);
        }
        
        // Immediately update the reversal form display if it's open
        const reversalFormContainer = document.getElementById('reversalFormContainer');
        if (reversalFormContainer && reversalFormContainer.style.display !== 'none') {
            populateParametersWithComments();
        }
        
    } catch (error) {
        console.error('Error saving parameter comment:', error);
        // Don't show alert for every failed save - just log it
        // User can try again if needed
        console.warn('Comment save failed, will retry on next change');
    }
}

// Make functions globally accessible
window.showParameterCommentModal = showParameterCommentModal;
window.closeParameterCommentModal = closeParameterCommentModal;
window.saveParameterCommentFromModal = saveParameterCommentFromModal;
window.toggleCommentsColumn = toggleCommentsColumn;
window.saveParameterComment = saveParameterComment;

// Acknowledge audit
async function acknowledgeAudit() {
    // Verify that current user is the audited employee
    if (!isCurrentUserAuditedEmployee()) {
        alert('Error: You can only acknowledge audits assigned to you.');
        return;
    }
    
    // Wait for confirmation dialog to be available
    if (!window.confirmationDialog) {
        // Wait a bit for it to initialize
        await new Promise(resolve => setTimeout(resolve, 100));
        if (!window.confirmationDialog) {
            alert('Error: Confirmation dialog not available. Please refresh the page.');
            return;
        }
    }
    
    const result = await window.confirmationDialog.show({
        title: 'Acknowledge Audit',
        message: 'By acknowledging this audit, you confirm that you have reviewed the results and do not wish to submit a reversal request. Continue?',
        confirmText: 'Acknowledge',
        cancelText: 'Cancel'
    });
    
    if (result) {
        if (!currentAudit || !currentTableName) {
            alert('Error: Audit data not available');
            return;
        }
        
        try {
            // Get current acknowledgement status
            const currentAcknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
            const currentStatusLower = currentAcknowledgementStatus.toLowerCase();
            
            // Check if reversal was processed (approved or rejected)
            const reversalApproved = currentAudit.reversal_approved;
            const reversalRespondedAt = currentAudit.reversal_responded_at || currentAudit.reversalRespondedAt;
            const hasReversalBeenProcessed = reversalRespondedAt && (reversalApproved === true || reversalApproved === false);
            
            // Determine acknowledgement status based on current status
            let acknowledgementStatus = 'Acknowledged';
            
            // If current status is "pending - after reversal approved/rejected", change to acknowledged version
            if (currentStatusLower === 'pending - after reversal approved') {
                acknowledgementStatus = 'acknowledged - after reversal approved';
            } else if (currentStatusLower === 'pending - after reversal rejected') {
                acknowledgementStatus = 'acknowledged - after reversal rejected';
            }
            // If no reversal was processed, status remains "Acknowledged"
            
            // Record acknowledgment in the database with correct fields
            const acknowledgementTime = new Date().toISOString();
            const { data, error } = await window.supabaseClient
                .from(currentTableName)
                .update({
                    acknowledgement_status: acknowledgementStatus,
                    acknowledgement_status_updated_at: acknowledgementTime
                })
                .eq('id', currentAudit.id)
                .select();
            
            if (error) throw error;
            
            // Show success message
            if (window.confirmationDialog) {
                await window.confirmationDialog.show({
                    title: 'Success',
                    message: '✓ Audit acknowledged. Thank you for your confirmation.',
                    confirmText: 'OK',
                    type: 'success'
                });
            } else {
            alert('✓ Audit acknowledged. Thank you for your confirmation.');
            }
            
            // Reload audit data to reflect changes
            loadAuditFromURL();
            
        } catch (error) {
            console.error('Error acknowledging audit:', error);
            if (window.confirmationDialog) {
                await window.confirmationDialog.show({
                    title: 'Error',
                    message: 'Failed to record acknowledgment. Please try again.',
                    confirmText: 'OK',
                    type: 'error'
                });
            } else {
            alert('Failed to record acknowledgment. Please try again.');
            }
        }
    }
}

// Handle reversal form submission
document.addEventListener('DOMContentLoaded', function() {
    const reversalForm = document.getElementById('reversalForm');
    if (reversalForm) {
        reversalForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            // Verify that current user is the audited employee
            if (!isCurrentUserAuditedEmployee()) {
                alert('Error: You can only submit reversal requests for audits assigned to you.');
                return;
            }
            
            if (!currentAudit || !currentTableName) {
                alert('Error: Audit data not available');
                return;
            }
            
            // Check if Supabase client is initialized
            if (!window.supabaseClient) {
                alert('Error: Database connection not available. Please refresh the page and try again.');
                return;
            }
            
            // Validate required fields
            const reversalType = document.getElementById('reversalType').value;
            const reversalReason = document.getElementById('reversalReasonDropdown').value;
            
            if (!reversalType || !reversalReason) {
                alert('Please fill in all required fields (marked with *)');
                return;
            }
            
            // Get all parameters with comments (automatically included)
            // First, check database comments (from currentAudit - which is updated in real-time)
            let parameterComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
            
            // Also check inline comment inputs in the DOM (real-time fallback - takes precedence)
            const inlineComments = {};
            currentErrorFields.forEach(field => {
                const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
                const comments = [];
                commentInputs.forEach(input => {
                    if (input.value && input.value.trim()) {
                        comments.push(input.value.trim());
                    }
                });
                if (comments.length > 0) {
                    // Always use inline comments if they exist (most up-to-date)
                    inlineComments[field.key] = { comments: comments };
                }
            });
            
            // Merge: Start with database comments, then override with inline comments (which are more up-to-date)
            parameterComments = { ...parameterComments };
            // Override with inline comments if they exist (they're more current)
            Object.keys(inlineComments).forEach(key => {
                parameterComments[key] = inlineComments[key];
            });
            
            // Find all parameters that have comments (check both formats)
            const parametersWithComments = currentErrorFields.filter(field => {
                const fieldComment = parameterComments[field.key];
                if (!fieldComment) return false;
                
                // Check for single comment format: {comment: "text"}
                if (fieldComment.comment && fieldComment.comment.trim()) {
                    return true;
                }
                
                // Check for array format: {comments: ["text1", "text2"]}
                if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
                    return fieldComment.comments.some(c => c && c.trim());
                }
                
                return false;
            });
            
            if (parametersWithComments.length === 0) {
                alert('⚠ No parameter comments found. Please add comments using the comment icon next to each parameter\'s feedback before submitting a reversal request.\n\nYou can add comments by clicking on the comment input boxes in the Error Details section.');
                e.preventDefault(); // Explicitly prevent form submission
                return false;
            }
            
            // Build justification from parameter comments
            const selectedParameters = [];
            const justificationParts = [];
            
            parametersWithComments.forEach(field => {
                const fieldComment = parameterComments[field.key];
                let commentText = '';
                
                // Get comment text (handle both formats)
                if (fieldComment.comment && fieldComment.comment.trim()) {
                    commentText = fieldComment.comment.trim();
                } else if (fieldComment.comments && Array.isArray(fieldComment.comments)) {
                    // Join all comments with newlines
                    commentText = fieldComment.comments.filter(c => c && c.trim()).join('\n');
                }
                
                if (commentText) {
                selectedParameters.push(field.label);
                    justificationParts.push(`${field.label}: ${commentText}`);
                }
            });
            
            const detailedJustification = justificationParts.join('\n\n');
            
            // Capture FULL audit state BEFORE updating (for activity log)
            const fullAuditState = {
                parameters: {},
                feedback: {},
                score: currentAudit.average_score || currentAudit.averageScore || 0,
                passing_status: currentAudit.passing_status || currentAudit.passingStatus || '',
                acknowledgement_status: currentAudit.acknowledgement_status || currentAudit.acknowledgementStatus || '',
                // Capture all other relevant audit fields
                audited_employee_email: currentAudit.audited_employee_email || currentAudit.auditedEmployeeEmail || null,
                auditor_email: currentAudit.auditor_email || currentAudit.auditorEmail || null,
                conversation_id: currentAudit.conversation_id || currentAudit.conversationId || null
            };
            
            // Capture all parameter values
            if (currentErrorFields && currentErrorFields.length > 0) {
                currentErrorFields.forEach(field => {
                    const fieldKey = field.key;
                    const value = currentAudit[fieldKey] || 0;
                    fullAuditState.parameters[fieldKey] = value;
                    
                    // Capture feedback
                    const feedbackKey = `feedback_${fieldKey}`;
                    const feedbackValue = currentAudit[feedbackKey] || null;
                    fullAuditState.feedback[fieldKey] = feedbackValue;
                });
            }
            
            // Get user info for activity log
            const userInfo = getCurrentUserInfo();
            const logUserEmail = userInfo?.email || '';
            const logUserName = userInfo?.name || userInfo?.email || 'Unknown';
            
            // Gather form data - use column names that match the database schema
            // Based on actual schema: fnchat_cfd table does NOT have reversal_status column
            // Status is tracked via reversal_approved and reversal_responded_at fields
            const reversalData = {
                reversal_requested_at: new Date().toISOString(),
                reversal_type: reversalType,
                // Combine reversal reason and detailed justification from parameter comments
                reversal_justification_from_agent: `${reversalReason}: ${detailedJustification}`,
                reversal_metrics_parameters: selectedParameters.join(', ') || null,
                within_auditor_scope: document.getElementById('withinAuditorScope').checked ? 'true' : 'false',
                score_before_appeal: currentAudit.average_score || currentAudit.averageScore || null,
                // Save parameter comments to database when reversal is submitted
                parameter_comments: parameterComments
                // Note: reversal_status column doesn't exist in the schema
                // Status is determined by reversal_approved (null = pending, 'true' = approved, 'false' = rejected)
                // reversal_responded_at is null until reviewed
            };
            
            // Don't set reversal_approved and reversal_responded_at to null explicitly
            // They will remain null by default if not set
            
            // Helper function to retry database operations on schema cache errors
            async function retryOnSchemaCacheError(operation, maxRetries = 3) {
                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    if (attempt > 0) {
                        // Wait longer on each retry (exponential backoff)
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                    
                    const result = await operation();
                    
                    // If no error, return success
                    if (!result.error) {
                        return result;
                    }
                    
                    // If it's a schema cache error, retry
                    if (result.error.message && (
                        result.error.message.includes('schema cache') ||
                        result.error.message.includes('Could not find') ||
                        result.error.message.includes('column') && result.error.message.includes('schema cache')
                    )) {
                        continue;
                    }
                    
                    // If it's not a schema cache error, return immediately
                    return result;
                }
                
                // Return last result after all retries exhausted
                return await operation();
            }
            
            try {
                // FIRST: Log the original state to activity log BEFORE updating
                try {
                    const activityLogData = {
                        audit_id: currentAudit.id,
                        scorecard_table_name: currentTableName,
                        activity_type: 'reversal_requested',
                        activity_timestamp: new Date().toISOString(),
                        performed_by_email: logUserEmail,
                        performed_by_name: logUserName,
                        audit_state_snapshot: fullAuditState,
                        parameters_snapshot: fullAuditState.parameters,
                        feedback_snapshot: fullAuditState.feedback,
                        score_snapshot: fullAuditState.score,
                        passing_status_snapshot: fullAuditState.passing_status,
                        reversal_type: reversalType,
                        reversal_justification: `${reversalReason}: ${detailedJustification}`,
                        change_reason: 'Reversal requested by audited employee',
                        metadata: {
                            reversal_metrics_parameters: selectedParameters,
                            within_auditor_scope: document.getElementById('withinAuditorScope').checked,
                            parameter_comments: parameterComments
                        }
                    };
                    
                    const { error: logError } = await window.supabaseClient
                        .from('audit_activity_log')
                        .insert(activityLogData);
                    
                    if (logError) {
                        console.error('Error logging reversal request to activity log:', logError);
                        // Don't throw - continue with reversal submission even if logging fails
                    } else {
                        console.log('Successfully logged reversal request to activity log');
                    }
                } catch (logErr) {
                    console.error('Error creating activity log entry:', logErr);
                    // Don't throw - continue with reversal submission
                }
                
                // THEN: Update the audit record with reversal data
                // First, try with parameter_comments included
                let result = await retryOnSchemaCacheError(async () => {
                    return await window.supabaseClient
                        .from(currentTableName)
                        .update(reversalData)
                        .eq('id', currentAudit.id)
                        .select();
                });
                
                let data = result.data;
                let error = result.error;
                
                // If error is specifically about parameter_comments column not existing, retry without it
                if (error && error.message && (
                    error.message.includes('parameter_comments') && 
                    (error.message.includes('Could not find') || error.message.includes('does not exist') || error.message.includes('column'))
                )) {
                    console.warn('parameter_comments column not found, retrying without it...');
                    
                    // Create a copy without parameter_comments
                    const reversalDataWithoutComments = { ...reversalData };
                    delete reversalDataWithoutComments.parameter_comments;
                    
                    result = await retryOnSchemaCacheError(async () => {
                        return await window.supabaseClient
                            .from(currentTableName)
                            .update(reversalDataWithoutComments)
                            .eq('id', currentAudit.id)
                            .select();
                    });
                    
                    data = result.data;
                    error = result.error;
                    
                    // Successfully submitted without parameter_comments column
                }
                
                if (error) throw error;
                
                // Update currentAudit object immediately to reflect reversal submission
                if (currentAudit && data && data.length > 0) {
                    const updatedAudit = data[0];
                    currentAudit.reversalRequestedAt = updatedAudit.reversal_requested_at;
                    currentAudit.reversal_requested_at = updatedAudit.reversal_requested_at;
                    currentAudit.reversalType = updatedAudit.reversal_type;
                    currentAudit.reversal_type = updatedAudit.reversal_type;
                    currentAudit.reversalJustificationFromAgent = updatedAudit.reversal_justification_from_agent;
                    currentAudit.reversal_justification_from_agent = updatedAudit.reversal_justification_from_agent;
                    currentAudit.reversalMetricsParameters = updatedAudit.reversal_metrics_parameters;
                    currentAudit.reversal_metrics_parameters = updatedAudit.reversal_metrics_parameters;
                    currentAudit.withinAuditorScope = updatedAudit.within_auditor_scope;
                    currentAudit.within_auditor_scope = updatedAudit.within_auditor_scope;
                }
                
                // Show success dialog
                if (window.confirmationDialog) {
                    await window.confirmationDialog.show({
                        title: 'Success',
                        message: '✓ Reversal request submitted successfully!\n\nYour request will be reviewed by the quality team. You will be notified once a decision has been made.',
                        confirmText: 'OK',
                        type: 'success'
                    });
                } else {
                alert('✓ Reversal request submitted successfully!\n\nYour request will be reviewed by the quality team. You will be notified once a decision has been made.');
                }
                
                // Hide form and reload audit data
                toggleReversalForm();
                location.reload();
                
            } catch (error) {
                console.error('Error submitting reversal request:', error);
                console.error('Error details:', error.message, error);
                
                // Check if this is a schema cache or column error
                let errorMessage = error.message || 'Unknown error occurred';
                if (error.message && (
                    error.message.includes('schema cache') ||
                    error.message.includes('Could not find') ||
                    (error.message.includes('column') && error.message.includes('schema cache'))
                )) {
                    errorMessage = 'The database schema cache is being updated. Please wait a moment and try again. If the issue persists, the column may need to be added to the database table.';
                }
                
                // Provide more helpful error message
                let errorMsg = 'Failed to submit reversal request.\n\n';
                errorMsg += 'Error: ' + errorMessage + '\n\n';
                errorMsg += 'Please try again or contact support if the issue persists.';
                
                if (window.confirmationDialog) {
                    await window.confirmationDialog.show({
                        title: 'Error',
                        message: errorMsg,
                        confirmText: 'OK',
                        type: 'error'
                    });
                } else {
                    alert(errorMsg);
                }
            }
        });
    }
});
// Update feedback boxes for a parameter based on error count (max 10)
function updateFeedbackBoxesForParameter(fieldId, fieldType, paramType) {
    const feedbackContainer = document.getElementById(`feedback_container_${fieldId}`);
    if (!feedbackContainer) return;
    
    // Get current error count
    let errorCount = 0;
    if (fieldType === 'radio') {
        const selectedRadio = document.querySelector(`input[name="${fieldId}"]:checked`);
        if (selectedRadio) {
            const value = parseInt(selectedRadio.value) || 0;
            // For additive/achievement: NO (0) = not achieved = error
            // For error parameters: YES (1) = error occurred = error
            if (paramType === 'achievement' || paramType === 'bonus') {
                errorCount = value === 0 ? 1 : 0;
            } else {
                errorCount = value;
            }
        }
    } else {
        const field = document.getElementById(fieldId);
        errorCount = field ? (parseInt(field.value) || 0) : 0;
    }
    
    // Always show at least 1 feedback box, but limit to max 10 based on error count
    // If errorCount is 0, show 1 box (optional)
    // If errorCount > 0, show up to errorCount boxes (max 10), all required
    const feedbackCount = errorCount === 0 ? 1 : Math.min(errorCount, 10);
    const isRequired = errorCount > 0;
    
    // Get existing feedback values (preserve user input)
    const existingFeedbacks = [];
    const existingTextareas = feedbackContainer.querySelectorAll(`textarea[id^="feedback_${fieldId}_"]`);
    existingTextareas.forEach(textarea => {
        const index = parseInt(textarea.id.split('_').pop()) || 0;
        existingFeedbacks[index] = textarea.value;
    });
    
    // Clear container
    feedbackContainer.innerHTML = '';
    
    // Create feedback boxes
    for (let i = 0; i < feedbackCount; i++) {
        const feedbackDiv = document.createElement('div');
        const feedbackId = `feedback_${fieldId}_${i}`;
        // Make required if errorCount > 0, otherwise optional
        const requiredAttr = isRequired ? 'required' : '';
        const placeholder = errorCount === 0 
            ? 'Enter feedback (optional)...' 
            : (feedbackCount === 1 
                ? 'Enter feedback (required)...' 
                : `Feedback ${i + 1} of ${feedbackCount} (required)...`);
        
        feedbackDiv.innerHTML = `
            <textarea 
                id="${feedbackId}" 
                name="${feedbackId}" 
                ${requiredAttr}
                placeholder="${placeholder}" 
                rows="2" 
                style="font-family: 'Poppins', sans-serif; font-size: 0.5659rem; line-height: 1.2; border: 0.0625rem solid #d1d5db; border-radius: 0.1617rem; padding: 0.2425rem 0.3234rem; width: 100%; resize: vertical; min-height: 2rem;"
            >${existingFeedbacks[i] || ''}</textarea>
        `;
        feedbackContainer.appendChild(feedbackDiv);
    }
}

// Counter Button Functionality for Edit Mode
document.addEventListener('click', function(e) {
    if (e.target.classList.contains('counter-btn') || e.target.closest('.counter-btn')) {
        const btn = e.target.classList.contains('counter-btn') ? e.target : e.target.closest('.counter-btn');
        const action = btn.getAttribute('data-action');
        const targetId = btn.getAttribute('data-target');
        const targetInput = document.getElementById(targetId);
        
        if (targetInput) {
            let currentValue = parseInt(targetInput.value) || 0;
            
            if (action === 'increment') {
                currentValue = Math.min(currentValue + 1, 10);
            } else if (action === 'decrement') {
                currentValue = Math.max(0, currentValue - 1);
            }
            
            targetInput.value = currentValue;
            
            // Update display
            const displayElement = document.getElementById(`${targetId}_display`);
            if (displayElement) {
                displayElement.textContent = currentValue;
                displayElement.style.color = currentValue > 0 ? '#ef4444' : '#1f2937';
            }
            
            // Update feedback boxes based on new error count
            // Get field type and param type from the input's data attributes
            const fieldType = targetInput.dataset.fieldType || 'counter';
            const paramType = targetInput.dataset.paramType || 'error';
            updateFeedbackBoxesForParameter(targetId, fieldType, paramType);
            
            // If count is 0, clear the error count field
            if (currentValue === 0) {
                targetInput.value = 0;
            }
            
            // Update score calculation whenever error count changes
            // Use setTimeout to ensure DOM is updated first
            setTimeout(() => {
                updateAverageScoreDisplay();
            }, 10);
            
            // Also update calculated score if in reversal approval interface
            if (shouldShowReversalApprovalInterface()) {
                setTimeout(() => {
                    updateCalculatedScore();
                }, 100);
            }
        }
    }
});

// Radio Button Change Handler for Edit Mode
document.addEventListener('change', function(e) {
    if (e.target.type === 'radio' && e.target.dataset.category && e.target.name) {
        const fieldName = e.target.name;
        const fieldType = 'radio';
        const paramType = e.target.dataset.paramType || 'error';
        
        // Update feedback boxes based on new selection
        updateFeedbackBoxesForParameter(fieldName, fieldType, paramType);
        
        // Update score calculation whenever error count changes
        // Use setTimeout to ensure DOM is updated first
        setTimeout(() => {
            updateAverageScoreDisplay();
        }, 10);
        
        // Also update calculated score if in edit mode with pending reversal
        if (shouldShowReversalApprovalInterface()) {
            setTimeout(() => {
                updateCalculatedScore();
            }, 100);
        }
    }
});

// Store original audit state for change tracking
let originalAuditState = null;

// Capture original audit state when page loads in edit mode with pending reversal
function captureOriginalAuditState() {
    if (!currentAudit || !shouldShowReversalApprovalInterface()) {
        return;
    }
    
    originalAuditState = {
        parameters: {},
        feedback: {},
        score: currentAudit.averageScore || currentAudit.average_score || 0,
        passingStatus: currentAudit.passingStatus || currentAudit.passing_status || ''
    };
    
    // Capture all parameter values
    currentErrorFields.forEach(field => {
        const value = currentAudit[field.key] || 0;
        originalAuditState.parameters[field.key] = value;
        
        // Capture feedback
        const feedbackKey = `feedback_${field.key}`;
        const feedbackValue = currentAudit[feedbackKey] || null;
        originalAuditState.feedback[field.key] = feedbackValue;
    });
}

// Calculate new score based on current parameter values
// Uses the same logic as create-audit.html to support deductive, additive, and hybrid scoring
function calculateNewScore() {
    if (!currentErrorFields || currentErrorFields.length === 0 || !currentAuditScorecard) {
        return currentAudit?.averageScore || currentAudit?.average_score || 0;
    }
    
    const scorecard = currentAuditScorecard;
    const scoringType = scorecard.scoring_type || 'deductive';
    
    let score = 0;
    
    switch(scoringType) {
        case 'deductive':
            score = calculateDeductiveScoreForEdit();
            break;
        case 'additive':
            score = calculateAdditiveScoreForEdit();
            break;
        case 'hybrid':
            score = calculateHybridScoreForEdit();
            break;
        default:
            score = calculateDeductiveScoreForEdit();
    }
    
    return Math.round(score * 100) / 100; // Round to 2 decimal places
}

// Deductive scoring: Start at 100, subtract for errors
function calculateDeductiveScoreForEdit() {
    let totalDeduction = 0;
    
    currentErrorFields.forEach(field => {
        // Default to 'error' if parameter_type is null/undefined/empty
        // Skip only if it's explicitly an achievement or bonus type
        const paramType = field.parameter_type || 'error';
        if (paramType === 'achievement' || paramType === 'bonus') {
            return;
        }
        
        let value = 0;
        
        if (field.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            const fieldInput = document.getElementById(field.key);
            value = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
        }
        
        const penalty = parseFloat(field.points) || 0;
        totalDeduction += value * penalty;
    });
    
    return Math.max(0, 100 - totalDeduction);
}

// Additive scoring: Start at 0, add for achievements
function calculateAdditiveScoreForEdit() {
    let totalPoints = 0;
    
    currentErrorFields.forEach(field => {
        if (field.parameter_type !== 'achievement' && field.parameter_type !== 'bonus') return;
        
        let value = 0;
        
        if (field.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            const fieldInput = document.getElementById(field.key);
            value = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
        }
        
        const points = parseFloat(field.points) || 0;
        totalPoints += value * points;
    });
    
    return Math.min(100, totalPoints);
}

// Hybrid scoring: Deduct for errors, add for achievements
function calculateHybridScoreForEdit() {
    let baseScore = 100;
    let bonusPoints = 0;
    
    currentErrorFields.forEach(field => {
        let value = 0;
        
        if (field.field_type === 'radio') {
            const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
            value = selectedRadio ? parseInt(selectedRadio.value) : 0;
        } else {
            const fieldInput = document.getElementById(field.key);
            value = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
        }
        
        const points = parseFloat(field.points) || 0;
        
        // Default to 'error' if parameter_type is null/undefined/empty
        const paramType = field.parameter_type || 'error';
        
        if (paramType === 'error') {
            // Subtract from base score
            baseScore -= value * points;
        } else if (paramType === 'achievement' || paramType === 'bonus') {
            // Add to bonus
            bonusPoints += value * points;
        }
        // If parameter doesn't match any condition, it's skipped (no deduction or bonus)
    });
    
    // Apply max bonus cap if set
    const maxBonus = parseFloat(currentAuditScorecard.max_bonus_points) || 0;
    if (maxBonus > 0) {
        bonusPoints = Math.min(bonusPoints, maxBonus);
    }
    
    // Calculate final score
    let finalScore = baseScore + bonusPoints;
    
    // Apply over 100% cap if not allowed
    const allowOver100 = currentAuditScorecard.allow_over_100 || false;
    if (!allowOver100) {
        finalScore = Math.min(100, finalScore);
    }
    
    // Ensure minimum of 0
    finalScore = Math.max(0, finalScore);
    
    return finalScore;
}

// Update calculated score display
function updateCalculatedScore() {
    const newScore = calculateNewScore();
    const scoreDisplay = document.getElementById('calculatedNewScore');
    const passingStatusDisplay = document.getElementById('calculatedPassingStatus');
    
    if (scoreDisplay) {
        scoreDisplay.textContent = `${newScore.toFixed(2)}%`;
    }
    
    if (passingStatusDisplay) {
        const scorecard = currentAuditScorecard || {};
        const passingThreshold = scorecard.passing_threshold || 85;
        const isPassing = newScore >= passingThreshold;
        
        passingStatusDisplay.textContent = isPassing ? 'Passing' : 'Not Passing';
        passingStatusDisplay.className = isPassing 
            ? 'text-green-600 font-semibold' 
            : 'text-red-600 font-semibold';
    }
}

// Update average score display in the main form (similar to create-audit.html)
function updateAverageScoreDisplay() {
    if (!currentErrorFields || currentErrorFields.length === 0 || !currentAuditScorecard) {
        return;
    }
    
    const newScore = calculateNewScore();
    
    // Update average score field if it exists (hidden input for form submission)
    const averageScoreField = document.getElementById('averageScore');
    if (averageScoreField) {
        averageScoreField.value = newScore.toFixed(2);
    }
    
    // Update average score display element - try multiple ways to find it
    let averageScoreDisplay = document.getElementById('averageScoreDisplay');
    
    // If not found by ID, try to find it by looking for the element containing "Avg Score" label
    if (!averageScoreDisplay) {
        // Find the label "Avg Score" and get the next sibling div
        const labels = Array.from(document.querySelectorAll('p'));
        const avgScoreLabel = labels.find(p => p.textContent && p.textContent.trim().toUpperCase().includes('AVG SCORE'));
        if (avgScoreLabel && avgScoreLabel.nextElementSibling) {
            averageScoreDisplay = avgScoreLabel.nextElementSibling;
        }
    }
    
    // If still not found, try querySelector for any element with averageScore in id
    if (!averageScoreDisplay) {
        averageScoreDisplay = document.querySelector('[id*="averageScore" i]');
    }
    
    if (averageScoreDisplay) {
        averageScoreDisplay.textContent = `${newScore.toFixed(2)}%`;
    }
    
    // Update header score display
    const headerScoreDisplay = document.getElementById('headerScoreDisplay');
    if (headerScoreDisplay) {
        headerScoreDisplay.textContent = `${newScore.toFixed(2)}%`;
    }
    
    // Update passing status
    const scorecard = currentAuditScorecard || {};
    const passingThreshold = parseFloat(scorecard.passing_threshold) || 85;
    const passingStatusField = document.getElementById('passingStatus');
    const passingStatusDisplay = document.getElementById('passingStatusDisplay');
    const headerStatusDisplay = document.getElementById('headerStatusDisplay');
    const headerElement = document.getElementById('auditFormHeader');
    
    // Check if any "fail all" parameters have errors
    let hasFailAllError = false;
    if (currentErrorFields) {
        currentErrorFields.forEach(field => {
            // Check if this field has is_fail_all flag
            if (field.is_fail_all) {
                let errorCount = 0;
                
                if (field.field_type === 'radio') {
                    const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
                    const value = selectedRadio ? parseInt(selectedRadio.value) : 0;
                    // For error parameters: YES (1) = error
                    // For achievement/bonus: NO (0) = error
                    if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
                        errorCount = value === 0 ? 1 : 0;
                    } else {
                        errorCount = value;
                    }
                } else {
                    const fieldInput = document.getElementById(field.key);
                    errorCount = fieldInput ? (parseInt(fieldInput.value) || 0) : 0;
                }
                
                if (errorCount > 0) {
                    hasFailAllError = true;
                }
            }
        });
    }
    
    // Determine passing status
    let passingStatus = 'Not Passing';
    if (hasFailAllError) {
        passingStatus = 'Not Passing';
    } else if (newScore >= passingThreshold) {
        passingStatus = 'Pass';
    } else {
        passingStatus = 'Not Passing';
    }
    
    if (passingStatusField) {
        passingStatusField.value = passingStatus;
    }
    
    // Update passing status display element if it exists
    if (passingStatusDisplay) {
        // Normalize status for display
        const displayStatus = passingStatus === 'Pass' || passingStatus === 'Passing' || passingStatus === 'Passed' 
            ? 'Pass' 
            : (passingStatus === 'Not Passing' || passingStatus === 'Not Passed' 
                ? 'Not Passed' 
                : passingStatus);
        passingStatusDisplay.textContent = displayStatus;
    }
    
    // Update header status display
    if (headerStatusDisplay) {
        // Determine status icon
        const isPassing = passingStatus === 'Pass' || passingStatus === 'Passing' || passingStatus === 'Passed';
        const statusIcon = isPassing ? '✓ ' : '✗ ';
        // Normalize status for display
        const displayStatus = isPassing 
            ? 'Pass' 
            : (passingStatus === 'Not Passing' || passingStatus === 'Not Passed' 
                ? 'Not Passed' 
                : passingStatus);
        headerStatusDisplay.textContent = `${statusIcon}${displayStatus}`;
    }
    
    // Update header background color based on passing status
    if (headerElement) {
        const isPassing = passingStatus === 'Pass' || passingStatus === 'Passing' || passingStatus === 'Passed';
        if (isPassing) {
            headerElement.style.background = 'linear-gradient(135deg, #1A733E 0%, #2d9a5a 100%)';
        } else {
            headerElement.style.background = 'linear-gradient(135deg, #d41212 0%, #b91c1c 100%)';
        }
    }
    
    // Recalculate and update error counts based on current form values
    if (currentErrorFields && currentErrorFields.length > 0) {
        let totalErrors = 0;
        let criticalFailTotal = 0;
        let criticalTotal = 0;
        let significantTotal = 0;
        
        currentErrorFields.forEach(field => {
            let errorCount = 0;
            
            // Get current value from form
            if (field.field_type === 'radio') {
                const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
                if (selectedRadio) {
                    const value = parseInt(selectedRadio.value) || 0;
                    // For error parameters: YES (1) = error
                    // For achievement/bonus: NO (0) = error
                    if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
                        errorCount = value === 0 ? 1 : 0;
                    } else {
                        errorCount = value;
                    }
                }
            } else {
                // Counter field
                const fieldInput = document.getElementById(field.key);
                if (fieldInput) {
                    errorCount = parseInt(fieldInput.value) || 0;
                }
            }
            
            // Only count errors (not achievements/bonuses) in total
            if (field.parameter_type === 'error' || !field.parameter_type) {
                totalErrors += errorCount;
            }
            
            // Count by severity
            if (errorCount > 0) {
                if (field.severity === 'Critical Fail') {
                    criticalFailTotal += errorCount;
                } else if (field.severity === 'Critical') {
                    criticalTotal += errorCount;
                } else if (field.severity === 'Significant') {
                    significantTotal += errorCount;
                }
            }
        });
        
        // Update total errors count display
        const totalErrorsDisplay = document.getElementById('totalErrorsCountDisplay');
        if (totalErrorsDisplay) {
            totalErrorsDisplay.textContent = totalErrors.toString();
        }
        
        // Update critical fail total displays
        const criticalFailDisplay = document.getElementById('criticalFailTotalDisplay');
        if (criticalFailDisplay) {
            criticalFailDisplay.textContent = criticalFailTotal.toString();
        }
        const errorDetailsCriticalFail = document.getElementById('errorDetailsCriticalFailTotal');
        if (errorDetailsCriticalFail) {
            errorDetailsCriticalFail.textContent = `Critical Fail: ${criticalFailTotal}`;
        }
        
        // Update critical total displays
        const criticalDisplay = document.getElementById('criticalTotalDisplay');
        if (criticalDisplay) {
            criticalDisplay.textContent = criticalTotal.toString();
        }
        const errorDetailsCritical = document.getElementById('errorDetailsCriticalTotal');
        if (errorDetailsCritical) {
            errorDetailsCritical.textContent = `Critical: ${criticalTotal}`;
        }
        
        // Update significant total displays
        const significantDisplay = document.getElementById('significantTotalDisplay');
        if (significantDisplay) {
            significantDisplay.textContent = significantTotal.toString();
        }
        const errorDetailsSignificant = document.getElementById('errorDetailsSignificantTotal');
        if (errorDetailsSignificant) {
            errorDetailsSignificant.textContent = `Significant: ${significantTotal}`;
        }
    }
}

// Check if any changes were made
function hasParameterChanges() {
    if (!originalAuditState || !currentErrorFields) {
        return false;
    }
    
    for (const field of currentErrorFields) {
        const fieldKey = field.key;
        let currentValue = 0;
        
        // Get current value from form
        if (field.field_type === 'radio') {
            const radioInput = document.querySelector(`input[name="${fieldKey}"]:checked`);
            if (radioInput) {
                currentValue = parseInt(radioInput.value) || 0;
            }
        } else {
            const numberInput = document.getElementById(fieldKey);
            if (numberInput) {
                currentValue = parseInt(numberInput.value) || 0;
            }
        }
        
        const originalValue = originalAuditState.parameters[fieldKey] || 0;
        
        if (currentValue !== originalValue) {
            return true;
        }
        
        // Also check feedback changes
        const feedbackKey = `feedback_${fieldKey}`;
        const feedbackTextareas = document.querySelectorAll(`textarea[id^="${feedbackKey}"]`);
        const currentFeedbacks = Array.from(feedbackTextareas)
            .map(ta => ta.value.trim())
            .filter(v => v);
        
        const originalFeedback = originalAuditState.feedback[fieldKey];
        let originalFeedbacks = [];
        if (originalFeedback) {
            if (Array.isArray(originalFeedback)) {
                originalFeedbacks = originalFeedback.filter(f => f && f.trim());
            } else if (typeof originalFeedback === 'string') {
                try {
                    const parsed = JSON.parse(originalFeedback);
                    originalFeedbacks = Array.isArray(parsed) ? parsed.filter(f => f && f.trim()) : [originalFeedback.trim()];
                } catch {
                    originalFeedbacks = originalFeedback.trim() ? [originalFeedback.trim()] : [];
                }
            }
        }
        
        if (JSON.stringify(currentFeedbacks.sort()) !== JSON.stringify(originalFeedbacks.sort())) {
            return true;
        }
    }
    
    return false;
}

// Display reversal approval interface
function displayReversalApprovalInterface(audit) {
    const auditContentDiv = document.getElementById('auditContent');
    if (!auditContentDiv) return;
    
    // Get current user info
    const userInfo = getCurrentUserInfo();
    const currentUserName = userInfo?.name || userInfo?.email || 'Unknown';
    const currentUserEmailFromInfo = userInfo?.email || getCurrentUserEmail() || '';
    
    // Get scorecard for passing threshold
    const scorecard = currentAuditScorecard || {};
    const passingThreshold = scorecard.passing_threshold || 85;
    
    // Calculate initial score
    const newScore = calculateNewScore();
    const isPassing = newScore >= passingThreshold;
    
    // Calculate SLA hours
    const reversalRequestedAt = audit.reversalRequestedAt || audit.reversal_requested_at;
    let slaHours = 0;
    if (reversalRequestedAt) {
        const requestedAt = new Date(reversalRequestedAt);
        const now = new Date();
        slaHours = ((now - requestedAt) / (1000 * 60 * 60));
    }
    
    const approvalInterfaceHtml = `
        <div id="reversalApprovalInterface" class="no-print" style="background: white; border: 0.0625rem solid #e5e7eb; border-radius: 0.2812rem; padding: 0.75rem; box-shadow: 0 0.0625rem 0.1875rem rgba(0,0,0,0.1); margin-top: 0.5625rem;">
            <div style="display: flex; align-items: center; gap: 0.375rem; margin-bottom: 0.5625rem;">
                <svg style="width: 0.9375rem; height: 0.9375rem; color: #1A733E;" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                <h3 style="font-size: 0.8438rem; font-weight: 700; color: #111827; margin: 0; font-family: 'Poppins', sans-serif;">Review & Process Reversal</h3>
            </div>
            
            <!-- Score Summary -->
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5625rem; margin-bottom: 0.75rem;">
                <div style="background: #f9fafb; border: 0.0625rem solid #e5e7eb; border-radius: 0.2812rem; padding: 0.5625rem;">
                    <p style="font-size: 0.6094rem; color: #4b5563; text-transform: uppercase; letter-spacing: 0.05em; margin: 0 0 0.1875rem 0; font-weight: 600; font-family: 'Poppins', sans-serif;">Original Score</p>
                    <p style="font-size: 0.9375rem; font-weight: 700; color: #111827; margin: 0; font-family: 'Poppins', sans-serif;">${(currentAudit?.averageScore || currentAudit?.average_score || 0).toFixed(2)}%</p>
                </div>
                <div style="background: #f0fdf4; border: 0.0625rem solid #bbf7d0; border-radius: 0.2812rem; padding: 0.5625rem;">
                    <p style="font-size: 0.6094rem; color: #4b5563; text-transform: uppercase; letter-spacing: 0.05em; margin: 0 0 0.1875rem 0; font-weight: 600; font-family: 'Poppins', sans-serif;">New Score (Auto-calculated)</p>
                    <p id="calculatedNewScore" style="font-size: 0.9375rem; font-weight: 700; color: #16a34a; margin: 0; font-family: 'Poppins', sans-serif;">${newScore.toFixed(2)}%</p>
                    <p id="calculatedPassingStatus" style="font-size: 0.6562rem; margin-top: 0.1875rem; font-weight: 600; font-family: 'Poppins', sans-serif; color: ${isPassing ? '#16a34a' : '#dc2626'};">
                        ${isPassing ? 'Passing' : 'Not Passing'}
                    </p>
                </div>
            </div>
            
            <!-- Change Summary -->
            <div id="changeSummary" style="background: #eff6ff; border: 0.0625rem solid #bfdbfe; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <p style="font-size: 0.6562rem; font-weight: 600; color: #1e40af; margin: 0 0 0.375rem 0; font-family: 'Poppins', sans-serif;">Change Summary</p>
                <p id="changeSummaryText" style="font-size: 0.6562rem; color: #1e40af; margin: 0; font-family: 'Poppins', sans-serif;">No changes detected yet. Please make adjustments to parameters above.</p>
            </div>
            
            <!-- Decision Section -->
            <div style="border-top: 0.0625rem solid #e5e7eb; padding-top: 0.75rem;">
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5625rem; margin-bottom: 0.5625rem;">
                    <div>
                        <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                            Decision <span style="color: #ef4444;">*</span>
                        </label>
                        <select id="reversalDecision" required style="width: 100%; padding: 0.375rem 0.5625rem; border: 0.0625rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; background: white;">
                            <option value="">Select decision...</option>
                            <option value="approved">Approve Reversal</option>
                            <option value="rejected">Reject Reversal</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                            Approved By
                        </label>
                        <input type="text" id="reversalApprovedBy" value="${escapeHtml(currentUserName)}" readonly style="width: 100%; padding: 0.375rem 0.5625rem; border: 0.0625rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; background: #f9fafb; color: #4b5563;">
                    </div>
                </div>
                
                <div style="margin-bottom: 0.5625rem;">
                    <label style="display: block; font-size: 0.6562rem; font-weight: 600; color: #374151; margin-bottom: 0.2812rem; font-family: 'Poppins', sans-serif;">
                        Response From Auditor
                    </label>
                    <textarea id="reversalDelayReason" rows="2" placeholder="Explain if response took longer than expected..." style="width: 100%; padding: 0.375rem 0.5625rem; border: 0.0625rem solid #d1d5db; border-radius: 0.2812rem; font-size: 0.6562rem; font-family: 'Poppins', sans-serif; resize: vertical; box-sizing: border-box;"></textarea>
                </div>
                
                <div style="display: flex; gap: 0.5625rem; justify-content: flex-end; padding-top: 0.5625rem; border-top: 0.0625rem solid #e5e7eb;">
                    <button onclick="rejectReversal()" style="padding: 0.375rem 0.75rem; background: #f3f4f6; color: #374151; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                        Reject
                    </button>
                    <button onclick="approveReversal()" style="padding: 0.375rem 0.75rem; background: #16a34a; color: white; border: none; border-radius: 0.2812rem; font-size: 0.6562rem; font-weight: 600; font-family: 'Poppins', sans-serif; cursor: pointer; transition: background 0.2s;">
                        Approve
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Insert after submitted reversal form
    const submittedForm = document.getElementById('submittedReversalForm');
    if (submittedForm && submittedForm.parentElement) {
        submittedForm.parentElement.insertAdjacentHTML('afterend', approvalInterfaceHtml);
    } else {
        // Fallback: insert before footer
        const footerBar = document.getElementById('footerBar');
        if (footerBar && footerBar.parentElement) {
            footerBar.parentElement.insertAdjacentHTML('beforebegin', approvalInterfaceHtml);
        } else {
            auditContentDiv.insertAdjacentHTML('beforeend', approvalInterfaceHtml);
        }
    }
    
    // Capture original state
    captureOriginalAuditState();
    
    // Update score calculation on any parameter change
    updateCalculatedScore();
    
    // Update change summary periodically
    setInterval(() => {
        updateChangeSummary();
    }, 500);
}

// Update change summary display
function updateChangeSummary() {
    const changeSummaryText = document.getElementById('changeSummaryText');
    if (!changeSummaryText) return;
    
    const hasChanges = hasParameterChanges();
    
    if (!hasChanges) {
        changeSummaryText.textContent = 'No changes detected yet. Please make adjustments to parameters above.';
        changeSummaryText.className = 'text-sm text-blue-800';
        changeSummaryText.style.fontFamily = "'Poppins', sans-serif";
        return;
    }
    
    // Count changed parameters
    let changedCount = 0;
    const changes = [];
    
    if (originalAuditState && currentErrorFields) {
        currentErrorFields.forEach(field => {
            const fieldKey = field.key;
            let currentValue = 0;
            
            if (field.field_type === 'radio') {
                const radioInput = document.querySelector(`input[name="${fieldKey}"]:checked`);
                if (radioInput) {
                    currentValue = parseInt(radioInput.value) || 0;
                }
            } else {
                const numberInput = document.getElementById(fieldKey);
                if (numberInput) {
                    currentValue = parseInt(numberInput.value) || 0;
                }
            }
            
            const originalValue = originalAuditState.parameters[fieldKey] || 0;
            
            if (currentValue !== originalValue) {
                changedCount++;
                changes.push(`${field.label}: ${originalValue} → ${currentValue}`);
            }
        });
    }
    
    if (changedCount > 0) {
        changeSummaryText.innerHTML = `<strong>${changedCount}</strong> parameter(s) changed. ${changes.slice(0, 3).join(', ')}${changes.length > 3 ? '...' : ''}`;
        changeSummaryText.className = 'text-sm text-green-800';
        changeSummaryText.style.fontFamily = "'Poppins', sans-serif";
    } else {
        changeSummaryText.textContent = 'No parameter changes detected.';
        changeSummaryText.className = 'text-sm text-blue-800';
        changeSummaryText.style.fontFamily = "'Poppins', sans-serif";
    }
}

// Approve reversal
async function approveReversal() {
    // Check if changes were made
    if (!hasParameterChanges()) {
        alert('Error: You cannot approve a reversal without making any changes to the audit parameters. Please adjust the parameters first.');
        return;
    }
    
    const decision = document.getElementById('reversalDecision')?.value;
    if (!decision || decision !== 'approved') {
        document.getElementById('reversalDecision').value = 'approved';
    }
    
    await processReversalDecision('approved');
}

// Reject reversal
async function rejectReversal() {
    const decision = document.getElementById('reversalDecision')?.value;
    if (!decision || decision !== 'rejected') {
        document.getElementById('reversalDecision').value = 'rejected';
    }
    
    await processReversalDecision('rejected');
}

// Process reversal decision
async function processReversalDecision(decision) {
    if (!currentAudit || !currentTableName) {
        alert('Error: Audit data not available');
        return;
    }
    
    // For approval, require changes
    if (decision === 'approved' && !hasParameterChanges()) {
        alert('Error: You cannot approve a reversal without making any changes to the audit parameters. Please adjust the parameters first.');
        return;
    }
    
    try {
        // FIRST: Retrieve the original state from activity log (when reversal was requested)
        // This ensures we have the true original state, not the current state
        let loggedOriginalState = null;
        try {
            const { data: reversalRequestLog, error: logFetchError } = await window.supabaseClient
                .from('audit_activity_log')
                .select('*')
                .eq('audit_id', currentAudit.id)
                .eq('activity_type', 'reversal_requested')
                .order('activity_timestamp', { ascending: false })
                .limit(1)
                .maybeSingle();
            
            if (!logFetchError && reversalRequestLog) {
                loggedOriginalState = {
                    parameters: reversalRequestLog.parameters_snapshot || {},
                    feedback: reversalRequestLog.feedback_snapshot || {},
                    score: reversalRequestLog.score_snapshot || 0,
                    passingStatus: reversalRequestLog.passing_status_snapshot || ''
                };
                console.log('Retrieved original state from activity log:', loggedOriginalState);
            } else if (logFetchError) {
                console.warn('Could not retrieve original state from activity log:', logFetchError);
            }
        } catch (logErr) {
            console.warn('Error retrieving original state from activity log:', logErr);
        }
        
        // Use logged original state if available, otherwise fall back to originalAuditState
        const trueOriginalState = loggedOriginalState || originalAuditState;
        
        // First, save all parameter changes
        const auditData = {};
        
        // Collect parameter values
        const errorInputs = document.querySelectorAll('input[type="number"][id]:not([id^="feedback_"]):not([id^="comment_"]), input[type="radio"]:checked');
        errorInputs.forEach(input => {
            if (input.type === 'radio') {
                auditData[input.name] = parseInt(input.value) || 0;
            } else {
                const fieldId = input.id;
                if (fieldId && !fieldId.startsWith('feedback_') && !fieldId.startsWith('comment_')) {
                    auditData[fieldId] = parseInt(input.value) || 0;
                }
            }
        });
        
        // Collect feedback values
        const feedbackTextareas = document.querySelectorAll('textarea[id^="feedback_"]');
        const feedbackByField = {};
        feedbackTextareas.forEach(textarea => {
            const fieldId = textarea.id.replace(/^feedback_/, '').replace(/_\d+$/, '');
            if (!feedbackByField[fieldId]) {
                feedbackByField[fieldId] = [];
            }
            if (textarea.value && textarea.value.trim()) {
                feedbackByField[fieldId].push(textarea.value.trim());
            }
        });
        
        Object.keys(feedbackByField).forEach(fieldId => {
            const feedbacks = feedbackByField[fieldId];
            auditData[`feedback_${fieldId}`] = feedbacks.length > 0 ? feedbacks : null;
        });
        
        // Note: Feedback should never be cleared, even if error count is 0
        // This ensures feedback/comments remain visible regardless of error count changes
        
        // Calculate new score
        const newScore = calculateNewScore();
        const scorecard = currentAuditScorecard || {};
        const passingThreshold = scorecard.passing_threshold || 85;
        const isPassing = newScore >= passingThreshold;
        
        // Get user info
        const userInfo = getCurrentUserInfo();
        const currentUserName = userInfo?.name || userInfo?.email || 'Unknown';
        const logUserEmail = userInfo?.email || '';
        
        // Get reversal decision details
        const approvedBy = document.getElementById('reversalApprovedBy')?.value || currentUserName;
        const delayReason = document.getElementById('reversalDelayReason')?.value || null;
        
        // Calculate SLA
        const reversalRequestedAt = currentAudit.reversal_requested_at || currentAudit.reversalRequestedAt;
        const respondedAt = new Date();
        let slaHours = 0;
        if (reversalRequestedAt) {
            const requestedAt = new Date(reversalRequestedAt);
            slaHours = ((respondedAt - requestedAt) / (1000 * 60 * 60));
        }
        
        // Prepare change log data
        const changedParameters = {};
        const changedFeedback = {};
        let parametersChangedCount = 0;
        let feedbackChangedCount = 0;
        
        if (trueOriginalState) {
            currentErrorFields.forEach(field => {
                const fieldKey = field.key;
                let currentValue = 0;
                
                if (field.field_type === 'radio') {
                    const radioInput = document.querySelector(`input[name="${fieldKey}"]:checked`);
                    if (radioInput) {
                        currentValue = parseInt(radioInput.value) || 0;
                    }
                } else {
                    const numberInput = document.getElementById(fieldKey);
                    if (numberInput) {
                        currentValue = parseInt(numberInput.value) || 0;
                    }
                }
                
                const originalValue = trueOriginalState.parameters[fieldKey] || 0;
                if (currentValue !== originalValue) {
                    changedParameters[fieldKey] = {
                        original: originalValue,
                        changed: currentValue,
                        fieldName: field.label
                    };
                    parametersChangedCount++;
                }
                
                // Check feedback changes
                const feedbackKey = `feedback_${fieldKey}`;
                const feedbackTextareas = document.querySelectorAll(`textarea[id^="${feedbackKey}"]`);
                const currentFeedbacks = Array.from(feedbackTextareas)
                    .map(ta => ta.value.trim())
                    .filter(v => v);
                
                const originalFeedback = trueOriginalState.feedback[fieldKey];
                let originalFeedbacks = [];
                if (originalFeedback) {
                    if (Array.isArray(originalFeedback)) {
                        originalFeedbacks = originalFeedback.filter(f => f && f.trim());
                    } else if (typeof originalFeedback === 'string') {
                        try {
                            const parsed = JSON.parse(originalFeedback);
                            originalFeedbacks = Array.isArray(parsed) ? parsed.filter(f => f && f.trim()) : [originalFeedback.trim()];
                        } catch {
                            originalFeedbacks = originalFeedback.trim() ? [originalFeedback.trim()] : [];
                        }
                    }
                }
                
                if (JSON.stringify(currentFeedbacks.sort()) !== JSON.stringify(originalFeedbacks.sort())) {
                    changedFeedback[fieldKey] = {
                        original: originalFeedbacks,
                        changed: currentFeedbacks,
                        fieldName: field.label
                    };
                    feedbackChangedCount++;
                }
            });
        }
        
        // Prepare audit update data
        const originalScore = trueOriginalState?.score || currentAudit.averageScore || currentAudit.average_score || 0;
        const originalPassingStatus = trueOriginalState?.passingStatus || currentAudit.passingStatus || currentAudit.passing_status || '';
        
        // Set acknowledgement status to pending after reversal is processed
        const newAcknowledgementStatus = decision === 'approved' 
            ? 'pending - after reversal approved' 
            : 'pending - after reversal rejected';
        
        const updateData = {
            ...auditData,
            reversal_approved: decision === 'approved',
            reversal_responded_at: respondedAt.toISOString(),
            reversal_approved_by: approvedBy,
            reversal_resolved_by: currentUserName,
            response_from_auditor: delayReason,
            sla_in_hours: parseFloat(slaHours.toFixed(2)),
            acknowledgement_status: newAcknowledgementStatus,
            acknowledgement_status_updated_at: respondedAt.toISOString()
        };
        
        // If approved, update score and passing status
        if (decision === 'approved') {
            updateData.average_score = newScore;
            updateData.passing_status = isPassing ? 'Passing' : 'Not Passing';
            updateData.score_after_appeal = newScore;
            // Note: passed_after_appeal column doesn't exist in schema, using did_result_in_pass instead
            updateData.did_result_in_pass = isPassing;
        }
        
        // Update audit in database
        const { data: updatedAudit, error: updateError } = await window.supabaseClient
            .from(currentTableName)
            .update(updateData)
            .eq('id', currentAudit.id)
            .select();
        
        if (updateError) throw updateError;
        
        // Log approval/rejection to activity log
        try {
            // Capture new state after update
            const newAuditState = {
                parameters: auditData,
                feedback: feedbackByField,
                score: decision === 'approved' ? newScore : originalScore,
                passing_status: decision === 'approved' ? (isPassing ? 'Passing' : 'Not Passing') : originalPassingStatus,
                acknowledgement_status: newAcknowledgementStatus
            };
            
            const activityLogData = {
                audit_id: currentAudit.id,
                scorecard_table_name: currentTableName,
                activity_type: decision === 'approved' ? 'reversal_approved' : 'reversal_rejected',
                activity_timestamp: respondedAt.toISOString(),
                performed_by_email: logUserEmail,
                performed_by_name: currentUserName,
                audit_state_snapshot: newAuditState,
                parameters_snapshot: auditData,
                feedback_snapshot: feedbackByField,
                score_snapshot: newAuditState.score,
                passing_status_snapshot: newAuditState.passing_status,
                changes_made: {
                    parameters: changedParameters,
                    feedback: changedFeedback,
                    score_change: decision === 'approved' ? (newScore - originalScore) : 0,
                    passing_status_changed: decision === 'approved' && (isPassing !== (originalPassingStatus === 'Passing' || originalPassingStatus === 'Passed'))
                },
                change_reason: decision === 'approved' ? 'Reversal approved by quality analyst' : 'Reversal rejected by quality analyst',
                metadata: {
                    approved_by: approvedBy,
                    delay_reason: delayReason,
                    sla_hours: parseFloat(slaHours.toFixed(2)),
                    parameters_changed_count: parametersChangedCount,
                    feedback_changed_count: feedbackChangedCount
                }
            };
            
            const { error: activityLogError } = await window.supabaseClient
                .from('audit_activity_log')
                .insert(activityLogData);
            
            if (activityLogError) {
                console.error('Error logging reversal decision to activity log:', activityLogError);
                // Don't throw - audit update succeeded, logging is secondary
            } else {
                console.log('Successfully logged reversal decision to activity log');
            }
        } catch (activityLogErr) {
            console.error('Error creating activity log entry for reversal decision:', activityLogErr);
            // Don't throw - audit update succeeded
        }
        
        // Save to reversal_change_log table
        try {
            const changeLogData = {
                audit_id: currentAudit.id,
                scorecard_table_name: currentTableName,
                reversal_requested_at: reversalRequestedAt,
                original_score: originalScore,
                original_passing_status: originalPassingStatus,
                original_parameters: trueOriginalState?.parameters || {},
                original_feedback: trueOriginalState?.feedback || {},
                changed_parameters: changedParameters,
                changed_feedback: changedFeedback,
                new_score: decision === 'approved' ? newScore : originalScore,
                new_passing_status: decision === 'approved' ? (isPassing ? 'Passing' : 'Not Passing') : originalPassingStatus,
                parameters_changed_count: parametersChangedCount,
                feedback_changed_count: feedbackChangedCount,
                score_change: decision === 'approved' ? (newScore - originalScore) : 0,
                passing_status_changed: decision === 'approved' && (isPassing !== (originalPassingStatus === 'Passing' || originalPassingStatus === 'Passed')),
                reversal_decision: decision,
                reversal_approved: decision === 'approved',
                reversal_responded_at: respondedAt.toISOString(),
                processed_by_email: logUserEmail,
                processed_by_name: currentUserName,
                approved_by_email: logUserEmail,
                approved_by_name: approvedBy,
                sla_hours: parseFloat(slaHours.toFixed(2)),
                delay_reason: delayReason
            };
            
            const { error: logError } = await window.supabaseClient
                .from('reversal_change_log')
                .insert(changeLogData);
            
            if (logError) {
                console.error('Error saving to reversal_change_log:', logError);
                // Don't throw - audit update succeeded, logging is secondary
            }
        } catch (logErr) {
            console.error('Error creating change log:', logErr);
            // Don't throw - audit update succeeded
        }
        
        // Show success message
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Success',
                message: `✓ Reversal ${decision === 'approved' ? 'approved' : 'rejected'} successfully!${decision === 'approved' ? ` Score updated to ${newScore.toFixed(2)}%.` : ''}`,
                confirmText: 'OK',
                type: 'success'
            });
        } else {
            alert(`✓ Reversal ${decision === 'approved' ? 'approved' : 'rejected'} successfully!${decision === 'approved' ? ` Score updated to ${newScore.toFixed(2)}%.` : ''}`);
        }
        
        // Reload page to show updated state
        location.reload();
        
    } catch (error) {
        console.error('Error processing reversal:', error);
        alert('Failed to process reversal: ' + (error.message || 'Unknown error'));
    }
}

// Make functions globally accessible
window.approveReversal = approveReversal;
window.rejectReversal = rejectReversal;
window.deleteCurrentAudit = deleteCurrentAudit;

// Save Audit Changes Function
async function saveAuditChanges() {
    const urlParams = new URLSearchParams(window.location.search);
    const auditId = urlParams.get('id');
    const tableName = urlParams.get('table');
    
    if (!auditId || !tableName) {
        alert('Error: Missing audit ID or table name');
        return;
    }
    
    // Check if audit is acknowledged - lock everything (no edits allowed)
    if (currentAudit) {
        const acknowledgementStatus = currentAudit.acknowledgementStatus || currentAudit.acknowledgement_status || '';
        if (isAcknowledgedStatus(acknowledgementStatus)) {
            alert('This audit has been acknowledged and cannot be edited.');
            return;
        }
    }
    
    try {
        // Collect all form data
        const auditData = {};
        
        // Collect error parameter values - inputs use field.key as ID/name directly
        const errorInputs = document.querySelectorAll('input[type="number"][id]:not([id^="feedback_"]):not([id^="comment_"]), input[type="radio"]:checked');
        errorInputs.forEach(input => {
            if (input.type === 'radio') {
                auditData[input.name] = parseInt(input.value) || 0;
            } else {
                // Only collect if it's a parameter field (not feedback or comment fields)
                const fieldId = input.id;
                if (fieldId && !fieldId.startsWith('feedback_') && !fieldId.startsWith('comment_')) {
                    auditData[fieldId] = parseInt(input.value) || 0;
                }
            }
        });
        
        // Collect feedback values - only include non-empty feedbacks
        const feedbackTextareas = document.querySelectorAll('textarea[id^="feedback_"]');
        const feedbackByField = {};
        feedbackTextareas.forEach(textarea => {
            const fieldId = textarea.id.replace(/^feedback_/, '').replace(/_\d+$/, '');
            if (!feedbackByField[fieldId]) {
                feedbackByField[fieldId] = [];
            }
            if (textarea.value && textarea.value.trim()) {
                feedbackByField[fieldId].push(textarea.value.trim());
            }
        });
        
        // Add feedback to auditData, and set to null if empty
        Object.keys(feedbackByField).forEach(fieldId => {
            const feedbacks = feedbackByField[fieldId];
            auditData[`feedback_${fieldId}`] = feedbacks.length > 0 ? feedbacks : null;
        });
        
        // Collect recommendations field
        const recommendationsTextarea = document.getElementById('recommendations');
        if (recommendationsTextarea) {
            auditData.recommendations = recommendationsTextarea.value.trim() || null;
        }
        
        // Collect parameter comments from all comment input fields
        // Comments should be saved even if error count is 0
        const parameterComments = {};
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                const commentInputs = document.querySelectorAll(`input[data-param-key="${field.key}"]`);
                const comments = [];
                commentInputs.forEach(input => {
                    // Include all comments, even empty ones (to handle deletion)
                    const commentValue = input.value ? input.value.trim() : '';
                    comments.push(commentValue);
                });
                
                // Filter out empty comments at the end
                const nonEmptyComments = comments.filter(c => c.length > 0);
                
                // Always update the parameter comment entry if there are comment inputs OR if there are existing comments
                // This allows us to save comments even if error count is 0, and also delete comments if cleared
                // Check if there are existing comments for this parameter
                const existingParamComments = (currentAudit?.parameterComments || currentAudit?.parameter_comments || {})[field.key];
                const hasExistingComments = existingParamComments && existingParamComments.comments && existingParamComments.comments.length > 0;
                
                if (commentInputs.length > 0 || hasExistingComments) {
                    // Get current user email for commented_by
                    const userEmail = getCurrentUserEmail() || '';
                    if (nonEmptyComments.length > 0) {
                        // Save comments if there are any
                        parameterComments[field.key] = {
                            comments: nonEmptyComments,
                            commented_at: new Date().toISOString(),
                            commented_by: userEmail
                        };
                    } else if (commentInputs.length > 0) {
                        // If comment inputs exist but are all empty, remove the parameter comment entry
                        // Set to null to explicitly remove it
                        parameterComments[field.key] = null;
                    }
                    // If no comment inputs but existing comments, preserve existing comments
                    // (don't add to parameterComments, they'll be preserved in mergedComments)
                }
            });
        }
        
        // Merge with existing parameter comments
        // Start with existing comments, then update with new/cleared comments
        const existingComments = currentAudit?.parameterComments || currentAudit?.parameter_comments || {};
        const mergedComments = { ...existingComments };
        
        // Update merged comments with new values (including nulls for deletions)
        Object.keys(parameterComments).forEach(key => {
            if (parameterComments[key] === null) {
                // Remove the comment entry if it was cleared
                delete mergedComments[key];
            } else {
                // Update with new comments
                mergedComments[key] = parameterComments[key];
            }
        });
        
        // Note: Feedback should never be cleared, even if error count is 0
        // This ensures feedback/comments remain visible regardless of error count changes
        errorInputs.forEach(input => {
            // For radio buttons, use name; for number inputs, use id
            const fieldId = input.type === 'radio' ? input.name : (input.id || input.name);
            const errorValue = input.type === 'radio' ? (parseInt(input.value) || 0) : (parseInt(input.value) || 0);
            
            // Skip if this is not a parameter field (e.g., feedback or comment inputs)
            if (fieldId && (fieldId.startsWith('feedback_') || fieldId.startsWith('comment_'))) {
                return;
            }
            
            // Note: Feedback should never be cleared, even if error count is 0
            // This ensures feedback/comments remain visible regardless of error count changes
            // Ensure the error count field is set to the current value
            auditData[fieldId] = errorValue;
        });
        
        // Calculate total errors count and error category counts from current form values
        let totalErrorsCount = 0;
        let criticalFailTotal = 0;
        let criticalTotal = 0;
        let significantTotal = 0;
        
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                // Only count error parameters (not achievements/bonuses)
                if (field.parameter_type === 'error' || !field.parameter_type) {
                    let errorCount = 0;
                    
                    if (field.field_type === 'radio') {
                        const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
                        if (selectedRadio) {
                            const value = parseInt(selectedRadio.value) || 0;
                            errorCount = value;
                        }
                    } else {
                        const fieldInput = document.getElementById(field.key);
                        if (fieldInput) {
                            errorCount = parseInt(fieldInput.value) || 0;
                        }
                    }
                    
                    totalErrorsCount += errorCount;
                    
                    // Count by severity/error_category
                    if (errorCount > 0) {
                        // Use severity if available, otherwise map from error_category
                        let severity = field.severity;
                        if (!severity && field.error_category) {
                            const category = field.error_category || '';
                            if (category.includes('Fail')) {
                                severity = 'Critical Fail';
                            } else if (category.includes('Critical')) {
                                severity = 'Critical';
                            } else if (category.includes('Significant') || category.includes('Major') || category.includes('Minor')) {
                                severity = 'Significant';
                            } else {
                                severity = 'Significant'; // default
                            }
                        }
                        
                        if (severity === 'Critical Fail') {
                            criticalFailTotal += errorCount;
                        } else if (severity === 'Critical') {
                            criticalTotal += errorCount;
                        } else if (severity === 'Significant' || severity === 'Major' || severity === 'Minor') {
                            significantTotal += errorCount;
                        }
                    }
                }
            });
        }
        
        // Calculate average score
        const calculatedAverageScore = calculateNewScore();
        
        // Calculate passing status
        const scorecard = currentAuditScorecard || {};
        const passingThreshold = parseFloat(scorecard.passing_threshold) || 85;
        
        // Check if any "fail all" parameters have errors
        let hasFailAllError = false;
        if (currentErrorFields && currentErrorFields.length > 0) {
            currentErrorFields.forEach(field => {
                if (field.is_fail_all) {
                    let errorCount = 0;
                    
                    if (field.field_type === 'radio') {
                        const selectedRadio = document.querySelector(`input[name="${field.key}"]:checked`);
                        if (selectedRadio) {
                            const value = parseInt(selectedRadio.value) || 0;
                            if (field.parameter_type === 'achievement' || field.parameter_type === 'bonus') {
                                errorCount = value === 0 ? 1 : 0;
                            } else {
                                errorCount = value;
                            }
                        }
                    } else {
                        const fieldInput = document.getElementById(field.key);
                        if (fieldInput) {
                            errorCount = parseInt(fieldInput.value) || 0;
                        }
                    }
                    
                    if (errorCount > 0) {
                        hasFailAllError = true;
                    }
                }
            });
        }
        
        // Determine passing status
        let passingStatus = 'Not Passing';
        if (hasFailAllError) {
            passingStatus = 'Not Passing';
        } else if (calculatedAverageScore >= passingThreshold) {
            passingStatus = 'Passing';
        } else {
            passingStatus = 'Not Passing';
        }
        
        // Build update payload
        const updatePayload = {};
        
        // Add error parameter values
        Object.keys(auditData).forEach(key => {
            if (key.startsWith('feedback_')) {
                updatePayload[key] = auditData[key];
            } else {
                updatePayload[key] = auditData[key];
            }
        });
        
        // Add calculated fields
        updatePayload.total_errors_count = totalErrorsCount;
        updatePayload.critical_errors = criticalTotal;
        updatePayload.critical_fail_error = criticalFailTotal;
        updatePayload.significant_error = significantTotal;
        updatePayload.average_score = parseFloat(calculatedAverageScore.toFixed(2));
        updatePayload.passing_status = passingStatus;
        
        console.log('Calculated average score:', calculatedAverageScore, 'Will save as:', updatePayload.average_score);
        console.log('Calculated passing status:', passingStatus);
        console.log('Calculated error counts - Critical:', criticalTotal, 'Critical Fail:', criticalFailTotal, 'Significant:', significantTotal);
        
        // Add parameter comments (always include, even if empty, to ensure comments are saved)
        // Comments should be saved even if error count is 0
        updatePayload.parameter_comments = mergedComments;
        
        // Helper function to retry database operations on schema cache errors
        async function retryOnSchemaCacheError(operation, maxRetries = 3) {
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                if (attempt > 0) {
                    // Wait longer on each retry (exponential backoff)
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
                
                const result = await operation();
                
                // If no error, return success
                if (!result.error) {
                    return result;
                }
                
                // If it's a schema cache error, retry
                if (result.error.message && result.error.message.includes('schema cache')) {
                    continue;
                }
                
                // If it's not a schema cache error, return immediately
                return result;
            }
            
            // Return last result after all retries exhausted
            return await operation();
        }
        
        // Update in Supabase with retry logic for schema cache errors
        const { data, error } = await retryOnSchemaCacheError(async () => {
            return await window.supabaseClient
                .from(tableName)
                .update(updatePayload)
                .eq('id', auditId)
                .select();
        });
        
        if (error) {
            console.error('Error saving audit:', error);
            throw error;
        }
        
        // Show success message
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Success',
                message: '✓ Audit changes saved successfully!',
                confirmText: 'OK',
                type: 'success'
            });
        } else {
            alert('✓ Audit changes saved successfully!');
        }
        
        // Redirect to audit-view.html to see the changes
        // Use the already-declared variables from the beginning of the function
        const scorecardId = urlParams.get('scorecard');
        
        if (auditId && scorecardId && tableName) {
            window.location.href = `audit-view.html?id=${auditId}&scorecard=${scorecardId}&table=${tableName}`;
        } else {
            // Fallback to reload if parameters are missing
            location.reload();
        }
        
    } catch (error) {
        console.error('Error saving audit changes:', error);
        alert('Error saving audit changes: ' + error.message);
    }
}

// Delete Audit Function
async function deleteCurrentAudit() {
    // Verify that current user is the auditor
    if (!isCurrentUserAuditor()) {
        if (window.confirmationDialog) {
            await window.confirmationDialog.show({
                title: 'Access Denied',
                message: 'Only the auditor who created this audit can delete it.',
                confirmText: 'OK',
                type: 'error'
            });
        } else {
            alert('Only the auditor who created this audit can delete it.');
        }
        return;
    }
    
    if (!currentAudit || !currentTableName) {
        alert('Error: Audit data not loaded');
        return;
    }
    
    // Show confirmation dialog
    const confirmed = await window.confirmationDialog.show({
        title: 'Delete Audit?',
        message: `Are you sure you want to delete this audit?\n\nEmployee: ${currentAudit.employeeName || currentAudit.employee_name || 'Unknown'}\nInteraction ID: ${currentAudit.interactionId || currentAudit.interaction_id || 'N/A'}\n\nThis action cannot be undone. The audit will be permanently deleted and any related assignments will be reset to pending.`,
        confirmText: 'Delete',
        cancelText: 'Cancel',
        type: 'warning'
    });
    
    if (!confirmed) return;
    
    try {
        const auditId = currentAudit.id;
        
        // First, find and update audit_assignments that reference this audit
        const { data: assignments, error: assignmentsError } = await window.supabaseClient
            .from('audit_assignments')
            .select('id')
            .eq('audit_id', auditId);
        
        if (assignmentsError) {
            console.error('Error finding audit assignments:', assignmentsError);
            // Continue with deletion even if we can't find assignments
        } else if (assignments && assignments.length > 0) {
            // Update all assignments to pending status
            const assignmentIds = assignments.map(a => a.id);
            const { error: updateError } = await window.supabaseClient
                .from('audit_assignments')
                .update({
                    status: 'pending',
                    completed_at: null,
                    audit_id: null
                })
                .in('id', assignmentIds);
            
            if (updateError) {
                console.error('Error updating audit assignments:', updateError);
                // Continue with deletion even if update fails
            } else {
                console.log(`Updated ${assignmentIds.length} assignment(s) to pending status`);
            }
        }
        
        // Delete the audit from the table
        const { error: deleteError } = await window.supabaseClient
            .from(currentTableName)
            .delete()
            .eq('id', auditId);
        
        if (deleteError) {
            throw deleteError;
        }
        
        // Show success message
        await window.confirmationDialog.show({
            title: 'Success!',
            message: 'Audit deleted successfully. Any related assignments have been reset to pending status.',
            confirmText: 'OK',
            type: 'success'
        });
        
        // Redirect to expert-audits page or go back
        window.location.href = 'expert-audits.html';
        
    } catch (error) {
        console.error('Error deleting audit:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to delete audit: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

</script>

    <!-- Image Viewer Modal -->
    <div id="imageViewerModal" tabindex="0" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 10000; align-items: center; justify-content: center; cursor: pointer;" onclick="if(event.target.id === 'imageViewerModal') closeImageViewer();" onkeydown="if(event.key === 'Escape') closeImageViewer(); if(event.key === 'ArrowLeft') navigateImage('prev'); if(event.key === 'ArrowRight') navigateImage('next');">
        <!-- Close Button -->
        <button id="imageViewerClose" onclick="closeImageViewer(); event.stopPropagation();" style="position: absolute; top: 1rem; right: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 2.5rem; height: 2.5rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Close (Esc)">
            ×
        </button>
        
        <!-- Previous Button -->
        <button id="imageViewerPrev" onclick="navigateImage('prev'); event.stopPropagation();" style="position: absolute; left: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 3rem; height: 3rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Previous (←)">
            ‹
        </button>
        
        <!-- Next Button -->
        <button id="imageViewerNext" onclick="navigateImage('next'); event.stopPropagation();" style="position: absolute; right: 1rem; background: rgba(255, 255, 255, 0.2); border: none; color: white; width: 3rem; height: 3rem; border-radius: 50%; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; transition: background 0.2s ease; z-index: 10001;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'" title="Next (→)">
            ›
        </button>
        
        <!-- Image Counter -->
        <div id="imageViewerCounter" style="position: absolute; bottom: 1rem; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); color: white; padding: 0.5rem 1rem; border-radius: 1.5rem; font-size: 0.875rem; font-family: 'Poppins', sans-serif; z-index: 10001;">
            1 / 1
        </div>
        
        <!-- Image Container -->
        <div style="max-width: 95%; max-height: 95%; display: flex; align-items: center; justify-content: center;" onclick="event.stopPropagation();">
            <img id="imageViewerImg" src="" alt="Conversation image" style="max-width: 100%; max-height: 90vh; object-fit: contain; border-radius: 0.5rem; box-shadow: 0 0.5rem 2rem rgba(0,0,0,0.5);">
        </div>
    </div>

</body>
</html>