<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Create Audit | QMS</title>
<meta name="description" content="Quality Management System Dashboard">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="access-control.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="load-sidebar.js"></script>
    <script src="search.js"></script>
    <script src="form-validation.js"></script>
    <script src="timezone-utils.js"></script>
    <script src="date-filter-utils.js"></script>
    <style>
        .header-actions {
            display: flex;
            gap: 0.5625rem;
            flex-wrap: wrap;
            align-items: center;
            width: 100%;
            max-width: 100%;
        }

        .action-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.4688rem 0.75rem;
            background-color: var(--background-white);
            color: var(--text-color);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            font-size: 0.6562rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-family);
        }

        .action-btn:hover {
            background-color: var(--gray-50);
            border-color: var(--primary-color);
        }

        .action-btn.active {
            background-color: var(--primary-color);
            color: var(--white);
            border-color: var(--primary-color);
        }

        .action-btn svg {
            width: 0.75rem;
            height: 0.75rem;
        }

        /* Date Range Picker */
        .date-picker-dropdown {
            position: relative;
            display: inline-block;
        }

        .date-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.375rem;
            background: var(--background-white);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            box-shadow: var(--shadow-lg);
            padding: 0.75rem;
            z-index: 1000;
            min-width: 9.8438rem;
        }

        .date-dropdown-menu.active {
            display: block;
        }

        /* Filter Dropdown */
        .filter-dropdown {
            position: relative;
            display: inline-block;
        }

        .filter-dropdown-menu {
            display: none;
            position: absolute;
            top: calc(100% + 0.375rem);
            left: 0;
            background: var(--background-white);
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.375rem;
            box-shadow: var(--shadow-lg);
            padding: 0.75rem;
            z-index: 1000;
            min-width: 20rem;
            max-width: 90vw;
        }

        .filter-dropdown-menu.active {
            display: block;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.375rem;
        }

        .filter-label {
            font-size: 0.5625rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .filter-input, .filter-select {
            padding: 0.375rem 0.5625rem;
            border: 0.0469rem solid var(--border-light);
            border-radius: 0.2812rem;
            font-size: 0.6562rem;
            font-family: var(--font-family);
            background-color: var(--background-white);
            color: var(--text-color);
        }

        .filter-input:focus, .filter-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        
        /* Loading animation */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Smooth transitions for stat cards */
        #statsContainer > div {
            transition: opacity 0.3s ease;
        }
        
        /* Smooth transitions for table updates */
        #performanceTableBody {
            transition: opacity 0.2s ease;
        }
    </style>

</head>

<body>
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
 <main class="main-content" role="main">
    <p class="page-heading">Auditors' Dashboard</p>
    <div style="margin-bottom: 1.125rem; width: 100%;"></div>

        
            <!-- Tab Navigation -->
            <div style="position: relative; display: flex; background-color: var(--dark-forest); border-radius: 0.4688rem; overflow: hidden; width: 100%; max-width: 15rem; margin: 0.9375rem auto; padding: 0.2344rem; margin-top: 2rem;">
                <div style="position: absolute; top: 0.2344rem; height: calc(100% - 0.4688rem); background-color: var(--primary-color); border-radius: 0.2344rem; transition: all 0.3s ease; left: 0.2344rem; width: calc(50% - 0.2344rem);"></div>
                <button style="flex: 1; padding: 0.375rem 0.75rem; text-align: center; cursor: pointer; background: none; border: none; color: #ffffff; font-weight: 700; transition: color 0.2s ease; z-index: 2; position: relative; font-family: var(--font-family); font-size: .6rem;" class="active" onclick="switchTab(this, 0)">Team Stats</button>
                <button style="flex: 1; padding: 0.375rem 0.75rem; text-align: center; cursor: pointer; background: none; border: none; color: #ffffff; font-weight: 700; transition: color 0.2s ease; z-index: 2; position: relative; font-family: var(--font-family); font-size: .6rem;" onclick="switchTab(this, 1)">Standup View</button>
            </div>

    <!-- Action Buttons -->
    <div class="header-actions" style="margin-top: 1.125rem; margin-bottom: 1.125rem; justify-content: center;">
        <!-- Week Navigation -->
        <div style="display: flex; align-items: center; gap: 0.5625rem;">
            <button class="action-btn" id="prevWeekBtn" style="padding: 0.4688rem 0.5625rem;" title="Previous Week">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.75rem; height: 0.75rem;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
            </button>
            <div class="action-btn" id="weekDisplay" style="padding: 0.4688rem 0.75rem; cursor: default; background-color: var(--primary-color); color: var(--white); border-color: var(--primary-color);">
                <span id="weekText">Week -</span>
            </div>
            <button class="action-btn" id="nextWeekBtn" style="padding: 0.4688rem 0.5625rem;" title="Next Week">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 0.75rem; height: 0.75rem;">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
            </button>
        </div>
        <!-- Date Range Picker -->
        <div class="date-picker-dropdown">
            <button class="action-btn" id="dateBtn">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                </svg>
                <span id="dateBtnText">Date Range</span>
                <svg style="width: 0.5625rem; height: 0.5625rem;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div class="date-dropdown-menu" id="dateDropdown">
                <div class="filter-group">
                    <label class="filter-label">Start Date</label>
                    <input type="date" class="filter-input" id="startDate">
                </div>
                <div class="filter-group">
                    <label class="filter-label">End Date</label>
                    <input type="date" class="filter-input" id="endDate">
                </div>
                <div style="display: flex; gap: 0.375rem; margin-top: 0.375rem;">
                    <button class="action-btn" style="flex: 1;" onclick="applyDateFilter()">Apply</button>
                    <button class="action-btn" style="flex: 1;" onclick="clearDateFilter()">Clear</button>
                </div>
            </div>
        </div>
        <!-- Quick Date Filters -->
        <div style="display: flex; align-items: center; gap: 0.375rem;">
            <button class="action-btn quick-date-btn active" id="todayBtn" onclick="applyQuickDateFilter('today')">Today</button>
            <button class="action-btn quick-date-btn" id="yesterdayBtn" onclick="applyQuickDateFilter('yesterday')">Yesterday</button>
            <button class="action-btn quick-date-btn" id="thisMonthBtn" onclick="applyQuickDateFilter('thisMonth')">This Month</button>
        </div>
        <div class="filter-dropdown">
            <button class="action-btn" id="filterBtn">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"></path>
                </svg>
                <span>Filter</span>
            </button>
            <!-- Filter Dropdown Menu -->
            <div class="filter-dropdown-menu" id="filterDropdown">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5625rem; padding-bottom: 0.375rem; border-bottom: 0.0469rem solid #e5e7eb;">
                    <div style="font-size: 0.6562rem; font-weight: 600; color: #1A733E;">Filters</div>
                    <button onclick="clearFilters()" style="padding: 0.2812rem 0.5625rem; background-color: #f9fafb; color: #374151; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif; cursor: pointer;">Clear All</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(8rem, 1fr)); gap: 0.75rem;">
                    <!-- Status Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Status</label>
                        <select class="filter-input" id="statusFilter" onchange="applyFilters()">
                            <option value="">All Statuses</option>
                            <option value="pending">Pending</option>
                            <option value="in_progress">In Progress</option>
                            <option value="completed">Completed</option>
                        </select>
                    </div>
                    <!-- Channel Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Channel</label>
                        <select class="filter-input" id="channelFilter" onchange="applyFilters()">
                            <option value="">All Channels</option>
                        </select>
                    </div>
                    <!-- Auditor Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Auditor</label>
                        <select class="filter-input" id="auditorFilter" onchange="applyFilters()">
                            <option value="">All Auditors</option>
                        </select>
                    </div>
                    <!-- Employee Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Employee</label>
                        <select class="filter-input" id="employeeFilter" onchange="applyFilters()">
                            <option value="">All Employees</option>
                        </select>
                    </div>
                    <!-- Scorecard Filter -->
                    <div class="filter-group">
                        <label class="filter-label">Scorecard</label>
                        <select class="filter-input" id="scorecardFilter" onchange="applyFilters()">
                            <option value="">All Scorecards</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

            <!-- stat Cards -->
            <div id="statsContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(9rem, 1fr)); gap: 1.125rem; margin-bottom: 1.5rem; width: 100%;">
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div id="stat1Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">Assigned</div>
                    <div id="stat1Count" style="font-size: 2.625rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">Completed</div>
                    <div style="display: flex; align-items: baseline; gap: 0.375rem; margin-bottom: 0.1875rem;">
                        <div id="completedCount" style="font-size: 2.625rem; font-weight: 700;">-</div>
                        <div id="backlogCountText" style="font-size: 0.5625rem; opacity: 0.85; font-weight: 500;"></div>
                    </div>
                    <div id="targetAchieved" style="font-size: 0.5625rem; opacity: 0.9; margin-top: 0.1875rem;">-</div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">Remaining</div>
                    <div id="remainingCount" style="font-size: 2.625rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div id="stat4Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">In Progress</div>
                    <div id="stat4Count" style="font-size: 2.625rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                    <div id="stat4Subtitle" style="font-size: 0.5625rem; opacity: 0.9; margin-top: 0.1875rem;">-</div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div id="stat5Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">Reversal Rate</div>
                    <div id="stat5Count" style="font-size: 2.625rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                    <div id="stat5Subtitle" style="font-size: 0.5625rem; opacity: 0.9; margin-top: 0.1875rem;"></div>
                </div>
                <div style="background-color: var(--dark-forest); color: var(--white); padding: 0.75rem; border-radius: 0.5625rem; text-align: left; box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1); min-height: 4.5rem; display: flex; flex-direction: column; justify-content: center;">
                    <div id="stat6Label" style="font-size: 0.6562rem; font-weight: 600; text-transform: uppercase; margin-bottom: 0.0938rem;">Avg Duration</div>
                    <div id="stat6Count" style="font-size: 1.875rem; font-weight: 700; margin-bottom: 0.1875rem;">-</div>
                    <div id="stat6Subtitle" style="font-size: 0.5625rem; opacity: 0.9; margin-top: 0.1875rem;">-</div>
                </div>
            </div>


            <!-- Data Table -->
            <div id="performanceTable" style="background-color: var(--white); border-radius: 0.5625rem; box-shadow: 0 0.0469rem 0.1406rem 0 rgba(0, 0, 0, 0.1); overflow: hidden; max-width: 80%; width: fit-content; min-width: 100%;">
                <div style="background-color: #f8f9fa; padding: 0.5625rem 0.75rem; border-bottom: 0.0469rem solid #e5e7eb;">
                    <h3 style="font-size: 0.8438rem; font-weight: 600; color: var(--text-color);">Progress Overview</h3>
                </div>
                <div style="padding: 0.75rem; overflow-x: auto;">
                    <div id="tableHeader" style="display: grid; grid-template-columns: minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(4.5rem, 1.2fr) minmax(7.0312rem, 2fr); gap: 0.75rem; align-items: center; padding: 0.375rem 0 0.5625rem 0; font-weight: 700; font-size: 0.6562rem; color: var(--text-color); text-transform: uppercase; letter-spacing: 0.05em; min-width: fit-content;">
                        <div>Name</div>
                        <div style="text-align: center;">Assigned</div>
                        <div style="text-align: center;">Completed</div>
                        <div style="text-align: center;">Remaining</div>
                        <div style="text-align: center;">Avg Duration</div>
                        <div style="text-align: center;">Progress Meter</div>
                    </div>
                    <div id="performanceTableBody" style="min-width: fit-content;">
                        <div style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</main>


<script>
// ============================================================================
// Global Variables
// ============================================================================
let currentTab = 0; // 0 = Team Stats, 1 = Standup View (removed Your Stats)
let allAssignments = [];
let unfilteredAssignments = []; // Store unfiltered data
let currentUserEmail = '';
let allUsers = [];
let currentFilters = {
    status: '',
    channel: '',
    auditor: '',
    employee: '',
    scorecard: ''
};
let allScorecards = [];
let cachedScorecardTables = []; // Cache scorecard table names to avoid repeated queries
let currentWeek = null;
let currentWeekYear = null;
let dateFilter = { start: null, end: null };
let useWeekFilter = false; // Default to month view instead of week view
let presenceChannel = null;
let onlineAuditors = new Set(); // Track online auditor emails
let heartbeatInterval = null;
let isInitialLoad = true; // Track if this is the first load
let isLoading = false; // Track if data is currently loading
let renderInProgress = false; // Prevent duplicate renders
let loadingTimeout = null; // Track loading timeout

// ============================================================================
// Initialize Page
// ============================================================================
document.addEventListener('DOMContentLoaded', async function() {
    // Check page access using centralized access control
    if (!window.accessControl || !window.accessControl.enforcePageAccess('auditor-dashboard.html')) {
        return; // Access denied, user will be redirected
    }
    
    await initializeDashboard();
    initializeSlider();
});

async function initializeDashboard() {
    try {
        // Show initial loading state
        showLoadingState();
        
        // Wait for Supabase to be ready
        let attempts = 0;
        while (!window.supabaseClient && attempts < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }

        if (!window.supabaseClient) {
            console.error('Supabase client not initialized');
            hideLoadingState();
            return;
        }

        // Get current user
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        currentUserEmail = userInfo.email;

        if (!currentUserEmail) {
            console.error('No user logged in');
            hideLoadingState();
            return;
        }

        // Initialize today filter (default view)
        initializeTodayFilter();
        setupEventListeners();

        // Load all data in parallel for faster initialization
        await Promise.all([
            loadAllUsers(),
            loadScorecards(),
            loadAssignments()
        ]);
        
        // Setup presence tracking after everything is loaded
        await setupPresenceTracking();
        
        // Mark initial load as complete after a short delay to ensure all renders are done
        setTimeout(() => {
            isInitialLoad = false;
        }, 500);
        
        // Hide loading state
        hideLoadingState();
        
    } catch (error) {
        console.error('Error initializing dashboard:', error);
        hideLoadingState();
    }
}

// Get current period dates (week or date range) in Dhaka timezone
function getCurrentPeriodDates() {
    if (dateFilter.start || dateFilter.end) {
        // Using date range filter
        // dateFilter.start and dateFilter.end are stored as date strings (YYYY-MM-DD format)
        return {
            start: dateFilter.start ? getDhakaStartOfDay(parseDhakaDate(dateFilter.start)) : new Date(0),
            end: dateFilter.end ? getDhakaEndOfDay(parseDhakaDate(dateFilter.end)) : getDhakaNow()
        };
    } else if (useWeekFilter && currentWeek !== null) {
        // Using week filter
        return getDhakaWeekDates(currentWeek, currentWeekYear);
    } else {
        // Default to today in Dhaka timezone
        const today = getDhakaNow();
        return {
            start: getDhakaStartOfDay(today),
            end: getDhakaEndOfDay(today)
        };
    }
}

// ============================================================================
// Helper Functions for Parallelized Queries
// ============================================================================
// Helper to convert audit duration to minutes
function convertDurationToMinutes(duration) {
    if (!duration) return 0;
    
    let durationInMinutes = 0;
    if (typeof duration === 'number') {
        // If value is >= 1440 (24 hours in minutes), assume it's in seconds (new format)
        // Otherwise, assume it's already in minutes (legacy format)
        if (duration >= 1440) {
            durationInMinutes = duration / 60; // Convert seconds to minutes
        } else {
            durationInMinutes = duration; // Already in minutes
        }
    } else if (typeof duration === 'string') {
        const asInt = parseInt(duration);
        if (!isNaN(asInt)) {
            if (asInt >= 1440) {
                durationInMinutes = asInt / 60; // Convert seconds to minutes
            } else {
                durationInMinutes = asInt; // Already in minutes
            }
        }
    }
    return durationInMinutes;
}

// Helper to format duration text
function formatDurationText(avgDurationMinutes) {
    if (avgDurationMinutes <= 0) return '-';
    
    if (avgDurationMinutes >= 60) {
        const hours = Math.floor(avgDurationMinutes / 60);
        const minutes = Math.round(avgDurationMinutes % 60);
        return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
    } else {
        return `${Math.round(avgDurationMinutes)}m`;
    }
}

// Helper to add date filter to query (converts Dhaka dates to UTC for database)
function addDateFilter(query, period) {
    if (!period || (!period.start && !period.end)) return query;
    
    if (period.start && period.end) {
        return query.gte('submitted_at', dhakaDateToUTCISO(period.start))
                    .lte('submitted_at', dhakaDateToUTCISO(period.end));
    } else if (period.start) {
        return query.gte('submitted_at', dhakaDateToUTCISO(period.start));
    } else if (period.end) {
        return query.lte('submitted_at', dhakaDateToUTCISO(period.end));
    }
    return query;
}

// ============================================================================
// Load Data
// ============================================================================
async function loadAllUsers() {
    try {
        // Use sessionStorage cache for users (5 minutes cache, same as home.html)
        const cachedUsers = sessionStorage.getItem('cachedUsers');
        const cachedUsersTime = sessionStorage.getItem('cachedUsersTime');
        const cacheAge = cachedUsersTime ? Date.now() - parseInt(cachedUsersTime) : Infinity;
        
        if (cachedUsers && cacheAge < 300000) { // 5 minutes cache
            allUsers = JSON.parse(cachedUsers);
            console.log(`Loaded ${allUsers.length} users from cache`);
        } else {
            const { data, error } = await window.supabaseClient
                .from('users')
                .select('email, name, role, channel, quality_mentor')
                .eq('is_active', true);
            
            if (error) throw error;
            
            allUsers = data || [];
            console.log(`Loaded ${allUsers.length} users`);
            
            // Cache users in sessionStorage
            sessionStorage.setItem('cachedUsers', JSON.stringify(allUsers));
            sessionStorage.setItem('cachedUsersTime', Date.now().toString());
        }
        
    } catch (error) {
        console.error('Error loading users:', error);
        allUsers = [];
    }
}

async function loadScorecards() {
    try {
        // Always fetch fresh data
        const { data, error } = await window.supabaseClient
            .from('scorecards')
            .select('id, name, table_name')
            .eq('is_active', true)
            .order('name', { ascending: true });
        
        if (error) throw error;
        
        allScorecards = data || [];
        cachedScorecardTables = allScorecards.map(s => s.table_name).filter(Boolean);
        
        // Update UI with fresh data
        console.log('Updating UI with fresh scorecards');
        populateScorecardFilter();
        
    } catch (error) {
        console.error('Error loading scorecards:', error);
        allScorecards = [];
        cachedScorecardTables = [];
    }
}

async function loadAssignments() {
    try {
        const period = getCurrentPeriodDates();
        
        // Show loading if initial load
        if (isInitialLoad) {
            showLoadingState();
        }
        // Populate filters with empty data so UI is ready
        populateChannelFilter();
        populateAuditorFilter();
        populateEmployeeFilter();
        
        // Always fetch fresh data
        await fetchAndCacheAssignments(period);
        
    } catch (error) {
        console.error('Error loading assignments:', error);
        allAssignments = [];
        unfilteredAssignments = [];
        hideLoadingState();
    }
}

async function fetchAndCacheAssignments(period) {
    try {
        // Prevent duplicate fetches
        if (isLoading) {
            return;
        }
        isLoading = true;
        
        let assignmentsQuery = window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .eq('auditor_email', currentUserEmail)
            .order('created_at', { ascending: false });
        
        // Apply date filters server-side if possible (convert Dhaka to UTC)
        if (period && period.start) {
            assignmentsQuery = assignmentsQuery.gte('created_at', dhakaDateToUTCISO(period.start));
        }
        if (period && period.end) {
            assignmentsQuery = assignmentsQuery.lte('created_at', dhakaDateToUTCISO(period.end));
        }
        
        let { data, error } = await assignmentsQuery;
        
        // If server-side date filter fails, try without date filter and filter client-side
        if (error && period && (period.start || period.end)) {
            console.warn('Server-side date filter failed, falling back to client-side filtering:', error);
            const retryResult = await window.supabaseClient
                .from('audit_assignments')
                .select('*')
                .eq('auditor_email', currentUserEmail)
                .order('created_at', { ascending: false });
            
            if (retryResult.data && period && period.start) {
                retryResult.data = retryResult.data.filter(assignment => {
                    if (!assignment.created_at) return false;
                        const assignmentDate = toDhakaTime(assignment.created_at);
                    return (!period.start || assignmentDate >= period.start) && 
                           (!period.end || assignmentDate <= period.end);
                });
            }
            data = retryResult.data;
            error = retryResult.error;
        }
        
        if (error) throw error;
        
        allAssignments = data || [];
        unfilteredAssignments = [...allAssignments]; // Store unfiltered copy
        console.log(`Loaded ${allAssignments.length} assignments`);
        
        // Populate filters
        populateChannelFilter();
        populateAuditorFilter();
        populateEmployeeFilter();
        
        // Update UI with fresh data
        console.log('Updating UI with fresh assignments');
        await updateDashboard();
        
        isLoading = false;
        
    } catch (error) {
        console.error('Error fetching assignments:', error);
        allAssignments = [];
        unfilteredAssignments = [];
        isLoading = false;
        hideLoadingState();
    }
}

// ============================================================================
// Update Dashboard
// ============================================================================
async function updateDashboard() {
    // Prevent duplicate updates
    if (renderInProgress) {
        return;
    }
    
    renderInProgress = true;
    
    try {
        if (currentTab === 0) {
            // Team Stats
            await updateTeamStats();
        } else if (currentTab === 1) {
            // Standup View
            await updateStandupView();
        }
    } finally {
        // Use a small delay to prevent rapid re-renders
        setTimeout(() => {
            renderInProgress = false;
        }, 100);
    }
}

// Note: updateYourStats() function has been moved to create-audit.html

async function updateTeamStats() {
    // Only proceed if we're still on Team Stats tab
    if (currentTab !== 0) {
        return;
    }
    
    const period = getCurrentPeriodDates();
    
    // Show loading if initial load
    if (isInitialLoad) {
        showLoadingState();
    }
    
    // Always fetch fresh data
    await fetchAndCacheTeamStats(period);
}

async function fetchAndCacheTeamStats(period) {
    try {
        // Ensure allUsers is loaded
        if (!allUsers || allUsers.length === 0) {
            console.warn('Users not loaded yet, waiting...');
            await loadAllUsers();
        }
        
        // Get all Quality Analysts (auditors)
        const qualityAnalysts = allUsers.filter(u => u.role === 'Quality Analyst');
        
        if (qualityAnalysts.length === 0) {
            const tableBody = document.getElementById('performanceTableBody');
            tableBody.innerHTML = `
                <div style="text-align: center; padding: 1.5rem; color: #6b7280;">
                    No Quality Analysts found in the system.
                </div>
            `;
            
            // Reset stats
            document.getElementById('stat1Label').textContent = 'ASSIGNED';
            document.getElementById('stat1Count').textContent = '0';
            document.getElementById('completedCount').textContent = '0';
            document.getElementById('targetAchieved').textContent = '-';
            document.getElementById('remainingCount').textContent = '0';
            document.getElementById('stat4Label').textContent = 'IN PROGRESS';
            document.getElementById('stat4Count').textContent = '0';
            document.getElementById('stat4Subtitle').textContent = '-';
            document.getElementById('stat5Label').textContent = 'REVERSAL RATE';
            document.getElementById('stat5Count').textContent = '0';
            hideLoadingState();
            return;
        }
        
        // Load all assignments for all Quality Analysts with date filtering
        // Note: period is already passed as a parameter to this function
            let assignmentsQuery = window.supabaseClient
                .from('audit_assignments')
                .select('*')
                .in('auditor_email', qualityAnalysts.map(qa => qa.email))
                .order('created_at', { ascending: false });
            
            // Apply date filters server-side if possible (convert Dhaka to UTC)
            if (period.start) {
                assignmentsQuery = assignmentsQuery.gte('created_at', dhakaDateToUTCISO(period.start));
            }
            if (period.end) {
                assignmentsQuery = assignmentsQuery.lte('created_at', dhakaDateToUTCISO(period.end));
            }
            
            let { data, error } = await assignmentsQuery;
            
            // If server-side date filter fails, try without date filter and filter client-side
            if (error && period && (period.start || period.end)) {
                console.warn('Server-side date filter failed, falling back to client-side filtering:', error);
                const retryResult = await window.supabaseClient
                    .from('audit_assignments')
                    .select('*')
                    .in('auditor_email', qualityAnalysts.map(qa => qa.email))
                    .order('created_at', { ascending: false });
                
                if (retryResult.data && period.start) {
                    retryResult.data = retryResult.data.filter(assignment => {
                        if (!assignment.created_at) return false;
                        const assignmentDate = toDhakaTime(assignment.created_at);
                        return (!period.start || assignmentDate >= period.start) && 
                               (!period.end || assignmentDate <= period.end);
                    });
                }
                data = retryResult.data;
                error = retryResult.error;
            }
            
            if (error) throw error;
            
            const teamAssignments = data || [];
        
        // Calculate overall team stats
        const totalAssigned = teamAssignments.length;
        const inProgress = teamAssignments.filter(a => a.status === 'in_progress').length;
        const pending = teamAssignments.filter(a => a.status === 'pending').length;
        const remaining = pending + inProgress;
        
        // Calculate team average audit duration and reversal count in parallel
        let avgDurationText = '-';
        let avgDurationSubtitle = 'per audit';
        let teamReversalCount = 0;
        let completed = 0; // Will be calculated from scorecard tables
        
        try {
            // Ensure scorecards are loaded
            if (!cachedScorecardTables || cachedScorecardTables.length === 0) {
                await loadScorecards();
            }
            
            // Discover all audit tables using get_audit_tables RPC (matching expert-audits.html)
            let tablesToQuery = [];
            try {
                const { data: allTables, error: tablesError } = await window.supabaseClient.rpc('get_audit_tables');
                
                if (!tablesError && allTables && allTables.length > 0) {
                    // Filter out ai_analysis_results and calibration_results and map to table names
                    tablesToQuery = allTables
                        .filter(t => t.table_name !== 'ai_analysis_results' && t.table_name !== 'calibration_results')
                        .map(t => t.table_name);
                } else {
                    // Fallback: use scorecard tables
                    tablesToQuery = cachedScorecardTables.length > 0 
                ? cachedScorecardTables 
                : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
                }
            } catch (rpcError) {
                console.warn('RPC get_audit_tables failed, using scorecard-based loading:', rpcError);
                // Fallback: use scorecard tables
                tablesToQuery = cachedScorecardTables.length > 0 
                    ? cachedScorecardTables 
                    : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
            }
            
            if (tablesToQuery.length > 0) {
                // Parallelize all audit table queries
                const queryPromises = tablesToQuery.map(async (tableName) => {
                    try {
                        // Build queries with date filters (count all audits, not just Quality Analysts)
                        let durationQuery = window.supabaseClient
                            .from(tableName)
                            .select('audit_duration, submitted_at')
                            .not('audit_duration', 'is', null);
                        
                        let reversalQuery = window.supabaseClient
                            .from(tableName)
                            .select('id, submitted_at')
                            .not('reversal_requested_at', 'is', null);
                        
                        // Query to count completed audits (submitted in the period) - all audits regardless of auditor
                        // All audits in scorecard tables are completed by default (they have submitted_at)
                        let completedQuery = window.supabaseClient
                            .from(tableName)
                            .select('id, submitted_at')
                            .not('submitted_at', 'is', null);
                        
                        // Apply date filters server-side if possible (convert Dhaka to UTC)
                        if (period.start) {
                            durationQuery = durationQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            reversalQuery = reversalQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            completedQuery = completedQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                        }
                        if (period.end) {
                            durationQuery = durationQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            reversalQuery = reversalQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            completedQuery = completedQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                        }
                        
                        // Query for duration, reversals, and completed audits in parallel for each table
                        const [durationResult, reversalResult, completedResult] = await Promise.all([
                            (async () => {
                                try {
                                    let result = await durationQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false; // Exclude if no date when filtering
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('audit_duration, submitted_at')
                                        .not('audit_duration', 'is', null);
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })(),
                            (async () => {
                                try {
                                    let result = await reversalQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('id, submitted_at')
                                        .not('reversal_requested_at', 'is', null);
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })(),
                            (async () => {
                                try {
                                    let result = await completedQuery;
                                    
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('id, submitted_at')
                                        .not('submitted_at', 'is', null);
                                    
                                    if (retryResult.data) {
                                        if (period && (period.start || period.end)) {
                                            retryResult.data = retryResult.data.filter(audit => {
                                                if (!audit.submitted_at) return false;
                                                const auditDate = toDhakaTime(audit.submitted_at);
                                                return (!period.start || auditDate >= period.start) && 
                                                       (!period.end || auditDate <= period.end);
                                            });
                                        }
                                    }
                                    return retryResult;
                                }
                            })()
                        ]);
                        
                        return {
                            durations: durationResult.data || [],
                            reversals: reversalResult.data || [],
                            completed: completedResult.data || []
                        };
                    } catch (err) {
                        console.warn(`Error querying ${tableName}:`, err);
                        return { durations: [], reversals: [], completed: [] };
                    }
                });
                
                const results = await Promise.all(queryPromises);
                
                // Aggregate results
                let totalDuration = 0;
                let auditCount = 0;
                
                results.forEach(result => {
                    result.durations.forEach(audit => {
                        const durationInMinutes = convertDurationToMinutes(audit.audit_duration);
                        if (durationInMinutes > 0) {
                            totalDuration += durationInMinutes;
                            auditCount++;
                        }
                    });
                    teamReversalCount += result.reversals.length;
                    // All audits in scorecard tables are completed by default (they have submitted_at)
                    completed += result.completed.length;
                });
                
                if (auditCount > 0) {
                    const avgDuration = totalDuration / auditCount;
                    avgDurationText = formatDurationText(avgDuration);
                }
            }
            // Note: completed count is always from scorecard tables, not assignments
            // If no scorecards exist, completed will remain 0
        } catch (error) {
            console.error('Error calculating team stats:', error);
            // completed count remains 0 if there's an error (always use scorecard tables)
        }
        
        const percentage = totalAssigned > 0 ? Math.round((completed / totalAssigned) * 100) : 0;
        console.log('Team Stats - Reversal count:', teamReversalCount);
        console.log('Team Stats - Completed count:', completed);
        
        // Ensure scorecards are loaded
        if (!cachedScorecardTables || cachedScorecardTables.length === 0) {
            await loadScorecards();
        }
        
        // Discover all audit tables using get_audit_tables RPC (matching expert-audits.html)
        let auditorTablesToQuery = [];
        try {
            const { data: allTables, error: tablesError } = await window.supabaseClient.rpc('get_audit_tables');
            
            if (!tablesError && allTables && allTables.length > 0) {
                // Filter out ai_analysis_results and calibration_results and map to table names
                auditorTablesToQuery = allTables
                    .filter(t => t.table_name !== 'ai_analysis_results' && t.table_name !== 'calibration_results')
                    .map(t => t.table_name);
            } else {
                // Fallback: use scorecard tables
                auditorTablesToQuery = cachedScorecardTables.length > 0 
            ? cachedScorecardTables 
            : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
            }
        } catch (rpcError) {
            console.warn('RPC get_audit_tables failed, using scorecard-based loading:', rpcError);
            // Fallback: use scorecard tables
            auditorTablesToQuery = cachedScorecardTables.length > 0 
                ? cachedScorecardTables 
                : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
        }
        
        // Parallelize all auditor duration queries
        const auditorDurationPromises = qualityAnalysts.map(async (qa) => {
            const qaAssignments = teamAssignments.filter(a => a.auditor_email === qa.email);
            const qaInProgress = qaAssignments.filter(a => a.status === 'in_progress').length;
            const qaPending = qaAssignments.filter(a => a.status === 'pending').length;
            const qaRemaining = qaPending + qaInProgress;
            
            // Calculate completed audits by querying scorecard tables (based on submitted_at, not created_at)
            let qaCompleted = 0;
            let avgDurationText = '-';
            try {
                if (auditorTablesToQuery.length > 0) {
                    const durationPromises = auditorTablesToQuery.map(async (tableName) => {
                        try {
                            // Build query with date filters for duration
                            let query = window.supabaseClient
                                .from(tableName)
                                .select('audit_duration, submitted_at')
                                .eq('auditor_email', qa.email)
                                .not('audit_duration', 'is', null);
                            
                            // Build query for completed audits count
                            // All audits in scorecard tables are completed by default (they have submitted_at)
                            let completedQuery = window.supabaseClient
                                .from(tableName)
                                .select('id, submitted_at')
                                .eq('auditor_email', qa.email)
                                .not('submitted_at', 'is', null);
                            
                            // Apply date filters server-side if possible (convert Dhaka to UTC)
                            if (period.start) {
                                query = query.gte('submitted_at', dhakaDateToUTCISO(period.start));
                                completedQuery = completedQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            }
                            if (period.end) {
                                query = query.lte('submitted_at', dhakaDateToUTCISO(period.end));
                                completedQuery = completedQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            }
                            
                            // Query both duration and completed audits in parallel
                            const [durationResult, completedResult] = await Promise.all([
                                query,
                                completedQuery
                            ]);
                            
                            // Check if error is due to missing auditor_email column - skip this table if so
                            // Only skip if error message specifically mentions auditor_email
                            if (durationResult.error) {
                                const errorMessage = durationResult.error.message || JSON.stringify(durationResult.error);
                                if (errorMessage.includes('auditor_email') && 
                                    (durationResult.error.code === '42703' || durationResult.error.code === 'PGRST116')) {
                                    console.warn(`Table ${tableName} does not have auditor_email column, skipping`);
                                    return { audits: [], completed: 0 };
                                }
                            }
                            
                            if (completedResult.error) {
                                const errorMessage = completedResult.error.message || JSON.stringify(completedResult.error);
                                if (errorMessage.includes('auditor_email') && 
                                    (completedResult.error.code === '42703' || completedResult.error.code === 'PGRST116')) {
                                    console.warn(`Table ${tableName} does not have auditor_email column, skipping`);
                                    return { audits: [], completed: 0 };
                                }
                            }
                            
                            let audits = durationResult.data;
                            let error = durationResult.error;
                            let completedAudits = completedResult.data || [];
                            
                            // If server-side date filter fails, try without date filter and filter client-side
                            if (error && period && (period.start || period.end)) {
                                const retryQuery = window.supabaseClient
                                    .from(tableName)
                                    .select('audit_duration, submitted_at')
                                    .eq('auditor_email', qa.email)
                                    .not('audit_duration', 'is', null);
                                
                                const retryCompletedQuery = window.supabaseClient
                                    .from(tableName)
                                    .select('id, submitted_at')
                                    .eq('auditor_email', qa.email)
                                    .not('submitted_at', 'is', null);
                                
                                const [retryResult, retryCompletedResult] = await Promise.all([
                                    retryQuery,
                                    retryCompletedQuery
                                ]);
                                
                                // Check if error is due to missing auditor_email column - skip this table if so
                                if (retryResult.error) {
                                    const retryErrorMessage = retryResult.error.message || JSON.stringify(retryResult.error);
                                    if (retryErrorMessage.includes('auditor_email') && 
                                        (retryResult.error.code === '42703' || retryResult.error.code === 'PGRST116')) {
                                        console.warn(`Table ${tableName} does not have auditor_email column, skipping`);
                                        return { audits: [], completed: 0 };
                                    }
                                }
                                if (retryCompletedResult.error) {
                                    const retryErrorMessage = retryCompletedResult.error.message || JSON.stringify(retryCompletedResult.error);
                                    if (retryErrorMessage.includes('auditor_email') && 
                                        (retryCompletedResult.error.code === '42703' || retryCompletedResult.error.code === 'PGRST116')) {
                                        console.warn(`Table ${tableName} does not have auditor_email column, skipping`);
                                        return { audits: [], completed: 0 };
                                    }
                                }
                                
                                if (retryResult.data && period.start) {
                                    retryResult.data = retryResult.data.filter(audit => {
                                        if (!audit.submitted_at) return false;
                                        const auditDate = toDhakaTime(audit.submitted_at);
                                        return (!period.start || auditDate >= period.start) && 
                                               (!period.end || auditDate <= period.end);
                                    });
                                }
                                
                                if (retryCompletedResult.data && period.start) {
                                    retryCompletedResult.data = retryCompletedResult.data.filter(audit => {
                                        if (!audit.submitted_at) return false;
                                        const auditDate = toDhakaTime(audit.submitted_at);
                                        return (!period.start || auditDate >= period.start) && 
                                               (!period.end || auditDate <= period.end);
                                    });
                                }
                                
                                audits = retryResult.data;
                                error = retryResult.error;
                                completedAudits = retryCompletedResult.data || [];
                            }
                            
                            if (error) {
                                // If duration query failed, still try to get completed count
                                if (completedResult.data) {
                                    // All audits in scorecard tables are completed by default (they have submitted_at)
                                    return { audits: [], completed: completedResult.data.length };
                                }
                                return { audits: [], completed: 0 };
                            }
                            
                            // Fallback client-side filtering if needed
                            let filteredAudits = audits || [];
                            let filteredCompleted = completedAudits || [];
                            
                            // Apply client-side date filtering if period exists
                            if (period && (period.start || period.end)) {
                                filteredAudits = filteredAudits.filter(audit => {
                                    if (!audit.submitted_at) return false;
                                    const auditDate = toDhakaTime(audit.submitted_at);
                                    return (!period.start || auditDate >= period.start) && 
                                           (!period.end || auditDate <= period.end);
                                });
                                
                                filteredCompleted = filteredCompleted.filter(audit => {
                                    if (!audit.submitted_at) return false;
                                    const auditDate = toDhakaTime(audit.submitted_at);
                                    return (!period.start || auditDate >= period.start) && 
                                           (!period.end || auditDate <= period.end);
                                });
                            }
                            
                            // All audits in scorecard tables are completed by default (they have submitted_at)
                            
                            return { audits: filteredAudits, completed: filteredCompleted.length };
                        } catch (err) {
                            console.warn(`Error getting duration from ${tableName} for ${qa.email}:`, err);
                            return { audits: [], completed: 0 };
                        }
                    });
                    
                    const allResults = await Promise.all(durationPromises);
                    const flatAudits = allResults.flatMap(r => r.audits);
                    const completedCounts = allResults.map(r => r.completed);
                    
                    // Sum up completed audits from all scorecard tables
                    qaCompleted = completedCounts.reduce((sum, count) => sum + count, 0);
                    
                    let totalDuration = 0;
                    let auditCount = 0;
                    
                    flatAudits.forEach(audit => {
                        const durationInMinutes = convertDurationToMinutes(audit.audit_duration);
                        if (durationInMinutes > 0) {
                            totalDuration += durationInMinutes;
                            auditCount++;
                        }
                    });
                    
                    if (auditCount > 0) {
                        const avgDuration = totalDuration / auditCount;
                        avgDurationText = formatDurationText(avgDuration);
                    }
                }
                // Note: qaCompleted count is always from scorecard tables, not assignments
                // If no scorecards exist, qaCompleted will remain 0
            } catch (error) {
                console.error(`Error calculating stats for ${qa.email}:`, error);
                // qaCompleted count remains 0 if there's an error (always use scorecard tables)
            }
            
            // Calculate backlog coverage (assignments created on one day but completed on another)
            // Filter by completed_at date (not created_at) to show backlog work completed in the selected period
            // Use Dhaka timezone for date comparison to match the rest of the dashboard
            let backlogCount = 0;
            let backlogDates = []; // Store dates when backlog audits were created
            try {
                // Fetch all completed assignments for this auditor, filtered by completed_at date
                let backlogQuery = window.supabaseClient
                    .from('audit_assignments')
                    .select('*')
                    .eq('auditor_email', qa.email)
                    .eq('status', 'completed')
                    .not('completed_at', 'is', null)
                    .not('created_at', 'is', null);
                
                // Filter by completed_at date (when the audit was completed, not when it was assigned)
                if (period.start) {
                    backlogQuery = backlogQuery.gte('completed_at', dhakaDateToUTCISO(period.start));
                }
                if (period.end) {
                    backlogQuery = backlogQuery.lte('completed_at', dhakaDateToUTCISO(period.end));
                }
                
                const { data: completedAssignments, error: backlogError } = await backlogQuery;
                
                if (!backlogError && completedAssignments) {
                    // Filter client-side to ensure accuracy with Dhaka timezone
                    const filteredCompleted = completedAssignments.filter(a => {
                        if (!a.completed_at) return false;
                        const completedDate = toDhakaTime(a.completed_at);
                        // Check if completed date falls within the period
                        const inPeriod = (!period.start || completedDate >= period.start) && 
                                        (!period.end || completedDate <= period.end);
                        if (!inPeriod) return false;
                        
                        // Check if created on a different day than completed (in Dhaka timezone)
                        if (!a.created_at) return false;
                        const createdDate = toDhakaTime(a.created_at);
                        const createdDay = formatDhakaDate(createdDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                        const completedDay = formatDhakaDate(completedDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                        return createdDay !== completedDay;
                    });
                    
                    backlogCount = filteredCompleted.length;
                    // Collect unique dates when backlog audits were created
                    backlogDates = [...new Set(filteredCompleted.map(a => {
                        const createdDate = toDhakaTime(a.created_at);
                        return formatDhakaDate(createdDate, { year: 'numeric', month: 'short', day: 'numeric' });
                    }))].sort();
                } else if (backlogError) {
                    // Fallback: filter from all assignments if query fails
                    const allCompleted = qaAssignments.filter(a => {
                        if (a.status !== 'completed' || !a.completed_at || !a.created_at) return false;
                        const completedDate = toDhakaTime(a.completed_at);
                        // Check if completed date falls within the period
                        const inPeriod = (!period.start || completedDate >= period.start) && 
                                        (!period.end || completedDate <= period.end);
                        if (!inPeriod) return false;
                        
                        // Check if created on a different day than completed
                        const createdDate = toDhakaTime(a.created_at);
                        const createdDay = formatDhakaDate(createdDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                        const completedDay = formatDhakaDate(completedDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                        return createdDay !== completedDay;
                    });
                    backlogCount = allCompleted.length;
                    backlogDates = [...new Set(allCompleted.map(a => {
                        const createdDate = toDhakaTime(a.created_at);
                        return formatDhakaDate(createdDate, { year: 'numeric', month: 'short', day: 'numeric' });
                    }))].sort();
                }
            } catch (error) {
                console.warn(`Error calculating backlog for ${qa.email}:`, error);
                // Fallback to simple calculation from qaAssignments
                const backlogItems = qaAssignments.filter(a => {
                    if (a.status !== 'completed' || !a.completed_at || !a.created_at) return false;
                    const createdDate = toDhakaTime(a.created_at);
                    const completedDate = toDhakaTime(a.completed_at);
                    const createdDay = formatDhakaDate(createdDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                    const completedDay = formatDhakaDate(completedDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                    return createdDay !== completedDay;
                });
                backlogCount = backlogItems.length;
                backlogDates = [...new Set(backlogItems.map(a => {
                    const createdDate = toDhakaTime(a.created_at);
                    return formatDhakaDate(createdDate, { year: 'numeric', month: 'short', day: 'numeric' });
                }))].sort();
            }
            
            // Exclude backlog audits from completed count
            // Completed count should only show same-day completions (not backlog)
            const sameDayCompleted = Math.max(0, qaCompleted - backlogCount);
            
            const qaPercentage = qaAssignments.length > 0 ? Math.round((sameDayCompleted / qaAssignments.length) * 100) : 0;
            
            return {
                name: qa.name || qa.email,
                email: qa.email,
                assigned: qaAssignments.length,
                completed: sameDayCompleted,
                remaining: qaRemaining,
                percentage: qaPercentage,
                avgDuration: avgDurationText,
                backlogCovered: backlogCount,
                backlogDates: backlogDates,
                isCurrentUser: qa.email === currentUserEmail
            };
        });
        
        const auditorStats = await Promise.all(auditorDurationPromises);
        
        // Sort by assigned count (descending) and then by name
        auditorStats.sort((a, b) => {
            if (b.assigned !== a.assigned) {
                return b.assigned - a.assigned;
            }
            return a.name.localeCompare(b.name);
        });
        
        // Calculate total backlog count from all auditors
        const totalBacklogCount = auditorStats.reduce((sum, auditor) => sum + (auditor.backlogCovered || 0), 0);
        
        // Exclude backlog audits from team completed count
        // Completed count should only show same-day completions (not backlog)
        const sameDayCompleted = Math.max(0, completed - totalBacklogCount);
        
        // Recalculate percentage based on same-day completed count
        const adjustedPercentage = totalAssigned > 0 ? Math.round((sameDayCompleted / totalAssigned) * 100) : 0;
        
        // Prepare the stats data
        const statsData = {
            totalAssigned,
            completed: sameDayCompleted,
            inProgress,
            pending,
            remaining,
            percentage: adjustedPercentage,
            avgDurationText,
            avgDurationSubtitle,
            teamReversalCount,
            totalBacklogCount,
            auditorStats,
            qualityAnalystsCount: qualityAnalysts.length
        };
        
        // Update UI with fresh data (only if still on Team Stats tab)
        if (currentTab === 0) {
            console.log('Updating UI with fresh team stats');
            renderTeamStats(statsData);
            // Update online status indicators after rendering
            setTimeout(() => updateOnlineStatusIndicators(), 100);
            hideLoadingState();
        } else {
            console.log('Skipping team stats render - user switched to tab', currentTab);
        }
        
    } catch (error) {
        console.error('Error loading team stats:', error);
        hideLoadingState();
        
        // Show error message in table
        const tableBody = document.getElementById('performanceTableBody');
        if (tableBody && currentTab === 0) {
            tableBody.innerHTML = `
                <div style="text-align: center; padding: 1.5rem; color: #ef4444;">
                    Error loading data. Please refresh the page.
                </div>
            `;
        }
        
        // Reset stats to default values
        try {
            document.getElementById('stat1Label').textContent = 'ASSIGNED';
            document.getElementById('stat1Count').textContent = '0';
            document.getElementById('completedCount').textContent = '0';
            document.getElementById('targetAchieved').textContent = '-';
            document.getElementById('remainingCount').textContent = '0';
            document.getElementById('stat4Label').textContent = 'IN PROGRESS';
            document.getElementById('stat4Count').textContent = '0';
            document.getElementById('stat4Subtitle').textContent = '-';
            document.getElementById('stat5Label').textContent = 'REVERSAL RATE';
            document.getElementById('stat5Count').textContent = '0';
        } catch (e) {
            // Ignore errors if elements don't exist
        }
    }
}

function renderTeamStats(statsData) {
    const {
        totalAssigned,
        completed,
        inProgress,
        remaining,
        percentage,
        avgDurationText,
        avgDurationSubtitle,
        teamReversalCount,
        totalBacklogCount,
        auditorStats,
        qualityAnalystsCount
    } = statsData;
    
    // Get all Quality Analysts (auditors)
    const qualityAnalysts = allUsers.filter(u => u.role === 'Quality Analyst');
    const qualityAnalystsLength = qualityAnalystsCount || qualityAnalysts.length;
    
    if (qualityAnalysts.length === 0) {
        const tableBody = document.getElementById('performanceTableBody');
        tableBody.innerHTML = `
            <div style="text-align: center; padding: 1.5rem; color: #6b7280;">
                No Quality Analysts found in the system.
            </div>
        `;
        
        // Reset stats
        document.getElementById('stat1Label').textContent = 'ASSIGNED';
        document.getElementById('stat1Count').textContent = '0';
        document.getElementById('completedCount').textContent = '0';
        document.getElementById('targetAchieved').textContent = '-';
        document.getElementById('remainingCount').textContent = '0';
        document.getElementById('stat4Label').textContent = 'IN PROGRESS';
        document.getElementById('stat4Count').textContent = '0';
        document.getElementById('stat4Subtitle').textContent = '-';
        document.getElementById('stat5Label').textContent = 'REVERSAL RATE';
        document.getElementById('stat5Count').textContent = '0';
        return;
    }
    
    // Show the 4th and 6th stat cards (in case they were hidden in standup view)
    const stat4Card = document.getElementById('stat4Count').closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat4Card) {
        stat4Card.style.display = 'flex';
        // Remove progress bar if it exists
        const progressBar = stat4Card.querySelector('.progress-bar-container');
        if (progressBar) progressBar.remove();
    }
    
    const stat6Card = document.getElementById('stat6Count').closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat6Card) {
        stat6Card.style.display = 'flex';
    }
    
    // Reset 3rd card label to REMAINING and remove progress bar
    const remainingCard = document.querySelector('#remainingCount').closest('div[style*="background-color: var(--dark-forest)"]');
    if (remainingCard) {
        const label = remainingCard.querySelector('div[style*="font-size: 0.6562rem"]');
        if (label) label.textContent = 'REMAINING';
        
        // Remove progress bar if it exists
        const progressBar = remainingCard.querySelector('.progress-bar-container');
        if (progressBar) progressBar.remove();
    }
    
    // Update stat cards with team stats
    document.getElementById('stat1Label').textContent = 'ASSIGNED';
    document.getElementById('stat1Count').textContent = totalAssigned;
    document.getElementById('completedCount').textContent = completed;
    
    // Update backlog count text next to completed count
    const backlogCountText = document.getElementById('backlogCountText');
    if (backlogCountText) {
        const backlogCount = totalBacklogCount || 0;
        if (backlogCount > 0) {
            backlogCountText.textContent = `+${backlogCount} Backlog`;
            backlogCountText.style.display = 'block';
        } else {
            backlogCountText.textContent = '';
            backlogCountText.style.display = 'none';
        }
    }
    
    document.getElementById('targetAchieved').textContent = `${percentage}% Team Target Achieved`;
    
    const remainingCount = document.getElementById('remainingCount');
    remainingCount.style.fontSize = '2.625rem';
    remainingCount.textContent = remaining;
    
    document.getElementById('stat4Label').textContent = 'IN PROGRESS';
    const stat4Count = document.getElementById('stat4Count');
    stat4Count.style.fontSize = '2.625rem';
    stat4Count.textContent = inProgress;
    document.getElementById('stat4Subtitle').textContent = `${qualityAnalystsLength} auditor${qualityAnalystsLength !== 1 ? 's' : ''}`;
    document.getElementById('stat5Label').textContent = 'REVERSAL RATE';
    document.getElementById('stat5Count').textContent = teamReversalCount;
    document.getElementById('stat5Subtitle').textContent = '';
    document.getElementById('stat6Label').textContent = 'AVG DURATION';
    document.getElementById('stat6Count').textContent = avgDurationText;
    document.getElementById('stat6Subtitle').textContent = avgDurationSubtitle;
    
    // Update table header
    const tableHeader = document.getElementById('tableHeader');
    tableHeader.style.gridTemplateColumns = 'minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(4.5rem, 1.2fr) minmax(7.0312rem, 2fr)';
    tableHeader.style.display = 'grid';
    tableHeader.style.gap = '0.75rem';
    tableHeader.style.alignItems = 'center';
    tableHeader.innerHTML = `
        <div>Name</div>
        <div style="text-align: center;">Assigned</div>
        <div style="text-align: center;">Completed</div>
        <div style="text-align: center;">Remaining</div>
        <div style="text-align: center;">Avg Duration</div>
        <div style="text-align: center;">Progress Meter</div>
    `;
    
    // Update table with all Quality Analysts
    const tableBody = document.getElementById('performanceTableBody');
    tableBody.innerHTML = auditorStats.map(stats => {
        // Build tooltip text for backlog
        let backlogTooltip = '';
        if (stats.backlogCovered > 0 && stats.backlogDates && stats.backlogDates.length > 0) {
            const datesText = stats.backlogDates.join(', ');
            backlogTooltip = `${stats.backlogCovered} backlog covered from ${datesText}`;
        }
        
        return `
        <div style="display: grid; grid-template-columns: minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(4.5rem, 1.2fr) minmax(7.0312rem, 2fr); gap: 0.75rem; align-items: center; padding: 0.375rem 0; border-bottom: 0.0469rem solid #f3f4f6; ${stats.isCurrentUser ? 'background-color: #f0fdf4;' : ''}" data-auditor-email="${escapeHtml(stats.email)}">
            <div style="font-size: 0.6562rem; color: var(--text-color); font-weight: 600; display: flex; align-items: center;" data-label="Name">
                ${escapeHtml(stats.name)}${stats.isCurrentUser ? ' <span style="color: var(--primary-color); font-size: 0.5625rem;">(You)</span>' : ''}
                ${onlineAuditors.has(stats.email) ? '<span class="online-indicator" style="display: inline-block; width: 0.5rem; height: 0.5rem; background-color: #10b981; border-radius: 50%; margin-left: 0.375rem; border: 0.125rem solid var(--white); box-shadow: 0 0 0 0.125rem var(--primary-color);" title="Online"></span>' : ''}
            </div>
            <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;" data-label="Assigned">${stats.assigned}</div>
            <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;" data-label="Completed">
                <div style="display: inline-flex; align-items: baseline; gap: 0.25rem;">
                    <span>${stats.completed}</span>
                    ${stats.backlogCovered > 0 ? `<span style="font-size: 0.5rem; color: #f59e0b; font-weight: 600; cursor: help;" title="${escapeHtml(backlogTooltip)}">+${stats.backlogCovered}</span>` : ''}
                </div>
            </div>
            <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;" data-label="Remaining">${stats.remaining}</div>
            <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;" data-label="Avg Duration">${stats.avgDuration}</div>
            <div style="font-size: 0.6562rem; color: var(--text-color); text-align: center;" data-label="Progress">
                <div style="display: flex; align-items: center; gap: 0.75rem; justify-content: center;">
                    <span style="font-size: 0.6562rem; font-weight: 600; color: var(--text-color); min-width: 1.875rem;">${stats.percentage}%</span>
                    <div style="flex: 1; height: 0.5625rem; background-color: var(--dark-forest); border-radius: 0.2812rem; overflow: hidden; position: relative; max-width: 5rem;">
                        <div style="height: 100%; background: var(--success-color); border-radius: 0.2812rem; transition: width 0.3s ease; width: ${stats.percentage}%;"></div>
                    </div>
                </div>
            </div>
        </div>
    `;
    }).join('');
    
    // Update online status indicators after rendering
    setTimeout(() => updateOnlineStatusIndicators(), 100);
}

async function updateStandupView() {
    // Only proceed if we're still on Standup View tab
    if (currentTab !== 1) {
        return;
    }
    
    // Update UI structure immediately (cards, table headers) - instant feedback
    renderStandupViewStructure();
    
    const period = getCurrentPeriodDates();
    
    // Show loading if initial load
    if (isInitialLoad) {
        showLoadingState();
    }
    
    // Always fetch fresh data
    await fetchAndCacheStandupView(period);
}

// Render the UI structure immediately (cards, table headers) - no data needed
function renderStandupViewStructure() {
    // Update table header for standup view immediately
    const tableHeader = document.getElementById('tableHeader');
    if (tableHeader) {
        tableHeader.style.gridTemplateColumns = 'minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(7.0312rem, 2fr)';
        tableHeader.style.display = 'grid';
        tableHeader.style.gap = '0.75rem';
        tableHeader.style.alignItems = 'center';
        tableHeader.innerHTML = `
            <div>Channel</div>
            <div>Assigned</div>
            <div>Completed</div>
            <div>Remaining</div>
            <div>Progress Meter</div>
        `;
    }
    
    // Show loading state in table body
    const tableBody = document.getElementById('performanceTableBody');
    if (tableBody) {
        tableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading...</div>';
    }
    
    // Update card labels immediately (values will be updated when data loads)
    const stat1Label = document.getElementById('stat1Label');
    if (stat1Label) stat1Label.textContent = 'ASSIGNED';
    
    // Update 3rd card to COVERAGE
    const remainingCard = document.querySelector('#remainingCount')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (remainingCard) {
        const label = remainingCard.querySelector('div[style*="font-size: 0.6562rem"]');
        if (label) label.textContent = 'COVERAGE';
    }
    
    // Update 4th card to PASSING RATE
    const stat4Card = document.getElementById('stat4Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat4Card) {
        stat4Card.style.display = 'flex';
        const label = stat4Card.querySelector('#stat4Label');
        if (label) label.textContent = 'PASSING RATE';
    }
    
    // Update 5th card to REVERSALS
    const stat5Label = document.getElementById('stat5Label');
    if (stat5Label) stat5Label.textContent = 'REVERSALS';
    
    // Hide 6th card (AVG DURATION)
    const stat6Card = document.getElementById('stat6Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat6Card) {
        stat6Card.style.display = 'none';
    }
}

// Render standup view data (called with cached or fresh data)
function renderStandupViewData(standupData) {
    const {
        totalAssigned,
        completed,
        percentage,
        coveragePercent,
        passingRate,
        standupReversalCount,
        channelStats
    } = standupData;
    
    // Update stat cards
    const stat1Count = document.getElementById('stat1Count');
    if (stat1Count) stat1Count.textContent = totalAssigned || 0;
    
    const completedCount = document.getElementById('completedCount');
    if (completedCount) completedCount.textContent = completed || 0;
    
    const targetAchieved = document.getElementById('targetAchieved');
    if (targetAchieved) targetAchieved.textContent = `${percentage || 0}% Target Achieved`;
    
    // Update 3rd card to COVERAGE with progress bar
    const remainingCard = document.querySelector('#remainingCount')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (remainingCard) {
        const countDiv = remainingCard.querySelector('#remainingCount');
        if (countDiv) {
            countDiv.style.fontSize = '2.625rem';
            countDiv.textContent = (coveragePercent || 0) + '%';
            
            // Add/update progress bar
            let progressContainer = remainingCard.querySelector('.progress-bar-container');
            if (!progressContainer) {
                progressContainer = document.createElement('div');
                progressContainer.className = 'progress-bar-container';
                progressContainer.style.cssText = 'width: 100%; height: 0.375rem; background-color: rgba(255,255,255,0.2); border-radius: 0.1875rem; overflow: hidden; margin-top: 0.375rem;';
                countDiv.parentElement.appendChild(progressContainer);
            }
            progressContainer.innerHTML = `<div style="height: 100%; background: linear-gradient(90deg, #10b981, #34d399); border-radius: 0.1875rem; transition: width 0.3s ease; width: ${coveragePercent || 0}%;"></div>`;
        }
    }
    
    // Update 4th card to PASSING RATE with progress bar
    const stat4Card = document.getElementById('stat4Count')?.closest('div[style*="background-color: var(--dark-forest)"]');
    if (stat4Card) {
        const countDiv = stat4Card.querySelector('#stat4Count');
        if (countDiv) {
            countDiv.style.fontSize = '2.625rem';
            countDiv.textContent = (passingRate || 0) + '%';
            
            const subtitle = stat4Card.querySelector('#stat4Subtitle');
            if (subtitle) subtitle.textContent = '';
            
            // Add/update progress bar
            let progressContainer = stat4Card.querySelector('.progress-bar-container');
            if (!progressContainer) {
                progressContainer = document.createElement('div');
                progressContainer.className = 'progress-bar-container';
                progressContainer.style.cssText = 'width: 100%; height: 0.375rem; background-color: rgba(255,255,255,0.2); border-radius: 0.1875rem; overflow: hidden; margin-top: 0.375rem;';
                countDiv.parentElement.appendChild(progressContainer);
            }
            progressContainer.innerHTML = `<div style="height: 100%; background: linear-gradient(90deg, #10b981, #34d399); border-radius: 0.1875rem; transition: width 0.3s ease; width: ${passingRate || 0}%;"></div>`;
        }
    }
    
    // Update 5th card to REVERSALS
    const stat5Count = document.getElementById('stat5Count');
    if (stat5Count) stat5Count.textContent = standupReversalCount || 0;
    
    const stat5Subtitle = document.getElementById('stat5Subtitle');
    if (stat5Subtitle) stat5Subtitle.textContent = '';
    
    // Update table with channel statistics
    const tableBody = document.getElementById('performanceTableBody');
    if (tableBody) {
        if (!channelStats || Object.keys(channelStats).length === 0) {
            tableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #6b7280;">No channel data available</div>';
        } else {
            const sortedChannels = Object.keys(channelStats).sort();
            tableBody.innerHTML = sortedChannels.map(channel => {
                const stats = channelStats[channel];
                
                return `
                    <div style="display: grid; grid-template-columns: minmax(5.2734rem, 2fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(3.5156rem, 1fr) minmax(7.0312rem, 2fr); gap: 0.75rem; align-items: center; padding: 0.375rem 0; border-bottom: 0.0469rem solid #f3f4f6;">
                        <div style="font-size: 0.6562rem; color: var(--text-color); font-weight: 600;" data-label="Channel">${escapeHtml(channel)}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Assigned">${stats.assigned || 0}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Completed">${stats.completed || 0}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Remaining">${stats.remaining || 0}</div>
                        <div style="font-size: 0.6562rem; color: var(--text-color);" data-label="Progress">
                            <div style="display: flex; align-items: center; gap: 0.75rem;">
                                <span style="font-size: 0.6562rem; font-weight: 600; color: var(--text-color); min-width: 1.875rem;">${stats.percentage || 0}%</span>
                                <div style="flex: 1; height: 0.5625rem; background-color: var(--dark-forest); border-radius: 0.2812rem; overflow: hidden; position: relative;">
                                    <div style="height: 100%; background: var(--success-color); border-radius: 0.2812rem; transition: width 0.3s ease; width: ${stats.percentage || 0}%;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
    }
}

async function fetchAndCacheStandupView(period) {
    // Only proceed if we're still on Standup View tab
    if (currentTab !== 1) {
        return;
    }
    
    try {
        // Load all audit assignments with date filtering
        // Filter to only Quality Analysts (auditors) to match Team Stats calculation
        
        // Get all Quality Analysts (auditors) - matching Team Stats logic
        const qualityAnalysts = allUsers.filter(u => u.role === 'Quality Analyst');
        
        if (qualityAnalysts.length === 0) {
            const tableBody = document.getElementById('performanceTableBody');
            if (tableBody) {
                tableBody.innerHTML = `
                    <div style="text-align: center; padding: 1.5rem; color: #6b7280;">
                        No Quality Analysts found in the system.
                    </div>
                `;
            }
            hideLoadingState();
            return;
        }
        
        let assignmentsQuery = window.supabaseClient
            .from('audit_assignments')
            .select('*')
            .in('auditor_email', qualityAnalysts.map(qa => qa.email))
            .order('created_at', { ascending: false });
        
        // Apply date filters server-side if possible (convert Dhaka to UTC)
        if (period.start) {
            assignmentsQuery = assignmentsQuery.gte('created_at', dhakaDateToUTCISO(period.start));
        }
        if (period.end) {
            assignmentsQuery = assignmentsQuery.lte('created_at', dhakaDateToUTCISO(period.end));
        }
        
        let { data, error } = await assignmentsQuery;
        
        // If server-side date filter fails, try without date filter and filter client-side
        if (error && period && (period.start || period.end)) {
            console.warn('Server-side date filter failed, falling back to client-side filtering:', error);
            const retryResult = await window.supabaseClient
                .from('audit_assignments')
                .select('*')
                .in('auditor_email', qualityAnalysts.map(qa => qa.email))
                .order('created_at', { ascending: false });
            
            if (retryResult.data && period.start) {
                retryResult.data = retryResult.data.filter(assignment => {
                    if (!assignment.created_at) return false;
                    const assignmentDate = toDhakaTime(assignment.created_at);
                    return (!period.start || assignmentDate >= period.start) && 
                           (!period.end || assignmentDate <= period.end);
                });
            }
            data = retryResult.data;
            error = retryResult.error;
        }
        
        if (error) throw error;
        
        const allAuditAssignments = data || [];
        
        // Calculate overall stats
        const totalAssigned = allAuditAssignments.length;
        const inProgress = allAuditAssignments.filter(a => a.status === 'in_progress').length;
        const pending = allAuditAssignments.filter(a => a.status === 'pending').length;
        const remaining = pending + inProgress;
        
        // Calculate passing rate, reversal count, completed count, and duration in parallel
        let passingRate = 0;
        let standupReversalCount = 0;
        let completed = 0; // Will be calculated from scorecard tables
        // Store completed audits by channel for channel stats
        let completedAuditsByChannel = {};
        
        try {
            // Ensure scorecards are loaded
            if (!cachedScorecardTables || cachedScorecardTables.length === 0) {
                await loadScorecards();
            }
            
            // Discover all audit tables using get_audit_tables RPC (matching expert-audits.html)
            let standupTablesToQuery = [];
            try {
                const { data: allTables, error: tablesError } = await window.supabaseClient.rpc('get_audit_tables');
                
                if (!tablesError && allTables && allTables.length > 0) {
                    // Filter out ai_analysis_results and calibration_results and map to table names
                    standupTablesToQuery = allTables
                        .filter(t => t.table_name !== 'ai_analysis_results' && t.table_name !== 'calibration_results')
                        .map(t => t.table_name);
                } else {
                    // Fallback: use scorecard tables
                    standupTablesToQuery = cachedScorecardTables.length > 0 
                ? cachedScorecardTables 
                : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
                }
            } catch (rpcError) {
                console.warn('RPC get_audit_tables failed, using scorecard-based loading:', rpcError);
                // Fallback: use scorecard tables
                standupTablesToQuery = cachedScorecardTables.length > 0 
                    ? cachedScorecardTables 
                    : (await window.supabaseClient.from('scorecards').select('table_name').eq('is_active', true)).data?.map(s => s.table_name) || [];
            }
            
            if (standupTablesToQuery.length > 0) {
                // Parallelize all queries for each table
                const queryPromises = standupTablesToQuery.map(async (tableName) => {
                    try {
                        // Build queries with date filters
                        let passingQuery = window.supabaseClient
                            .from(tableName)
                            .select('passing_status, submitted_at');
                        
                        let reversalQuery = window.supabaseClient
                            .from(tableName)
                            .select('id, submitted_at')
                            .not('reversal_requested_at', 'is', null);
                        
                        let durationQuery = window.supabaseClient
                            .from(tableName)
                            .select('audit_duration, submitted_at')
                            .not('audit_duration', 'is', null);
                        
                        // Query to count completed audits (submitted in the period) - all audits regardless of auditor
                        // All audits in scorecard tables are completed by default (they have submitted_at)
                        let completedQuery = window.supabaseClient
                            .from(tableName)
                            .select('id, submitted_at, employee_email')
                            .not('submitted_at', 'is', null);
                        
                        // Apply date filters server-side if possible (convert Dhaka to UTC)
                        if (period.start) {
                            passingQuery = passingQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            reversalQuery = reversalQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            durationQuery = durationQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                            completedQuery = completedQuery.gte('submitted_at', dhakaDateToUTCISO(period.start));
                        }
                        if (period.end) {
                            passingQuery = passingQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            reversalQuery = reversalQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            durationQuery = durationQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                            completedQuery = completedQuery.lte('submitted_at', dhakaDateToUTCISO(period.end));
                        }
                        
                        // Query for passing status, reversals, completed audits, and duration in parallel
                        const [passingResult, reversalResult, durationResult, completedResult] = await Promise.all([
                            (async () => {
                                try {
                                    let result = await passingQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('passing_status, submitted_at');
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })(),
                            (async () => {
                                try {
                                    let result = await reversalQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('id, submitted_at')
                                        .not('reversal_requested_at', 'is', null);
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })(),
                            (async () => {
                                try {
                                    let result = await durationQuery;
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('audit_duration, submitted_at')
                                        .not('audit_duration', 'is', null);
                                    
                                    if (retryResult.data && period.start) {
                                        retryResult.data = retryResult.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return retryResult;
                                }
                            })(),
                            (async () => {
                                try {
                                    let result = await completedQuery;
                                    
                                    // Fallback client-side filtering if server-side filter fails or data has no date
                                    if (result.data && period.start) {
                                        result.data = result.data.filter(audit => {
                                            if (!audit.submitted_at) return false;
                                            const auditDate = toDhakaTime(audit.submitted_at);
                                            return (!period.start || auditDate >= period.start) && 
                                                   (!period.end || auditDate <= period.end);
                                        });
                                    }
                                    return result;
                                } catch (err) {
                                    // If server-side date filter fails, try without date filter and filter client-side
                                    const retryResult = await window.supabaseClient
                                        .from(tableName)
                                        .select('id, submitted_at, employee_email')
                                        .not('submitted_at', 'is', null);
                                    
                                    if (retryResult.data) {
                                        if (period && (period.start || period.end)) {
                                            retryResult.data = retryResult.data.filter(audit => {
                                                if (!audit.submitted_at) return false;
                                                const auditDate = toDhakaTime(audit.submitted_at);
                                                return (!period.start || auditDate >= period.start) && 
                                                       (!period.end || auditDate <= period.end);
                                            });
                                        }
                                    }
                                    return retryResult;
                                }
                            })()
                        ]);
                        
                        return {
                            passing: passingResult.data || [],
                            reversals: reversalResult.data || [],
                            durations: durationResult.data || [],
                            completed: completedResult.data || []
                        };
                    } catch (err) {
                        console.warn(`Error querying ${tableName}:`, err);
                        return { passing: [], reversals: [], durations: [], completed: [] };
                    }
                });
                
                const results = await Promise.all(queryPromises);
                
                // Aggregate results
                let totalAudits = 0;
                let passedAudits = 0;
                
                results.forEach(result => {
                    // Count passing rate
                    result.passing.forEach(audit => {
                        totalAudits++;
                        const passingStatus = audit.passing_status || audit.passingStatus;
                        const normalizedStatus = normalizePassingStatus(passingStatus);
                        if (normalizedStatus === 'Passed') {
                            passedAudits++;
                        }
                    });
                    
                    // Count reversals
                    standupReversalCount += result.reversals.length;
                    
                    // All audits in scorecard tables are completed by default (they have submitted_at)
                    const completedAudits = result.completed;
                    
                    // Count completed audits and group by channel
                    completedAudits.forEach(audit => {
                        completed++;
                        // Group by channel for channel stats
                        if (audit.employee_email) {
                            const emp = allUsers.find(u => u.email === audit.employee_email);
                            const channel = emp?.channel || 'Unknown';
                            if (!completedAuditsByChannel[channel]) {
                                completedAuditsByChannel[channel] = 0;
                            }
                            completedAuditsByChannel[channel]++;
                        }
                    });
                });
                
                // Calculate pass rate
                if (totalAudits > 0) {
                    passingRate = Math.round((passedAudits / totalAudits) * 100);
                }
            }
        } catch (error) {
            console.error('Error calculating standup stats:', error);
        }
        
        console.log('Standup View - Reversal count:', standupReversalCount);
        console.log('Standup View - Completed count:', completed);
        
        // Calculate backlog coverage (assignments created on one day but completed on another)
        // Filter by completed_at date (not created_at) to show backlog work completed in the selected period
        // Use Dhaka timezone for date comparison to match the rest of the dashboard
        // This matches Team Stats calculation logic exactly
        let totalBacklogCount = 0;
        let backlogByChannel = {}; // Track backlog per channel
        
        try {
            // Get all Quality Analysts (auditors) - matching Team Stats logic
            const qualityAnalysts = allUsers.filter(u => u.role === 'Quality Analyst');
            
            // Fetch all completed assignments for Quality Analysts, filtered by completed_at date
            // This matches Team Stats calculation logic exactly
            let backlogQuery = window.supabaseClient
                .from('audit_assignments')
                .select('*')
                .in('auditor_email', qualityAnalysts.map(qa => qa.email))
                .eq('status', 'completed')
                .not('completed_at', 'is', null)
                .not('created_at', 'is', null);
            
            // Filter by completed_at date (when the audit was completed, not when it was assigned)
            if (period.start) {
                backlogQuery = backlogQuery.gte('completed_at', dhakaDateToUTCISO(period.start));
            }
            if (period.end) {
                backlogQuery = backlogQuery.lte('completed_at', dhakaDateToUTCISO(period.end));
            }
            
            const { data: completedAssignments, error: backlogError } = await backlogQuery;
            
            if (!backlogError && completedAssignments) {
                // Filter client-side to ensure accuracy with Dhaka timezone
                const filteredCompleted = completedAssignments.filter(a => {
                    if (!a.completed_at) return false;
                    const completedDate = toDhakaTime(a.completed_at);
                    // Check if completed date falls within the period
                    const inPeriod = (!period.start || completedDate >= period.start) && 
                                    (!period.end || completedDate <= period.end);
                    if (!inPeriod) return false;
                    
                    // Check if created on a different day than completed (in Dhaka timezone)
                    if (!a.created_at) return false;
                    const createdDate = toDhakaTime(a.created_at);
                    const createdDay = formatDhakaDate(createdDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                    const completedDay = formatDhakaDate(completedDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                    return createdDay !== completedDay;
                });
                
                totalBacklogCount = filteredCompleted.length;
                
                // Group backlog by channel
                filteredCompleted.forEach(a => {
                    const emp = allUsers.find(u => u.email === a.employee_email);
                    const channel = emp?.channel || 'Unknown';
                    if (!backlogByChannel[channel]) {
                        backlogByChannel[channel] = 0;
                    }
                    backlogByChannel[channel]++;
                });
            } else if (backlogError) {
                // Fallback: filter from all assignments if query fails
                const allCompleted = allAuditAssignments.filter(a => {
                    if (a.status !== 'completed' || !a.completed_at || !a.created_at) return false;
                    const completedDate = toDhakaTime(a.completed_at);
                    // Check if completed date falls within the period
                    const inPeriod = (!period.start || completedDate >= period.start) && 
                                    (!period.end || completedDate <= period.end);
                    if (!inPeriod) return false;
                    
                    // Check if created on a different day than completed
                    const createdDate = toDhakaTime(a.created_at);
                    const createdDay = formatDhakaDate(createdDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                    const completedDay = formatDhakaDate(completedDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                    return createdDay !== completedDay;
                });
                totalBacklogCount = allCompleted.length;
                
                // Group backlog by channel
                allCompleted.forEach(a => {
                    const emp = allUsers.find(u => u.email === a.employee_email);
                    const channel = emp?.channel || 'Unknown';
                    if (!backlogByChannel[channel]) {
                        backlogByChannel[channel] = 0;
                    }
                    backlogByChannel[channel]++;
                });
            }
        } catch (error) {
            console.warn('Error calculating backlog for standup view:', error);
            // Fallback to simple calculation from allAuditAssignments
            const backlogItems = allAuditAssignments.filter(a => {
                if (a.status !== 'completed' || !a.completed_at || !a.created_at) return false;
                const createdDate = toDhakaTime(a.created_at);
                const completedDate = toDhakaTime(a.completed_at);
                const createdDay = formatDhakaDate(createdDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                const completedDay = formatDhakaDate(completedDate, { year: 'numeric', month: '2-digit', day: '2-digit' });
                return createdDay !== completedDay;
            });
            totalBacklogCount = backlogItems.length;
            
            // Group backlog by channel
            backlogItems.forEach(a => {
                const emp = allUsers.find(u => u.email === a.employee_email);
                const channel = emp?.channel || 'Unknown';
                if (!backlogByChannel[channel]) {
                    backlogByChannel[channel] = 0;
                }
                backlogByChannel[channel]++;
            });
        }
        
        // Exclude backlog audits from completed count (matching Team Stats logic exactly)
        // Completed count should only show same-day completions (not backlog)
        const sameDayCompleted = Math.max(0, completed - totalBacklogCount);
        
        // Calculate percentage and coverage (using same-day completed count, matching Team Stats)
        const percentage = totalAssigned > 0 ? Math.round((sameDayCompleted / totalAssigned) * 100) : 0;
        const coveragePercent = totalAssigned > 0 ? Math.round((sameDayCompleted / totalAssigned) * 100) : 0;
        
        // Group assignments by channel (for assigned, inProgress, pending counts)
        const channelStats = {};
        
        allAuditAssignments.forEach(assignment => {
            // Find the employee to get their channel
            const emp = allUsers.find(u => u.email === assignment.employee_email);
            const channel = emp?.channel || 'Unknown';
            
            if (!channelStats[channel]) {
                channelStats[channel] = {
                    assigned: 0,
                    completed: 0, // Will be set from scorecard tables (same-day only)
                    inProgress: 0,
                    pending: 0,
                    remaining: 0,
                    percentage: 0
                };
            }
            
            channelStats[channel].assigned++;
            
            if (assignment.status === 'in_progress') {
                channelStats[channel].inProgress++;
            } else if (assignment.status === 'pending') {
                channelStats[channel].pending++;
            }
            // Note: completed count comes from scorecard tables, not assignment status
        });
        
        // Update completed counts from scorecard tables (completedAuditsByChannel)
        // This was populated in the results.forEach loop above
        // Exclude backlog per channel to match Team Stats logic
        Object.keys(completedAuditsByChannel || {}).forEach(channel => {
            if (!channelStats[channel]) {
                channelStats[channel] = {
                    assigned: 0,
                    completed: 0,
                    inProgress: 0,
                    pending: 0,
                    remaining: 0,
                    percentage: 0
                };
            }
            // Exclude backlog from completed count per channel (matching Team Stats logic)
            const channelBacklog = backlogByChannel[channel] || 0;
            const channelCompleted = completedAuditsByChannel[channel] || 0;
            channelStats[channel].completed = Math.max(0, channelCompleted - channelBacklog);
        });
        
        // Calculate remaining and percentage for each channel (using same-day completed count)
        Object.keys(channelStats).forEach(channel => {
            const stats = channelStats[channel];
            stats.remaining = stats.pending + stats.inProgress;
            stats.percentage = stats.assigned > 0 ? Math.round((stats.completed / stats.assigned) * 100) : 0;
        });
        
        // Prepare the standup data (using sameDayCompleted to match Team Stats)
        const standupData = {
            totalAssigned,
            completed: sameDayCompleted, // Use same-day completed count (excluding backlog)
            percentage,
            coveragePercent,
            passingRate,
            standupReversalCount,
            channelStats
        };
        
        // Update UI with fresh data (only if still on Standup View tab)
        if (currentTab === 1) {
            console.log('Updating UI with fresh standup view data');
            renderStandupViewData(standupData);
            hideLoadingState();
        } else {
            console.log('Skipping standup view render - user switched to tab', currentTab);
        }
        
    } catch (error) {
        console.error('Error loading standup view:', error);
        // Show error in table
        const tableBody = document.getElementById('performanceTableBody');
        if (tableBody && currentTab === 1) {
            tableBody.innerHTML = '<div style="text-align: center; padding: 1.5rem; color: #ef4444;">Error loading data. Please try again.</div>';
        }
    }
}

// ============================================================================
// Tab Switching
// ============================================================================
    async function switchTab(tabElement, index) {
    currentTab = index;
    
        const tabs = document.querySelectorAll('button[onclick*="switchTab"]');
        const slider = document.querySelector('div[style*="position: absolute"]');
        const tabBar = document.querySelector('div[style*="position: relative"]');
        
        // Remove active class from all tabs
        tabs.forEach(tab => tab.classList.remove('active'));
        // Add active class to clicked tab
        tabElement.classList.add('active');
        
        // Calculate position based on tab index and container width
        const containerPadding = 5; // 0.2344rem = 0.1758rem
        const tabWidth = (tabBar.offsetWidth - (containerPadding * 2)) / 2; // 2 tabs
        const sliderLeft = containerPadding + (index * tabWidth);
        
        slider.style.left = `${sliderLeft}px`;
        slider.style.width = `${tabWidth}px`;
        
    // Show loading state when switching tabs
    showLoadingState();
    
    // Update dashboard based on tab
    await updateDashboard();
}

// ============================================================================
// Initialize Slider
// ============================================================================
function initializeSlider() {
        const slider = document.querySelector('div[style*="position: absolute"]');
        const tabBar = document.querySelector('div[style*="position: relative"]');
        
        if (slider && tabBar) {
            // Disable transition for initial positioning
            slider.style.transition = 'none';
            
            // Calculate position for first tab (index 0)
            const containerPadding = 5; // 0.2344rem = 0.1758rem
            const tabWidth = (tabBar.offsetWidth - (containerPadding * 2)) / 2; // 2 tabs
            const sliderLeft = containerPadding + (0 * tabWidth); // First tab
            
            slider.style.left = `${sliderLeft}px`;
            slider.style.width = `${tabWidth}px`;
            
            // Re-enable transition after positioning
            requestAnimationFrame(() => {
                slider.style.transition = 'all 0.3s ease';
            });
        }
}

// ============================================================================
// Filter Functions
// ============================================================================
function toggleFilters() {
    const dropdown = document.getElementById('filterDropdown');
    const filterBtn = document.getElementById('filterBtn');
    if (dropdown && filterBtn) {
        dropdown.classList.toggle('active');
        filterBtn.classList.toggle('active');
    }
}

function populateChannelFilter() {
    const channelFilter = document.getElementById('channelFilter');
    if (!channelFilter) return;
    
    // Get unique channels from all users
    const uniqueChannels = [...new Set(allUsers.map(u => u.channel).filter(Boolean))];
    
    // Clear existing options except "All Channels"
    const existingValue = channelFilter.value;
    channelFilter.innerHTML = '<option value="">All Channels</option>';
    
    // Add channel options
    uniqueChannels.sort().forEach(channel => {
        const option = document.createElement('option');
        option.value = channel;
        option.textContent = channel;
        channelFilter.appendChild(option);
    });
    
    if (existingValue) channelFilter.value = existingValue;
}

function populateAuditorFilter() {
    const auditorFilter = document.getElementById('auditorFilter');
    if (!auditorFilter) return;
    
    // Get all Quality Analysts (auditors)
    const auditors = allUsers.filter(u => u.role === 'Quality Analyst');
    
    const existingValue = auditorFilter.value;
    auditorFilter.innerHTML = '<option value="">All Auditors</option>';
    
    auditors.sort((a, b) => (a.name || a.email).localeCompare(b.name || b.email)).forEach(auditor => {
        const option = document.createElement('option');
        option.value = auditor.email;
        option.textContent = auditor.name || auditor.email;
        auditorFilter.appendChild(option);
    });
    
    if (existingValue) auditorFilter.value = existingValue;
}

function populateEmployeeFilter() {
    const employeeFilter = document.getElementById('employeeFilter');
    if (!employeeFilter) return;
    
    // Get unique employees from assignments
    const employeeEmails = [...new Set(unfilteredAssignments.map(a => a.employee_email).filter(Boolean))];
    
    const existingValue = employeeFilter.value;
    employeeFilter.innerHTML = '<option value="">All Employees</option>';
    
    employeeEmails.sort().forEach(email => {
        const user = allUsers.find(u => u.email === email);
        const option = document.createElement('option');
        option.value = email;
        option.textContent = user?.name || email;
        employeeFilter.appendChild(option);
    });
    
    if (existingValue) employeeFilter.value = existingValue;
}

function populateScorecardFilter() {
    const scorecardFilter = document.getElementById('scorecardFilter');
    if (!scorecardFilter) return;
    
    const existingValue = scorecardFilter.value;
    scorecardFilter.innerHTML = '<option value="">All Scorecards</option>';
    
    allScorecards.forEach(scorecard => {
        const option = document.createElement('option');
        option.value = scorecard.id;
        option.textContent = scorecard.name;
        scorecardFilter.appendChild(option);
    });
    
    if (existingValue) scorecardFilter.value = existingValue;
}

async function applyFilters() {
    // Show loading state when filters change
    showLoadingState();
    
    // Get filter values
    const statusEl = document.getElementById('statusFilter');
    const channelEl = document.getElementById('channelFilter');
    const auditorEl = document.getElementById('auditorFilter');
    const employeeEl = document.getElementById('employeeFilter');
    const scorecardEl = document.getElementById('scorecardFilter');
    
    currentFilters.status = statusEl ? statusEl.value : '';
    currentFilters.channel = channelEl ? channelEl.value : '';
    currentFilters.auditor = auditorEl ? auditorEl.value : '';
    currentFilters.employee = employeeEl ? employeeEl.value : '';
    currentFilters.scorecard = scorecardEl ? scorecardEl.value : '';
    
    // Start with unfiltered assignments (these are already filtered by date/week period from database)
    // unfilteredAssignments contains assignments for the current period only
    if (!unfilteredAssignments || unfilteredAssignments.length === 0) {
        console.warn('No unfiltered assignments available. Data may still be loading.');
        allAssignments = [];
    } else {
        allAssignments = [...unfilteredAssignments];
    }
    
    // Apply status filter
    if (currentFilters.status) {
        allAssignments = allAssignments.filter(a => a.status === currentFilters.status);
    }
    
    // Apply channel filter (need to look up employee's channel)
    if (currentFilters.channel) {
        allAssignments = allAssignments.filter(a => {
            const emp = allUsers.find(u => u.email === a.employee_email);
            return emp && emp.channel === currentFilters.channel;
        });
    }
    
    // Apply auditor filter
    if (currentFilters.auditor) {
        allAssignments = allAssignments.filter(a => a.auditor_email === currentFilters.auditor);
    }
    
    // Apply employee filter
    if (currentFilters.employee) {
        allAssignments = allAssignments.filter(a => a.employee_email === currentFilters.employee);
    }
    
    // Apply scorecard filter
    if (currentFilters.scorecard) {
        allAssignments = allAssignments.filter(a => a.scorecard_id === currentFilters.scorecard);
    }
    
    // Note: Date/week filtering is already applied when loading assignments from the database
    // in fetchAndCacheAssignments() and fetchAndCacheTeamStats(), so we don't need to filter again here
    // The unfilteredAssignments are already filtered by the current period (month/week/date range)
    
    console.log(`Filtered to ${allAssignments.length} assignments`);
    
    // Update the dashboard with filtered data
    await updateDashboard();
}

async function clearFilters() {
    // Reset filter inputs
    const statusEl = document.getElementById('statusFilter');
    const channelEl = document.getElementById('channelFilter');
    const auditorEl = document.getElementById('auditorFilter');
    const employeeEl = document.getElementById('employeeFilter');
    const scorecardEl = document.getElementById('scorecardFilter');
    
    if (statusEl) statusEl.value = '';
    if (channelEl) channelEl.value = '';
    if (auditorEl) auditorEl.value = '';
    if (employeeEl) employeeEl.value = '';
    if (scorecardEl) scorecardEl.value = '';
    
    // Reset filter state
    currentFilters = {
        status: '',
        channel: '',
        auditor: '',
        employee: '',
        scorecard: ''
    };
    
    // Restore unfiltered data
    allAssignments = [...unfilteredAssignments];
    
    // Update the dashboard
    await updateDashboard();
}

// ============================================================================
// Week and Date Filter Functions
// ============================================================================
function getWeekNumber(date = null) {
    if (!date) date = getDhakaNow();
    return getDhakaWeekNumber(date);
}

function getWeekDates(weekNumber, year) {
    return getDhakaWeekDates(weekNumber, year);
}

function initializeWeekFilter() {
    const today = getDhakaNow();
    currentWeek = getDhakaWeekNumber(today);
    currentWeekYear = today.getFullYear();
    updateWeekDisplay();
}

function initializeTodayFilter() {
    const today = getDhakaNow();
    const startOfDay = getDhakaStartOfDay(today);
    const endOfDay = getDhakaEndOfDay(today);
    const startOfDayStr = formatDhakaDateForInput(startOfDay);
    const endOfDayStr = formatDhakaDateForInput(endOfDay);
    
    // Set date filter to today
    dateFilter.start = startOfDayStr;
    dateFilter.end = endOfDayStr;
    useWeekFilter = false;
    
    // Update date input fields
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const dateBtnTextEl = document.getElementById('dateBtnText');
    
    if (startDateEl) startDateEl.value = startOfDayStr;
    if (endDateEl) endDateEl.value = endOfDayStr;
    
    // Update date button text to show today
    if (dateBtnTextEl) {
        const start = formatDhakaDate(startOfDay, { month: 'short', day: 'numeric' });
        const end = formatDhakaDate(endOfDay, { month: 'short', day: 'numeric' });
        dateBtnTextEl.textContent = `${start} - ${end}`;
    }
    
    // Activate "Today" button
    const quickDateButtons = document.querySelectorAll('.quick-date-btn');
    quickDateButtons.forEach(btn => btn.classList.remove('active'));
    const todayBtn = document.getElementById('todayBtn');
    if (todayBtn) {
        todayBtn.classList.add('active');
    }
    
    // Update week display to show it's disabled
    updateWeekDisplay();
}

function initializeMonthFilter() {
    const today = getDhakaNow();
    const firstDay = getDhakaFirstDayOfMonth(today);
    const lastDay = getDhakaLastDayOfMonth(today);
    const firstDayStr = formatDhakaDateForInput(firstDay);
    const lastDayStr = formatDhakaDateForInput(lastDay);
    
    // Set date filter to current month
    dateFilter.start = firstDayStr;
    dateFilter.end = lastDayStr;
    useWeekFilter = false;
    
    // Update date input fields
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const dateBtnTextEl = document.getElementById('dateBtnText');
    
    if (startDateEl) startDateEl.value = firstDayStr;
    if (endDateEl) endDateEl.value = lastDayStr;
    
    // Update date button text to show current month
    if (dateBtnTextEl) {
        const start = formatDhakaDate(firstDay, { month: 'short', day: 'numeric' });
        const end = formatDhakaDate(lastDay, { month: 'short', day: 'numeric' });
        dateBtnTextEl.textContent = `${start} - ${end}`;
    }
    
    // Activate "This Month" button
    const quickDateButtons = document.querySelectorAll('.quick-date-btn');
    quickDateButtons.forEach(btn => btn.classList.remove('active'));
    const thisMonthBtn = document.getElementById('thisMonthBtn');
    if (thisMonthBtn) {
        thisMonthBtn.classList.add('active');
    }
    
    // Update week display to show it's disabled
    updateWeekDisplay();
}

function updateWeekDisplay() {
    const weekTextEl = document.getElementById('weekText');
    const prevWeekBtn = document.getElementById('prevWeekBtn');
    const nextWeekBtn = document.getElementById('nextWeekBtn');
    const weekDisplay = document.getElementById('weekDisplay');
    
    // Initialize current week if not set
    if (currentWeek === null) {
        const today = getDhakaNow();
        currentWeek = getDhakaWeekNumber(today);
        currentWeekYear = today.getFullYear();
    }
    
    if (weekTextEl) {
        if (useWeekFilter && currentWeek !== null) {
            weekTextEl.textContent = `Week ${currentWeek}`;
        } else {
            weekTextEl.textContent = `Week ${currentWeek || '-'}`;
        }
    }
    
    // Always enable week navigation buttons - they can switch to week view when clicked
    // Matching employee-performance.html and expert-audits.html UX
    if (prevWeekBtn) {
        prevWeekBtn.disabled = false;
        prevWeekBtn.style.opacity = '1';
        prevWeekBtn.style.cursor = 'pointer';
    }
    
    if (nextWeekBtn) {
        nextWeekBtn.disabled = false;
        nextWeekBtn.style.opacity = '1';
        nextWeekBtn.style.cursor = 'pointer';
    }
    
    // Update week display styling
    if (weekDisplay) {
        if (useWeekFilter) {
            weekDisplay.style.backgroundColor = 'var(--primary-color)';
            weekDisplay.style.color = 'var(--white)';
            weekDisplay.style.borderColor = 'var(--primary-color)';
            weekDisplay.style.cursor = 'default';
        } else {
            weekDisplay.style.backgroundColor = '#f3f4f6';
            weekDisplay.style.color = '#6b7280';
            weekDisplay.style.borderColor = '#e5e7eb';
            weekDisplay.style.cursor = 'pointer';
        }
    }
}

function navigateWeek(direction) {
    // Show loading state when navigating weeks
    showLoadingState();
    
    // Initialize current week if not set
    if (currentWeek === null) {
        const today = getDhakaNow();
        currentWeek = getDhakaWeekNumber(today);
        currentWeekYear = today.getFullYear();
    }
    
    // Switch to week view when navigating (if not already in week view)
    if (!useWeekFilter) {
        useWeekFilter = true;
        dateFilter.start = null;
        dateFilter.end = null;
        const startDateEl = document.getElementById('startDate');
        const endDateEl = document.getElementById('endDate');
        const dateBtnTextEl = document.getElementById('dateBtnText');
        if (startDateEl) startDateEl.value = '';
        if (endDateEl) endDateEl.value = '';
        if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
        
        // Clear active state of quick filter buttons when switching to week view
        const quickDateButtons = document.querySelectorAll('.quick-date-btn');
        quickDateButtons.forEach(btn => btn.classList.remove('active'));
    }
    
    currentWeek += direction;
    
    if (currentWeek > 52) {
        currentWeek = 1;
        currentWeekYear += 1;
    } else if (currentWeek < 1) {
        currentWeek = 52;
        currentWeekYear -= 1;
    }
    
    updateWeekDisplay();
    
    // Reload assignments with new week filter
    loadAssignments();
}

// Function to switch to week view when week display is clicked
function switchToWeekView() {
    // Show loading state when switching to week view
    showLoadingState();
    
    // Initialize current week if not set
    if (currentWeek === null) {
        const today = getDhakaNow();
        currentWeek = getDhakaWeekNumber(today);
        currentWeekYear = today.getFullYear();
    }
    
    useWeekFilter = true;
    dateFilter.start = null;
    dateFilter.end = null;
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const dateBtnTextEl = document.getElementById('dateBtnText');
    if (startDateEl) startDateEl.value = '';
    if (endDateEl) endDateEl.value = '';
    if (dateBtnTextEl) dateBtnTextEl.textContent = 'Date Range';
    
    // Clear active state of quick filter buttons when switching to week view
    const quickDateButtons = document.querySelectorAll('.quick-date-btn');
    quickDateButtons.forEach(btn => btn.classList.remove('active'));
    
    updateWeekDisplay();
    
    // Reload assignments with new week filter
    loadAssignments();
}

function setupEventListeners() {
    // Week navigation buttons
    const prevWeekBtn = document.getElementById('prevWeekBtn');
    const nextWeekBtn = document.getElementById('nextWeekBtn');
    const weekDisplay = document.getElementById('weekDisplay');
    
    if (prevWeekBtn) {
        prevWeekBtn.addEventListener('click', () => {
            // If in month view, switch to week view first
            if (!useWeekFilter) {
                switchToWeekView();
            }
            // Navigate (will work whether we just switched or were already in week view)
            navigateWeek(-1);
        });
    }
    if (nextWeekBtn) {
        nextWeekBtn.addEventListener('click', () => {
            // If in month view, switch to week view first
            if (!useWeekFilter) {
                switchToWeekView();
            }
            // Navigate (will work whether we just switched or were already in week view)
            navigateWeek(1);
        });
    }
    
    // Make week display clickable to switch to week view when in month view
    if (weekDisplay) {
        weekDisplay.addEventListener('click', function() {
            if (!useWeekFilter) {
                switchToWeekView();
            }
        });
    }

    // Date button
    const dateBtn = document.getElementById('dateBtn');
    if (dateBtn) {
        dateBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const dropdown = document.getElementById('dateDropdown');
            if (dropdown) {
                dropdown.classList.toggle('active');
            }
        });
    }

    // Filter button
    const filterBtn = document.getElementById('filterBtn');
    if (filterBtn) {
        filterBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFilters();
        });
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.date-picker-dropdown')) {
            const dateDropdown = document.getElementById('dateDropdown');
            if (dateDropdown) {
                dateDropdown.classList.remove('active');
            }
        }
        if (!e.target.closest('.filter-dropdown')) {
            const filterDropdown = document.getElementById('filterDropdown');
            const filterBtn = document.getElementById('filterBtn');
            if (filterDropdown) {
                filterDropdown.classList.remove('active');
            }
            if (filterBtn) {
                filterBtn.classList.remove('active');
            }
        }
    });
}

window.applyDateFilter = function() {
    // Show loading state when date filter changes
    showLoadingState();
    
    const startDateEl = document.getElementById('startDate');
    const endDateEl = document.getElementById('endDate');
    const startDate = startDateEl?.value || '';
    const endDate = endDateEl?.value || '';
    
    // Store as date strings to match initializeMonthFilter() and employee-performance.html
    if (startDate) {
        dateFilter.start = startDate;
    } else {
        dateFilter.start = null;
    }
    
    if (endDate) {
        dateFilter.end = endDate;
    } else {
        dateFilter.end = null;
    }

    const dateBtnTextEl = document.getElementById('dateBtnText');
    if (startDate || endDate) {
        const start = startDate ? formatDhakaDate(parseDhakaDate(startDate), { month: 'short', day: 'numeric' }) : 'Start';
        const end = endDate ? formatDhakaDate(parseDhakaDate(endDate), { month: 'short', day: 'numeric' }) : 'End';
        if (dateBtnTextEl) dateBtnTextEl.textContent = `${start} - ${end}`;
        useWeekFilter = false;
        
        // Clear active state of quick filter buttons when using custom date range
        const quickDateButtons = document.querySelectorAll('.quick-date-btn');
        quickDateButtons.forEach(btn => btn.classList.remove('active'));
        
        updateWeekDisplay(); // Update week display to show "-"
    } else {
        // If both dates are cleared, reset to today view
        initializeTodayFilter();
    }

    const dateDropdown = document.getElementById('dateDropdown');
    if (dateDropdown) dateDropdown.classList.remove('active');
    
    // Reload assignments with new date filter
    loadAssignments();
};

window.clearDateFilter = function() {
    // Show loading state when clearing date filter
    showLoadingState();
    
    // Reset to today view
    initializeTodayFilter();
    const dateDropdown = document.getElementById('dateDropdown');
    if (dateDropdown) dateDropdown.classList.remove('active');
    updateWeekDisplay(); // Update week display
    
    // Reload assignments with today filter
    loadAssignments();
};

// Use shared date filter utility - wrap to provide page-specific callbacks
const originalApplyQuickDateFilter = window.applyQuickDateFilter;
window.applyQuickDateFilter = function(period) {
    // Show loading state when quick date filter changes
    showLoadingState();
    
    originalApplyQuickDateFilter(period, {
        dateFilter: dateFilter,
        setUseWeekFilter: () => { useWeekFilter = false; },
        onUpdate: updateWeekDisplay,
        onRefresh: () => {
            // Reload assignments with new date filter
            loadAssignments();
        }
    });
};

// Helper function to normalize passing status (handles both old and new values)
// Matching expert-audits.html implementation
function normalizePassingStatus(status) {
    if (!status) return status;
    
    // Convert to string and trim
    const statusStr = String(status).trim();
    
    // Convert old values to new ones for consistency
    // Handle "Passing", "Pass", "passed" (case-insensitive)
    if (statusStr === 'Passing' || statusStr === 'Pass' || statusStr.toLowerCase() === 'passed') {
        return 'Passed';
    }
    // Handle "Not Passing", "Not Pass", "not passed" (case-insensitive)
    if (statusStr === 'Not Passing' || statusStr === 'Not Pass' || statusStr.toLowerCase() === 'not passed') {
        return 'Not Passed';
    }
    
    // Return as-is if already normalized or unknown
    return statusStr;
}

// Helper function to check if date is within filter range
function isDateInRange(date, filterStart, filterEnd) {
    if (!filterStart && !filterEnd) {
        // If no date filter, check against current week or today
        if (useWeekFilter && currentWeek !== null) {
            const weekDates = getDhakaWeekDates(currentWeek, currentWeekYear);
            filterStart = weekDates.start;
            filterEnd = weekDates.end;
        } else {
            // Default to today (matching getCurrentPeriodDates)
            const today = getDhakaNow();
            filterStart = getDhakaStartOfDay(today);
            filterEnd = getDhakaEndOfDay(today);
        }
    }
    
    return isDhakaDateInRange(date, filterStart, filterEnd);
}

// ============================================================================
// Realtime Presence Functions
// ============================================================================
async function setupPresenceTracking() {
    try {
        if (!window.supabaseClient || !currentUserEmail) {
            console.warn('Cannot setup presence: Supabase or user email not available');
            return;
        }

        // Get user info to check role
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const userRole = userInfo.role;

        // Only track presence for Quality Analysts (auditors)
        if (userRole !== 'Quality Analyst') {
            return;
        }

        // Create a channel for auditor presence
        const channelName = 'auditor-presence';
        presenceChannel = window.supabaseClient.channel(channelName, {
            config: {
                presence: {
                    key: currentUserEmail, // Use email as presence key
                }
            }
        });

        // Track current user's presence
        presenceChannel
            .on('presence', { event: 'sync' }, () => {
                updateOnlineAuditors();
            })
            .on('presence', { event: 'join' }, ({ key, newPresences }) => {
                console.log('User joined:', key, newPresences);
                updateOnlineAuditors();
            })
            .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
                console.log('User left:', key, leftPresences);
                updateOnlineAuditors();
            })
            .subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    // Track current user as online
                    await trackPresence();
                    
                    // Set up heartbeat to keep presence alive
                    startHeartbeat();
                }
            });
    } catch (error) {
        console.error('Error setting up presence tracking:', error);
    }
}

async function trackPresence() {
    try {
        if (!presenceChannel) return;

        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const userRole = userInfo.role;

        // Only track presence for Quality Analysts (auditors)
        if (userRole !== 'Quality Analyst') {
            return;
        }

        await presenceChannel.track({
            email: currentUserEmail,
            name: userInfo.name || currentUserEmail,
            role: userRole,
            online_at: dhakaDateToUTCISO(getDhakaNow()),
            page: 'auditor-dashboard'
        });
    } catch (error) {
        console.error('Error tracking presence:', error);
    }
}

function startHeartbeat() {
    // Clear any existing heartbeat
    if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
    }

    // Send heartbeat every 30 seconds to keep presence alive
    heartbeatInterval = setInterval(async () => {
        await trackPresence();
    }, 30000); // 30 seconds
}

function stopHeartbeat() {
    if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
    }
}

function updateOnlineAuditors() {
    try {
        if (!presenceChannel) return;

        const state = presenceChannel.presenceState();
        const newOnlineAuditors = new Set();

        // Extract online auditor emails from presence state
        Object.values(state).forEach((presences) => {
            presences.forEach((presence) => {
                if (presence.role === 'Quality Analyst' && presence.email) {
                    newOnlineAuditors.add(presence.email);
                }
            });
        });

        onlineAuditors = newOnlineAuditors;
        
        // Update the UI to reflect online status
        updateOnlineStatusIndicators();
    } catch (error) {
        console.error('Error updating online auditors:', error);
    }
}

function updateOnlineStatusIndicators() {
    // Update status indicators in the table
    const tableBody = document.getElementById('performanceTableBody');
    if (!tableBody) return;

    // Find all rows and update their online status
    const rows = tableBody.querySelectorAll('div[data-auditor-email]');
    rows.forEach(row => {
        const auditorEmail = row.dataset.auditorEmail;
        const nameCell = row.querySelector('[data-label="Name"]');
        
        if (nameCell && auditorEmail) {
            if (onlineAuditors.has(auditorEmail)) {
                // Add or update online indicator
                let indicator = nameCell.querySelector('.online-indicator');
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'online-indicator';
                    indicator.style.cssText = 'display: inline-block; width: 0.5rem; height: 0.5rem; background-color: #10b981; border-radius: 50%; margin-left: 0.375rem; border: 0.125rem solid var(--white); box-shadow: 0 0 0 0.125rem var(--primary-color);';
                    indicator.title = 'Online';
                    nameCell.appendChild(indicator);
                }
            } else {
                // Remove online indicator
                const indicator = nameCell.querySelector('.online-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }
        }
    });
}

async function cleanupPresence() {
    try {
        stopHeartbeat();
        
        if (presenceChannel) {
            await presenceChannel.untrack();
            await presenceChannel.unsubscribe();
            presenceChannel = null;
        }
    } catch (error) {
        console.error('Error cleaning up presence:', error);
    }
}

// ============================================================================
// Loading State Functions
// ============================================================================
function showLoadingState() {
    // Clear any existing timeout
    if (loadingTimeout) {
        clearTimeout(loadingTimeout);
    }
    
    // Show loading after a short delay to avoid flicker for fast loads
    loadingTimeout = setTimeout(() => {
        const tableBody = document.getElementById('performanceTableBody');
        if (tableBody && !tableBody.querySelector('.loading-indicator')) {
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'loading-indicator';
            loadingDiv.style.cssText = 'text-align: center; padding: 2rem; color: #6b7280;';
            loadingDiv.innerHTML = `
                <div style="display: inline-block; width: 1.5rem; height: 1.5rem; border: 0.1875rem solid #e5e7eb; border-top-color: var(--primary-color); border-radius: 50%; animation: spin 0.8s linear infinite;"></div>
                <div style="margin-top: 0.75rem; font-size: 0.6562rem;">Loading...</div>
            `;
            tableBody.innerHTML = '';
            tableBody.appendChild(loadingDiv);
        }
        
        // Add fade effect to stat cards
        const statCards = document.querySelectorAll('#statsContainer > div');
        statCards.forEach(card => {
            card.style.opacity = '0.6';
            card.style.transition = 'opacity 0.3s ease';
        });
    }, 200); // 200ms delay before showing loading
}

function hideLoadingState() {
    // Clear timeout if loading hasn't shown yet
    if (loadingTimeout) {
        clearTimeout(loadingTimeout);
        loadingTimeout = null;
    }
    
    // Remove loading indicator
    const tableBody = document.getElementById('performanceTableBody');
    if (tableBody) {
        const loadingIndicator = tableBody.querySelector('.loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.remove();
        }
    }
    
    // Restore stat cards opacity
    const statCards = document.querySelectorAll('#statsContainer > div');
    statCards.forEach(card => {
        card.style.opacity = '1';
    });
}

function renderTeamStatsWithFade(statsData) {
    // Fade out, update, fade in
    const tableBody = document.getElementById('performanceTableBody');
    if (tableBody) {
        tableBody.style.opacity = '0.5';
        tableBody.style.transition = 'opacity 0.2s ease';
        
        setTimeout(() => {
            renderTeamStats(statsData);
            setTimeout(() => {
                tableBody.style.opacity = '1';
                setTimeout(() => updateOnlineStatusIndicators(), 100);
            }, 50);
        }, 200);
    } else {
        renderTeamStats(statsData);
    }
}

// ============================================================================
// Utility Functions
// ============================================================================
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// ============================================================================
// Cleanup on page unload
// ============================================================================
window.addEventListener('beforeunload', async () => {
    await cleanupPresence();
});
</script>


</body>
</html>

