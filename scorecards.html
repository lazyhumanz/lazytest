<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Scorecards | QMS</title>
<meta name="description" content="Quality Management System - Manage Scorecards">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAtOTYwIDk2MCA5NjAiIHdpZHRoPSIyNHB4IiBmaWxsPSIjMWY5ZTRiIj48cGF0aCBkPSJNMjAwLTEyMHEtMzMgMC01Ni41LTIzLjVUMTIwLTIwMHYtNTYwcTAtMzMgMjMuNS01Ni41VDIwMC04NDBoNTYwcTMzIDAgNTYuNSAyMy41VDg0MC03NjB2NTYwcTAgMzMtMjMuNSA1Ni41VDc2MC0xMjBIMjAwWm00OTEtODBoNjl2LTY5bC02OSA2OVptLTQ1NyAwaDczbDEyMC0xMjBoODVMNDUyLTIwMGg2NGwxMjAtMTIwaDg1TDU0MS0yMDBoNjVsMTIwLTEyMGgzNHYtNDQwSDIwMHY1MDlsNjktNjloODVMNDM0LTIwMFptNzItMjAwLTU2LTU2IDE3Ny0xNzcgODAgODAgMTQ3LTE0NyA1NiA1Ni0yMDMgMjA0LTgwLTgwLTEyMSAxMjBaIi8+PC9zdmc+">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="theme.css">
    <link rel="stylesheet" href="sidebar.css">
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="env-config.js"></script>
    <script src="supabase-config.js"></script>
    <script src="auth-check.js"></script>
    <script src="access-control.js"></script>
    <script src="confirmation-dialog.js"></script>
    <script src="load-sidebar.js"></script>
    <style>
        /* Scorecards Specific Styles */
        .scorecards-container {
            display: flex;
            flex-direction: column;
            gap: 1.125rem;
            padding: 0;
            width: 100%;
            margin: 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-bottom: 1.125rem;
            width: 100%;
        }

        .stat-card {
            background: #ffffff;
            border-radius: 0.375rem;
            padding: 0.75rem;
            border: 0.0469rem solid #e5e7eb;
            transition: all 0.2s ease;
            position: relative;
        }

        .stat-card:hover {
            box-shadow: 0 0.1875rem 0.2812rem -0.0469rem rgba(0, 0, 0, 0.1);
            transform: translateY(-0.0938rem);
        }

        .stat-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.375rem;
        }

        .stat-title {
            font-size: 0.5625rem;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .stat-icon {
            width: 0.9375rem;
            height: 0.9375rem;
            color: var(--primary-color);
        }

        .stat-value {
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.1875rem;
        }

        .stat-change {
            font-size: 0.5625rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.1875rem;
        }

        .stat-change.positive {
            color: #10b981;
        }

        .stat-change.negative {
            color: #ef4444;
        }

        .controls-section {
            background: #ffffff;
            border-radius: 0.375rem;
            padding: 0.75rem;
            border: 0.0469rem solid #e5e7eb;
            margin-bottom: 0.1875rem;
            width: 100%;
            align-self: center;
        }

        .controls-header {
            font-size: 0.6562rem;
            font-weight: 600;
            color: #1A733E;
            margin-bottom: 0.5625rem;
            padding-bottom: 0.1875rem;
            border-bottom: 0.0469rem solid #1A733E;
            text-transform: uppercase;
            letter-spacing: 0.0141rem;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(7.0312rem, 1fr));
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-label {
            font-size: 0.5625rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.1875rem;
            font-family: 'Poppins', sans-serif;
        }

        .control-select {
            padding: 0.2812rem 0.375rem;
            border: 0.0469rem solid #d1d5db;
            border-radius: 0.1875rem;
            font-size: 0.5625rem;
            font-family: 'Poppins', sans-serif;
            transition: all 0.2s ease;
            background-color: #ffffff;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23374151\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3e%3cpolyline points=\'6,9 12,15 18,9\'%3e%3c/polyline%3e%3c/svg%3e');
            background-repeat: no-repeat;
            background-position: right 0.5625rem center;
            background-size: 0.75rem;
            padding-right: 1.875rem;
            cursor: pointer;
        }

        .control-select:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .action-buttons {
            display: flex;
            gap: 0.375rem;
            flex-wrap: wrap;
        }

        .btn-create {
            background-color: var(--primary-color);
            color: #ffffff;
            border: none;
            border-radius: 0.1875rem;
            padding: 0.375rem 0.75rem;
            font-size: 0.5625rem;
            font-weight: 600;
            font-family: 'Poppins', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.1875rem;
        }

        .btn-create:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: #f9fafb;
            color: #374151;
            border: 0.0469rem solid #d1d5db;
            border-radius: 0.1875rem;
            padding: 0.375rem 0.75rem;
            font-size: 0.5625rem;
            font-weight: 600;
            font-family: 'Poppins', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.1875rem;
        }

        .btn-secondary:hover {
            background-color: #f3f4f6;
        }

        .scorecards-table-section {
            background: #ffffff;
            border-radius: 0.375rem;
            padding: 0.75rem;
            border: 0.0469rem solid #e5e7eb;
            width: 100%;
        }

        .table-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }

        .table-title {
            font-size: 0.6562rem;
            font-weight: 600;
            color: #1A733E;
            text-transform: uppercase;
            letter-spacing: 0.0141rem;
        }

        .table-count {
            background-color: var(--primary-color);
            color: #ffffff;
            padding: 0.1875rem 0.375rem;
            border-radius: 0.1875rem;
            font-size: 0.5625rem;
            font-weight: 600;
        }

        .scorecards-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.5625rem;
            table-layout: auto;
        }

        .scorecards-table th,
        .scorecards-table td {
            padding: 0.5625rem;
            text-align: left;
            border-bottom: 0.0469rem solid #e5e7eb;
        }

        .scorecards-table th {
            background-color: #f9fafb;
            font-weight: 600;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.4688rem;
        }

        .scorecards-table tr:hover {
            background-color: #f9fafb;
        }

        .status-badge {
            padding: 0.1875rem 0.375rem;
            border-radius: 0.1875rem;
            font-size: 0.4688rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .status-active {
            background-color: #d1fae5;
            color: #065f46;
        }

        .status-inactive {
            background-color: #e5e7eb;
            color: #6b7280;
        }

        .version-badge {
            padding: 0.1125rem 0.3rem;
            border-radius: 0.1875rem;
            font-size: 0.4688rem;
            font-weight: 600;
            background-color: #dbeafe;
            color: #1e40af;
        }

        .version-badge-v1 {
            background-color: #f3f4f6;
            color: #6b7280;
        }

        .btn-action {
            background-color: #f3f4f6;
            color: #374151;
            border: 0.0469rem solid #d1d5db;
            border-radius: 0.1875rem;
            padding: 0.2812rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 1.3125rem;
            height: 1.3125rem;
        }

        .btn-action:hover {
            background-color: #e5e7eb;
        }

        .btn-action-primary {
            background-color: #1A733E;
            color: white;
            border: none;
        }

        .btn-action-primary:hover {
            background-color: #145a30;
        }

        .btn-action-danger {
            background-color: #fee2e2;
            color: #dc2626;
            border: 0.0469rem solid #fca5a5;
        }

        .btn-action-danger:hover {
            background-color: #fecaca;
        }

        .btn-action-warning {
            background-color: #fef3c7;
            color: #92400e;
            border: 0.0469rem solid #fcd34d;
        }

        .btn-action-warning:hover {
            background-color: #fde68a;
        }

        .btn-action-success {
            background-color: #d1fae5;
            color: #065f46;
            border: 0.0469rem solid #6ee7b7;
        }

        .btn-action-success:hover {
            background-color: #a7f3d0;
        }

        .parameter-row {
            display: grid;
            grid-template-columns: 2fr 0.8fr 1.2fr 1fr 1fr 1.2fr 2fr 0.6fr 0.6fr 0.4fr;
            gap: 0.2812rem;
            align-items: start;
            padding: 0.2812rem;
            background: white;
            border: 0.0469rem solid #e5e7eb;
            border-radius: 0.1875rem;
            margin-bottom: 0.2812rem;
        }
        
        .parameter-row.with-ai-prompt {
            grid-template-columns: 2fr 0.8fr 1.2fr 1fr 1fr 1.2fr 2fr 0.6fr 2fr 0.6fr 0.4fr;
        }
        
        .parameter-headers.with-ai-prompt {
            grid-template-columns: 2fr 0.8fr 1.2fr 1fr 1fr 1.2fr 2fr 0.6fr 2fr 0.6fr 0.4fr !important;
        }

        .parameter-row:hover {
            background: #f9fafb;
            border-color: #d1d5db;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            overflow-y: auto;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 0.375rem;
            max-width: 45rem;
            width: 90%;
            max-height: 90vh;
            overflow: hidden;
        }

    </style>
</head>

<body>
<!-- Sidebar will be loaded dynamically by load-sidebar.js -->
<main class="main-content" role="main">
    <p class="page-heading">Scorecards Management</p>
    <div style="margin-bottom: 1.125rem; width: 100%;"></div>

    <div class="scorecards-container" style="margin-top: 2rem;">
        <!-- Statistics Overview -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-header">
                    <span class="stat-title">Total Scorecards</span>
                    <svg class="stat-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
                    </svg>
                </div>
                <div class="stat-value" id="totalScorecards">-</div>
                <div class="stat-change positive" id="totalScorecardsChange">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="23,6 13.5,15.5 8.5,10.5 1,18"/>
                        <polyline points="17,6 23,6 23,12"/>
                    </svg>
                    All scorecards
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-header">
                    <span class="stat-title">Active Scorecards</span>
                    <svg class="stat-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 12l2 2 4-4"/>
                        <circle cx="12" cy="12" r="10"/>
                    </svg>
                </div>
                <div class="stat-value" id="activeScorecards">-</div>
                <div class="stat-change positive" id="activeScorecardsChange">
                    Currently in use
                </div>
            </div>

            <div class="stat-card">
                <div class="stat-header">
                    <span class="stat-title">Inactive Scorecards</span>
                    <svg class="stat-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18.36 6.64a9 9 0 1 1-12.73 0"/>
                        <line x1="12" y1="2" x2="12" y2="22"/>
                    </svg>
                </div>
                <div class="stat-value" id="inactiveScorecards">-</div>
                <div class="stat-change" id="inactiveScorecardsChange">
                    Archived
                </div>
            </div>

        </div>

        <!-- Scorecards Table Section -->
        <div class="scorecards-table-section">
            <div class="table-header">
                <div style="display: flex; align-items: center; gap: 0.375rem;">
                    <h3 class="table-title">All Scorecards</h3>
                    <span class="table-count" id="scorecardsCount">0 Scorecards</span>
                </div>
                <div style="display: flex; align-items: center; gap: 0.375rem;">
                    <button class="btn-create" onclick="openScorecardModal()" style="margin: 0;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"/>
                            <line x1="5" y1="12" x2="19" y2="12"/>
                        </svg>
                        Create New Scorecard
                    </button>
                </div>
            </div>
            <table class="scorecards-table">
                <thead>
                    <tr>
                        <th>Scorecard Name</th>
                        <th>Scoring Type</th>
                        <th>Table Name</th>
                        <th>Passing Threshold</th>
                        <th>Audits</th>
                        <th>Version</th>
                        <th>Status</th>
                        <th>Created</th>
                        <th style="text-align: center;">Actions</th>
                    </tr>
                </thead>
                <tbody id="scorecardsTableBody">
                    <tr>
                        <td colspan="9" style="text-align: center; padding: 1.5rem; color: #6b7280;">Loading scorecards...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
</main>

<!-- View Scorecard Modal -->
<div id="viewScorecardModal" class="modal">
    <div class="modal-content" style="max-width: 28.125rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; border-bottom: 0.0469rem solid #e5e7eb; background: #f9fafb;">
            <h2 id="viewModalTitle" style="font-size: 0.8438rem; font-weight: 600; color: #1A733E; margin: 0;">Scorecard Details</h2>
            <button onclick="closeViewModal()" style="background: none; border: none; font-size: 1.125rem; cursor: pointer; color: #6b7280; padding: 0; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center;">&times;</button>
        </div>
        <div id="viewModalBody" style="padding: 0.75rem; max-height: 70vh; overflow-y: auto;">
            <!-- Content will be populated dynamically -->
        </div>
    </div>
</div>

<!-- Create/Edit Scorecard Modal -->
<div id="scorecardModal" class="modal">
    <div class="modal-content" style="max-width: 95vw; width: 95vw;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.375rem 0.5625rem; border-bottom: 0.0469rem solid #e5e7eb; background: #f9fafb;">
            <h2 id="modalTitle" style="font-size: 0.7031rem; font-weight: 600; color: #1A733E; margin: 0;">Create New Scorecard</h2>
            <button onclick="closeScorecardModal()" style="background: none; border: none; font-size: 0.9375rem; cursor: pointer; color: #6b7280; padding: 0; width: 1.125rem; height: 1.125rem; display: flex; align-items: center; justify-content: center;">&times;</button>
        </div>
        <div style="padding: 0.5625rem; max-height: calc(90vh - 3.5156rem); overflow-y: auto;">
            <form id="scorecardForm">
                <input type="hidden" id="scorecardId">
                <input type="hidden" id="parentScorecardId">
                
                <!-- Basic Information -->
                <div style="background: #f9fafb; border-radius: 0.2812rem; padding: 0.375rem; margin-bottom: 0.5625rem;">
                    <h3 style="font-size: 0.5625rem; font-weight: 600; color: #374151; margin-bottom: 0.375rem;">Basic Information</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5625rem;">
                        <div>
                            <label for="scorecardName" style="font-size: 0.5156rem; font-weight: 500; color: #374151; margin-bottom: 0.0938rem; display: block;">Scorecard Name <span style="color: #ef4444;">*</span></label>
                            <input type="text" id="scorecardName" required style="width: 100%; padding: 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif;">
                        </div>
                        
                        <div style="grid-column: 1 / -1;">
                            <label for="scorecardDescription" style="font-size: 0.5156rem; font-weight: 500; color: #374151; margin-bottom: 0.0938rem; display: block;">Description</label>
                            <textarea id="scorecardDescription" placeholder="Brief description... (supports multiple paragraphs)" rows="3" style="width: 100%; padding: 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif; resize: vertical; min-height: 3rem;"></textarea>
                        </div>
                        
                        <div>
                            <label for="scoringType" style="font-size: 0.5156rem; font-weight: 500; color: #374151; margin-bottom: 0.0938rem; display: block;">Scoring Type <span style="color: #ef4444;">*</span></label>
                            <select id="scoringType" required style="width: 100%; padding: 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif; cursor: pointer;">
                                <option value="deductive">Deductive (100% - errors)</option>
                                <option value="additive">Additive (0% + achievements)</option>
                                <option value="hybrid">Hybrid (both)</option>
                            </select>
                            <small style="font-size: 0.4219rem; color: #6b7280; display: block; margin-top: 0.0938rem;" id="scoringTypeHelp">
                                <strong>Deductive:</strong> Start perfect, lose points for mistakes.
                            </small>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.375rem;">
                            <div>
                                <label for="passingThreshold" style="font-size: 0.5156rem; font-weight: 500; color: #374151; margin-bottom: 0.0938rem; display: block;">Passing Threshold (%) <span style="color: #ef4444;">*</span></label>
                                    <input type="number" id="passingThreshold" value="90" min="0" max="100" step="0.01" required style="width: 100%; padding: 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif;">
                            </div>
                            
                            <div>
                                <label for="tableName" style="font-size: 0.5156rem; font-weight: 500; color: #374151; margin-bottom: 0.0938rem; display: block;">Table Name <span style="color: #ef4444;">*</span></label>
                                <input type="text" id="tableName" required placeholder="audit_reports_example" style="width: 100%; padding: 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif;">
                            </div>
                        </div>
                        
                        <!-- Hybrid-specific options -->
                        <div id="hybridOptions" style="display: none; grid-column: 1 / -1;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.375rem;">
                                <div>
                                    <label for="maxBonusPoints" style="font-size: 0.5156rem; font-weight: 500; color: #374151; margin-bottom: 0.0938rem; display: block;">Max Bonus Points</label>
                                    <input type="number" id="maxBonusPoints" value="20" min="0" max="100" step="1" style="width: 100%; padding: 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif;">
                                </div>
                                <div>
                                    <label style="font-size: 0.5156rem; font-weight: 500; color: #374151; margin-bottom: 0.0938rem; display: block;">Allow Over 100%</label>
                                    <label style="display: flex; align-items: center; gap: 0.2812rem; padding: 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; cursor: pointer; background: white;">
                                        <input type="checkbox" id="allowOver100" style="width: 0.6562rem; height: 0.6562rem; cursor: pointer;">
                                        <span style="font-size: 0.5156rem; color: #374151;">Allow scores above 100%</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Applicable Channels -->
                        <div style="grid-column: 1 / -1;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.2812rem;">
                                <label style="font-size: 0.5156rem; font-weight: 500; color: #374151; margin: 0;">Applicable Channels <span style="color: #ef4444;">*</span></label>
                                <div style="display: flex; gap: 0.2812rem;">
                                    <button type="button" onclick="loadDeductiveScorecardTemplate()" style="padding: 0.1875rem 0.375rem; background: #1A733E; color: white; border: none; border-radius: 0.1875rem; font-size: 0.4688rem; cursor: pointer; font-weight: 500; display: flex; align-items: center; gap: 0.1875rem;">
                                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                            <polyline points="14 2 14 8 20 8"/>
                                            <line x1="16" y1="13" x2="8" y2="13"/>
                                            <line x1="16" y1="17" x2="8" y2="17"/>
                                            <polyline points="10 9 9 9 8 9"/>
                                        </svg>
                                        Load Template
                                    </button>
                                <button type="button" onclick="openChannelManagementModal()" style="padding: 0.1875rem 0.375rem; background: transparent; color: #1A733E; border: 0.0469rem solid #1A733E; border-radius: 0.1875rem; font-size: 0.4688rem; cursor: pointer; font-weight: 500;">+ Manage Channels</button>
                                </div>
                            </div>
                            <div id="channelsContainer" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.375rem; padding: 0.5625rem; background: white; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem;">
                                <!-- Channel checkboxes will be dynamically generated here -->
                            </div>
                            <small style="font-size: 0.4219rem; color: #6b7280; display: block; margin-top: 0.1875rem;">Select at least one channel where this scorecard will be used.</small>
                            
                            <!-- Default Scorecard Selection -->
                            <div id="defaultChannelsContainer" style="display: none; margin-top: 0.5625rem; padding: 0.5625rem; background: #f0fdf4; border: 0.0469rem solid #86efac; border-radius: 0.1875rem;">
                                <label style="font-size: 0.5156rem; font-weight: 600; color: #166534; margin-bottom: 0.375rem; display: block;">Set as Default Scorecard for Channels</label>
                                <div id="defaultChannelsCheckboxes" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.375rem;">
                                    <!-- Default channel checkboxes will be dynamically generated here -->
                                </div>
                                <small style="font-size: 0.4219rem; color: #166534; display: block; margin-top: 0.1875rem;">When multiple scorecards are active for a channel, the default one will be selected automatically.</small>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Parameters -->
                <div style="background: #f9fafb; border-radius: 0.2812rem; padding: 0.375rem; margin-bottom: 0.5625rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.375rem;">
                        <h3 style="font-size: 0.5625rem; font-weight: 600; color: #374151;" id="parametersHeader">Parameters</h3>
                        <div style="display: flex; gap: 0.2812rem;">
                            <button type="button" onclick="openBulkImportModal()" class="btn-secondary" style="padding: 0.1875rem 0.4688rem; font-size: 0.4688rem; display: flex; align-items: center; gap: 0.1875rem;">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                    <polyline points="17 8 12 3 7 8"/>
                                    <line x1="12" y1="3" x2="12" y2="15"/>
                                </svg>
                                Bulk Import
                            </button>
                            <button type="button" id="addParameterBtn" class="btn-secondary" style="padding: 0.1875rem 0.4688rem; font-size: 0.4688rem;">+ Add One</button>
                        </div>
                    </div>
                    
                    <!-- Parameter Headers -->
                    <div class="parameter-headers" style="display: grid; grid-template-columns: 2fr 0.8fr 1.2fr 1fr 1fr 1.2fr 2fr 0.6fr 0.6fr 0.4fr; gap: 0.2812rem; padding: 0.1875rem 0.2812rem; margin-bottom: 0.1875rem; font-size: 0.4688rem; font-weight: 600; color: #6b7280; text-transform: uppercase; letter-spacing: 0.025em;">
                        <div>Name</div>
                        <div>Points</div>
                        <div>Type</div>
                        <div>Category <span style="font-size: 0.375rem; font-weight: 400; color: #9ca3af;">(Severity)</span></div>
                        <div>Field Type</div>
                        <div>Field ID</div>
                        <div>Description</div>
                        <div style="text-align: center;">AI Audit</div>
                        <div id="aiPromptHeader" style="display: none;">AI Prompt</div>
                        <div style="text-align: center;">Fatal Error</div>
                        <div></div>
                    </div>
                    
                    <div id="parametersContainer">
                        <!-- Parameters will be added here -->
                    </div>
                </div>
            </form>
        </div>
        
        <!-- Form Actions -->
        <div style="display: flex; justify-content: flex-end; gap: 0.2812rem; padding: 0.375rem 0.5625rem; border-top: 0.0469rem solid #e5e7eb; background: #f9fafb;">
            <button type="button" id="cancelModalBtn" class="btn-secondary" style="font-size: 0.5156rem; padding: 0.2812rem 0.5625rem;">Cancel</button>
            <button type="button" onclick="document.getElementById('scorecardForm').requestSubmit()" class="btn-create" style="font-size: 0.5156rem; padding: 0.2812rem 0.5625rem;">Save Scorecard</button>
        </div>
    </div>
</div>

<!-- Channel Management Modal -->
<div id="channelManagementModal" class="modal">
    <div class="modal-content" style="max-width: 21.0938rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5625rem; border-bottom: 0.0469rem solid #e5e7eb; background: #f9fafb;">
            <h2 style="font-size: 0.75rem; font-weight: 600; color: #1A733E; margin: 0;">Manage Channels</h2>
            <button onclick="closeChannelManagementModal()" style="background: none; border: none; font-size: 1.125rem; cursor: pointer; color: #6b7280; padding: 0; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center;">&times;</button>
        </div>
        <div style="padding: 0.5625rem; max-height: 60vh; overflow-y: auto;">
            <!-- Add New Channel Section -->
            <div style="background: #f0fdf4; border: 0.0469rem solid #86efac; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.5625rem;">
                <h3 style="font-size: 0.5625rem; font-weight: 600; color: #166534; margin: 0 0 0.375rem 0;">Add New Channel</h3>
                <div style="display: flex; gap: 0.375rem;">
                    <input type="text" id="newChannelName" placeholder="Enter channel name..." style="flex: 1; padding: 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5625rem; font-family: 'Poppins', sans-serif;">
                    <button onclick="createChannel()" style="padding: 0.2812rem 0.5625rem; background: #1A733E; color: white; border: none; border-radius: 0.1875rem; font-size: 0.5625rem; font-weight: 600; cursor: pointer; white-space: nowrap;">+ Add</button>
                </div>
            </div>
            
            <!-- Existing Channels List -->
            <h3 style="font-size: 0.5625rem; font-weight: 600; color: #374151; margin: 0 0 0.375rem 0;">Existing Channels</h3>
            <div id="channelsListContainer" style="display: flex; flex-direction: column; gap: 0.375rem;">
                <!-- Channels will be listed here -->
            </div>
        </div>
        <div style="display: flex; justify-content: flex-end; padding: 0.5625rem; border-top: 0.0469rem solid #e5e7eb; background: #f9fafb;">
            <button onclick="closeChannelManagementModal()" style="padding: 0.375rem 0.75rem; background: #1A733E; color: white; border: none; border-radius: 0.1875rem; font-size: 0.5625rem; font-weight: 600; cursor: pointer;">Done</button>
        </div>
    </div>
</div>

<!-- Bulk Import Modal -->
<div id="bulkImportModal" class="modal">
    <div class="modal-content" style="max-width: 31.6406rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5625rem; border-bottom: 0.0469rem solid #e5e7eb; background: #f9fafb;">
            <h2 style="font-size: 0.75rem; font-weight: 600; color: #1A733E; margin: 0;">üìã Bulk Import Parameters</h2>
            <button onclick="closeBulkImportModal()" style="background: none; border: none; font-size: 1.125rem; cursor: pointer; color: #6b7280; padding: 0; width: 1.5rem; height: 1.5rem; display: flex; align-items: center; justify-content: center;">&times;</button>
        </div>
        <div style="padding: 0.75rem; max-height: 70vh; overflow-y: auto;">
            <!-- Instructions -->
            <div style="background: #eff6ff; border: 0.0469rem solid #60a5fa; border-radius: 0.2812rem; padding: 0.5625rem; margin-bottom: 0.75rem;">
                <h3 style="font-size: 0.6094rem; font-weight: 600; color: #1e40af; margin: 0 0 0.375rem 0;">How to Import</h3>
                <ul style="font-size: 0.5625rem; color: #1e3a8a; margin: 0; padding-left: 0.9375rem; line-height: 1.6;">
                    <li><strong>Option 1:</strong> Download the CSV template, fill it out, and upload it</li>
                    <li><strong>Option 2:</strong> Copy data from Excel/Google Sheets and paste it below</li>
                    <li><strong>Format:</strong> Parameter Name, Points, Type, Category, Field Type, Field ID, Description, Prompt, Enable AI Audit, Auto-Fail (one per line)</li>
                </ul>
            </div>

            <!-- Download Template Button -->
            <div style="margin-bottom: 0.75rem;">
                <button onclick="downloadCSVTemplate()" style="padding: 0.375rem 0.75rem; background: #1A733E; color: white; border: none; border-radius: 0.1875rem; font-size: 0.5625rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 0.375rem;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Download CSV Template
                </button>
            </div>

            <!-- File Upload -->
            <div style="margin-bottom: 0.75rem;">
                <label style="font-size: 0.5625rem; font-weight: 600; color: #374151; display: block; margin-bottom: 0.1875rem;">Upload CSV File</label>
                <input type="file" id="csvFileInput" accept=".csv,.txt" style="font-size: 0.5625rem; padding: 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; width: 100%; font-family: 'Poppins', sans-serif;">
            </div>

            <!-- OR Divider -->
            <div style="display: flex; align-items: center; gap: 0.375rem; margin: 0.75rem 0;">
                <div style="flex: 1; height: 0.0469rem; background: #d1d5db;"></div>
                <span style="font-size: 0.5625rem; font-weight: 600; color: #6b7280;">OR</span>
                <div style="flex: 1; height: 0.0469rem; background: #d1d5db;"></div>
            </div>

            <!-- Paste Area -->
            <div style="margin-bottom: 0.75rem;">
                <label style="font-size: 0.5625rem; font-weight: 600; color: #374151; display: block; margin-bottom: 0.1875rem;">Paste Data from Excel/CSV</label>
                <textarea id="bulkPasteArea" placeholder="Paste your data here... (Tab or comma separated)
Example:
Loss of Business	50	error	Critical Fail Error	counter	error_loss_business	Error that directly results in customer leaving	Check if conversation resulted in cancellation	true	true
Incorrect Information	10	error	Critical Error	counter	incorrect_info	Providing wrong information to customer	Detect instances of incorrect information	true	false
Good Empathy	5	achievement	Major	radio	good_empathy	Demonstrating understanding and care	Assess if agent showed empathy and understanding	false	false" style="width: 100%; min-height: 7.0312rem; padding: 0.375rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Courier New', monospace; resize: vertical;"></textarea>
                <small style="font-size: 0.4688rem; color: #6b7280; display: block; margin-top: 0.1875rem;">
                    üí° Tip: Copy directly from Excel/Google Sheets - it works with tabs or commas
                </small>
            </div>

            <!-- Parse Button -->
            <div style="margin-bottom: 0.75rem;">
                <button onclick="parseBulkData()" style="width: 100%; padding: 0.4688rem; background: #3b82f6; color: white; border: none; border-radius: 0.1875rem; font-size: 0.5625rem; font-weight: 600; cursor: pointer;">
                    üîç Preview Import
                </button>
            </div>

            <!-- Preview Area -->
            <div id="importPreviewArea" style="display: none;">
                <div style="border-top: 0.0469rem solid #e5e7eb; padding-top: 0.75rem; margin-top: 0.75rem;">
                    <h3 style="font-size: 0.6094rem; font-weight: 600; color: #374151; margin: 0 0 0.5625rem 0;">Preview (<span id="previewCount">0</span> parameters)</h3>
                    <div id="previewTable" style="max-height: 10.5469rem; overflow-y: auto; border: 0.0469rem solid #e5e7eb; border-radius: 0.2812rem;">
                        <!-- Preview will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Footer Actions -->
        <div style="display: flex; justify-content: space-between; gap: 0.375rem; padding: 0.5625rem; border-top: 0.0469rem solid #e5e7eb; background: #f9fafb;">
            <button onclick="closeBulkImportModal()" style="padding: 0.375rem 0.75rem; background: #f3f4f6; color: #374151; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5625rem; font-weight: 600; cursor: pointer;">Cancel</button>
            <button id="confirmImportBtn" onclick="confirmBulkImport()" style="padding: 0.375rem 0.75rem; background: #1A733E; color: white; border: none; border-radius: 0.1875rem; font-size: 0.5625rem; font-weight: 600; cursor: pointer; display: none;">
                ‚úÖ Import Parameters
            </button>
        </div>
    </div>
</div>

<script>
let scorecards = [];
let filteredScorecards = [];
let editingScorecard = null;
let originalParameters = []; // Stores original parameters when editing for change detection
let availableChannels = []; // Will be populated from users' team data
let parsedImportData = []; // Stores parsed bulk import data

// Load available channels from channels table
async function loadAvailableChannels() {
    try {
        const { data, error } = await window.supabaseClient
            .from('channels')
            .select('name')
            .eq('is_active', true)
            .order('name', { ascending: true });
        
        if (error) throw error;
        
        // Extract channel names
        availableChannels = data.map(channel => channel.name);
        
        console.log('Loaded channels from channels table:', availableChannels);
        
    } catch (error) {
        console.error('Error loading channels:', error);
        // Fallback to empty array if error
        availableChannels = [];
    }
}

// Initialize page
document.addEventListener('DOMContentLoaded', async function() {
    // Check page access using centralized access control
    if (!window.accessControl || !window.accessControl.enforcePageAccess('scorecards.html')) {
        return; // Access denied, user will be redirected
    }
    
    await loadAvailableChannels();
    await loadScorecards();
    initializeEventListeners();
});

function initializeEventListeners() {
    document.getElementById('cancelModalBtn').addEventListener('click', closeScorecardModal);
    document.getElementById('scorecardForm').addEventListener('submit', handleScorecardSubmit);
    document.getElementById('addParameterBtn').addEventListener('click', addParameterRow);
    document.getElementById('scoringType').addEventListener('change', handleScoringTypeChange);
    
    // Close modal on outside click
    document.getElementById('scorecardModal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeScorecardModal();
        }
    });
    
    document.getElementById('viewScorecardModal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeViewModal();
        }
    });
}

// Initialize channel checkboxes
function initializeChannelCheckboxes() {
    const container = document.getElementById('channelsContainer');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (availableChannels.length === 0) {
        container.innerHTML = '<p style="font-size: 0.5625rem; color: #6b7280; padding: 0.375rem;">No active channels found. Please <a href="channel-management.html" style="color: #1A733E; text-decoration: underline;">create channels</a> first.</p>';
        return;
    }
    
    // Add "Select All" checkbox at the top
    const selectAllWrapper = document.createElement('label');
    selectAllWrapper.style.cssText = 'display: flex; align-items: center; gap: 0.2812rem; cursor: pointer; padding: 0.2812rem; background: #f0fdf4; border: 0.0469rem solid #86efac; border-radius: 0.1875rem; margin-bottom: 0.1875rem; grid-column: 1 / -1; font-weight: 500;';
    
    const selectAllCheckbox = document.createElement('input');
    selectAllCheckbox.type = 'checkbox';
    selectAllCheckbox.id = 'selectAllChannels';
    selectAllCheckbox.className = 'select-all-checkbox';
    selectAllCheckbox.style.cssText = 'width: 0.6562rem; height: 0.6562rem; cursor: pointer; accent-color: #1A733E;';
    
    const selectAllLabel = document.createElement('span');
    selectAllLabel.textContent = 'Select All';
    selectAllLabel.style.cssText = 'font-size: 0.5625rem; color: #166534; user-select: none; font-weight: 600;';
    
    selectAllWrapper.appendChild(selectAllCheckbox);
    selectAllWrapper.appendChild(selectAllLabel);
    container.appendChild(selectAllWrapper);
    
    // Add event listener for select all
    selectAllCheckbox.addEventListener('change', function() {
        const checkboxes = document.querySelectorAll('.channel-checkbox');
        checkboxes.forEach(cb => {
            cb.checked = this.checked;
        });
        updateSelectAllState();
        updateDefaultChannelsUI();
    });
    
    // Add individual channel checkboxes
    availableChannels.forEach(channel => {
        const checkboxWrapper = document.createElement('label');
        checkboxWrapper.style.cssText = 'display: flex; align-items: center; gap: 0.2812rem; cursor: pointer; padding: 0.1875rem;';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.name = 'channels';
        checkbox.value = channel;
        checkbox.className = 'channel-checkbox';
        checkbox.style.cssText = 'width: 0.6562rem; height: 0.6562rem; cursor: pointer; accent-color: #1A733E;';
        
        // Add event listener to update select all state when individual checkboxes change
        checkbox.addEventListener('change', function() {
            updateSelectAllState();
            updateDefaultChannelsUI();
        });
        
        const label = document.createElement('span');
        label.textContent = channel;
        label.style.cssText = 'font-size: 0.5156rem; color: #374151; user-select: none;';
        
        checkboxWrapper.appendChild(checkbox);
        checkboxWrapper.appendChild(label);
        container.appendChild(checkboxWrapper);
    });
    
    // Initialize select all state
    updateSelectAllState();
}

// Update select all checkbox state based on individual checkboxes
function updateSelectAllState() {
    const selectAllCheckbox = document.getElementById('selectAllChannels');
    if (!selectAllCheckbox) return;
    
    const checkboxes = document.querySelectorAll('.channel-checkbox');
    const checkedCount = document.querySelectorAll('.channel-checkbox:checked').length;
    
    if (checkboxes.length === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else if (checkedCount === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else if (checkedCount === checkboxes.length) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
    } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
    }
}

// Get selected channels
function getSelectedChannels() {
    const checkboxes = document.querySelectorAll('.channel-checkbox:checked');
    return Array.from(checkboxes).map(cb => cb.value);
}

// Set selected channels (for editing)
function setSelectedChannels(channelsString) {
    // Uncheck all first
    document.querySelectorAll('.channel-checkbox').forEach(cb => cb.checked = false);
    
    if (!channelsString) {
        updateSelectAllState();
        updateDefaultChannelsUI();
        return;
    }
    
    // Parse comma-separated string and check matching boxes
    const channels = channelsString.split(',').map(c => c.trim());
    channels.forEach(channel => {
        const checkbox = document.querySelector(`.channel-checkbox[value="${channel}"]`);
        if (checkbox) checkbox.checked = true;
    });
    
    // Update select all state after setting channels
    updateSelectAllState();
    updateDefaultChannelsUI();
}

// Update default channels UI based on selected channels
function updateDefaultChannelsUI() {
    const selectedChannels = getSelectedChannels();
    const defaultContainer = document.getElementById('defaultChannelsContainer');
    const defaultCheckboxes = document.getElementById('defaultChannelsCheckboxes');
    
    if (selectedChannels.length === 0) {
        defaultContainer.style.display = 'none';
        return;
    }
    
    // Show the default channels section
    defaultContainer.style.display = 'block';
    
    // Clear existing checkboxes
    defaultCheckboxes.innerHTML = '';
    
    // Create checkboxes for each selected channel
    selectedChannels.forEach(channel => {
        const checkboxWrapper = document.createElement('label');
        checkboxWrapper.style.cssText = 'display: flex; align-items: center; gap: 0.2812rem; cursor: pointer; padding: 0.1875rem;';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.name = 'defaultChannels';
        checkbox.value = channel;
        checkbox.className = 'default-channel-checkbox';
        checkbox.style.cssText = 'width: 0.6562rem; height: 0.6562rem; cursor: pointer; accent-color: #166534;';
        
        const label = document.createElement('span');
        label.textContent = `Default for ${channel}`;
        label.style.cssText = 'font-size: 0.5156rem; color: #166534; user-select: none; font-weight: 500;';
        
        checkboxWrapper.appendChild(checkbox);
        checkboxWrapper.appendChild(label);
        defaultCheckboxes.appendChild(checkboxWrapper);
    });
}

// Get selected default channels
function getDefaultChannels() {
    const checkboxes = document.querySelectorAll('.default-channel-checkbox:checked');
    return Array.from(checkboxes).map(cb => cb.value);
}

// Set default channels (for editing)
function setDefaultChannels(defaultChannelsString) {
    // Uncheck all first
    document.querySelectorAll('.default-channel-checkbox').forEach(cb => cb.checked = false);
    
    if (!defaultChannelsString) {
        return;
    }
    
    // Parse comma-separated string and check matching boxes
    const defaultChannels = defaultChannelsString.split(',').map(c => c.trim());
    defaultChannels.forEach(channel => {
        const checkbox = document.querySelector(`.default-channel-checkbox[value="${channel}"]`);
        if (checkbox) checkbox.checked = true;
    });
}

// Validate at least one channel is selected
function validateChannelSelection() {
    const selectedChannels = getSelectedChannels();
    return selectedChannels.length > 0;
}

// Load all scorecards
async function loadScorecards() {
    try {
        const { data, error } = await window.supabaseClient
            .from('scorecards')
            .select('*')
            .order('created_at', { ascending: false });
        
        if (error) throw error;
        
        scorecards = data || [];
        
        // Load audit counts for each scorecard
        await Promise.all(scorecards.map(async (scorecard) => {
            try {
                const { count, error: countError } = await window.supabaseClient
                    .from(scorecard.table_name)
                    .select('*', { count: 'exact', head: true });
                
                scorecard.audit_count = countError ? 0 : (count || 0);
            } catch (e) {
                scorecard.audit_count = 0;
            }
        }));
        
        // Apply filters (respects the status filter default value)
        filterScorecards();
    } catch (error) {
        console.error('Error loading scorecards:', error);
        document.getElementById('scorecardsTableBody').innerHTML = 
            '<tr><td colspan="9" style="text-align: center; padding: 1.5rem; color: #ef4444;">Error loading scorecards: ' + error.message + '</td></tr>';
    }
}

function updateStatistics() {
    const total = scorecards.length;
    const active = scorecards.filter(s => s.is_active).length;
    const inactive = total - active;
    
    document.getElementById('totalScorecards').textContent = total;
    document.getElementById('activeScorecards').textContent = active;
    document.getElementById('inactiveScorecards').textContent = inactive;
    document.getElementById('scorecardsCount').textContent = `${filteredScorecards.length} Scorecard${filteredScorecards.length !== 1 ? 's' : ''}`;
}

function renderScorecards() {
    const tbody = document.getElementById('scorecardsTableBody');
    
    if (filteredScorecards.length === 0) {
        tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; padding: 1.5rem; color: #6b7280;">No scorecards found</td></tr>';
        return;
    }
    
    tbody.innerHTML = filteredScorecards.map(scorecard => createScorecardRow(scorecard)).join('');
    updateStatistics();
}

function createScorecardRow(scorecard) {
    const statusBadge = scorecard.is_active 
        ? '<span class="status-badge status-active">Active</span>'
        : '<span class="status-badge status-inactive">Inactive</span>';
    
    const versionBadge = scorecard.version && scorecard.version > 1 
        ? `<span class="version-badge">v${scorecard.version}</span>`
        : '<span class="version-badge version-badge-v1">v1</span>';
    
    const createdDate = scorecard.created_at ? new Date(scorecard.created_at).toLocaleDateString() : 'N/A';
    
    const scoringTypeLabels = {
        'deductive': 'Deductive',
        'additive': 'Additive',
        'hybrid': 'Hybrid'
    };
    const scoringTypeColors = {
        'deductive': '#ef4444',
        'additive': '#10b981',
        'hybrid': '#3b82f6'
    };
    const scoringTypeLabel = scoringTypeLabels[scorecard.scoring_type] || 'Deductive';
    const scoringTypeColor = scoringTypeColors[scorecard.scoring_type] || '#6b7280';
    
    return `
        <tr>
            <td>
                <div style="font-weight: 600; color: #1A733E;">${escapeHtml(scorecard.name)}</div>
            </td>
            <td>
                <span style="display: inline-flex; align-items: center; padding: 0.1875rem 0.375rem; border-radius: 0.1875rem; font-size: 0.4688rem; font-weight: 600; background-color: ${scoringTypeColor}15; color: ${scoringTypeColor}; text-transform: uppercase; letter-spacing: 0.05em;">
                    ${scoringTypeLabel}
                </span>
            </td>
            <td>
                <code style="font-size: 0.4688rem; background: #f3f4f6; padding: 0.0938rem 0.2812rem; border-radius: 0.1875rem; color: #374151;">${escapeHtml(scorecard.table_name)}</code>
            </td>
            <td>
                <span style="font-weight: 600; color: #374151;">${scorecard.passing_threshold}%</span>
            </td>
            <td>
                <span style="display: inline-flex; align-items: center; justify-content: center; padding: 0.0938rem 0.375rem; border-radius: 0.1875rem; font-size: 0.5156rem; font-weight: 600; ${scorecard.audit_count > 0 ? 'background-color: #dbeafe; color: #1e40af;' : 'background-color: #f3f4f6; color: #6b7280;'}">
                    ${scorecard.audit_count || 0}
                </span>
            </td>
            <td>${versionBadge}</td>
            <td>${statusBadge}</td>
            <td style="font-size: 0.5156rem; color: #6b7280;">${createdDate}</td>
            <td style="text-align: center;">
                <div style="display: flex; gap: 0.1875rem; justify-content: center;">
                    <button onclick="viewScorecard('${scorecard.id}')" class="btn-action" title="View Details">
                        <svg style="width: 0.6562rem; height: 0.6562rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                    </button>
                    <button onclick="editScorecard('${scorecard.id}')" class="btn-action btn-action-primary" title="Edit">
                        <svg style="width: 0.6562rem; height: 0.6562rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                        </svg>
                    </button>
                    <button onclick="toggleScorecardStatus('${scorecard.id}', ${!scorecard.is_active})" class="btn-action ${scorecard.is_active ? 'btn-action-danger' : 'btn-action-success'}" title="${scorecard.is_active ? 'Deactivate' : 'Activate'}">
                        ${scorecard.is_active 
                            ? '<svg style="width: 0.6562rem; height: 0.6562rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"/><line x1="12" y1="2" x2="12" y2="12"/></svg>'
                            : '<svg style="width: 0.6562rem; height: 0.6562rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="8 12 12 16 16 12"/><line x1="12" y1="8" x2="12" y2="16"/></svg>'
                        }
                    </button>
                    ${(scorecard.audit_count === 0 || typeof scorecard.audit_count === 'undefined')
                        ? `<button onclick="deleteScorecard('${scorecard.id}', '${escapeHtml(scorecard.table_name)}')" class="btn-action btn-action-danger" title="Delete Scorecard">
                            <svg style="width: 0.6562rem; height: 0.6562rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"/>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                                <line x1="10" y1="11" x2="10" y2="17"/>
                                <line x1="14" y1="11" x2="14" y2="17"/>
                            </svg>
                        </button>`
                        : `<button onclick="showCannotDeleteMessage('${escapeHtml(scorecard.name)}', ${scorecard.audit_count})" class="btn-action" style="background-color: #f3f4f6; color: #9ca3af; cursor: not-allowed;" title="Cannot delete: Contains ${scorecard.audit_count} audit report(s)">
                            <svg style="width: 0.6562rem; height: 0.6562rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="5" y="11" width="14" height="10" rx="2" ry="2"/>
                                <path d="M12 17a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/>
                                <path d="M8 11V7a4 4 0 0 1 8 0v4"/>
                            </svg>
                        </button>`
                    }
                </div>
            </td>
        </tr>
    `;
}

function filterScorecards() {
    // Show all scorecards by default (no filtering)
    filteredScorecards = scorecards;
    renderScorecards();
}

function refreshScorecards() {
    loadScorecards();
}

// View scorecard details
async function viewScorecard(scorecardId) {
    const scorecard = scorecards.find(s => s.id === scorecardId);
    if (!scorecard) return;
    
    try {
        const { data: parameters, error } = await window.supabaseClient
            .from('scorecard_parameters')
            .select('*')
            .eq('scorecard_id', scorecardId)
            .order('display_order', { ascending: true });
        
        if (error) throw error;
        
        let parametersHtml = '';
        parameters.forEach(param => {
            parametersHtml += `
                <div style="padding: 0.4688rem; background: white; border: 0.0352rem solid #e5e7eb; border-radius: 0.1875rem; margin-bottom: 0.375rem;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.1875rem;">
                        <strong style="color: #1A733E; font-size: 0.6094rem;">${escapeHtml(param.error_name)}</strong>
                        <span style="background: #1A733E; color: white; padding: 0.0938rem 0.375rem; border-radius: 0.1875rem; font-size: 0.5156rem; font-weight: 600;">-${param.penalty_points} pts</span>
                    </div>
                    ${param.description ? `<div style="font-size: 0.5625rem; color: #374151; margin-bottom: 0.1875rem; font-style: italic; white-space: pre-wrap;">${escapeHtml(param.description)}</div>` : ''}
                    <div style="font-size: 0.5156rem; color: #6b7280; display: flex; gap: 0.375rem; align-items: center; margin-bottom: ${(param.enable_ai_audit && param.prompt) ? '0.375rem' : '0'};">
                        <span>${param.error_category}</span>
                        <span>‚Ä¢</span>
                        <code style="background: #f3f4f6; padding: 0.0938rem 0.2812rem; border-radius: 0.1875rem; font-size: 0.4688rem;">${param.field_id}</code>
                        ${param.enable_ai_audit ? `<span style="background: #1A733E; color: white; padding: 0.0938rem 0.2812rem; border-radius: 0.1875rem; font-size: 0.4688rem; font-weight: 500;">AI Audit</span>` : ''}
                    </div>
                    ${param.enable_ai_audit && param.prompt ? `
                    <div style="padding: 0.375rem; background: #f0fdf4; border: 0.0352rem solid #86efac; border-radius: 0.1875rem; margin-top: 0.375rem;">
                        <div style="font-size: 0.4688rem; color: #166534; font-weight: 600; margin-bottom: 0.1875rem;">AI Prompt:</div>
                        <div style="font-size: 0.5156rem; color: #166534; white-space: pre-wrap; line-height: 1.4;">${escapeHtml(param.prompt)}</div>
                    </div>
                    ` : ''}
                </div>
            `;
        });
        
        document.getElementById('viewModalTitle').textContent = scorecard.name;
        document.getElementById('viewModalBody').innerHTML = `
            <div>
                <p style="margin-bottom: 0.75rem; color: #6b7280; font-size: 0.6094rem; line-height: 1.5; white-space: pre-wrap;">${escapeHtml(scorecard.description || 'No description provided')}</p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(5.2734rem, 1fr)); gap: 0.5625rem; margin-bottom: 0.9375rem; padding: 0.5625rem; background: #f9fafb; border-radius: 0.375rem;">
                    <div>
                        <p style="font-size: 0.5156rem; color: #6b7280; margin-bottom: 0.1875rem;">Passing Threshold</p>
                        <p style="font-size: 0.75rem; font-weight: 700; color: #1A733E; margin: 0;">${scorecard.passing_threshold}%</p>
                    </div>
                    <div>
                        <p style="font-size: 0.5156rem; color: #6b7280; margin-bottom: 0.1875rem;">Version</p>
                        <p style="font-size: 0.75rem; font-weight: 700; color: #374151; margin: 0;">v${scorecard.version || 1}</p>
                    </div>
                    <div style="grid-column: 1 / -1;">
                        <p style="font-size: 0.5156rem; color: #6b7280; margin-bottom: 0.1875rem;">Table Name</p>
                        <code style="font-size: 0.5625rem; font-weight: 500; color: #374151; background: white; padding: 0.1875rem 0.375rem; border-radius: 0.1875rem; display: inline-block;">${escapeHtml(scorecard.table_name)}</code>
                    </div>
                    <div style="grid-column: 1 / -1;">
                        <p style="font-size: 0.5156rem; color: #6b7280; margin-bottom: 0.1875rem;">Applicable Channels</p>
                        <div style="display: flex; flex-wrap: wrap; gap: 0.2812rem; margin-top: 0.1875rem;">
                            ${(scorecard.channels || '').split(',').map(ch => `<span style="background: #1A733E; color: white; padding: 0.0938rem 0.375rem; border-radius: 0.1875rem; font-size: 0.4688rem; font-weight: 500;">${escapeHtml(ch.trim())}</span>`).join('')}
                        </div>
                    </div>
                </div>
                
                <h4 style="font-size: 0.6094rem; font-weight: 600; color: #374151; margin-bottom: 0.5625rem; padding-bottom: 0.1875rem; border-bottom: 0.0352rem solid #e5e7eb;">
                    Error Parameters <span style="color: #6b7280; font-weight: 400;">(${parameters.length})</span>
                </h4>
                
                <div style="max-height: 14.0625rem; overflow-y: auto;">
                    ${parametersHtml}
                </div>
            </div>
        `;
        
        document.getElementById('viewScorecardModal').classList.add('active');
    } catch (error) {
        console.error('Error loading scorecard details:', error);
        alert('Error loading scorecard details: ' + error.message);
    }
}

function closeViewModal() {
    document.getElementById('viewScorecardModal').classList.remove('active');
}

// Edit scorecard
async function editScorecard(scorecardId) {
    const scorecard = scorecards.find(s => s.id === scorecardId);
    if (scorecard) {
        await openScorecardModal(scorecard);
    }
}

// Open modal for creating/editing scorecard
async function openScorecardModal(scorecard = null) {
    editingScorecard = scorecard;
    const modal = document.getElementById('scorecardModal');
    const modalTitle = document.getElementById('modalTitle');
    const form = document.getElementById('scorecardForm');
    
    form.reset();
    document.getElementById('parametersContainer').innerHTML = '';
    
    // Initialize channel checkboxes
    initializeChannelCheckboxes();
    
    if (scorecard) {
        modalTitle.textContent = 'Edit Scorecard';
        document.getElementById('scorecardId').value = scorecard.id;
        document.getElementById('scorecardName').value = scorecard.name;
        document.getElementById('scorecardDescription').value = scorecard.description || '';
        document.getElementById('passingThreshold').value = scorecard.passing_threshold;
        document.getElementById('tableName').value = scorecard.table_name;
        document.getElementById('tableName').readOnly = true;
        document.getElementById('scoringType').value = scorecard.scoring_type || 'deductive';
        document.getElementById('maxBonusPoints').value = scorecard.max_bonus_points || 20;
        document.getElementById('allowOver100').checked = scorecard.allow_over_100 || false;
        
        // Set selected channels
        setSelectedChannels(scorecard.channels || '');
        
        // Set default channels if they exist
        if (scorecard.default_for_channels) {
            setDefaultChannels(scorecard.default_for_channels);
        }
        
        // Trigger scoring type change to show/hide hybrid options
        handleScoringTypeChange();
        
        await loadScorecardParameters(scorecard.id);
    } else {
        modalTitle.textContent = 'Create New Scorecard';
        document.getElementById('tableName').readOnly = false;
        document.getElementById('scoringType').value = 'deductive';
        handleScoringTypeChange();
        addParameterRow();
        
        // Clear channel selection and original parameters for new scorecard
        setSelectedChannels('');
        originalParameters = [];
    }
    
    modal.classList.add('active');
}

function closeScorecardModal() {
    document.getElementById('scorecardModal').classList.remove('active');
    editingScorecard = null;
    originalParameters = []; // Clear original parameters
}

// Load deductive scorecard template with pre-configured error parameters
async function loadDeductiveScorecardTemplate() {
    await openScorecardModal();
    
    // Generate unique table name with timestamp to avoid conflicts
    const timestamp = Date.now();
    const uniqueTableName = `standard_deductive_scorecard_${timestamp}`;
    
    // Set scorecard name and basic info
    document.getElementById('scorecardName').value = 'Standard Deductive Scorecard';
    document.getElementById('scorecardDescription').value = 'Comprehensive error-based quality scorecard with industry-standard error categories';
    document.getElementById('passingThreshold').value = '90';
    document.getElementById('tableName').value = uniqueTableName;
    document.getElementById('scoringType').value = 'deductive';
    handleScoringTypeChange();
    
    // Clear any existing parameters
    document.getElementById('parametersContainer').innerHTML = '';
    
    // Define all error parameters based on the scoring system
    const errorParameters = [
        // Critical Fail Error (50)
        { error_name: 'Error Leading to a Loss of Business', penalty_points: 50, parameter_type: 'error', error_category: 'Critical Fail Error', field_type: 'counter', field_id: 'error_loss_business', description: 'Error that directly results in customer leaving or cancelling service', is_fail_all: true },
        { error_name: 'Zero Tolerance', penalty_points: 50, parameter_type: 'error', error_category: 'Critical Fail Error', field_type: 'counter', field_id: 'zero_tolerance', description: 'Violation of zero tolerance policy or major compliance breach', is_fail_all: true },
        
        // Critical Error (10)
        { error_name: 'Incorrect Information', penalty_points: 10, parameter_type: 'error', error_category: 'Critical Error', field_type: 'counter', field_id: 'incorrect_information', description: 'Providing wrong information to customer that could cause confusion or issues', is_fail_all: false },
        { error_name: 'Lack of Professionalism', penalty_points: 10, parameter_type: 'error', error_category: 'Critical Error', field_type: 'counter', field_id: 'lack_professionalism', description: 'Unprofessional behavior, language, or tone during interaction', is_fail_all: false },
        { error_name: 'Lack of Escalation/Unnecessary Escalation', penalty_points: 10, parameter_type: 'error', error_category: 'Critical Error', field_type: 'counter', field_id: 'escalation_issue', description: 'Failed to escalate when needed, or escalated unnecessarily', is_fail_all: false },
        { error_name: 'Lack of Investigation', penalty_points: 10, parameter_type: 'error', error_category: 'Critical Error', field_type: 'counter', field_id: 'lack_investigation', description: 'Insufficient investigation into customer issue or concern', is_fail_all: false },
        
        // Significant Error (10)
        { error_name: 'Lack of Empathy', penalty_points: 10, parameter_type: 'error', error_category: 'Significant Error', field_type: 'counter', field_id: 'lack_empathy', description: 'Not showing appropriate understanding or concern for customer situation', is_fail_all: false },
        { error_name: 'Lack of Knowledge', penalty_points: 10, parameter_type: 'error', error_category: 'Significant Error', field_type: 'counter', field_id: 'lack_knowledge', description: 'Lacking necessary product or service knowledge to assist customer', is_fail_all: false },
        { error_name: 'Lack of Information about Internal Communications', penalty_points: 10, parameter_type: 'error', error_category: 'Significant Error', field_type: 'counter', field_id: 'lack_internal_comms', description: 'Not properly communicating or following up internally as required', is_fail_all: false },
        
        // Major Error (5)
        { error_name: 'Missing Information', penalty_points: 5, parameter_type: 'error', error_category: 'Major Error', field_type: 'counter', field_id: 'missing_information', description: 'Important information missing from interaction or documentation', is_fail_all: false },
        { error_name: 'Outdated Macro Usage', penalty_points: 5, parameter_type: 'error', error_category: 'Major Error', field_type: 'counter', field_id: 'outdated_macro', description: 'Using outdated templates, macros, or scripts', is_fail_all: false },
        { error_name: 'Information Overload', penalty_points: 5, parameter_type: 'error', error_category: 'Major Error', field_type: 'counter', field_id: 'information_overload', description: 'Providing too much information at once, overwhelming the customer', is_fail_all: false },
        { error_name: 'Grammatical Errors', penalty_points: 5, parameter_type: 'error', error_category: 'Major Error', field_type: 'counter', field_id: 'grammatical_errors', description: 'Spelling or grammar mistakes in written communication', is_fail_all: false },
        
        // Minor Error (2.5)
        { error_name: 'Inadequate engagement/excessive engagement', penalty_points: 2.5, parameter_type: 'error', error_category: 'Minor Error', field_type: 'counter', field_id: 'engagement_issue', description: 'Too little or too much customer engagement during interaction', is_fail_all: false },
        { error_name: 'Missing Minimal information', penalty_points: 2.5, parameter_type: 'error', error_category: 'Minor Error', field_type: 'counter', field_id: 'missing_minimal_info', description: 'Minor information gaps that do not significantly impact service delivery', is_fail_all: false }
    ];
    
    // Add all parameters to the form
    errorParameters.forEach(param => {
        addParameterRow(param);
    });
    
    // Show success message
    await window.confirmationDialog.show({
        title: 'Template Loaded',
        message: 'Deductive scorecard template has been loaded with 16 pre-configured error parameters. Review and adjust as needed, then save.',
        confirmText: 'OK',
        showCancel: false,
        type: 'info'
    });
}

function handleScoringTypeChange() {
    const scoringType = document.getElementById('scoringType').value;
    const helpText = document.getElementById('scoringTypeHelp');
    const parametersHeader = document.getElementById('parametersHeader');
    const hybridOptions = document.getElementById('hybridOptions');
    
    // Update help text
    switch(scoringType) {
        case 'deductive':
            helpText.innerHTML = '<strong>Deductive:</strong> Start perfect, lose points for mistakes.';
            parametersHeader.textContent = 'Error Parameters';
            hybridOptions.style.display = 'none';
            break;
        case 'additive':
            helpText.innerHTML = '<strong>Additive:</strong> Start at zero, earn points for achievements.';
            parametersHeader.textContent = 'Achievement Parameters';
            hybridOptions.style.display = 'none';
            break;
        case 'hybrid':
            helpText.innerHTML = '<strong>Hybrid:</strong> Deduct for errors, reward for excellence.';
            parametersHeader.textContent = 'Parameters (Errors & Achievements)';
            hybridOptions.style.display = 'block';
            break;
    }
    
    // Update all existing parameter rows to reflect new restrictions
    updateAllParameterRowRestrictions();
}

// Update parameter type restrictions for all rows based on scoring type
function updateAllParameterRowRestrictions() {
    const rows = document.querySelectorAll('.parameter-row');
    rows.forEach(row => updateParameterRowRestrictions(row));
}

// Update parameter type dropdown restrictions based on scoring type
function updateParameterRowRestrictions(row) {
    const scoringType = document.getElementById('scoringType').value;
    const paramTypeSelect = row.querySelector('.param-type-select');
    const fieldTypeSelect = row.querySelector('.field-type-select');
    
    if (!paramTypeSelect) return;
    
    const errorOption = paramTypeSelect.querySelector('option[value="error"]');
    const achievementOption = paramTypeSelect.querySelector('option[value="achievement"]');
    const bonusOption = paramTypeSelect.querySelector('option[value="bonus"]');
    
    // Reset all parameter type options
    errorOption.disabled = false;
    achievementOption.disabled = false;
    bonusOption.disabled = false;
    
    // Reset field type options
    if (fieldTypeSelect) {
        const counterOption = fieldTypeSelect.querySelector('option[value="counter"]');
        const radioOption = fieldTypeSelect.querySelector('option[value="radio"]');
        
        if (counterOption) counterOption.disabled = false;
        if (radioOption) radioOption.disabled = false;
    }
    
    // Apply restrictions based on scoring type
    switch(scoringType) {
        case 'deductive':
            achievementOption.disabled = true;
            bonusOption.disabled = true;
            // Auto-select error if current value is invalid
            if (paramTypeSelect.value === 'achievement' || paramTypeSelect.value === 'bonus' || paramTypeSelect.value === '') {
                paramTypeSelect.value = 'error';
                updateCategoryField(paramTypeSelect);
            }
            // Deductive ONLY allows counter (errors can accumulate multiple times)
            if (fieldTypeSelect) {
                const radioOption = fieldTypeSelect.querySelector('option[value="radio"]');
                if (radioOption) {
                    radioOption.disabled = true;
                    // Auto-switch to counter if radio is currently selected
                    if (fieldTypeSelect.value === 'radio') {
                        fieldTypeSelect.value = 'counter';
                    }
                }
            }
            break;
            
        case 'additive':
            errorOption.disabled = true;
            bonusOption.disabled = true;
            // Auto-select achievement if current value is invalid
            if (paramTypeSelect.value === 'error' || paramTypeSelect.value === 'bonus' || paramTypeSelect.value === '') {
                paramTypeSelect.value = 'achievement';
                updateCategoryField(paramTypeSelect);
            }
            // Additive ONLY allows radio (achievements are binary yes/no)
            if (fieldTypeSelect) {
                const counterOption = fieldTypeSelect.querySelector('option[value="counter"]');
                if (counterOption) {
                    counterOption.disabled = true;
                    // Auto-switch to radio if counter is currently selected
                    if (fieldTypeSelect.value === 'counter') {
                        fieldTypeSelect.value = 'radio';
                    }
                }
            }
            break;
            
        case 'hybrid':
            // All options available for hybrid (can have errors with counters, achievements with radio)
            break;
    }
    
    // Update category field based on current parameter type
    updateCategoryField(paramTypeSelect);
}

// Update category field based on parameter type
// Category is ALWAYS required - it represents severity/importance for ALL parameter types
function updateCategoryField(paramTypeSelect) {
    const row = paramTypeSelect.closest('.parameter-row');
    const categorySelect = row.querySelector('.param-category-select');
    
    if (!categorySelect) return;
    
    // Category is always required regardless of parameter type
    // It represents the severity/importance of the parameter
    categorySelect.required = true;
    categorySelect.style.opacity = '1';
    categorySelect.disabled = false;
    categorySelect.style.cursor = 'pointer';
}

async function loadScorecardParameters(scorecardId) {
    try {
        const { data, error } = await window.supabaseClient
            .from('scorecard_parameters')
            .select('*')
            .eq('scorecard_id', scorecardId)
            .order('display_order', { ascending: true});
        
        if (error) throw error;
        
        // Store original parameters for change detection
        originalParameters = data ? JSON.parse(JSON.stringify(data)) : [];
        
        const container = document.getElementById('parametersContainer');
        container.innerHTML = '';
        
        if (data && data.length > 0) {
            data.forEach(param => addParameterRow(param));
        } else {
            addParameterRow();
        }
        
        // Update layout after loading parameters
        setTimeout(() => {
            updateAllParameterRowsLayout();
        }, 100);
    } catch (error) {
        console.error('Error loading parameters:', error);
    }
}

function addParameterRow(param = null) {
    const container = document.getElementById('parametersContainer');
    const scoringType = document.getElementById('scoringType').value;
    
    // Determine default parameter type based on scoring type
    let defaultParamType = '';
    let defaultFieldType = '';
    
    if (param) {
        defaultParamType = param.parameter_type || '';
        defaultFieldType = param.field_type || 'counter';
    } else {
        if (scoringType === 'deductive') {
            defaultParamType = 'error';
            defaultFieldType = 'counter';
        } else if (scoringType === 'additive') {
            defaultParamType = 'achievement';
            defaultFieldType = 'radio'; // Additive must use radio (achievements are binary)
        } else {
            defaultFieldType = 'counter';
        }
    }
    
    // Determine if this should be marked as auto-fail by default
    const isFailAll = param ? (param.is_fail_all === true) : false;
    
    const row = document.createElement('div');
    row.className = 'parameter-row';
    row.innerHTML = `
        <input type="text" class="param-name-input" placeholder="Parameter Name" value="${param ? escapeHtml(param.error_name) : ''}" required style="padding: 0.1875rem 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif;">
        <input type="number" class="param-points-input" placeholder="Points" value="${param ? param.penalty_points : ''}" min="0" step="0.01" required style="padding: 0.1875rem 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif;">
        <select required class="param-type-select" style="padding: 0.1875rem 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif;" title="Parameter Type" onchange="updateCategoryField(this)">
            <option value="">Type</option>
            <option value="error" ${defaultParamType === 'error' ? 'selected' : ''}>Error</option>
            <option value="achievement" ${defaultParamType === 'achievement' ? 'selected' : ''}>Achievement</option>
            <option value="bonus" ${defaultParamType === 'bonus' ? 'selected' : ''}>Bonus</option>
        </select>
        <select class="param-category-select" style="padding: 0.1875rem 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif;" title="Category">
            <option value="">Category</option>
            <option value="Critical Fail Error" ${param && param.error_category === 'Critical Fail Error' ? 'selected' : ''}>Critical Fail</option>
            <option value="Critical Error" ${param && param.error_category === 'Critical Error' ? 'selected' : ''}>Critical</option>
            <option value="Significant Error" ${param && param.error_category === 'Significant Error' ? 'selected' : ''}>Significant</option>
            <option value="Major Error" ${param && param.error_category === 'Major Error' ? 'selected' : ''}>Major</option>
            <option value="Minor Error" ${param && param.error_category === 'Minor Error' ? 'selected' : ''}>Minor</option>
        </select>
        <select required class="field-type-select" style="padding: 0.1875rem 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif;" title="Field Type">
            <option value="counter" ${defaultFieldType === 'counter' ? 'selected' : ''}>Counter</option>
            <option value="radio" ${defaultFieldType === 'radio' ? 'selected' : ''}>Yes/No</option>
        </select>
        <input type="text" class="param-field-id-input" placeholder="field_id" value="${param ? escapeHtml(param.field_id) : ''}" required style="padding: 0.1875rem 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif;">
        <input type="text" class="param-description-input" placeholder="Description (optional)" value="${param && param.description ? escapeHtml(param.description) : ''}" style="padding: 0.1875rem 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif;">
        <label style="display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Enable AI Audit for this parameter">
            <input type="checkbox" class="param-enable-ai-audit-checkbox" ${param && param.enable_ai_audit ? 'checked' : ''} style="width: 0.75rem; height: 0.75rem; cursor: pointer; accent-color: #1A733E;">
        </label>
        <input type="text" class="param-prompt-input" placeholder="AI Prompt (optional)" value="${param && param.prompt ? escapeHtml(param.prompt) : ''}" style="padding: 0.1875rem 0.2812rem; border: 0.0469rem solid #d1d5db; border-radius: 0.1875rem; font-size: 0.5156rem; font-family: 'Poppins', sans-serif; display: ${param && param.enable_ai_audit ? 'block' : 'none'};" title="AI prompt for this parameter when AI audit is enabled" disabled="${param && param.enable_ai_audit ? '' : 'disabled'}">
        <label style="display: flex; align-items: center; justify-content: center; cursor: pointer;" title="Causes automatic fail regardless of score">
            <input type="checkbox" class="is-fail-all-checkbox" ${isFailAll ? 'checked' : ''} style="width: 0.75rem; height: 0.75rem; cursor: pointer; accent-color: #ef4444;">
        </label>
        <button type="button" onclick="this.parentElement.remove()" style="padding: 0.1875rem; background: #ef4444; color: white; border: none; border-radius: 0.1875rem; cursor: pointer; font-size: 0.6562rem; line-height: 1; display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">√ó</button>
    `;
    
    container.appendChild(row);
    
    // Apply restrictions after adding to DOM
    updateParameterRowRestrictions(row);
    
    // Set up AI audit checkbox toggle for this parameter
    const enableAiAuditCheckbox = row.querySelector('.param-enable-ai-audit-checkbox');
    const promptInput = row.querySelector('.param-prompt-input');
    
    if (enableAiAuditCheckbox && promptInput) {
        // Set initial state
        const isEnabled = enableAiAuditCheckbox.checked;
        promptInput.style.display = isEnabled ? 'block' : 'none';
        promptInput.disabled = !isEnabled;
        
        // Add event listener to toggle prompt field
        enableAiAuditCheckbox.addEventListener('change', function() {
            const enabled = this.checked;
            promptInput.style.display = enabled ? 'block' : 'none';
            promptInput.disabled = !enabled;
            if (!enabled) {
                promptInput.value = ''; // Clear prompt when disabled
            }
            
            // Update grid layout
            updateParameterRowLayout(row);
        });
        
        // Update grid layout initially
        updateParameterRowLayout(row);
    }
}

// Update parameter row grid layout based on AI audit state
function updateParameterRowLayout(row) {
    const enableAiAuditCheckbox = row.querySelector('.param-enable-ai-audit-checkbox');
    const promptInput = row.querySelector('.param-prompt-input');
    
    if (enableAiAuditCheckbox && promptInput) {
        const isEnabled = enableAiAuditCheckbox.checked;
        if (isEnabled && promptInput.value.trim()) {
            row.classList.add('with-ai-prompt');
        } else {
            row.classList.remove('with-ai-prompt');
        }
    }
}

// Update all parameter rows layout
function updateAllParameterRowsLayout() {
    const parameterRows = document.querySelectorAll('.parameter-row');
    parameterRows.forEach(row => updateParameterRowLayout(row));
    
    // Update header row
    const headerRow = document.querySelector('.parameter-headers');
    const hasAnyEnabled = Array.from(parameterRows).some(row => {
        const checkbox = row.querySelector('.param-enable-ai-audit-checkbox');
        const promptInput = row.querySelector('.param-prompt-input');
        return checkbox && checkbox.checked && promptInput && promptInput.value.trim();
    });
    
    if (headerRow) {
        const aiPromptHeader = document.getElementById('aiPromptHeader');
        if (aiPromptHeader) {
            aiPromptHeader.style.display = hasAnyEnabled ? 'block' : 'none';
        }
        if (hasAnyEnabled) {
            headerRow.classList.add('with-ai-prompt');
        } else {
            headerRow.classList.remove('with-ai-prompt');
        }
    }
}


// Validate that parameter types are compatible with scoring type
function validateParameterTypes(scoringType, parameters) {
    const errorParams = parameters.filter(p => p.parameter_type === 'error');
    const achievementParams = parameters.filter(p => p.parameter_type === 'achievement');
    const bonusParams = parameters.filter(p => p.parameter_type === 'bonus');
    
    switch(scoringType) {
        case 'deductive':
            if (achievementParams.length > 0) {
                return 'Deductive scorecards cannot have Achievement parameters. Please remove them or change to Hybrid scoring type.';
            }
            if (bonusParams.length > 0) {
                return 'Deductive scorecards cannot have Bonus parameters. Please remove them or change to Hybrid scoring type.';
            }
            if (errorParams.length === 0) {
                return 'Deductive scorecards must have at least one Error parameter.';
            }
            // Validate that deductive parameters ONLY use counters (errors can occur multiple times)
            for (const param of parameters) {
                if (param.field_type === 'radio') {
                    return `Deductive scorecards cannot use Yes/No fields. Parameter "${param.error_name}" must use Counter field type. Errors can occur multiple times.`;
                }
            }
            break;
            
        case 'additive':
            if (errorParams.length > 0) {
                return 'Additive scorecards cannot have Error parameters. Please remove them or change to Hybrid scoring type.';
            }
            if (bonusParams.length > 0) {
                return 'Additive scorecards cannot have Bonus parameters. Please remove them or change to Hybrid scoring type.';
            }
            if (achievementParams.length === 0) {
                return 'Additive scorecards must have at least one Achievement parameter.';
            }
            // Validate that additive parameters ONLY use radio buttons (achievements are binary)
            for (const param of parameters) {
                if (param.field_type === 'counter') {
                    return `Additive scorecards cannot use Counter fields. Parameter "${param.error_name}" must use Yes/No field type. Achievements are binary (done or not done).`;
                }
            }
            break;
            
        case 'hybrid':
            // Hybrid can have any combination, but should have at least one parameter type
            if (errorParams.length === 0 && achievementParams.length === 0 && bonusParams.length === 0) {
                return 'Hybrid scorecards must have at least one parameter.';
            }
            break;
    }
    
    // Validate that all parameters have categories (category = severity for all types)
    for (const param of parameters) {
        if (!param.error_category || param.error_category === '') {
            return `Parameter "${param.error_name}" must have a category selected (category represents severity/importance).`;
        }
    }
    
    return null; // No errors
}

// Helper function to normalize parameter for comparison
function normalizeParameter(param) {
    return {
        error_name: param.error_name?.trim(),
        penalty_points: parseFloat(param.penalty_points),
        parameter_type: param.parameter_type?.toLowerCase(),
        error_category: param.error_category?.trim(),
        field_type: param.field_type?.toLowerCase(),
        field_id: param.field_id?.toLowerCase(),
        description: param.description?.trim() || null,
        enable_ai_audit: !!param.enable_ai_audit,
        prompt: param.prompt?.trim() || null,
        is_fail_all: !!param.is_fail_all
    };
}

// Check if parameters have changed (excluding descriptions - those don't require new version)
function parametersHaveChanged(originalParams, newParams) {
    if (originalParams.length !== newParams.length) return true;
    
    for (let i = 0; i < originalParams.length; i++) {
        const oldParam = normalizeParameter(originalParams[i]);
        const newParam = normalizeParameter(newParams[i]);
        
        // Exclude description from comparison - description changes don't require new version
        if (oldParam.error_name !== newParam.error_name ||
            oldParam.penalty_points !== newParam.penalty_points ||
            oldParam.parameter_type !== newParam.parameter_type ||
            oldParam.error_category !== newParam.error_category ||
            oldParam.field_type !== newParam.field_type ||
            oldParam.field_id !== newParam.field_id ||
            oldParam.is_fail_all !== newParam.is_fail_all) {
            return true;
        }
    }
    
    return false;
}

// Detect what changed between old and new scorecard
function detectChanges(oldScorecard, newData, newParameters) {
    const oldChannels = (oldScorecard.channels || '').split(',').map(c => c.trim()).filter(Boolean);
    const newChannels = (newData.channels || '').split(',').map(c => c.trim()).filter(Boolean);
    
    return {
        // Metadata changes (safe to update)
        nameChanged: oldScorecard.name !== newData.name,
        descriptionChanged: (oldScorecard.description || '') !== (newData.description || ''),
        thresholdChanged: parseFloat(oldScorecard.passing_threshold) !== parseFloat(newData.passing_threshold),
        
        // Channel changes
        channelsAdded: newChannels.filter(c => !oldChannels.includes(c)),
        channelsRemoved: oldChannels.filter(c => !newChannels.includes(c)),
        channelsChanged: oldChannels.sort().join(',') !== newChannels.sort().join(','),
        
        // Breaking changes (need new version)
        scoringTypeChanged: oldScorecard.scoring_type !== newData.scoring_type,
        parametersChanged: parametersHaveChanged(originalParameters, newParameters),
        
        // Hybrid-specific changes
        maxBonusChanged: (oldScorecard.max_bonus_points || 0) !== (newData.max_bonus_points || 0),
        allowOver100Changed: !!oldScorecard.allow_over_100 !== !!newData.allow_over_100
    };
}

async function handleScorecardSubmit(e) {
    e.preventDefault();
    
    const scorecardId = document.getElementById('scorecardId').value;
    const isEdit = !!scorecardId;
    
    const scoringType = document.getElementById('scoringType').value;
    
    // Validate channel selection
    if (!validateChannelSelection()) {
        await window.confirmationDialog.show({
            title: 'No Channels Selected',
            message: 'Please select at least one channel where this scorecard will be used.',
            confirmText: 'OK',
            type: 'warning'
        });
        return;
    }
    
    // Get selected channels as comma-separated string
    const selectedChannels = getSelectedChannels();
    const channelsString = selectedChannels.join(', ');
    
    // Get default channels as comma-separated string
    const defaultChannels = getDefaultChannels();
    const defaultChannelsString = defaultChannels.join(', ');
    
    // Get user email from localStorage (consistent with other functions in this file)
    const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
    const userEmail = userInfo.email || 'unknown';
    
    const scorecardData = {
        name: document.getElementById('scorecardName').value,
        description: document.getElementById('scorecardDescription').value,
        passing_threshold: parseFloat(document.getElementById('passingThreshold').value),
        table_name: document.getElementById('tableName').value.toLowerCase().replace(/[^a-z0-9_]/g, '_'),
        channels: channelsString,
        scoring_type: scoringType,
        created_by: userEmail,
        // Always include default_for_channels (even if empty) so it can be cleared
        default_for_channels: defaultChannelsString || null
    };
    
    // Add hybrid-specific fields
    if (scoringType === 'hybrid') {
        scorecardData.max_bonus_points = parseFloat(document.getElementById('maxBonusPoints').value) || 0;
        scorecardData.allow_over_100 = document.getElementById('allowOver100').checked;
    }
    
    const parametersContainer = document.getElementById('parametersContainer');
    const parameterRows = parametersContainer.querySelectorAll('.parameter-row');
    const parameters = [];
    
    parameterRows.forEach((row, index) => {
        // Use specific class selectors to ensure we get the correct values
        const nameInput = row.querySelector('.param-name-input');
        const pointsInput = row.querySelector('.param-points-input');
        const typeSelect = row.querySelector('.param-type-select');
        const categorySelect = row.querySelector('.param-category-select');
        const fieldTypeSelect = row.querySelector('.field-type-select');
        const fieldIdInput = row.querySelector('.param-field-id-input');
        const descriptionInput = row.querySelector('.param-description-input');
        const promptInput = row.querySelector('.param-prompt-input');
        const enableAiAuditCheckbox = row.querySelector('.param-enable-ai-audit-checkbox');
        const isFailAllCheckbox = row.querySelector('.is-fail-all-checkbox');
        
        // Validate that all required fields are present
        if (!nameInput || !pointsInput || !typeSelect || !categorySelect || !fieldTypeSelect || !fieldIdInput) {
            console.error('Missing required parameter fields in row', index, row);
            return; // Skip this row if required fields are missing
        }
        
        const paramType = typeSelect.value;
        const errorName = nameInput.value.trim();
        const points = parseFloat(pointsInput.value);
        const category = categorySelect.value.trim();
        const fieldType = fieldTypeSelect.value;
        const fieldId = fieldIdInput.value.replace(/[^a-zA-Z0-9_]/g, '');
        const description = descriptionInput ? descriptionInput.value.trim() : '';
        const enableAiAudit = enableAiAuditCheckbox ? enableAiAuditCheckbox.checked : false;
        const prompt = (enableAiAudit && promptInput) ? promptInput.value.trim() : null;
        
        // Skip empty rows
        if (!errorName || isNaN(points) || !paramType || !category || !fieldType || !fieldId) {
            console.warn('Skipping incomplete parameter row', index);
            return;
        }
        
        parameters.push({
            error_name: errorName,
            penalty_points: points,
            parameter_type: paramType,
            error_category: category,
            field_type: fieldType,
            field_id: fieldId,
            description: description || null,
            enable_ai_audit: enableAiAudit,
            prompt: prompt,
            points_direction: (paramType === 'error') ? 'subtract' : 'add',
            requires_feedback: true,
            display_order: index + 1,
            is_active: true,
            is_fail_all: isFailAllCheckbox ? isFailAllCheckbox.checked : false
        });
    });
    
    if (parameters.length === 0) {
        await window.confirmationDialog.show({
            title: 'No Parameters',
            message: 'Please add at least one parameter.',
            confirmText: 'OK',
            type: 'warning'
        });
        return;
    }
    
    // Validate parameter types match scoring type
    const validationError = validateParameterTypes(scoringType, parameters);
    if (validationError) {
        await window.confirmationDialog.show({
            title: 'Invalid Parameter Configuration',
            message: validationError,
            confirmText: 'OK',
            type: 'warning'
        });
        return;
    }
    
    try {
        if (isEdit) {
            // Detect what has changed
            const changes = detectChanges(editingScorecard, scorecardData, parameters);
            
            // Check if channels are being removed (warn user)
            if (changes.channelsRemoved.length > 0) {
                const confirmed = await window.confirmationDialog.show({
                    title: 'Remove Channels?',
                    message: `You are removing these channels: ${changes.channelsRemoved.join(', ')}.\n\nThis will create a new version. Active audits in the old version will remain unaffected.\n\nContinue?`,
                    confirmText: 'Yes, Remove',
                    cancelText: 'Cancel',
                    type: 'warning'
                });
                if (!confirmed) return;
            }
            
            // Determine if we need to create a new version
            const needsNewVersion = 
                changes.parametersChanged || 
                changes.scoringTypeChanged || 
                changes.channelsRemoved.length > 0;
            
            if (needsNewVersion) {
                // Create new version (parameters/scoring changed)
                let changesList = [];
                if (changes.parametersChanged) changesList.push('parameters');
                if (changes.scoringTypeChanged) changesList.push('scoring type');
                if (changes.channelsRemoved.length > 0) changesList.push('removed channels');
                
                const confirmed = await window.confirmationDialog.show({
                    title: 'Create New Version?',
                    message: `You changed: ${changesList.join(', ')}.\n\nThis requires creating a new version with a new table. Existing audits will remain in the old table.\n\nContinue?`,
                    confirmText: 'Create New Version',
                    cancelText: 'Cancel',
                    type: 'warning'
                });
                
                if (!confirmed) return;
                
                // Increment version and create new table
                const baseName = scorecardData.table_name.replace(/_v\d+$/, '');
                const version = (editingScorecard.version || 1) + 1;
                scorecardData.table_name = `${baseName}_v${version}`;
                scorecardData.version = version;
                scorecardData.parent_scorecard_id = scorecardId;
                
                // Deactivate old version
                await window.supabaseClient
                    .from('scorecards')
                    .update({ is_active: false })
                    .eq('id', scorecardId);
                
                // Create new audit table
                // Ensure all parameters are properly formatted and sanitized
                const tableParams = parameters.map(p => {
                    const param = {
                        field_id: String(p.field_id || '').trim().toLowerCase().replace(/[^a-z0-9_]/g, '_'),
                        error_name: String(p.error_name || '').trim()
                    };
                    
                    // Validate required fields
                    if (!param.field_id || !param.error_name) {
                        throw new Error(`Invalid parameter: field_id and error_name are required. Got: ${JSON.stringify(p)}`);
                    }
                    
                    return param;
                });
                
                // Validate we have at least one parameter
                if (tableParams.length === 0) {
                    throw new Error('At least one parameter is required to create an audit table.');
                }
                
                // Debug: Log parameters being sent to RPC
                console.log('Creating new version audit table with parameters:', {
                    table_name: scorecardData.table_name,
                    parameters: tableParams,
                    full_parameters: parameters
                });
                
                const { data: rpcResult, error: rpcError } = await window.supabaseClient
                    .rpc('create_audit_table', {
                        table_name: scorecardData.table_name,
                        parameters: tableParams
                    });
                
                if (rpcError || !rpcResult?.success) {
                    // Log full error details for debugging
                    console.error('RPC Error Details (new version):', {
                        rpcError,
                        rpcResult,
                        table_name: scorecardData.table_name,
                        parameters: tableParams
                    });
                    
                    const errorMsg = rpcResult?.error || rpcError?.message || rpcError?.details || 'Failed to create audit table';
                    const errorHint = rpcError?.hint || '';
                    const fullErrorMsg = errorHint ? `${errorMsg}\n\nHint: ${errorHint}` : errorMsg;
                    
                    // Check if this is a table already exists error
                    if (errorMsg.includes('already exists') || errorMsg.includes('duplicate')) {
                        throw new Error(`Table "${scorecardData.table_name}" already exists. Please use a different table name or delete the existing table first.`);
                    }
                    
                    throw new Error(fullErrorMsg);
                }
                
                // Wait a moment for Supabase schema cache to update after table creation
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Verify table was created with standard columns by attempting a test query
                // Retry logic to handle schema cache delays
                let verifyError = null;
                const maxRetries = 3;
                for (let attempt = 0; attempt < maxRetries; attempt++) {
                    if (attempt > 0) {
                        // Wait longer on each retry (exponential backoff)
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                    
                    const { error } = await window.supabaseClient
                        .from(scorecardData.table_name)
                        .select('audit_duration, submitted_at, auditor_email')
                        .limit(0);
                    
                    verifyError = error;
                    
                    // If no error, validation passed
                    if (!verifyError) {
                        break;
                    }
                    
                    // If it's a schema cache error, retry
                    if (verifyError.message && verifyError.message.includes('schema cache')) {
                        console.log(`Schema cache not ready, retrying (attempt ${attempt + 1}/${maxRetries})...`);
                        continue;
                    }
                    
                    // If it's a genuine column error (not schema cache), fail immediately
                    if (verifyError.message && (
                        (verifyError.message.includes('column') && verifyError.message.includes('not found')) ||
                        (verifyError.message.includes('does not exist') && !verifyError.message.includes('schema cache'))
                    )) {
                        throw new Error(`Table created but missing required standard columns (audit_duration, submitted_at, etc.). Please contact your system administrator to update the create_audit_table RPC function.`);
                    }
                }
                
                // If we still have an error after retries, only fail if it's a genuine column error
                if (verifyError && verifyError.message && !verifyError.message.includes('schema cache')) {
                    if (verifyError.message.includes('column') && verifyError.message.includes('not found') ||
                        verifyError.message.includes('does not exist')) {
                        throw new Error(`Table created but missing required standard columns (audit_duration, submitted_at, etc.). Please contact your system administrator to update the create_audit_table RPC function.`);
                    }
                    // If it's some other error, log it but don't fail (schema cache issues are transient)
                    console.warn('Table validation warning:', verifyError.message);
                }
                
                // Insert new scorecard version
                // Try with default_for_channels first, fallback without it if column doesn't exist
                let newScorecard;
                const { data, error } = await window.supabaseClient
                    .from('scorecards')
                    .insert([scorecardData])
                    .select()
                    .single();
                
                if (error) {
                    // If error is about missing column, retry without default_for_channels
                    if (error.message && error.message.includes('default_for_channels') && scorecardData.default_for_channels) {
                        const scorecardDataWithoutDefault = { ...scorecardData };
                        delete scorecardDataWithoutDefault.default_for_channels;
                        
                        const { data: retryData, error: retryError } = await window.supabaseClient
                            .from('scorecards')
                            .insert([scorecardDataWithoutDefault])
                            .select()
                            .single();
                        
                        if (retryError) throw retryError;
                        newScorecard = retryData;
                    } else {
                        throw error;
                    }
                } else {
                    newScorecard = data;
                }
                
                // Insert parameters for new version
                const parametersWithScorecardId = parameters.map(p => ({
                    ...p,
                    scorecard_id: newScorecard.id
                }));
                
                const { error: paramsError } = await window.supabaseClient
                    .from('scorecard_parameters')
                    .insert(parametersWithScorecardId);
                
                if (paramsError) throw paramsError;
                
                await window.confirmationDialog.show({
                    title: 'Success!',
                    message: `New version (v${version}) created successfully!`,
                    confirmText: 'OK',
                    type: 'success'
                });
                
            } else {
                // Just update the existing scorecard (metadata only, or description-only changes)
                const updateData = {
                    name: scorecardData.name,
                    description: scorecardData.description,
                    channels: scorecardData.channels,
                    default_for_channels: scorecardData.default_for_channels,
                    passing_threshold: scorecardData.passing_threshold
                };
                
                // Add hybrid-specific fields if applicable
                if (scoringType === 'hybrid') {
                    updateData.max_bonus_points = scorecardData.max_bonus_points;
                    updateData.allow_over_100 = scorecardData.allow_over_100;
                }
                
                // Try update with default_for_channels first, fallback without it if column doesn't exist
                const { error: updateError } = await window.supabaseClient
                    .from('scorecards')
                    .update(updateData)
                    .eq('id', scorecardId);
                
                if (updateError) {
                    // If error is about missing column, retry without default_for_channels
                    if (updateError.message && updateError.message.includes('default_for_channels') && updateData.default_for_channels) {
                        const updateDataWithoutDefault = { ...updateData };
                        delete updateDataWithoutDefault.default_for_channels;
                        
                        const { error: retryError } = await window.supabaseClient
                            .from('scorecards')
                            .update(updateDataWithoutDefault)
                            .eq('id', scorecardId);
                        
                        if (retryError) throw retryError;
                    } else {
                        throw updateError;
                    }
                }
                
                // Update parameter descriptions and prompts if they changed (without creating new version)
                // Since we're not creating a new version, parameters structure hasn't changed,
                // so we can safely update descriptions and prompts
                for (const newParam of parameters) {
                    const oldParam = originalParameters.find(p => 
                        p.field_id?.toLowerCase() === newParam.field_id?.toLowerCase()
                    );
                    
                    if (oldParam) {
                        const updates = {};
                        let needsUpdate = false;
                        
                        if ((oldParam.description || '') !== (newParam.description || '')) {
                            updates.description = newParam.description || null;
                            needsUpdate = true;
                        }
                        
                        if ((oldParam.enable_ai_audit || false) !== (newParam.enable_ai_audit || false)) {
                            updates.enable_ai_audit = newParam.enable_ai_audit || false;
                            needsUpdate = true;
                        }
                        
                        if ((oldParam.prompt || '') !== (newParam.prompt || '')) {
                            updates.prompt = newParam.prompt || null;
                            needsUpdate = true;
                        }
                        
                        if (needsUpdate) {
                            // Update description and/or prompt for this parameter
                            const { error: paramUpdateError } = await window.supabaseClient
                                .from('scorecard_parameters')
                                .update(updates)
                                .eq('scorecard_id', scorecardId)
                                .eq('field_id', newParam.field_id);
                            
                            if (paramUpdateError) {
                                console.warn('Error updating parameter description/prompt:', paramUpdateError);
                                // Don't throw - description/prompt updates are non-critical
                            }
                        }
                    }
                }
                
                await window.confirmationDialog.show({
                    title: 'Success!',
                    message: 'Scorecard updated successfully!',
                    confirmText: 'OK',
                    type: 'success'
                });
            }
        } else {
            // Creating new scorecard (original logic)
            // Ensure all parameters are properly formatted and sanitized
            const tableParams = parameters.map(p => {
                const param = {
                    field_id: String(p.field_id || '').trim().toLowerCase().replace(/[^a-z0-9_]/g, '_'),
                    error_name: String(p.error_name || '').trim()
                };
                
                // Validate required fields
                if (!param.field_id || !param.error_name) {
                    throw new Error(`Invalid parameter: field_id and error_name are required. Got: ${JSON.stringify(p)}`);
                }
                
                return param;
            });
            
            // Validate we have at least one parameter
            if (tableParams.length === 0) {
                throw new Error('At least one parameter is required to create an audit table.');
            }
            
            // Debug: Log parameters being sent to RPC
            console.log('Creating audit table with parameters:', {
                table_name: scorecardData.table_name,
                parameters: tableParams,
                full_parameters: parameters
            });
            
            const { data: rpcResult, error: rpcError } = await window.supabaseClient
                .rpc('create_audit_table', {
                    table_name: scorecardData.table_name,
                    parameters: tableParams
                });
            
            if (rpcError || !rpcResult?.success) {
                // Log full error details for debugging
                console.error('RPC Error Details:', {
                    rpcError,
                    rpcResult,
                    table_name: scorecardData.table_name,
                    parameters: tableParams
                });
                
                const errorMsg = rpcResult?.error || rpcError?.message || rpcError?.details || 'Failed to create audit table';
                const errorHint = rpcError?.hint || '';
                const fullErrorMsg = errorHint ? `${errorMsg}\n\nHint: ${errorHint}` : errorMsg;
                
                // Check if this is a table already exists error
                if (errorMsg.includes('already exists') || errorMsg.includes('duplicate')) {
                    throw new Error(`Table "${scorecardData.table_name}" already exists. Please use a different table name or delete the existing table first.`);
                }
                
                throw new Error(fullErrorMsg);
            }
            
            // Wait a moment for Supabase schema cache to update after table creation
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Verify table was created with standard columns by attempting a test query
            // Retry logic to handle schema cache delays
            let verifyError = null;
            const maxRetries = 3;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                if (attempt > 0) {
                    // Wait longer on each retry (exponential backoff)
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
                
                const { error } = await window.supabaseClient
                    .from(scorecardData.table_name)
                    .select('audit_duration, submitted_at, audit_start_time, audit_end_time, auditor_email, created_at, version')
                    .limit(0);
                
                verifyError = error;
                
                // If no error, validation passed
                if (!verifyError) {
                    break;
                }
                
                // If it's a schema cache error, retry
                if (verifyError.message && verifyError.message.includes('schema cache')) {
                    console.log(`Schema cache not ready, retrying (attempt ${attempt + 1}/${maxRetries})...`);
                    continue;
                }
                
                // If it's a genuine column error (not schema cache), fail immediately
                if (verifyError.message && (
                    (verifyError.message.includes('column') && verifyError.message.includes('not found')) ||
                    (verifyError.message.includes('does not exist') && !verifyError.message.includes('schema cache'))
                )) {
                    throw new Error(`Table created but missing required standard columns (audit_duration, submitted_at, etc.). Please contact your system administrator to update the create_audit_table RPC function.`);
                }
            }
            
            // If we still have an error after retries, only fail if it's a genuine column error
            if (verifyError && verifyError.message && !verifyError.message.includes('schema cache')) {
                if (verifyError.message.includes('column') && verifyError.message.includes('not found') ||
                    verifyError.message.includes('does not exist')) {
                    throw new Error(`Table created but missing required standard columns (audit_duration, submitted_at, etc.). Please contact your system administrator to update the create_audit_table RPC function.`);
                }
                // If it's some other error, log it but don't fail (schema cache issues are transient)
                console.warn('Table validation warning:', verifyError.message);
            }
            
            // Try insert with default_for_channels first, fallback without it if column doesn't exist
            let newScorecard;
            const { data, error: scorecardError } = await window.supabaseClient
                .from('scorecards')
                .insert([scorecardData])
                .select()
                .single();
            
            if (scorecardError) {
                // If error is about missing column, retry without default_for_channels
                if (scorecardError.message && scorecardError.message.includes('default_for_channels') && scorecardData.default_for_channels) {
                    const scorecardDataWithoutDefault = { ...scorecardData };
                    delete scorecardDataWithoutDefault.default_for_channels;
                    
                    const { data: retryData, error: retryError } = await window.supabaseClient
                        .from('scorecards')
                        .insert([scorecardDataWithoutDefault])
                        .select()
                        .single();
                    
                    if (retryError) throw retryError;
                    newScorecard = retryData;
                } else {
                    throw scorecardError;
                }
            } else {
                newScorecard = data;
            }
            
            const parametersWithScorecardId = parameters.map(p => ({
                ...p,
                scorecard_id: newScorecard.id
            }));
            
            const { error: paramsError } = await window.supabaseClient
                .from('scorecard_parameters')
                .insert(parametersWithScorecardId);
            
            if (paramsError) throw paramsError;
            
            await window.confirmationDialog.show({
                title: 'Success!',
                message: 'Scorecard created successfully!',
                confirmText: 'OK',
                type: 'success'
            });
        }
        
        closeScorecardModal();
        await loadScorecards();
        
    } catch (error) {
        console.error('Error saving scorecard:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to save scorecard: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

async function toggleScorecardStatus(scorecardId, newStatus) {
    try {
        const { error } = await window.supabaseClient
            .from('scorecards')
            .update({ is_active: newStatus })
            .eq('id', scorecardId);
        
        if (error) throw error;
        
        await loadScorecards();
    } catch (error) {
        console.error('Error updating scorecard status:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to update scorecard status: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// Show message when trying to delete scorecard with audits
async function showCannotDeleteMessage(scorecardName, auditCount) {
    await window.confirmationDialog.show({
        title: 'üîí Cannot Delete Scorecard',
        message: `The scorecard "${scorecardName}" contains ${auditCount} audit report(s) and cannot be deleted.\n\n` +
                 `üìå What you can do:\n` +
                 `‚Ä¢ Use the "Deactivate" button to hide it from view\n` +
                 `‚Ä¢ Keep it inactive to preserve audit history\n\n` +
                 `‚ö†Ô∏è To permanently delete this scorecard and all its audit reports, please contact your System Administrator.`,
        confirmText: 'OK',
        type: 'info'
    });
}

// Delete scorecard (only allowed if no audit reports exist)
async function deleteScorecard(scorecardId, tableName) {
    try {
        const confirmed = await window.confirmationDialog.show({
            title: 'Delete Scorecard?',
            message: `This scorecard has no audit reports.\n\nThe scorecard configuration and its database table will be permanently deleted.\n\nContinue?`,
            confirmText: 'Delete',
            cancelText: 'Cancel',
            type: 'warning'
        });
        
        if (!confirmed) return;
        
        // First, drop the associated database table
        const { data: dropResult, error: dropError } = await window.supabaseClient
            .rpc('drop_audit_table', {
                table_name: tableName
            });
        
        if (dropError || !dropResult.success) {
            throw new Error(dropResult?.error || dropError?.message || 'Failed to drop table');
        }
        
        // Then delete the scorecard record
        const { error } = await window.supabaseClient
            .from('scorecards')
            .delete()
            .eq('id', scorecardId);
        
        if (error) throw error;
        
        await window.confirmationDialog.show({
            title: 'Deleted',
            message: `Scorecard and its database table deleted successfully.`,
            confirmText: 'OK',
            type: 'success'
        });
        
        await loadScorecards();
        
    } catch (error) {
        console.error('Error deleting scorecard:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to delete scorecard: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// ============================================================================
// Channel Management Functions
// ============================================================================

// Open channel management modal
async function openChannelManagementModal() {
    await loadChannelsListForManagement();
    document.getElementById('channelManagementModal').classList.add('active');
}

// Close channel management modal
function closeChannelManagementModal() {
    document.getElementById('channelManagementModal').classList.remove('active');
    document.getElementById('newChannelName').value = '';
    // Reload channels and refresh checkboxes
    loadAvailableChannels().then(() => initializeChannelCheckboxes());
}

// Load channels list for management modal
async function loadChannelsListForManagement() {
    try {
        const { data, error } = await window.supabaseClient
            .from('channels')
            .select('*')
            .order('name', { ascending: true });
        
        if (error) throw error;
        
        const container = document.getElementById('channelsListContainer');
        
        if (!data || data.length === 0) {
            container.innerHTML = '<p style="font-size: 0.5625rem; color: #6b7280; text-align: center; padding: 0.75rem;">No channels yet. Add your first channel above!</p>';
            return;
        }
        
        container.innerHTML = data.map(channel => `
            <div style="display: flex; align-items: center; justify-content: space-between; padding: 0.375rem; background: white; border: 0.0469rem solid #e5e7eb; border-radius: 0.1875rem;">
                <div style="flex: 1;">
                    <span style="font-size: 0.5625rem; font-weight: 600; color: #374151;">${escapeHtml(channel.name)}</span>
                    <span style="font-size: 0.4688rem; color: #6b7280; margin-left: 0.375rem; padding: 0.0938rem 0.2812rem; background: ${channel.is_active ? '#d1fae5' : '#fee2e2'}; color: ${channel.is_active ? '#065f46' : '#991b1b'}; border-radius: 0.1875rem;">${channel.is_active ? 'Active' : 'Inactive'}</span>
                </div>
                <div style="display: flex; gap: 0.1875rem;">
                    <button onclick="toggleChannelStatus('${channel.id}', ${!channel.is_active})" style="padding: 0.1875rem 0.375rem; background: ${channel.is_active ? '#fee2e2' : '#d1fae5'}; color: ${channel.is_active ? '#991b1b' : '#065f46'}; border: none; border-radius: 0.1875rem; font-size: 0.4688rem; cursor: pointer;">${channel.is_active ? 'Deactivate' : 'Activate'}</button>
                    <button onclick="deleteChannel('${channel.id}', '${escapeHtml(channel.name)}')" style="padding: 0.1875rem 0.375rem; background: #fee2e2; color: #dc2626; border: none; border-radius: 0.1875rem; font-size: 0.4688rem; cursor: pointer;">Delete</button>
                </div>
            </div>
        `).join('');
        
    } catch (error) {
        console.error('Error loading channels list:', error);
        const container = document.getElementById('channelsListContainer');
        container.innerHTML = '<p style="font-size: 0.5625rem; color: #ef4444; text-align: center; padding: 0.75rem;">Error loading channels</p>';
    }
}

// Create new channel
async function createChannel() {
    const channelName = document.getElementById('newChannelName').value.trim();
    
    if (!channelName) {
        await window.confirmationDialog.show({
            title: 'Name Required',
            message: 'Please enter a channel name.',
            confirmText: 'OK',
            type: 'warning'
        });
        return;
    }
    
    try {
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const userEmail = userInfo.email || 'unknown';
        
        const { error } = await window.supabaseClient
            .from('channels')
            .insert([{
                name: channelName,
                is_active: true,
                created_by: userEmail
            }]);
        
        if (error) {
            if (error.code === '23505') {
                throw new Error('Channel already exists!');
            }
            throw error;
        }
        
        // Clear input
        document.getElementById('newChannelName').value = '';
        
        // Reload channels list
        await loadChannelsListForManagement();
        
        await window.confirmationDialog.show({
            title: 'Success!',
            message: `Channel "${channelName}" created successfully!`,
            confirmText: 'OK',
            type: 'success'
        });
        
    } catch (error) {
        console.error('Error creating channel:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to create channel: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// Toggle channel active status
async function toggleChannelStatus(channelId, newStatus) {
    try {
        const userInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
        const userEmail = userInfo.email || 'unknown';
        
        const { error } = await window.supabaseClient
            .from('channels')
            .update({
                is_active: newStatus,
                updated_by: userEmail
            })
            .eq('id', channelId);
        
        if (error) throw error;
        
        // Reload channels list
        await loadChannelsListForManagement();
        
    } catch (error) {
        console.error('Error updating channel status:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to update channel: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// Delete channel
async function deleteChannel(channelId, channelName) {
    const confirmed = await window.confirmationDialog.show({
        title: 'Delete Channel?',
        message: `Are you sure you want to delete "${channelName}"? This action cannot be undone.`,
        confirmText: 'Delete',
        cancelText: 'Cancel',
        type: 'warning'
    });
    
    if (!confirmed) return;
    
    try {
        const { error } = await window.supabaseClient
            .from('channels')
            .delete()
            .eq('id', channelId);
        
        if (error) throw error;
        
        // Reload channels list
        await loadChannelsListForManagement();
        
        await window.confirmationDialog.show({
            title: 'Deleted',
            message: `Channel "${channelName}" deleted successfully!`,
            confirmText: 'OK',
            type: 'success'
        });
        
    } catch (error) {
        console.error('Error deleting channel:', error);
        await window.confirmationDialog.show({
            title: 'Error',
            message: 'Failed to delete channel: ' + error.message,
            confirmText: 'OK',
            type: 'error'
        });
    }
}

// Close modal on outside click
document.addEventListener('DOMContentLoaded', function() {
    const channelModal = document.getElementById('channelManagementModal');
    if (channelModal) {
        channelModal.addEventListener('click', function(e) {
            if (e.target === this) {
                closeChannelManagementModal();
            }
        });
    }
    
    // Handle Enter key in channel name input
    const newChannelInput = document.getElementById('newChannelName');
    if (newChannelInput) {
        newChannelInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                createChannel();
            }
        });
    }
});

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// ============================================================================
// Bulk Import Functions
// ============================================================================

// Open bulk import modal
function openBulkImportModal() {
    document.getElementById('bulkImportModal').classList.add('active');
    // Reset the modal
    document.getElementById('bulkPasteArea').value = '';
    document.getElementById('csvFileInput').value = '';
    document.getElementById('importPreviewArea').style.display = 'none';
    document.getElementById('confirmImportBtn').style.display = 'none';
    parsedImportData = [];
}

// Close bulk import modal
function closeBulkImportModal() {
    document.getElementById('bulkImportModal').classList.remove('active');
}

// Download CSV Template
function downloadCSVTemplate() {
    const scoringType = document.getElementById('scoringType').value;
    
    // Create CSV content with example based on scoring type
    let csvContent = 'Parameter Name,Points,Type,Category,Field Type,Field ID,Description,Prompt,Enable AI Audit,Auto-Fail\n';
    
    if (scoringType === 'deductive') {
        csvContent += 'Loss of Business,50,error,Critical Fail Error,counter,error_loss_business,"Error that directly results in customer leaving","Check if the conversation resulted in customer cancellation or service termination",true,true\n';
        csvContent += 'Zero Tolerance,50,error,Critical Fail Error,counter,zero_tolerance,"Violation of zero tolerance policy","Identify any violations of company zero tolerance policies",true,true\n';
        csvContent += 'Incorrect Information,10,error,Critical Error,counter,incorrect_info,"Providing wrong information to customer","Detect instances where incorrect information was provided",true,false\n';
        csvContent += 'Lack of Professionalism,10,error,Critical Error,counter,lack_professionalism,"Unprofessional behavior or language","Identify unprofessional language or behavior",true,false\n';
        csvContent += 'Grammatical Errors,5,error,Major Error,counter,grammatical_errors,"Spelling or grammar mistakes in communication","Find spelling or grammar errors in the conversation",false,false\n';
    } else if (scoringType === 'additive') {
        csvContent += 'Excellent Empathy,10,achievement,Critical,radio,excellent_empathy,"Demonstrating exceptional understanding and care","Assess if the agent showed exceptional empathy and understanding",true,false\n';
        csvContent += 'Proactive Solution,10,achievement,Critical,radio,proactive_solution,"Offering solutions before customer asks","Check if solutions were offered proactively",true,false\n';
        csvContent += 'Clear Communication,5,achievement,Major,radio,clear_communication,"Clear and concise explanations","Evaluate if communication was clear and concise",false,false\n';
        csvContent += 'Good Engagement,5,achievement,Major,radio,good_engagement,"Active listening and appropriate engagement","Assess level of engagement and active listening",false,false\n';
    } else {
        csvContent += 'Loss of Business,50,error,Critical Fail Error,counter,error_loss_business,"Error that directly results in customer leaving","Check if the conversation resulted in customer cancellation",true,true\n';
        csvContent += 'Incorrect Information,10,error,Critical Error,counter,incorrect_info,"Providing wrong information to customer","Detect instances where incorrect information was provided",true,false\n';
        csvContent += 'Excellent Empathy,10,achievement,Critical,radio,excellent_empathy,"Demonstrating exceptional understanding and care","Assess if the agent showed exceptional empathy",true,false\n';
        csvContent += 'Exceptional Service,15,bonus,Major,radio,exceptional_service,"Going above and beyond expectations","Evaluate if service exceeded expectations",false,false\n';
    }
    
    // Create blob and download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `scorecard_parameters_template_${scoringType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// Handle CSV file upload
document.addEventListener('DOMContentLoaded', function() {
    const fileInput = document.getElementById('csvFileInput');
    if (fileInput) {
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const content = event.target.result;
                    document.getElementById('bulkPasteArea').value = content;
                    // Auto-parse after upload
                    parseBulkData();
                };
                reader.readAsText(file);
            }
        });
    }
    
    // Close bulk import modal on outside click
    const bulkModal = document.getElementById('bulkImportModal');
    if (bulkModal) {
        bulkModal.addEventListener('click', function(e) {
            if (e.target === this) {
                closeBulkImportModal();
            }
        });
    }
});

// Parse bulk data (CSV or pasted)
function parseBulkData() {
    const pasteArea = document.getElementById('bulkPasteArea');
    const rawData = pasteArea.value.trim();
    
    if (!rawData) {
        window.confirmationDialog.show({
            title: 'No Data',
            message: 'Please paste or upload data first.',
            confirmText: 'OK',
            type: 'warning'
        });
        return;
    }
    
    const lines = rawData.split('\n').filter(line => line.trim());
    parsedImportData = [];
    const errors = [];
    
    lines.forEach((line, index) => {
        // Skip header row if detected
        if (index === 0 && (line.toLowerCase().includes('parameter name') || line.toLowerCase().includes('name,points'))) {
            return;
        }
        
        // Try to parse as CSV (comma or tab separated)
        let parts;
        if (line.includes('\t')) {
            parts = line.split('\t');
        } else {
            // Handle CSV with potential commas in quotes
            parts = parseCSVLine(line);
        }
        
        // Clean up parts
        parts = parts.map(p => p.trim());
        
        if (parts.length < 6) {
            errors.push(`Line ${index + 1}: Not enough columns (found ${parts.length}, need at least 6)`);
            return;
        }
        
        // Handle format: Parameter Name, Points, Type, Category, Field Type, Field ID, Description, Prompt, Enable AI Audit, Auto-Fail
        // Support old formats for backward compatibility
        const hasDescription = parts.length >= 7;
        const hasPrompt = parts.length >= 8;
        const hasEnableAiAudit = parts.length >= 9;
        const hasAutoFail = parts.length >= 10;
        
        // New format (10 columns): name, points, type, category, fieldType, fieldId, description, prompt, enableAiAudit, isFailAll
        // Old format (9 columns): name, points, type, category, fieldType, fieldId, description, prompt, isFailAll
        // Older format (8 columns): name, points, type, category, fieldType, fieldId, description, prompt
        // Oldest format (7 columns): name, points, type, category, fieldType, fieldId, description
        // Very old format (6 columns): name, points, type, category, fieldType, fieldId
        
        let name, points, type, category, fieldType, fieldId, description, prompt, enableAiAudit, isFailAll;
        
        if (parts.length >= 10) {
            // New format with Enable AI Audit column
            [name, points, type, category, fieldType, fieldId, description, prompt, enableAiAudit, isFailAll] = parts;
        } else if (parts.length >= 9) {
            // Old format without Enable AI Audit column
            [name, points, type, category, fieldType, fieldId, description, prompt, isFailAll] = parts;
            enableAiAudit = ''; // Will be set based on prompt presence
        } else if (parts.length >= 8) {
            // Older format without Auto-Fail
            [name, points, type, category, fieldType, fieldId, description, prompt] = parts;
            enableAiAudit = '';
            isFailAll = '';
        } else if (parts.length >= 7) {
            // Oldest format without prompt
            [name, points, type, category, fieldType, fieldId, description] = parts;
            prompt = '';
            enableAiAudit = '';
            isFailAll = '';
        } else {
            // Very old format
            [name, points, type, category, fieldType, fieldId] = parts;
            description = '';
            prompt = '';
            enableAiAudit = '';
            isFailAll = '';
        }
        
        // Validate fields
        if (!name) {
            errors.push(`Line ${index + 1}: Parameter name is required`);
            return;
        }
        
        const pointsNum = parseFloat(points);
        if (isNaN(pointsNum) || pointsNum < 0) {
            errors.push(`Line ${index + 1}: Invalid points value "${points}"`);
            return;
        }
        
        const validTypes = ['error', 'achievement', 'bonus'];
        if (!validTypes.includes(type.toLowerCase())) {
            errors.push(`Line ${index + 1}: Invalid type "${type}" (must be: error, achievement, or bonus)`);
            return;
        }
        
        const validCategories = ['Critical Fail Error', 'Critical Error', 'Critical', 'Significant Error', 'Significant', 'Major Error', 'Major', 'Minor Error', 'Minor'];
        const normalizedCategory = category.replace(/\s+/g, ' ').trim();
        if (!validCategories.some(c => c.toLowerCase() === normalizedCategory.toLowerCase())) {
            errors.push(`Line ${index + 1}: Invalid category "${category}"`);
            return;
        }
        
        const validFieldTypes = ['counter', 'radio'];
        if (!validFieldTypes.includes(fieldType.toLowerCase())) {
            errors.push(`Line ${index + 1}: Invalid field type "${fieldType}" (must be: counter or radio)`);
            return;
        }
        
        if (!fieldId || !/^[a-zA-Z0-9_]+$/.test(fieldId)) {
            errors.push(`Line ${index + 1}: Invalid field ID "${fieldId}" (use only letters, numbers, underscores)`);
            return;
        }
        
        // Parse enable_ai_audit (optional, defaults to false)
        let enableAiAuditBool = false;
        if (enableAiAudit !== undefined && enableAiAudit !== '') {
            const aiAuditLower = enableAiAudit.toLowerCase().trim();
            enableAiAuditBool = aiAuditLower === 'true' || aiAuditLower === '1' || aiAuditLower === 'yes';
        } else if (prompt && prompt.trim()) {
            // If prompt is provided but enable_ai_audit is not specified, default to true
            enableAiAuditBool = true;
        }
        
        // Parse is_fail_all (optional, defaults to false)
        let isFailAllBool = false;
        if (isFailAll !== undefined && isFailAll !== '') {
            const failAllLower = isFailAll.toLowerCase().trim();
            isFailAllBool = failAllLower === 'true' || failAllLower === '1' || failAllLower === 'yes';
        }
        
        // Add to parsed data
        parsedImportData.push({
            error_name: name,
            penalty_points: pointsNum,
            parameter_type: type.toLowerCase(),
            error_category: normalizedCategory,
            field_type: fieldType.toLowerCase(),
            field_id: fieldId.toLowerCase().replace(/[^a-z0-9_]/g, '_'),
            description: (description && description.trim()) || null,
            enable_ai_audit: enableAiAuditBool,
            prompt: (prompt && prompt.trim()) || null,
            points_direction: type.toLowerCase() === 'error' ? 'subtract' : 'add',
            requires_feedback: true,
            is_active: true,
            is_fail_all: isFailAllBool
        });
    });
    
    if (errors.length > 0) {
        window.confirmationDialog.show({
            title: 'Import Errors',
            message: `Found ${errors.length} error(s):\n\n${errors.slice(0, 5).join('\n')}${errors.length > 5 ? `\n\n...and ${errors.length - 5} more` : ''}`,
            confirmText: 'OK',
            type: 'error'
        });
        return;
    }
    
    if (parsedImportData.length === 0) {
        window.confirmationDialog.show({
            title: 'No Valid Data',
            message: 'No valid parameters found. Please check your data format.',
            confirmText: 'OK',
            type: 'warning'
        });
        return;
    }
    
    // Show preview
    displayImportPreview();
}

// Parse CSV line handling quoted values
function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
            inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
        } else {
            current += char;
        }
    }
    
    result.push(current.trim());
    return result;
}

// Display import preview
function displayImportPreview() {
    const previewArea = document.getElementById('importPreviewArea');
    const previewTable = document.getElementById('previewTable');
    const previewCount = document.getElementById('previewCount');
    const confirmBtn = document.getElementById('confirmImportBtn');
    
    previewCount.textContent = parsedImportData.length;
    
    // Create preview table
    let tableHTML = `
        <table style="width: 100%; border-collapse: collapse; font-size: 0.5156rem;">
            <thead>
                <tr style="background: #f9fafb; border-bottom: 0.0469rem solid #e5e7eb;">
                    <th style="padding: 0.375rem; text-align: left; font-weight: 600; color: #374151;">Name</th>
                    <th style="padding: 0.375rem; text-align: left; font-weight: 600; color: #374151;">Points</th>
                    <th style="padding: 0.375rem; text-align: left; font-weight: 600; color: #374151;">Type</th>
                    <th style="padding: 0.375rem; text-align: left; font-weight: 600; color: #374151;">Category</th>
                    <th style="padding: 0.375rem; text-align: left; font-weight: 600; color: #374151;">Field Type</th>
                    <th style="padding: 0.375rem; text-align: left; font-weight: 600; color: #374151;">Field ID</th>
                    <th style="padding: 0.375rem; text-align: left; font-weight: 600; color: #374151;">Description</th>
                    <th style="padding: 0.375rem; text-align: left; font-weight: 600; color: #374151;">Prompt</th>
                    <th style="padding: 0.375rem; text-align: center; font-weight: 600; color: #374151;">AI Audit</th>
                    <th style="padding: 0.375rem; text-align: center; font-weight: 600; color: #374151;">Auto-Fail</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    parsedImportData.forEach((param, index) => {
        const typeColor = param.parameter_type === 'error' ? '#ef4444' : (param.parameter_type === 'achievement' ? '#10b981' : '#3b82f6');
        const failAllBadge = param.is_fail_all ? '<span style="background: #ef4444; color: white; padding: 0.0938rem 0.2812rem; border-radius: 0.1875rem; font-size: 0.4688rem; font-weight: 600;">‚úì</span>' : '<span style="color: #9ca3af;">-</span>';
        const aiAuditBadge = param.enable_ai_audit ? '<span style="background: #1A733E; color: white; padding: 0.0938rem 0.2812rem; border-radius: 0.1875rem; font-size: 0.4688rem; font-weight: 600;">‚úì</span>' : '<span style="color: #9ca3af;">-</span>';
        tableHTML += `
            <tr style="border-bottom: 0.0469rem solid #e5e7eb; ${index % 2 === 0 ? 'background: white;' : 'background: #f9fafb;'}">
                <td style="padding: 0.375rem;">${escapeHtml(param.error_name)}</td>
                <td style="padding: 0.375rem; font-weight: 600;">${param.penalty_points}</td>
                <td style="padding: 0.375rem;">
                    <span style="background: ${typeColor}15; color: ${typeColor}; padding: 0.0938rem 0.2812rem; border-radius: 0.1875rem; font-size: 0.4688rem; font-weight: 600; text-transform: uppercase;">
                        ${param.parameter_type}
                    </span>
                </td>
                <td style="padding: 0.375rem;">${escapeHtml(param.error_category)}</td>
                <td style="padding: 0.375rem;">${param.field_type}</td>
                <td style="padding: 0.375rem;">
                    <code style="background: #f3f4f6; padding: 0.0938rem 0.2812rem; border-radius: 0.1875rem; font-size: 0.4688rem;">${param.field_id}</code>
                </td>
                <td style="padding: 0.375rem; font-size: 0.4688rem; color: #6b7280; max-width: 7.0312rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(param.description || '')}">${escapeHtml(param.description || '-')}</td>
                <td style="padding: 0.375rem; font-size: 0.4688rem; color: #6b7280; max-width: 7.0312rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(param.prompt || '')}">${escapeHtml(param.prompt || '-')}</td>
                <td style="padding: 0.375rem; text-align: center;">${aiAuditBadge}</td>
                <td style="padding: 0.375rem; text-align: center;">${failAllBadge}</td>
            </tr>
        `;
    });
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    previewTable.innerHTML = tableHTML;
    previewArea.style.display = 'block';
    confirmBtn.style.display = 'block';
    
    // Scroll to preview
    previewArea.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Confirm and import parameters
async function confirmBulkImport() {
    if (parsedImportData.length === 0) {
        await window.confirmationDialog.show({
            title: 'No Data',
            message: 'No parameters to import.',
            confirmText: 'OK',
            type: 'warning'
        });
        return;
    }
    
    const scoringType = document.getElementById('scoringType').value;
    
    // Validate against scoring type
    const validationError = validateParameterTypes(scoringType, parsedImportData);
    if (validationError) {
        await window.confirmationDialog.show({
            title: 'Incompatible Parameters',
            message: validationError + '\n\nPlease fix your data or change the scoring type.',
            confirmText: 'OK',
            type: 'warning'
        });
        return;
    }
    
    // Clear existing parameters and add imported ones
    const container = document.getElementById('parametersContainer');
    container.innerHTML = '';
    
    parsedImportData.forEach((param, index) => {
        param.display_order = index + 1;
        addParameterRow(param);
    });
    
    await window.confirmationDialog.show({
        title: 'Success!',
        message: `${parsedImportData.length} parameter(s) imported successfully!`,
        confirmText: 'OK',
        type: 'success'
    });
    
    closeBulkImportModal();
}
</script>

</body>
</html>
